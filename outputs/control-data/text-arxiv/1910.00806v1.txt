arXiv:1910.00806v1 [cs.SE] 2 Oct 2019

A Mutation-based Approach for Assessing Weight
Coverage of a Path Planner
Thomas Laurent

Paolo Arcaini

Lero & University College Dublin, Ireland
National Institute of Informatics, Japan
thomas.laurent@ucdconnect.ie

National Institute of Informatics
Tokyo, Japan
arcaini@nii.ac.jp

Fuyuki Ishikawa

Anthony Ventresque

National Institute of Informatics
Tokyo, Japan
f-ishikawa@nii.ac.jp

Lero & University College Dublin
Dublin, Ireland
anthony.ventresque@ucd.ie

Abstract—Autonomous cars are subjected to several different
kind of inputs (other cars, road structure, etc.) and, therefore,
testing the car under all possible conditions is impossible. To
tackle this problem, scenario-based testing for automated driving
defines categories of different scenarios that should be covered.
Although this kind of coverage is a necessary condition, it still
does not guarantee that any possible behaviour of the autonomous
car is tested. In this paper, we consider the path planner of an
autonomous car that decides, at each timestep, the short-term
path to follow in the next few seconds; such decision is done by
using a weighted cost function that considers different aspects
(safety, comfort, etc.). In order to assess whether all the possible
decisions that can be taken by the path planner are covered by
a given test suite T , we propose a mutation-based approach that
mutates the weights of the cost function and then checks if at
least one scenario of T kills the mutant. Preliminary experiments
on a manually designed test suite show that some weights are
easier to cover as they consider aspects that more likely occur in
a scenario, and that more complicated scenarios (that generate
more complex paths) are those that allow to cover more weights.
Index Terms—software testing, mutation analysis, automated
driving, path planner

I. I NTRODUCTION
Automated driving is a technology currently being intensely
developed, that promises to impact our lives in many ways.
Application for automated vehicles range from transport of
goods (automated freight) to personal mobility, with offers
such as Tesla’s or Uber’s. As promising as the technology is,
great care must be taken in evaluating and validating such
systems, to avoid tragic accidents happening [1], [2].
Testing automated driving systems is critical for the satisfaction and safety of all stakeholders, but is also a very expensive
operation. Therefore, it is essential to know when a system has
been sufficiently tested. This is the question we focus on in
this paper.
This work was supported, in part, by Science Foundation Ireland grant
13/RC/2094. T. Laurent is supported by an Irish Research Council grant
(GOIPG/2017/1829). P. Arcaini and F. Ishikawa are supported by ERATO
HASUO Metamathematics for Systems Design Project (No. JPMJER1603),
JST. Funding Reference number: 10.13039/501100009024 ERATO.

Fig. 1: Illustration of the path planner.

An autonomous driving system can be seen as a set of
components that sense the environment of the vehicle, choose
a path given an itinerary, and implement this path into concrete
actions performed by actuators. In this paper, we consider
a path planner component provided by our industry partner,
which computes the best trajectory for the vehicle given a
target destination. At every timestep, the path planner decides
the short-term path that the car should follow in the next
few seconds and the control commands that must be provided
to implement it (such as acceleration and angle); in order to
decide the next short-term path, an optimisation algorithm is
employed. A set of short-term paths starting from the head of
the car to a grid of points in front of the car are enumerated.
This is shown in Fig. 1 where the white car is the ego car, the
red car another, immobile, car. The translucent cars represent
the possible future positions sampled by the path planner
and the blue arrows the associated short-term paths. Then,
each short-term path is evaluated according to a cost function.
The cost function considers different aspects, such as safety,
vehicle limitation, regulation compliance, and comfort. Given
the ranking of all the short-term paths, the one with the lowest
cost is taken.
The path planner is tested using a simulator. The simulator takes as input a path planner and a scenario –a road
configuration, a starting position, direction and speed for the
automated car (or ego car), and for other objects on the road–
and runs the path planner in this particular scenario, computing
the path the ego car would take. Evaluating the output of the
simulation, i.e., a path, is not done with a pass/fail oracle, as

there is no comprehensive definition of what a valid path is.
The presence or absence of a crash, for example, is not a good
enough oracle: one can drive badly and not crash, or can take
the best possible decision and still experience an unavoidable
crash. Instead, we can define some metrics to capture some
measures of interest (e.g., minimum distance of the ego car
with all the other objects along the path); these metrics can
be used to evaluate a path or compare paths computed by
different path planners for a same scenario.
In testing, coverage criteria are used to evaluate the quality
of a test suite T , i.e., if T is sufficient for testing the System
Under Test. For example, classical structural criteria check
that the code has been covered sufficiently. In scenario-based
testing [3] for automated driving (as done with our simulator),
main approaches aim at covering all different traffic situations
(e.g., number and positions of the other cars), and manoeuvres
done by the ego car [4]. To support this kind of testing,
ontologies regarding driving behaviours, road topologies, environmental conditions, etc. have been devised (see the eight
documents in [5]). Although such kind of coverage is also
necessary for our path planner, it still does not guarantee
coverage of all possible behaviours of the path planner.
Therefore, in this paper, we propose a definition of what
it means to sufficiently test a path planner. At a very high
level, we want to check that all the possible decisions that
can be taken by the path planner are observed in at least one
test. This is difficult because, in general, we do not know
which scenarios lead to some given decisions; this is why the
coverage of scenario elements (as in [4]) may be not sufficient
and so we need a different criterion. Moreover, we do not even
have a proper characterisation of the different decisions, i.e.,
given two short-term paths computed by the path planner, we
cannot say if they have been taken for the same reasons (i.e.,
for respecting the same aspects).
Although it is impossible to evaluate if all possible decisions
are covered in a direct manner, we propose an indirect way of
assessing this. The path planner can be seen as a weighted
function of the different aspects listed before (i.e., safety,
comfort, etc.). For each aspect, the path planner has one
or more weight(s) set by the system designer. Such weights
represent how important that aspect is in selecting a shortterm path (we call this selection a decision). We claim that
a minimal condition for testing the path planner is that each
weight is shown to be “relevant” in at least one decision in
one test. We say that a weight wi is covered by a scenario s
(i.e., that wi is “relevant” to at least a decision taken for s)
if using a different weight value wi0 in the path planner, the
computed path p0 is different from the path p computed with
the original weight. Indeed, if changing the weight wi in all
possible ways does not affect any decision, it means that the
aspect considered by wi is irrelevant in that scenario.
Since trying all the possible alternative weights is infeasible
(as their number is very large), we propose a mutation-based
approach [6] that is able to estimate the weight coverage
of a given test suite T . The approach consists in mutating
a weight wi with a finite set of mutation operators; wi is

considered covered by a test suite T if, in at least one test
in T , the path computed by the mutated path planner is
different from the path computed by original path planner,
according to a mutation oracle. We propose three mutation
oracles that provide different guarantees in terms of coverage:
the path oracle simply compares the two paths point-wise,
the safety oracle compares the minimum distance of the ego
car w.r.t. the other objects in the two paths, and the comfort
oracle compares the smoothness of the paths. Note that some
mutation oracles, as the path oracle, are more likely to say
that two paths are different, while others, as the comfort
oracle, are more demanding and require bigger differences
in order to consider two paths different; in general, stronger
mutation oracles provide stronger guarantees that two paths
are significantly different [6].
The rest of this paper is structured as follows: Section II
introduces some core definitions, and Section III presents our
definition of weight coverage and a mutation-based approach
to estimate it. Section IV presents some experiments we
performed to evaluate our approach and discusses their results.
Section V further discusses some insights from the experiments, and Section VI tackles some threats that could affect
the validity of the proposed approach. Finally, Section VII
reviews some related work, and Section VIII concludes the
paper.
II. D EFINITIONS
In the following, we provide some definitions related to the
path planner and its simulator.
Definition 1 (Scenario). A scenario s describes the environment in which the ego car is operating. It is constituted of:
• a map M describing the road structure:
• an initial position, speed, acceleration, and direction of
the ego car;
• a target destination of the ego car;
• a set of static objects SO; each static object is characterised by its position in the map, and its size (length and
width);
• a set of dynamic objects DO; each dynamic object, in
addition to position and size, is also characterised by its
initial speed, acceleration, and direction;
• a timeout TO; the scenario must be run until time TO.
We will use the dot notation (e.g., s.TO) to access a particular
field of a scenario.
For the sake of conciseness, in the following, we consider
static objects as dynamic objects having no velocity and no
acceleration.
Definition 2 (Path). A path is a sequence of tuples [(t1 ,
l1 = (x1 , y1 ), d1 , v1 , a1 ), . . . , (tn , ln = (xn , yn ), dn , vn ,
an )], where each tuple i identifies a timestamp ti , a location
li = (xi , yi ) in the map, a direction di , a speed vi , and an
acceleration ai . We use the dot notation to access tuple fields
at a given time ti (e.g., p.ai ).

Note that, for each dynamic object do of a scenario s,
we can automatically compute its path p up to the timeout
s.TO 1 ; we will write do(s) = p, where p = [(t1 , l1 =
(x1 , y1 ), d1 , v1 , a1 ), . . . , (tn , ln = (xn , yn ), dn , vn , an )] and
tn = s.TO.
Definition 3 (Path Planner). A path planner PP can be seen
as a function that, given a scenario s, produces a path p for the
ego car up to simulation time s.TO, formally, PP(s) = p. We
name each pair of consecutive tuples ((ti , li = (xi , yi ), di ,
vi , ai ), (ti+1 , li+1 = (xi+1 , yi+1 ), di+1 , vi+1 , ai+1 )) (with
i ∈ {1, . . . , n − 1}) as short-term path: it corresponds to a
decision taken by the path planner.
A. Evaluation metrics (path quality metrics)
Given a scenario s, we can define different metrics characterising the whole path computed by the path planner. In the
following, let pe = PP(s) be the path computed by the path
planner for the ego car, and p1 = do1 (s), . . . , pm = dom (s)
be the paths of the dynamic objects do1 . . . dom .
a) Safety metric: The first metric provides a quantitative
evaluation of how safe the chosen path is. It is defined in terms
of minimum distance between the ego car and any other object
along the path as follows
minDis(pe , {p1 , . . . , pm }) =

min
i∈{1...n}
j∈{1...m}

dis(pe .li , pj .li )

where dis is the Euclidean distance between two points.
b) Comfort metric: This metric assesses how comfortable the path has been for the driver. It is defined as maximum
acceleration along the path:
comf (pe ) = max |pe .ai |
i∈{1...n}

Note that other comfort metrics could be defined in terms of,
e.g., maximum torque or maximum lateral acceleration.
III. P ROPOSED APPROACH
In this paper, we are interested in defining sufficiency
criteria for path planner testing. A path planner can take
different decisions on the base of the different environmental
and driving conditions in which it is operating; we would
like to check that all these possible decisions that can be
taken by the path planner are observed in at least one test.
However, we do not precisely know which scenarios cause a
particular decision. Moreover, we cannot even characterise all
the possible decisions taken by the path planner, i.e., given two
decisions (two short-term paths computed by the path planner)
we do not know if they have been selected for the same reason.
However, we can exploit the architecture of the particular path
planner under test in order to create a proxy for these decisions.
In this section, we describe how we propose to do this using
a mutation-based approach.
1 In the path planner simulator we are using, the behaviour of dynamic
objects does not depend on the current situation, but only on the initial
conditions specified in the scenario. For this reason, we can compute the
path offline.

A. Path planner under test
The path planner provided by our industrial partner works as
follows. At each timestep, it chooses which short-term path to
follow in the next time period (see Def. 3). In order to do this,
it enumerates a set of possible short-term paths, and scores
them using a weighted cost function that considers different
aspects:
• Safety: no collision with moving or static objects must
happen and safety distances must be respected;
• Vehicle Limitation: actions that cannot be achieved by the
car must be avoided (e.g., no impossible steering can be
required to follow a path);
• Compliance: the car should respect road regulations as
much as possible;
• Comfort: the path should be as comfortable as possible for
the passenger, avoiding too much forward and/or lateral
acceleration.
In particular, the cost function uses these weights W for the
different aspects:
• w1 : a factor that is multiplied with the maximum lateral
acceleration along the short-term path;
• w2 : a constant that is added to the total cost if the
maximum lateral acceleration is over a given threshold;
• w3 : a constant that is added to the total cost if the speed
is over a given speed limit;
• w4 : a constant that is added to total cost if the maximum
acceleration along the short-term path is over a certain
threshold;
• w5 : a constant that is added to the total cost if the
maximum deceleration along the short-term path is over
a given threshold;
• w6 : a constant that is added to the total cost if the curvature along the short-term path is over a given threshold.
As such, the different decisions that the system can take are
tightly dictated by these weights. Note that weights w1 , w2 ,
w3 , w4 , and w5 are related to the safety aspect; weights w1 ,
w2 , and w6 , are related to the comfort aspect; weight w4
is related to the compliance aspect; finally, w2 , w4 , and w6
are related to the vehicle limitation aspect. A weight can be
associated with more than one aspect, e.g., w1 is associated
to the safety and comfort aspects, and w2 to all the aspects.
Our industrial partner provided us with a version of the
path planner that has been calibrated with a satisfactory set
of weight values w for W . In the following, we identify with
PPw the path planner configured with weight values w.
B. Weight coverage
Since the weights are strictly bound to the aspects that are
considered in the decisions, we propose to map the coverage
of the possible decisions with the coverage of the weights used
to make the decisions.
Therefore, in this section, we propose a way to assess
whether a weight is involved in a decision and, in section III-C,
a technique for measuring the sufficiency of a given test suite
T in testing the weights w.

Definition 4 (Weight coverage criterion). Given a path planner
PPw with weights w = {w1 , . . . , wk }, a test scenario s covers
a weight wi ∈ w w.r.t. a metric M , if there exists a weight
wi0 6= wi such that M (PPw (s)) 6= M (PPw0i (s)) with w0i =
{w1 , . . . , wi0 , . . . , wk }.

a weight. The other values of K let us explore the effect of
different scales of change to the weight values.
In the following, we identify with PPwj the path planner
i
obtained from PPw by mutating weight wi with mutation
operator MOj .

Intuitively, a test scenario s covers a weight wi if, with another value of the weight, the path planner behaves differently
according to metric M . A good test suite T should then cover
all weights wi .
Note that weight coverage has similarities with the MC/DC
coverage criterion [7] for Boolean expressions in which each
clause must be shown to determine the value of the global
predicate in a test: given an assignment of truth values, a clause
C determines the value of the global predicate P if flipping the
value of C changes the value of P . In our case, for each weight
wi , we want to have a test in which the aspect considered by
wi has some influence on the final decision taken by the path
planner; we want to show that by modifying the weight in
some way we can also modify the decision.

Remark 2. Note that our mutation operators are not meant
to be related to some fault-classes as in classical mutation
analysis, i.e., they are not meant to replicate some possible
faults. They are used to artificially perturbate the path planner,
such that it possibly takes different decisions due to the mutated weight. As future work, we could design more targeted
mutation operators, based on system and domain knowledge.

Remark 1. The path planner, in order to decide the next shortterm path in a scenario s, assigns a numerical cost to a set of
possible short-term paths stp 1 , . . . , stp n , using a cost function
that depends on the weights w; then, it selects the candidate
with the lowest cost. Changing a weight wi in wi0 will change
the cost of a given short-term path stp j from cj to c0j = cj +
∆j . If the weight considers an aspect that is relevant for the
scenario s, ∆j will be different for the different short-term
paths and so their ranking could be modified (and so the final
decision). Instead, if weight wi considers an aspect that is
irrelevant for the scenario s, the costs of all the possible shortterm paths will be modified by a same value ∆; therefore,
the rank of the possible short-term paths will not be affected
and the same short-term path (i.e., the one selected with the
original weights) will be selected as final decision.
C. Mutation-based approximation of weight coverage
As we can not exhaustively evaluate the weight coverage
of a test suite T (the weights having continuous values), we
propose a mutation-based approach to estimate whether or not
T covers the different weights.
In the following, we describe the mutation operators we
use to generate mutants, some oracles that we use to assess
whether a test kills a mutant, and finally how we use these for
estimating weight coverage.
1) Mutation operators: In this work, we are only concerned
with the coverage of the test suite T w.r.t. each individual
weight wi . Thus, we propose a simple mutation operator:
each mutant w0i differs only in the value wi0 of a weight
wi , which is multiplied by a constant K, i.e., wi0 = K · wi .
In order to explore different ranges for each weight, we use
the following values of K: 0, 0.5, 0.9, 1.1, 1.5, 2, 10. This
leads to seven versions of the operator that we refer to as
MOs = {MO1 , . . . , MO7 }. These factors were chosen to sample
the space of possible weight values. In particular, 0 and 10
show extreme changes, 0 completely cancelling the effect of

2) Mutation oracles: In order to assess whether a mutant
has been killed, we need to compare the paths computed by
the original path planner PPw and the mutated one PPwj . In
i
the following, given a scenario s, let pe = PPw (s) and p0e =
PPwj (s) be two paths computed by the two path planners, and
i
p1 = do1 (s), . . . , pm = dom (s) be the paths of the dynamic
objects do1 . . . dom . The mutated path planner is considered
killed by s if pe and p0e are sufficiently different.
In order to assess this, we can use different mutation oracles
that differ in the characteristics of the paths they consider (e.g.,
safety or comfort). We devised the following oracles, defined
as predicate killed that tells whether a scenario s kills the path
planner PPwj obtained by mutating weight wi with mutation
i
operator MOj .
Path Oracle (PO) Given a threshold θP , the mutated path
planner is considered killed if there is a timestep in which
the difference in the position of the ego car in the two
paths is greater than θP , i.e.,
killedP (s, wi , MOj ) =
(∃i ∈ {1, . . . , n} : dis(pe .li , p0e .li ) > θP )
where dis is the Euclidean distance.
Safety Oracle (SO) Given a threshold θS , the mutated path
planner is killed if the difference of the minimum distances (with the dynamic objects) of the two paths is
greater than θS , i.e.,
killed
S (s, wi , MOj ) =

minDis(pe , {p1 , . . . , pm })−
minDis(p0e , {p1 , . . . , pm })


> θS

Comfort Oracle (CO) Given a threshold θC , the mutated
path planner is killed if the difference of the comfort
measure in the two paths is greater than θC , i.e.,
killedC (s, wi , MOj ) = (|comf (pe ) − comf (p0e )| > θC )
Thresholds θP , θS , and θC must be selected by the domain
expert who can tune how much difference must be observed
in order to declare a mutant killed.
The different measures assess different aspects of the system
but are also more or less “strict”. For example, the Path Oracle
is the “easiest” to kill, and should be subsumed by the other
oracles (for equivalent thresholds). This idea can be somehow
related to the idea of weak and strong mutation testing [6]

TABLE I: D ESCRIPTION OF THE TEST SUITE SCENARIOS
ID

Description

s1
s2
s3
s4
s5

The ego car is proceeding on a lane and two dynamic objects cross the street closely in front of it.
The ego car is proceeding on a lane, following a slowing dynamic object and with a faster dynamic object coming from behind.
The ego car is proceeding on a lane and a dynamic object is proceeding in the different direction on a different lane.
The ego car is proceeding on a lane, encounters a parked car, and overtakes it.
Similar to s4 , but there is another car coming from the opposite direction. The ego car has enough time to overtake the parked car before the other
car arrives.
Similar to s5 , but the ego car must let the other car pass before overtaking the parked car (as there is not enough time before).
At a crossing, the ego car must turn right, while a dynamic object crosses the intersection from the opposite direction. The ego car must let the
object pass before turning.
At a crossing, the ego car must turn right, while a dynamic object is approaching the intersection from right. The ego car must slow down and let
the dynamic object pass.
At a crossing, the ego turns right, and, just after the turn, it encounters a dynamic object coming against the flow of traffic in its target lane.
The ego car is approaching from behind a dynamic object that is slowing down.

s6
s7
s8
s9
s10

in classic software testing, where weak mutation measures
changes in the internal state of the program caused by mutants,
while strong mutation considers only changes to output.
3) Estimating weight coverage: We can now describe a way
to estimate weight coverage. From an original valuation w of
weights W for the path planner PP, we create mutants w0 by
applying the mutation operators described before, by changing
the value of each weight wi in w in turn, thereby obtaining
mutated versions of the path planner PPwj . We then run T
i
against each PPwj and determine which mutants are killed by
i
T according to our different oracles. Finally, following our
initial definition of weight coverage (see Def. 4), we estimate
that a weight wi is covered w.r.t. a metric M (with M ∈
{P, S, C}) if one of its mutants is killed in a scenario, i.e.,
covered (wi , T, M ) =
(∃s ∈ T, ∃MOj ∈ MOs : killed M (s, wi , MOj ))

(1)

By Def. 4, if covered (wi , T, M ) holds, then wi is also covered for the weight coverage criterion. If covered (wi , T, M )
does not hold, we can estimate that weight coverage does not
hold as well, assuming that the mutation operators MOs are
a good proxy of all the possible weight changes (see Sect. VI
for a more detailed discussion on this point). In the remainder
of the text, we use the phrase weight coverage for both the
coverage and its mutation-based approximation.
IV. E XPERIMENTS
In order to evaluate the approach, we designed a test suite
T composed of 10 scenarios, whose description is reported
in Table I. Note that the path planner is designed to work in
countries as Ireland and Japan that adopt the left-hand traffic
practice. While designing the test suite, we tried to cover
different kinds of manoeuvres (e.g., going straight, overtaking a parked car, turning at a crossroad, giving precedence
to another car, etc.). All the scenarios have been designed
manually, except for scenario s1 that has been found using a
search algorithm with the aim of having a dangerous situation.
Then, we mutated the six weights W = {w1 , . . . , w6 } of the
original path planner (see Sect. III-A) using the seven mutation
operators MOs = {MO1 , . . . , MO7 } described in Sect. III-C1.
Therefore, in total we have 6 × 7 = 42 mutated versions
of the path planner; as before, we identify with PPwj the
i

TABLE II: W EIGHT COVERAGE (T: COVERED , F: NOT COVERED )
Weight
w1
w2
w3
w4
w5
w6

Mutation oracle
PO
SO
CO
T
T
T
T
T
T

T
T
F
T
T
F

T
T
F
T
T
F

path planner obtained from PPw by mutating weight wi with
mutation operator MOj .
We then ran the designed test suite T on the original path
planner PPw and the 42 mutated versions PPwj ; we collected
i
all the produced paths and computed the mutation oracles as
specified in Sect. III-C2. For the experiments, thresholds θP ,
θS , and θC of the mutation oracles have been set to 0: in this
way, it is easier to compare the killing strength of each oracle.
We evaluated the approach using four research questions.
RQ1: What is the weight coverage of the designed test suite?
We are interested in assessing how much the designed test
suite covers the path planner weights. Table II reports, for
each weight wi , its coverage (either True or False) according
to the three mutation oracles (see Eq. 1); we highlight in grey
the covered cases. Weights w1 , w2 , w4 , and w5 are covered
by the test suite with all the mutation oracles; these weights
are all related to (lateral) acceleration/deceleration. The fact
that they are all covered means that the test suite contains
tests in which the acceleration has some effect on the decision
taken by the path planner. Moreover, they are covered not only
with the path oracle (that is a weak criterion for declaring a
mutant killed), but also with the safety and comfort oracles,
that are more demanding: this means that the killed mutants
change both the minimum distance with the other dynamic
objects (considered in the safety oracle) and the maximum
acceleration (considered in the comfort oracle).
Weights w3 and w6 (related to the speed limit and sudden
change of direction), instead, are only covered by the path
oracle. This means that, although the mutants can slightly
change the taken path, they do not affect the minimum distance
with the other cars and the maximum speed.
RQ2: What is the weight coverage provided by each single
scenario?

TABLE III: W EIGHT COVERAGE BY SCENARIO (T: COVERED , F: NOT COVERED )
(b) Mutation oracle SO

(a) Mutation oracle PO
s
s1
s2
s3
s4
s5
s6
s7
s8
s9
s10

Weight
Count
w1 w2 w3 w4 w5 w6
T
F
F
T
T
F
T
T
T
T

T
T
F
T
T
T
T
T
T
F

T
F
F
F
F
F
F
F
F
F

T
T
F
F
T
T
T
T
T
T

F
F
F
F
T
T
T
T
T
T

F
T
F
F
F
F
F
F
F
F

Count 7/10 8/10 1/10 8/10 6/10 1/10

4/6
3/6
0/6
2/6
4/6
3/6
4/6
4/6
4/6
3/6

s
s1
s2
s3
s4
s5
s6
s7
s8
s9
s10

(c) Mutation oracle CO

Weight
Count
w1 w2 w3 w4 w5 w6
F
F
F
T
T
F
T
F
T
T

T
T
F
F
T
T
T
F
T
F

F
F
F
F
F
F
F
F
F
F

F
F
F
F
T
F
T
F
F
T

F
F
F
F
T
T
T
T
F
T

F
F
F
F
F
F
F
F
F
F

Count 5/10 6/10 0/10 3/10 5/10 0/10

We want to conduct a deeper analysis on the coverage
provided by each single scenario. Table III reports, for the
three mutation oracles, whether a given scenario covers a
given weight. Considering mutation oracle PO, we observe
that scenarios s1 , s5 , s7 , s8 , and s9 cover more than half
of the weights (4/6); these scenarios are among the most
complicated ones (see the description in Table I), in which
different aspects must be taken into consideration; this also
partially holds for scenarios s2 , s6 , and s10 that cover half
of the weights. Scenario s3 does not cover any weight, as
it simply describes a situation in which the ego car is going
straight, and not too many factors influence the decision of
the path planner in this case.
Regarding the mutation oracle SO, in general, scenarios kill
fewer weights than what done with the mutation oracle PO:
this is expected, as SO subsumes PO (i.e., if the minimum
distance is different, the path must be different as well, but
not the other way round). However, scenarios s5 , s7 , and s10
kill the same weights with the two oracles; this means that,
for these scenarios, the mutants always lead to a different path
in which the minimum distance with the dynamic objects is
affected (either smaller or larger). Indeed, using the original
path planner, the ego car gets quite close to the dynamic
objects, and so it is reasonable that any change in the path
affects also the minimum distance.
Regarding the mutation oracle CO, only three scenarios
kill some weight. Scenario s7 achieves the highest coverage,
killing half of the weights; this is due to the fact that the
change of the weights leads to either a greater maximum
acceleration to cross before the incoming car, or a lower
maximum acceleration to let the other car pass, depending
on the mutants (see scenario description in Table I).
RQ3: How many scenarios cover each weight?
We now want to assess how easy it is to cover a weight;
we assume that the more scenarios cover a weight, the easier
it is to cover it. The last rows of the tables in Table III report
the count of scenarios covering a given weight.
Using the mutation oracle PO, we observe that w1 , w2 ,
and w4 are the weights that are easier to cover. Indeed, they
are all related to lateral/normal acceleration and very likely a

1/6
1/6
0/6
1/6
4/6
2/6
4/6
1/6
2/6
3/6

s
s1
s2
s3
s4
s5
s6
s7
s8
s9
s10

Weight
Count
w1 w2 w3 w4 w5 w6
F
F
F
F
F
F
T
F
F
F

F
T
F
F
F
F
T
F
F
F

F
F
F
F
F
F
F
F
F
F

F
F
F
F
F
F
T
F
F
F

F
F
F
F
F
F
F
F
F
T

F
F
F
F
F
F
F
F
F
F

0/6
1/6
0/6
0/6
0/6
0/6
3/6
0/6
0/6
1/6

Count 1/10 2/10 0/10 1/10 1/10 0/10

decision of the path planner depends on the acceleration (and
so a perturbation of the weights changes the computed path).
Instead, weight w3 (related to the violation of the speed
limit) is only covered by scenario s1 in which the ego car is
close to collision with two other dynamic objects. We further
observe that, for w3 , only mutant PPw03 , in which the constraint
on the speed limit is completely removed, is killed: in this way,
the path planner can compute an even safer (and so different)
path that avoids the dynamic objects faster.
Also weight w6 (related to sudden change of direction) is
only covered by a single scenario, namely s2 . In s2 the ego
car is approaching a slowing car and is followed by a fast
car that is approaching its back: by relaxing the constraint on
the sudden change of lane, the path planner can compute a
different and safer path.
Observations similar to those done for mutation oracle PO
can also be done for mutation oracle SO. We only observe
that w3 is no more covered by s1 : this means that, although
the mutated path planner can compute a different path, the
minimum distance to the other dynamic objects remains the
same (the mutated path planner can simply exit from the
dangerous situation faster, as the constraint on the speed limit
has been relaxed). In the same way, scenario s2 no longer
covers weight w6 : the mutated path planner can avoid the
dangerous situation with a more sudden action (because the
weight is relaxed) but it reaches the same minimum distance
as the original path planner.
As we already observed in RQ2, the comfort oracle CO is
highly demanding and it is difficult to kill mutants with this
oracle (it is only possible by obtaining a path with a different
maximum acceleration). As expected, only the weights related
to acceleration (i.e., w1 , w2 , w4 , and w5 ) can be covered by
at least one scenario.
RQ4: What is the weight coverage provided by each mutation
operator?
We are interested in assessing which mutation operators
produce mutants that are easier to kill. Table IV reports, for
the three mutation oracles, whether a given mutation operator
(we report the constant K used in the operator) produces a
mutated path planner that is covered (for at least one scenario

TABLE IV: W EIGHT COVERAGE BY MUTATION OPERATOR (T: COVERED , F: NOT COVERED )
(b) Mutation oracle SO

(a) Mutation oracle PO
K
0
0.5
0.9
1.1
1.5
2
10

Weight
Count
w1 w2 w3 w4 w5 w6
T
T
F
F
F
F
T

T
F
F
F
T
T
T

T
F
F
F
F
F
F

T
T
T
F
T
T
T

T
T
F
T
T
T
T

F
F
F
F
F
F
T

5/6
3/6
1/6
1/6
3/6
3/6
5/6

Count 3/7 4/7 1/7 6/7 6/7 1/7

K
0
0.5
0.9
1.1
1.5
2
10

(c) Mutation oracle CO

Weight
Count
w1 w2 w3 w4 w5 w6
T
F
F
F
F
F
T

T
F
F
F
T
T
T

F
F
F
F
F
F
F

T
T
T
F
F
F
T

T
T
F
T
T
T
T

F
F
F
F
F
F
F

Count 2/7 4/7 0/7 4/7 6/7 0/7

4/6
3/6
1/6
1/6
2/6
2/6
4/6

K
0
0.5
0.9
1.1
1.5
2
10

Weight
Count
w1 w2 w3 w4 w5 w6
F
F
F
F
F
F
T

T
F
F
F
F
T
T

F
F
F
F
F
F
F

T
F
F
F
F
F
F

T
F
F
F
F
F
T

F
F
F
F
F
F
F

3/6
0/6
0/6
0/6
0/6
1/6
3/6

Count 1/7 3/7 0/7 1/7 2/7 0/7

of the test suite T ). For all the mutation oracles, coverage is
correlated with the degree of change of the weight: mutation
operators that change the weight significantly (i.e., 0 and 10)
are those that cover the most (5 out of 6 weights), while weaker
mutation operators (i.e., 0.9 and 1.1) cover less. For mutation
oracle CO, only mutants with K equal to 0, 2, or 10, can lead
to the coverage of at least one weight.
The results in Table IV also provide some insights on the
weights themselves. Let’s consider the results of the mutation
oracle PO in Table IVa. We observe that some weights such
as w4 and w5 are covered with almost any mutation operator:
this means that the weight is important in the decision making
of the path planner and thus it is sensitive to small changes.
On the other hand, if a system designer knew their test suite
is strong, but a weight is not covered, this could show that the
weight has no influence on the decision making, and could
highlight a fault in the system or its design.

in this work uses a linear cost function. For a new value to
change the result of a test when no mutant does, it would
then need to induce a greater change than the mutants, which
have already been designed to induce significant changes to
the weights. Still, if such a case occurred, one could ponder the
significance of such a coverage: does a scenario meaningfully
cover a weight, if for the decision of the path planner in this
scenario to change one must introduce massive change to the
weight?
A final observation is related to the mutation oracles. We
can note that, although the path oracle is a very weak criterion,
it is still useful to decide whether a scenario should be kept in
the test suite: if a scenario cannot kill any weight even with
regards to the path oracle, it means that it is not challenging
the path planner at all and should be removed from the test
suite (as scenario s3 . See Table IIIa).

V. D ISCUSSION

We identify these threats to the validity of the approach.
A threat to external validity [8] is that the approach may not
be generalizable to other systems. As this is a project driven
by a collaboration with an industrial partner, the solution has
the risk to be too domain specific. First of all, we want to
point out that, in some cases, a solution to a given problem is
necessarily domain-specific and trying to achieve generability
could also be counterproductive [9]. Moreover, we still believe
that the approach could be applied to other systems similar
to the path planner, i.e., systems solving some optimization
problems using some weights to consider different aspects.
As future work, we plan to evaluate whether the approach is
generalizable to a broader class of systems.
A threat to internal validity [8] could be that our mutationbased approach could be faulty and so the obtained results
would be not meaningful. In order to mitigate this threat, we
checked that the mutated scenarios are syntactically correct
and that they are parsed correctly by the path planner simulator; moreover, we assessed that the mutation oracles are
implemented correctly by verifying that some known relations
between them hold: for example, if the path oracle is 0, the
other two oracles must be 0 as well.

We now provide more general observations about the proposed approach.
The first observation is related to the coverage of a weight.
If a weight wi is never covered in a test suite, it could mean
that either the test suite is not complete enough to cover wi , or
wi is never relevant in the decisions taken by the path planner.
In the former case, we would just need to add some scenario
trying to cover wi ; in the latter case, we would need to mark
wi as an infeasible test requirement and we could report a
problem in the path planner. However, detecting infeasible test
requirements is in general undecidable.
Another observation is related to the completeness of the
mutation-based approach. In order to approximate weight coverage of a weight wi , we propose to use a set of seven mutants
where wi is modified using seven constants of different scales.
It could be that wi is covered by a test suite T according
to weight coverage (see Def. 4), but not using the mutationbased approximation. However, we believe that this does not
affect the general conclusions of our experiments regarding the
relations between the scenarios and the weights: it is unlikely
that, given two scenarios that do not cover any weight with
the mutation-based approach, there are some other changes
of the weights (not considered by the mutants) that cover one
scenario and not the other. Indeed, the path planner considered

VI. T HREATS TO VALIDITY

VII. R ELATED WORK
In this section we review some related work concerning
testing of, and testing criteria for automated driving systems,

as well as non-conventional applications of mutation analysis.
Testing of autonomous driving systems is a complex issue
that includes many challenges, as highlighted by Koopman and
Wagner in [10]. In [11], Wachenfeld and Winner show that it is
infeasible to test autonomous driving systems only using real
life test drives. Indeed, they show that, according to German
highway driving data, one would have to drive 6.61 billion
kilometers in order to encounter some fatal scenarios, i.e.,
the scenarios that should be most critically tested. Zhao and
Peng [12] and Helmer et al. [13] arrive at similar conclusions,
stating that billions of kilometers should be driven to achieve
sufficient testing guarantees.
As such, many works [3], [13]–[15] focus on using simulation and particular scenarios to test autonomous driving
systems, this is the situation we are in in the context of this
work. In this context, the question of test sufficiency, or of
a test stopping criterion becomes essential. Indeed, as Hauer
at al. remark in [4], “One can always come up with another
scenario type as well as with instances of those types that
are different from the types and instances used before”, which
means that we need a criterion to know when our test data has
covered all plausible situations. Our work not only focuses on
a test ending criterion but on a more general testing criterion
that lets us evaluate how much of the system’s decision space
a test suite covers, rather than how much of the possible
scenarios have been covered, as different scenarios could lead
to the same decisions.
Mutation analysis has been applied to diverse domains [6],
and recently to deep neural networks (DNNs). DNNs have
the same characteristic as the path planner, in that their
behavior is governed by computed numerical values, rather
than logical branches, and that their correctness is evaluated by
some metrics (e.g., accuracy) rather than with pass/fail tests.
A mutation analysis method for DNNs has been proposed
that considers mutations on training data, training code, and
trained models [16]. The mutation score evaluates whether
each mutation changes correct classification into misclassification in some test data. Our proposal works with the more
complex situation of path planner. Although the mutation
targets (weights) are also continuous values, we deal with
complex oracles and multiple evaluation criteria, instead of
the binary problem of misclassification.
VIII. C ONCLUSIONS
In this paper, we proposed a mutation-based approach for
assessing whether all the possible decisions that can be taken
by the path planner of an autonomous car are covered in
a test suite (each test is a scenario). The path planner we
consider makes decisions by using a weighted function of
different aspects (safety, comfort, etc.). The approach consists
in mutating the weights and checking whether the test suite is
able to kill the mutant. The approach has been experimented on
a manually designed test suite; we observed that some weights
are easier to cover as they consider aspects that occur more
often in a scenario. Moreover, more complicated scenarios that
generate more complex paths are those that allow coverage

of more weights. We believe that these preliminary results
confirm our intuition that the proposed coverage criterion is
reasonable. However, more rigorous and systematic evaluation
is needed: as future work, we plan to perform a wider set of
experiments using different test suites, automatically generated
and manually designed. Moreover, we plan to assess whether
weight coverage correlates with good fault detection.
Finally, we believe that the proposed approach is not only
applicable to path planners, but to any optimisation program
that relies on a weighted function; as future work, we plan to
give a more general definition of the weight coverage criterion,
and experiment it on a wider class of systems.
R EFERENCES
[1] J. Stewart. (2018, Mar) Tesla’s self-driving autopilot involved in another
deadly crash. Accessed October 3, 2019. [Online]. Available: https:
//www.wired.com/story/tesla-autopilot-self-driving-crash-california/
[2] S. Levin and J. Wong Carrie. (2018, Mar) Self-driving uber kills arizona
woman in first fatal crash involving pedestrian. Accessed October
3, 2019. [Online]. Available: https://www.theguardian.com/technology/
2018/mar/19/uber-self-driving-car-kills-woman-arizona-tempe
[3] T. Menzel, G. Bagschik, and M. Maurer, “Scenarios for development,
test and validation of automated vehicles,” in 2018 IEEE Intelligent
Vehicles Symposium (IV), June 2018, pp. 1821–1827.
[4] F. Hauer, T. Schmidt, B. Holzmuller, and A. Pretschner, “Did we test all
scenarios for automated and autonomous driving systems?” in PrePrint
for Proc. of IEEE Intelligent Transportation Systems Conference, 2019.
[5] K. Czarnecki, “WISE drive: Requirements analysis framework for
automated driving systems,” Waterloo Intelligent Systems Engineering
Lab (WISE), University of Waterloo, Tech. Rep., 07 2018, https:
//uwaterloo.ca/waterloo-intelligent-systems-engineering-lab/projects/
wise-drive-requirements-analysis-framework-automated-driving.
[6] M. Papadakis, M. Kintis, J. Zhang, Y. Jia, Y. Le Traon, and M. Harman,
“Chapter six - mutation testing advances: An analysis and survey,” ser.
Advances in Computers. Elsevier, 2019, vol. 112, pp. 275–378.
[7] J. J. Chilenski and S. P. Miller, “Applicability of modified condition/decision coverage to software testing,” Software Engineering Journal, vol. 9, no. 5, pp. 193–200, Sep. 1994.
[8] C. Wohlin, P. Runeson, M. Hst, M. C. Ohlsson, B. Regnell, and
A. Wessln, Experimentation in Software Engineering. Springer Publishing Company, Incorporated, 2012.
[9] L. C. Briand, D. Bianculli, S. Nejati, F. Pastore, and M. Sabetzadeh, “The
case for context-driven software engineering research: Generalizability
is overrated,” IEEE Software, vol. 34, no. 5, pp. 72–75, 2017.
[10] P. Koopman and M. Wagner, “Challenges in autonomous vehicle testing
and validation,” SAE Int. J. Trans. Safety, vol. 4, pp. 15–24, 04 2016.
[11] W. Wachenfeld and H. Winner, The Release of Autonomous Vehicles.
Berlin, Heidelberg: Springer Berlin Heidelberg, 2016, pp. 425–449.
[12] D. Zhao and H. Peng, “From the lab to the street: Solving the challenge
of accelerating automated vehicle testing,” CoRR, vol. abs/1707.04792,
2017.
[13] T. Helmer, L. Wang, K. Kompass, and R. Kates, “Safety performance
assessment of assisted and automated driving by virtual experiments:
Stochastic microscopic traffic simulation as knowledge synthesis,” in
2015 IEEE 18th International Conference on Intelligent Transportation
Systems, Sep. 2015, pp. 2019–2023.
[14] C. Roesener, F. Fahrenkrog, A. Uhlig, and L. Eckstein, “A scenariobased assessment approach for automated driving by using time series
classification of human-driving behaviour,” in 2016 IEEE 19th International Conference on Intelligent Transportation Systems (ITSC), Nov
2016, pp. 1360–1365.
[15] E. de Gelder and J.-P. Paardekooper, “Assessment of automated driving
systems using real-life scenarios,” in 2017 IEEE Intelligent Vehicles
Symposium (IV), June 2017, pp. 589–594.
[16] L. Ma, F. Zhang, J. Sun, M. Xue, B. Li, F. Juefei-Xu, C. Xie, L. Li,
Y. Liu, J. Zhao, and Y. Wang, “DeepMutation: Mutation testing of
deep learning systems,” in 2018 IEEE 29th International Symposium
on Software Reliability Engineering (ISSRE), Oct 2018, pp. 100–111.

