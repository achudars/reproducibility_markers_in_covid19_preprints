Tree Automata as Algebras:
Minimisation and Determinisation
Gerco van Heerdt
University College London, United Kingdom
gerco.heerdt@ucl.ac.uk

Tobias Kappé
University College London, United Kingdom
tkappe@cs.ucl.ac.uk

Jurriaan Rot
University College London, United Kingdom and Radboud University, The Netherlands
jrot@cs.ru.nl

arXiv:1904.08802v2 [cs.FL] 16 Jul 2019

Matteo Sammartino
University College London, United Kingdom
m.sammartino@ucl.ac.uk

Alexandra Silva
University College London, United Kingdom
alexandra.silva@ucl.ac.uk

Abstract
We study a categorical generalisation of tree automata, as Σ-algebras for a fixed endofunctor Σ
endowed with initial and final states. Under mild assumptions about the base category, we present a
general minimisation algorithm for these automata. We then build upon and extend an existing
generalisation of the Nerode equivalence to a categorical setting and relate it to the existence of
minimal automata. Finally, we show that generalised types of side-effects, such as non-determinism,
can be captured by this categorical framework, leading to a general determinisation procedure.
2012 ACM Subject Classification Theory of Computation → Formal languages and automata theory
Keywords and phrases tree automata, algebras, minimisation, determinisation, Nerode equivalence
Digital Object Identifier 10.4230/LIPIcs...
Funding This work was partially supported by the ERC Starting Grant ProFoundNet (grant code
679127), a Leverhulme Prize (PLP–2016–129) and a Marie Curie Fellowship (grant code 795119).

1

Introduction

Automata have been extensively studied using category theory, both from an algebraic and a
coalgebraic perspective [26, 6, 43, 40]. Categorical insights have enabled the development of
generic algorithms for minimisation [4], determinisation [45], and equivalence checking [15].
A fruitful line of work has focussed on characterising the semantics of different types of
automata as final coalgebras. The final coalgebra contains unique representatives of behaviour,
and the existence of a minimal automaton can be formalised by a suitable factorisation
of the map from a given automaton into the final coalgebra. Algorithms to compute the
minimal automaton can be devised based on the final sequence, which yields procedures
resembling classical partition refinement [32, 18]. Unfortunately, bottom-up tree automata do
not fit the abstract framework of final coalgebras.1 This impeded the application of abstract

1

The language semantics of top-down tree automata represented as coalgebras is given in [30], based on
a transformation to bottom-up tree automata. In this paper, we focus on bottom-up automata only.
© G. van Heerdt, T. Kappé, J. Rot, M. Sammartino, A. Silva;
licensed under Creative Commons License CC-BY
Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

XX:2

Tree Automata as Algebras: Minimisation and Determinisation

algorithms for minimisation, determinisation, and equivalence. We embrace the categorical
algebraic view on automata due to Arbib and Manes [8] to study bottom-up tree automata
(Section 3). This algebraic approach is also treated in detail by Adámek and Trnková [6],
who, among other results, give conditions under which minimal realisations exist (see also [3])
and constructions to determinise partial and non-deterministic bottom-up tree automata.
However, generic algorithms for minimisation, and a more abstract and uniform picture of
determinisation, have not been studied in this context.
The contributions of this paper are three-fold. First, we explore the notion of cobase to
devise an iterative construction for minimising tree automata, at the abstract level of algebras,
resembling partition refinement (Section 4). The notion of cobase is dual to that of base [11],
which plays a key role in reachability of coalgebras [46, 10] and therefore in minimisation
of automata. Second, we study a different characterisation of minimality via the Nerode
equivalence, again based on work of Arbib and Manes [8], and provide a generalisation using
monads that allows to treat automata with equations (Section 5). Third, we extend bottomup tree automata to algebras in the Kleisli category of a monad, which enables us to study
tree automata enriched with side-effects and derive an associated determinisation procedure
(Section 6). We demonstrate the generality of our approach by applying it both to classical
examples—deterministic, non-deterministic, and multiplicity/weighted tree automata—and
to a novel kind of tree automata, namely nominal tree automata.

2

Preliminaries

We assume basic knowledge of category theory. Throughout this paper, we fix a category C.
Monads A monad on C is a triple (T, η, µ) consisting of an endofunctor T on C and two
natural transformations: a unit η : Id ⇒ T and a multiplication µ : T 2 ⇒ T , which satisfy
the compatibility laws µ ◦ ηT = idT = µ ◦ T η and µ ◦ µT = µ ◦ T µ.
S
I Example 2.1. The triple (Pf , {−}, ) is a monad on Set, where Pf is the finite powerset
S
functor , {−} is the singleton operation, and
is union of sets. Another example is the
multiplicity monad (MF , e, m) for a field F, where MF is the functor sending a set X to
MF X = {ϕ : X → F | ϕ has finite support}. An element ϕ can be seen as a formal finite sum
P
, where each xi has multiplicity si . The unit e sends x to 1x and the multiplication
i si xiP
P
is mX ( i si ϕi )(x) = i si · ϕi (x), where · is the field multiplication.
Algebras and Varietors We fix a functor Σ : C → C and write Alg(Σ) for the category
of Σ-algebras. Throughout this paper, we assume that Σ is a varietor [6], i.e., that the
forgetful functor U : Alg(Σ) → C admits a left adjoint F : C → Alg(Σ). The varietor Σ
induces a monad (Σ , η, µ) on C, where Σ = U F . Given an object X of C, we refer to
F X = (Σ X, αX ) as the free Σ-algebra over X. The free Σ-algebra satisfies the following:
for every Σ-algebra Q and every morphism x : X → U Q of C, there is a unique Σ-algebra
morphism x] : (Σ X, αX ) → Q with U (x] ) ◦ ηX = x.
I Example 2.2. A functor is finitary if it preserves filtered colimits. Any finitary Set
functor is a varietor: free algebras over a set X can be obtained as a colimit of a transfinite
sequence [2, 28]. A polynomial functor on Set is a functor inductively defined by P := id |
`
A | P1 × P2 | i∈I Pi where A is any constant functor. Polynomial functors are finitary and
therefore varietors.

G. van Heerdt, T. Kappé, J. Rot, M. Sammartino, A. Silva

3

Tree automata, categorically

In this section we start our categorical investigation of (bottom-up) tree automata. We first
discuss a general notion of automaton over an endofunctor Σ due to Arbib and Manes [8]
and then discuss how this notion can be instantiated to obtain various kinds of automata.
I Definition 3.1 (Σ-tree automaton). A Σ-tree automaton over objects I and O in C is a
tuple (Q, δ, i, o) such that (Q, δ) is a Σ-algebra and i : I → Q and o : Q → O are morphisms
of C. The objects I and O are referred to as the input object and output object respectively.
A homomorphism from an automaton (Q, δ, i, o) to an automaton (Q0 , δ 0 , i0 , o0 ) is a Σ-algebra
homomorphism h : Q → Q0 (i.e., δ 0 ◦ Σh = h ◦ δ) such that h ◦ i = i0 and o0 ◦ h = o.
Throughout this paper, we fix input and output objects I and O respectively. If Σ is clear
from the context we sometimes refer to a Σ-tree automaton simply as an automaton.
A language (over Σ) is a morphism L : Σ I → O. In the context of an automaton
A = (Q, δ, i, o), we can think of U (i] ) : Σ I → Q, induced by the free Σ-algebra F I on I,
as the reachability map, telling us which state is reached by parsing an element of the free
algebra over I. We will write rchA (or rch if A is obvious) for U (i] ). The language of A is
the morphism L(A) : Σ I → O in C given by L(A) = o ◦ rchA .
I Example 3.2 (Deterministic bottom-up tree automata). Let us see how Σ-tree automata
can capture deterministic bottom-up tree automata. We first recall some basic concepts.
A ranked alphabet is a finite set of symbols Γ, where each γ ∈ Γ is equipped with an
arity ar(γ) ∈ N. A frontier alphabet is a finite set of symbols I. The set of Γ-trees over
I, denoted TΓ (I), is the smallest set such that I ⊆ TΓ (I), and for all γ ∈ Γ we have that
t1 , . . . , tar(γ) ∈ TΓ (I) implies (γ, t1 , . . . , tar(γ) ) ∈ TΓ (I). In other words, TΓ (I) consists of finite
trees with leaves labelled by symbols from I and internal nodes labelled by symbols from Γ;
the number of children of each internal node matches the arity of its label.
A ranked alphabet Γ gives rise to a polynomial signature endofunctor Σ : Set → Set given
`
by ΣX = γ∈Γ X ar(γ) . A deterministic bottom-up tree automaton is a Σ-tree automaton
A = (Q, δ, i, o) where Q is finite, Σ is a signature endofunctor, and O = 2. Here Q is the
set of states, i : I → Q is the initial assignment, o : Q → 2 is the characteristic function of
final states, and for each γ ∈ Γ we have a transition function δγ = δ ◦ κγ : Qar(γ) → Q. The
language L(A) is the set of all Γ-trees t such that (o ◦ δ̂)(t) = 1, where δ̂ : TΓ (I) → Q extends
δ to trees by structural recursion:
δ̂(`) = i(`)

(` ∈ I)

δ̂(γ, t1 , . . . , tk ) = δγ (δ̂(t1 ), . . . , δ̂(tk ))

In other words, L(A) contains the trees that evaluate to a final state. The map δ̂ above is
the transpose i] in the relevant adjunction between Set and Alg(Σ), where the left adjoint
sends a set I to the Σ-algebra with carrier TΓ (I) and the obvious structure map.

3.1

Nominal tree automata

To show the versatility of our definition, we instantiate it in the category Nom of nominal
sets and equivariant functions. This results in a notion of nominal tree automaton—along
the lines of nominal automata theory [13]—which, as we shall see below, provides a useful
model for languages of trees with variables and variable binding. We first recall some basic
notations of nominal set theory [41]. Let A be a countable set of atoms, and let Sym(A) be
the associated symmetry group, consisting of all permutations on A. A nominal set is a pair
(X, ·) of a set X and a function · : Sym(A) × X → X forming a left action of Sym(A) on X.

XX:3

XX:4

Tree Automata as Algebras: Minimisation and Determinisation

Each x ∈ X is required to have finite support, i.e., there must exist a finite A ⊆ A such that
for all π ∈ Sym(A), if π is equal to idA when restricted to A, then π · x = x. The minimal
such A is denoted supp(x), and can be understood as the set of “free” names of x. Given
x ∈ X, its orbit is the set {π · x | π ∈ Sym(A)}. We say that a nominal set X is orbit-finite
whenever it has finitely many orbits. An equivariant function f : (X, ·) → (Y, ·) is a function
X → Y that respects permutations, i.e., f (π · x) = π · f (x).
Polynomial functors in Nom support additional operations [20], such as the name abstraction functor [A] : Nom → Nom, which “binds” a name in the support. For instance, if x ∈ X,
then haix ∈ [A]X, with supp(haix) = supp(x) \ {a}. The element haix should be thought of
as an equivalence class up to α-conversion w.r.t. the binder hai. We can then define tree
automata for parsing trees with binders. Consider for instance Σλ : Nom → Nom given by
Σλ X = X × X + [A]X
| {z } | {z }
appl

lambda

describing the syntax of the λ-calculus [21]. This functor is finitary [20], which implies the
existence of free algebras. Fixing I = A, the carrier of the free Σλ -algebra over I consists
of parse trees for λ-terms (up to α-conversion) with variables in A. We can then define
automata parsing these trees as A = (Q, δ, i, o), where
Q is a nominal set;
δ consists of two equivariant functions δappl : Q × Q → Q and δlambda : [A]Q → Q;
i : A → Q is an equivariant function, selecting states for parsing variables;
o : Q → 2 is an equivariant characteristic function of final states, which implies that if a
state is final, so are all the states in its orbit.
The reachability function is the equivariant function given by


if t ∈ A

i(t)
rchA (t) = δappl (rchA (t1 ), rchA (t2 )) if t = (t1 , t2 )


δ
(hairch (t0 ))
if t = hait0 .
lambda

A

The most interesting case is the last one: in order to parse the α-equivalence class hait0 , we
first parse any tree t0 such that hait0 is in the class, and then we take the resulting state up
to α-conversion w.r.t. hai. Note that L(A) is equivariant, i.e., invariant under permutations
of atoms. Thus A recognises λ-trees up to bijective renamings of variables.

4

Minimisation

In this section we define a construction that allows to minimise a given tree automaton. We
start with a few basic preliminary notions related to quotients and factorisation systems.
Factorisations An (E, M)-factorisation system on C consists of classes of morphisms E and
M, closed under composition with isos, such that for every morphism f in C there exist
e ∈ E and m ∈ M with f = m ◦ e, and we have a unique diagonal fill-in property.
We list a few properties of factorisation systems. First, both E and M are closed under
composition. Furthermore, if g ◦ f ∈ E and f ∈ E, then g ∈ E. Lastly, if E consists of
epimorphisms, then it is closed under cointersections, i.e., wide pushouts of epimorphisms [5].
A functor Σ is said to preserve E-cointersections if it preserves wide pushouts of epimorphisms
in E. In that case, for an epimorphism e, if e ∈ E then Σe is again an epimorphism.

G. van Heerdt, T. Kappé, J. Rot, M. Sammartino, A. Silva

Quotients Define by ≤ the order on morphisms with common domain given by f ≤ g iff
∃h.g = h ◦ f . This induces an equivalence relation on such morphisms. A quotient of an
object X is an epimorphism q : X  X 0 identified up to the equivalence, i.e., an equivalence
class. We denote by Quot(X) the class of all quotients of X. The underlying category C is
said to be cowellpowered if Quot(X) is a set for every X. In that case, if C is cocomplete,
Quot(X) forms a complete lattice, with the order given by ≤, and the least upper bound
(join) given by cointersection. We denote by QuotE (X) the set of quotients of X that are in
E. (This is well-defined because E is closed under isomorphisms.)
I Assumption 4.1. Throughout this section, C is cocomplete and cowellpowered. Moreover,
we fix an (E, M)-factorisation system in C, where E contains epimorphisms only.
I Remark 4.2. The category Set is cocomplete and cowellpowered, and so is Nom introduced
in Section 3.1. In general, the existence of an (epi, strong mono)-factorisation system already
follows from C being cocomplete and cowellpowered [16]. Allowing a more general choice of
factorisation system will be useful in Section 5, where we work with a different E.
Let (Q, δ) be a Σ-algebra. A quotient algebra is a Σ-algebra (Q0 , δ 0 ) together with a
quotient q : Q  Q0 in E that is an algebra homomorphism. Given a Σ-tree automaton
(Q, δ, i, o), a quotient automaton is a Σ-tree automaton (Q0 , δ 0 , i0 , o0 ) together with a quotient
q : Q  Q0 in E that is a homomorphism of automata.
I Definition 4.3 (Minimisation). The minimisation of a Σ-tree automaton (Q, δ, i, o) is a
quotient automaton (Qm , δm , im , om ), q : Q  Qm , such that for any quotient automaton
(Q0 , δ 0 , i0 , o0 ), q 0 : Q  Q0 of (Q, δ, i, o) there exists a (necessarily unique) automaton homomorphism h : Q0  Qm such that h ◦ q 0 = q.
Minimisation is called minimal reduction in [6]. Note that the morphism h in the definition
of minimisation is in E, since q 0 and q are. In the sequel, we sometimes refer to a quotient
q : Q  Qm as the minimisation if there exist δm , im , om turning (Qm , δm , im , om ), q into the
minimisation of (Q, δ, i, o).
I Definition 4.4. A Σ-tree automaton A is said to be reachable if the associated reachability
map rch is in E. It is minimal if it is reachable and for every reachable Σ-tree automaton A0
s.t. L(A) = L(A0 ) there exists a (necessarily unique) homomorphism from A0 to A.
The above definition of minimality relies on reachability; a more orthogonal (but equivalent)
definition of minimality is explored in Section 4.2.
We conclude with a few observations on the connection between minimisation and
minimality, treated in detail in [6]. We say Σ admits minimisation of reachable automata if
every reachable automaton over Σ has a minimisation.
I Lemma 4.5. An automaton A is minimal iff it is the minimisation of (Σ I, αI , ηI , L(A)).
I Lemma 4.6. The functor Σ admits minimisation of reachable automata if and only if a
minimal automaton exists for every language over Σ. In that case, if A is reachable, then
the minimisation of A is minimal.
Proof. For the equivalence, the implication left to right follows from Lemma 4.5. For the
converse, one readily shows that the minimisation of an automaton A is given by the minimal
automaton accepting L(A). The second statement holds by uniqueness of minimisations. J

XX:5

XX:6

Tree Automata as Algebras: Minimisation and Determinisation

4.1

Minimisation via the cobase

We show how to compute the minimisation of a given automaton (Q, δ, i, o) using the so-called
cobase [11]. This is the dual of the base, which is used in [10, 46] for reachability of coalgebras.
The cobase allows us to characterise the minimisation as the greatest fixed point of a certain
monotone operator on QuotE (Q), which is a complete lattice by Assumption 4.1.
I Definition 4.7. Let f : ΣX → Y be a morphism. The (E)-cobase of f (if it exists) is the
greatest quotient q ∈ QuotE (X) such that there exists a morphism g with g ◦ Σq = f .
A concrete instance of the cobase will be given below in Example 4.11. The cobase can be
computed as the join of all quotients satisfying the relevant condition, provided that the
functor preserves cointersections.
I Theorem 4.8 (Existence of cobases). Suppose Σ : C → C preserves E-cointersections. Then
every map f : ΣX → Y has an E-cobase, given by the cointersection
_
{q ∈ QuotE (X) | ∃g. g ◦ Σq = f } .
Proof. For E the class of all epis, the dual is shown in [10, 46]. The proof goes through in
the current, more general setting, using that E is closed under cointersections.
J
I Remark 4.9. A Set functor preserves cointersections iff it is finitary [6]. In particular,
this is the case for polynomial functors. For Nom functors we can use that, in general, a
functor preserves cointersections if it is finitary and preserves reflexive coequalisers [6]. These
conditions hold for polynomial Nom functors introduced in Section 3.1, because they preserve
sifted colimits [34], which include filtered colimits and reflexive coequalisers.
We now define an operator on quotients of the state space of an automaton, which
characterises the minimisation of an automaton and gives a way of computing it. To
this end, given a Σ-algebra (Q, δ) and a quotient q : Q  Q0 ∈ QuotE (Q), define the
quotient Θδ (q) : Q  Θδ (Q0 ) as the cobase of q ◦ δ. This defines a monotone operator
Θδ : QuotE (Q) → QuotE (Q) that has the following important property (see [10, 46]):
I Lemma 4.10. Suppose Σ preserves E-cointersections. For any Σ-algebra (Q, δ), a quotient
q : Q  Q0 in QuotE (Q) satisfies q ≤ Θδ (q) iff there is an algebra structure δ 0 : ΣQ0 → Q0
turning q into an algebra homomorphism.
The operator Θδ allows us to quotient the transition structure of the automaton. In order
to obtain the minimal automaton, we incorporate the output map o : Q → O into the
construction of a monotone operator based on Θδ . For technical convenience, we assume
that this map is an element of QuotE (Q).2 The relevant monotone operator for minimisation
is Θδ ∧ o (where the meet ∧ is taken pointwise in QuotE (Q)).
I Example 4.11. Let Σ : Set → Set be a polynomial functor induced by signature Γ. We
first spell out what the cobase means concretely in this case and then study the operator Θδ
in more detail. Since Σ is an endofunctor on Set, the cobase of a map f : ΣX → Y is the
largest quotient q ∈ QuotE (X) such that for all t, t0 ∈ ΣX:
if Σq(t) = Σq(t0 ), then f (t) = f (t0 ) .

2

This is not a real restriction: one can just pre-process the automaton by factorising o, i.e., keeping only
those outputs actually occurring in the automaton.

G. van Heerdt, T. Kappé, J. Rot, M. Sammartino, A. Silva

This means that for every γ ∈ Γ with k = ar(γ), and any x1 , . . . , xk , y1 , . . . yk , we have that
q(x1 ) = q(y1 )

...

q(xk ) = q(yk )

f (κγ (x1 , . . . , xk )) = f (κγ (y1 , . . . , yk ))
or equivalently that for all x1 , . . . , xk and x0i with 1 ≤ i ≤ k we have
q(xi ) = q(x0i )
f (κγ (x1 , . . . , xi−1 , xi , xi+1 , . . . , xk )) = f (κγ (x1 , . . . , xi−1 , x0i , xi+1 , . . . , xk ))
Suppose (Q, δ, i, o) is an automaton. For q ∈ Quot(Q), we have q ≤ Θδ (q) ∧ o iff
for all x, x0 ∈ Q: if q(x) = q(x0 ), then o(x) = o(x0 ); and
for all γ ∈ Γ with k = ar(γ), and x1 , . . . , xk and x0i with 1 ≤ i ≤ k we have
q(xi ) = q(x0i )
q(δγ (x1 , . . . , xi−1 , xi , xi+1 , . . . , xk )) = q(δγ (x1 , . . . , xi−1 , x0i , xi+1 , . . . , xk ))
A partition q with the above two properties is known as a forward bisimulation [25].
I Theorem 4.12. Suppose Σ preserves E-cointersections. Let (Q, δ, i, o) be an automaton,
where o ∈ QuotE (Q). Then gfp(Θδ ∧ o) is the minimisation of (Q, δ, i, o).
Proof. Denote the quotient gfp(Θδ ∧ o) by qm : Q  Qm . Thus qm ≤ Θδ (qm ) and qm ≤ o,
hence (using Lemma 4.10) there exist δm , om turning qm into an automaton homomorphism
from (Q, δ, i, o) to (Qm , δm , qm ◦ i, om ). We show that this is the minimisation of (Q, δ, i, o).
To this end, let (Q0 , δ 0 , i0 , o0 ), q 0 : Q  Q0 be a quotient automaton of (Q, δ, i, o). By
Lemma 4.10 we get q 0 ≤ Θδ (q 0 ), and since o0 ◦ q 0 = o we have q 0 ≤ o, hence q 0 ≤ Θδ (q 0 ) ∧ o.
Thus q 0 ≤ gfp(Θδ ∧ o), i.e., there is a quotient h : Q0  Qm such that h ◦ q 0 = qm . It only
remains to show that h is a homomorphism of automata. First, since q 0 ∈ E and Σ preserves
E-cointersections, Σq 0 is an epimorphism. Combined with the fact that q 0 and qm are algebra
homomorphisms and that h ◦ q 0 = qm , it easily follows that h is an algebra homomorphism.
To see that it preserves the output, we have om ◦ h ◦ q 0 = om ◦ qm = o = o0 ◦ q 0 ; hence, since
q 0 is epic, we get om ◦ h = o0 . For preservation of the input, we have h ◦ i0 = h ◦ q 0 ◦ i = qm ◦ i,
where the first step holds because q 0 is a homomorphism of automata.
J
The above characterisation of minimisation of an automaton (Q, δ, i, o) gives us two ways
of constructing it by standard lattice-theoretic computations. First, via the Knaster-Tarski
theorem, we obtain it as the join of all post-fixed points of Θδ ∧ o, which, by Lemma 4.10,
amounts to the join of all quotient algebras respecting the output map o. That corresponds to
the construction in [6]. Second, and perhaps most interestingly, we obtain the minimisation
of (Q, δ, i, o) by iterating Θδ ∧ o, starting from the top element > of the lattice QuotE (Q).
The latter construction is analogous to the classical partition refinement algorithm: Starting
from > corresponds to identifying all states as equivalent (or in other words, starting from
the coarsest equivalence class of states). Every iteration step of Θδ ∧ o splits the states that
can be distinguished successively by just outputs, trees of depth 1, trees of depth 2, etc.
If the state space is finite, this construction terminates, yielding the minimisation of the
original automaton by Theorem 4.12.

4.2

Simple automata

We defined an automaton to be minimal if it is reachable and satisfies a universal property
w.r.t. reachable automata accepting the same language. It is also interesting to ask whether

XX:7

XX:8

Tree Automata as Algebras: Minimisation and Determinisation

there is another property that, together with reachability, implies minimality, but is not itself
dependent on reachability [9]. Here we propose precisely such a condition.
I Definition 4.13. An automaton (Q, δ, i, o) is called simple if for every quotient automaton
(Q0 , δ 0 , i0 , o0 ) the associated quotient q : Q  Q0 is an isomorphism.
The result below asserts that minimal automata are precisely the automata that are simple
and reachable. It can be seen as a refinement (and dual) of [10, Theorem 17], computing the
reachable part of a coalgebra. One of the implications makes use of Theorem 4.12, so we
assume that Σ preserves E-cointersections.
I Proposition 4.14. Suppose Σ preserves E-cointersections. Let (Q, δ, i, o) be an automaton
with o ∈ E, and let (Q0 , δ 0 , i0 , o0 ), q : Q  Q0 be a quotient automaton. Then (Q0 , δ 0 , i0 , o0 ) is
simple if and only if it is the minimisation of (Q, δ, i, o).
Proof. By Theorem 4.12, the minimisation of (Q, δ, i, o) exists. We denote it by qm : Q  Qm
and its associated automaton structure by (Qm , δm , im , om ).
Suppose (Q0 , δ 0 , i0 , o0 ) is simple. Since Qm is the minimisation of Q and Q0 is a quotient
automaton of Q, there exists a homomorphism of automata h : Q0  Qm . Since Q0 is simple,
this homomorphism is an iso.
Conversely, suppose (Q0 , δ 0 , i0 , o0 ) is the minimisation of (Q, δ, i, o) and consider any
quotient automaton Q00 of Q0 , witnessed by some q 0 : Q0  Q00 . Then Q00 is also a quotient
automaton of Q, via q 0 ◦ q. Because Q0 is the minimisation of Q, there exists k : Q00 → Q0
such that k ◦ q 0 ◦ q = q. Thus k ◦ q 0 = id, using that q is an epi. Since q 0 ◦ k ◦ q 0 = q 0 and q 0 is
an epi as well, we also have q 0 ◦ k = id. Hence q 0 is an iso, as needed.
J
I Corollary 4.15. If Σ preserves E-cointersections, then an automaton A = (Q, δ, i, o) with
o ∈ E is minimal if and only if it is simple and reachable.
Proof. First, suppose that A is minimal. By Lemma 4.5, we know that A is the minimisation
(and, in particular, a quotient) of (Σ I, αI , ηI , L(A)). In that case, A is reachable, and thus,
since o ∈ E, we have L(A) ∈ E. By Proposition 4.14, we conclude that A is simple.
Conversely, let A be simple and reachable. By reachability, A is a quotient automaton
of (Σ I, αI , ηI , L(A)); also, L(A) = o ◦ rch ∈ E. Proposition 4.14 then tells us that A is the
minimisation of (Σ I, αI , ηI , L(A)); by Lemma 4.5 we conclude that A is minimal.
J

5

Nerode equivalence

We now show a generalised Nerode equivalence from which the minimal automaton can
be constructed. Most of this section is based upon the work by Arbib and Manes [8],
whose construction was further studied and refined by Anderson et al. [7] and Adámek
and Trnková [6]. We make a significant improvement in generality by phrasing the central
equivalence definition (Definition 5.5) in terms of an arbitrary monad, which unlike the
previous cited work allows applications to algebras satisfying a fixed set of equations. A
monad generalisation of the Myhill-Nerode theorem appears in [12], which confines itself to
categories of sorted sets and does not characterise the equivalence as an object.
The abstract construction in this section does not require the varietor Σ. Instead, we
focus on the monad Σ induced by its adjunction and generalise by fixing an arbitrary
monad (T, η, µ) in C. Let F a U : C  EM(T ) be the adjunction with its category of
(Eilenberg-Moore) algebras. Given a C-morphism f : X → U Y for X in C and Y in EM(T ),
we write f ] : F X → Y for its adjoint transpose. We can then use a generalised version of the
automata defined in Section 3.

G. van Heerdt, T. Kappé, J. Rot, M. Sammartino, A. Silva

I Definition 5.1 (T -automaton). A T -automaton is a tuple (Q, δ, i, o), where (Q, δ) is a T algebra and i : I → Q and o : Q → O are morphisms in C. A homomorphism from (Q, δ, i, o)
to (Q0 , δ 0 , i0 , o0 ) is a T -algebra homomorphism h : (Q, δ) → (Q0 , δ 0 ) such that h ◦ i = i0 and
o0 ◦ h = o.
The reachability map of a T -automaton A = (Q, δ, i, o) is given by rchA = U (i] ) : T I → Q
and is therefore the unique T -algebra homomorphism (T I, µ) → (Q, q) preserving initial
states, taking ηI : I → T I to be the initial state selector of T I. The language of A is given
by L(A) = o ◦ rchA : T I → O.
The Σ-tree automata defined in Section 3 are recovered using the following fact: the
category of Σ-algebras is isomorphic to EM(T ) for T the free Σ-algebra monad Σ .
I Remark 5.2. In Set, we may even add equations to the signature [36, Chapter VI.8,
Theorem 1]. For Nom, this follows from the treatment of [34], giving a standard universal
algebraic presentation of algebras over Nom. Indeed, results in this section apply to nominal
tree automata, unless explicitly stated. For brevity we therefore focus on examples in Set.
I Assumption 5.3. In this section we will need the class E to be the reflexive regular epis.3
The next lemma will be used in proving our main theorems.
I Lemma 5.4. Suppose T maps reflexive coequalisers to epimorphisms. If i : B → U C is
such that U (i] ) reflexively coequalises q1 , q2 : A → T B in C, then i] reflexively coequalises
q1] , q2] : F A → F B.
Before defining an abstract Nerode equivalence, we recall the classical definition for
languages of words. Given a language L : A∗ → 2, the equivalence R ⊆ A∗ × A∗ is defined as
R = {(u, v) ∈ A∗ × A∗ | ∀w ∈ A∗ . L(uw) = L(vw)}.
In this setting, I = 1 and O = 2. A function Q × A → Q corresponds to an algebra for
the monad T = (−) × A∗ , whose unit and multiplication are defined using the unit and
multiplication of the monoid A∗ . If p1 , p2 : R → A∗ ∼
= 1 × A∗ are the projections, we note
that R is defined to be the largest relation making the following diagram commute.
p2 ×id

R × A∗

1 × A∗ × A∗
µ

1 × A∗

p1 ×id

1 × A∗ × A∗

µ

1 × A∗

L

L

2

This leads to an abstract definition, using a limit4 to generalise what it means to be maximal.
I Definition 5.5 (Nerode equivalence). Given a language L : T I → O and an object R with
morphisms p1 , p2 : R → T I, we say that (R, p1 , p2 ) is the Nerode equivalence of L if the
diagram below on the left commutes and for all objects S with a reflexive pair q1 , q2 : S → T I
3

4

In a regular category, (reflexive regular epi, mono) forms a factorisation system in the same way (regular
epi, mono) does, though one should note that the theory in this section does not actually need a
factorisation system; the instantiation of E is only invoked to obtain the right notion of reachability.
Note that it is not exactly a limit, as the defining property works with cones under T .

XX:9

XX:10

Tree Automata as Algebras: Minimisation and Determinisation

such that the diagram in the middle commutes there is a unique morphism u : S → R making
the diagram on the right commute.
T p2

TR

TTI

T q2

TS

TTI

µ

TI

T p1

TTI

TI

L

O

L

TTI

q1

TI

L
µ

S

µ
T q1
µ

TI

L

TI

p1

u

R

q2
p2

TI

O

To show the versatility of our definition, we briefly explain a different example where the
language is a set of words. This example cannot be recovered from the original definition by
Arbib and Manes [8].
∗

I Example 5.6 (Syntactic congruence). Let T be the free monoid or list monad (−) so that
EM(T ) is the category of monoids, I = A, and O = 2. Given a language L : A∗ → 2, the
Nerode equivalence as defined above is then the largest relation R ⊆ A∗ × A∗ such that
n∈N
(u1 , v1 ), . . . , (un , vn ) ∈ R
.
L(u1 · · · un ) = L(v1 · · · vn )
Equivalently, R is the largest relation such that
(u, v) ∈ R
w, x ∈ A∗
,
L(wux) = L(wvx)
which is precisely the syntactic congruence of the language.
We can show that the Nerode equivalence in Set exists, as long as the monad is finitary.
To define it concretely, we use the following piece of notation. For any set X and x ∈ X,
denote by 1x : 1 → X the constant x function, assuming no ambiguity of the set involved.
I Proposition 5.7. For C = Set and T any finitary monad, every language L : T I → O has
a Nerode equivalence given by
R = {(u, v) ∈ T I × T I | L ◦ µ ◦ T [idT I , 1u ] = L ◦ µ ◦ T [idT I , 1v ] : T (T I + 1) → O}
with the corresponding projections p1 , p2 : R → T I.
The definition of R above states that u, v ∈ T I are related iff the elements of T I formed
by putting either u or v in any context and then applying µ have the same value under L. A
context is an element of T (T I + 1), where 1 = {} denotes a hole where either u or v can
be plugged in. In the tree automata literature, such contexts, although restricted to contain
a single instance of , are used in algorithms for minimisation [25] and learning [44, 19].
Unfortunately, the characterisation of Proposition 5.7 does not directly extend to Nom,
because the functions 1x are not, in general, equivariant. We leave this for future work.
Below we show that, under a few mild assumptions, the abstract equivalence is in fact
a congruence: it induces a T -automaton, which moreover is minimal. Intuitively, given a
language L : T I → O that has a Nerode equivalence, we use the equivalence to quotient the
T -automaton (F I, η, L). We first need a technical lemma.
I Lemma 5.8. If C has coproducts, then for any Nerode equivalence (R, p1 , p2 ) there exists
a unique T -algebra structure u : T R → R making p1 and p2 T -algebra homomorphisms
(R, u) → (T I, µ) that have a common section.

G. van Heerdt, T. Kappé, J. Rot, M. Sammartino, A. Silva

XX:11

I Theorem 5.9. If C has coproducts and reflexive coequalisers and T preserves reflexive
coequalisers, then for every language that has a Nerode equivalence there exists a minimal
T -automaton accepting it.
Proof. Let L : T I → O be the language with Nerode equivalence (R, p1 , p2 ) and c : T → M
the coequaliser of p1 and p2 in C. By Lemma 5.8 there exists a T -algebra structure on R
making p1 and p2 T -algebra homomorphisms into (T I, µ) that have a common section. Since
T preserves reflexive coequalisers, they are lifted by U , and we have a morphism m : T M → M
making (M, m) a T -algebra such that c is a T -algebra homomorphism (T I, µ) → (M, m).
Since the diagram below on the left commutes and c coequalises p1 and p2 , there is a unique
morphism oM rendering the diagram on the right commutative.
p2

R

η

p1

TI

1

TR

1

1

η
T p2

2

2

TTI

µ

TI

3

naturality of η
monad law
Nerode equivalence
(1)

T p1
η

TI

TTI

TI

L

3

M
oM

µ

2

c
L

L

TI

O

O

Choosing iM = c ◦ η : I → M , we obtain a T -automaton M = (M, m, iM , oM ). Note that
U (i]M ) = c, so c is the reachability map of M. Hence, we find that L(M) = L by (1). The
morphism c coequalises the reflexive pair (p1 , p2 ) by definition, so M is reachable.
To see that M is minimal, consider any reachable T -automaton A = (Q, δ, i, o) such that
L(A) = L. Reachability amounts to the reachability map rch : T I → U Q being the reflexive
coequaliser of a pair of morphisms q1 , q2 : S → T I. From commutativity of
T q2

TS

TTI

T rch

1

µ
2

TQ
T q1
T rch

Q

2

µ

1
2

3

rch

TTI

TI

rch

δ

3

L

rch coequalises q1 and q2
rch is a T -algebra homomorphism
L(A) = L

o
3

L

TI

O

we obtain by the Nerode equivalence property a unique morphism v : S → R making the
diagram below on the left commute.
S
q1

TI

p1

v

R

q2

S
q2
p2

q1
p1

TI

TI

TI

p2

v

R

c

c

M

Extending this with c, the coequaliser of p1 and p2 , gives the commutative diagram on the
right. Recall that U (i]M ) = c. We now find
]

]

]

]

i]M ◦ q1] = (U (i]M ) ◦ q1 ) = (c ◦ q1 ) = (c ◦ q2 ) = (U (i]M ) ◦ q2 ) = i]M ◦ q2] .
Here the first and last equality apply a general naturality property of the adjunction. Since
rch = U (i] ) is the reflexive coequaliser of q1 and q2 , i] is the reflexive coequaliser of q1] and

XX:12

Tree Automata as Algebras: Minimisation and Determinisation

q2] by Lemma 5.4. We then obtain a unique T -algebra homomorphism h : (Q, δ) → (M, m)
making the diagram below on the left commute.
I
i]

FI

Q

M

h

η

Q
1

O

oM

iM
1

3

o

(1)

Q

(M, m)

L

c

rch

h

i]M

rch

TI

2

i

TI

2

c

rch

Q

h

3

L(A) = L
definition of rch
definition of iM

M

From commutativity of the other diagrams we find oM ◦ h = o (using that rch is epi) and
h ◦ i = iM . Thus, h is a T -automaton homomorphism A → M. To see that it is unique,
note that any T -automaton homomorphism h0 : A → M is a T -algebra homomorphism
]
(Q, δ) → (M, m) such that h0 ◦ i = iM . It is then not hard to see that h0 ◦ i] = (h0 ◦ i) = i]M .
]
0
]
We conclude that h = h by the uniqueness property of h satisfying h ◦ i = iM .
J
I Remark 5.10. We briefly discuss the conditions of the above theorem in the specific case of
C = Set with T a finitary monad. This includes the setting of tree automata in Set, as a
monad on Set is finitary if and only if EM(T ) is equivalent to the category of algebras for a
signature modulo equations. Proposition 5.7 shows that all Nerode equivalences exist here.
Furthermore, Lack and Rosickỳ [35] observe that an endofunctor on Set is finitary if and
only if it preserves sifted colimits, of which reflexive coequalisers form an instance.
To conclude this section we show that the converse of the previous theorem also holds,
using the existence of kernel pairs rather than coproducts. We need a technical lemma first.
I Lemma 5.11. If q1 , q2 : A → T B is a reflexive pair in C, then so is (q1] , q2] ) in EM(T ).
I Theorem 5.12. If C has kernel pairs and reflexive coequalisers and T preserves reflexive
coequalisers, then every language that has a minimal T -automaton has a Nerode equivalence.
Proof. Let M = (M, δM , iM , oM ) be a minimal T -automaton and p1 , p2 : K → T I the kernel
pair of its reachability map rch : F I → M . We claim that K together with p1 and p2 forms
the Nerode equivalence of L(M). To see this, note that the diagram below on the left
commutes.
1

T p2

TK

TTI
T rch

1

µ
2

TM
δM

T p1

3

kernel pair
rch is a T -algebra homomorphism
definition of L(M)

TI

T q2

TS

rch

TTI
µ

T rch

M

2

rch

TTI

2

µ

TI

3

L(M)

3

L(M)

oM

TI

T q1

L(M)

O

TTI

µ

TI

L(M)

O

Now if S with q1 , q2 : S → T I is any reflexive pair making the diagram on the right commute,
we let c : T I → Q be the coequaliser of U (q1] ) and U (q2] ), noting that this is a reflexive pair by
Lemma 5.11. Then since T preserves reflexive coequalisers, they are lifted by U , meaning that
there exists a unique T -algebra structure δ : T Q → Q making c : F I → (Q, δ) a T -algebra
homomorphism that is the coequaliser of q1] and q2] . We also have L(M)◦U (q1] ) = L(M)◦U (q2] )
by commutativity of the diagram on the right, so with c coequalising U (q1] ) and U (q2] ) there
is a unique morphism o : Q → O such that o ◦ c = L(M). Setting i = c ◦ ηI , we have a

G. van Heerdt, T. Kappé, J. Rot, M. Sammartino, A. Silva

XX:13

T -automaton (Q, δ, i, o) with reachability map U (i] ) = c that accepts the language L(M).
By M being minimal there exists a unique T -automaton homomorphism h : (Q, δ, i, o) → M.
Then the diagram below on the left commutes.
S

q2
η

TI

U (q2] )

1
2

TS
]
q1 U (q1 )

c coequalises U (q1] ) and U (q2] )
uniqueness of reachability maps

c
rch

1

Q

q1

2

h

c

TI

2

rch

TI

p1

S
u

K

q2
p2

TI

M

By p1 and p2 being the kernel pair of rch there exists a unique morphism u : S → K making
the diagram on the right commute.
J

6

Tree automata with side-effects

We extend tree automata with various side-effects, covering as examples non-deterministic,
weighted, and non-deterministic nominal automata. The key insight is to view them as
algebras in the Kleisli category of a monad S. We first recall some basic notions.
Kleisli category Every monad (S, η, µ) has an associated Kleisli category K`(S), whose
• Y are morphisms X → SX in C. Given
objects are those of C and whose morphisms X →
•
•
such morphisms f : X → Y and g : Y → Z, their (Kleisli) composition g ◦ f is defined
as µZ ◦ Sg ◦ f in C. The Kleisli adjunction J a V : C  K`(S) is given by JX = X,
• Y ) = µ
J(f : X → Y ) = ηY ◦ f and V Y = SY , V (f : X →
Y ◦ Sf .
I Example 6.1. The category K`(Pf ) has morphisms X → Pf Y , which are finitely-branching
relations, and Kleisli composition is relational composition. We have that J maps a function
• Y to the function
to its graph, and V maps X to Pf X and a relation R : X →
λU ⊆ X.{y | ∃x ∈ U : (x, y) ∈ R}.
The category K`(MF ) has morphisms X → MF Y that are matrices over F indexed by X and
Y (equivalently, linear maps between the corresponding free vector spaces), and composition
is matrix multiplication. The left adjoint J maps a function f : X → Y to the matrix
• Y
Jf [x, f (x)] = 1, for x ∈ X, and 0 elsewhere, and the right adjoint V maps a matrix X →
to the corresponding linear function MF X → MF Y .
b : K`(S) → K`(S) is an extension of Σ if the
Given an endofunctor Σ on C, a functor Σ
following diagram commutes:
C

Σ

K`(S)

b
Σ

J

C
J

K`(S)

Extensions are in bijective correspondence with distributive laws λ : ΣS ⇒ SΣ [39], which
b = ΣX and
are natural transformations satisfying certain axioms. Explicitly, we have ΣX
• Y (a morphism X → SY in C) is mapped to λ
f: X →
Y ◦ Σf : ΣX → SΣY , seen in K`(S).
In [23, Lemma 2.4] it is shown that a canonical distributive law in Set always exists in
case Σ is polynomial and S is a commutative monad [31].

XX:14

Tree Automata as Algebras: Minimisation and Determinisation

I Example 6.2. For Σ a polynomial Set endofunctor, the canonical distributive law λ : ΣPf ⇒
Pf Σ can be directly defined as follows: λX (u) = {v ∈ ΣX | (v, u) ∈ img(hΣp1 , Σp2 i)}, where
p1 and p2 are the left and right projections of the membership relation ∈X ⊆ X × Pf X.
The multiplicity monad (MF , e, m) admits a distributive law λ : ΣMF ⇒ MF Σ, inductively defined as follows, where ⊗ is the Kronecker product:
λid = idMF

λA = eA

λΣ1 ×Σ2 = ⊗ ◦ (λΣ1 × λΣ2 )

λqi∈I Σi = [MF (κi ) ◦ λΣi ]i∈I

We can now define our notion of tree automaton with side-effects.
b : K`(S) → K`(S) extendI Definition 6.3 ((Σ, S)-tree automaton). Given a monad S, and Σ
b
ing a functor Σ on C, a (Σ, S)-tree automaton is a Σ-tree
automaton, i.e., a tuple (Q, δ, i, o),
b
• Q and o : Q →
• O are morphisms in K`(S).
where (Q, δ) is a Σ-algebra
and i : I →
I Example 6.4.
1. Let Γ be a signature, and let Σ be its signature functor. Then the extension of Σ to
b = ΣX and
K`(Pf ) is obtained via the distributive law of Example 6.2, namely ΣX
b :X→
• Y )(κ (x , . . . , x
Σ(f
γ
1
ar(γ) )) = {(κγ (y1 , . . . , yar(γ) )) | yj ∈ f (xj ) for 1 ≤ j ≤ ar(γ)}
for γ ∈ Γ. Non-deterministic tree automata are (Σ, P)-tree automata (Q, δ, i, o) with
`
• Q is a family of relations
O = 1, the singleton set. In fact, we have that δ : γ∈Γ Qar(γ) →
ar(γ)
δγ ⊆ Q
× Q; by the same token, i ⊆ I × Q relates the frontier alphabet with (possibly
several) states, and o ⊆ Q × 1 ∼
= Q is the set of final states.
2. Let Γ be a signature, and let Σ be its signature functor. The extension of Σ to K`(MF ) is
b = ΣX and Σ(f
b :X→
• Y )
obtained via the distributive law of Example 6.2. Explicitly, ΣX
maps κγ (x1 , . . . , xar(γ) ) to the vector [κγ (vz )]z∈Y ar(γ) such that vz is the z-th component
of f (x1 ) ⊗ · · · ⊗ f (xar(γ) ), for γ ∈ Γ. A multiplicity tree automaton [29] is a (Σ, MF )-tree
automaton (Q, δ, i, o) with I = O = 1. In fact, we have that δγ is the transition matrix
ar(γ)
×|Q|
• Q is the initial weight vector in F1×|Q| ,
• Q in F|Q|
Qar(γ) →
; similarly, i : 1 →
• 1 is the final weight vector in F|Q|×1 . Intuitively, δ
and o : Q →
γ maps an ar(γ)-tuple
of elements of Q to a linear combination over Q. We note that we can go beyond
fields and consider (Σ, MS )-tree automata for a semiring S, encompassing weighted tree
automata [17].
3. The nondeterministic version of the automata defined in Section 3.1 can be obtained
via the monad Pω : Nom → Nom, mapping a nominal set to the nominal set of its
finitely-supported, orbit-finite subsets.5 This is analogous to non-deterministic nominal
automata [13]. We note that K`(Pω ) is precisely the category of nominal sets and (orbitfinitely branching) equivariant relations and that Σλ extends to relations just as a set
endofunctor—the distributive law is defined as the one for Pf of Example 6.2, where all
the maps are equivariant. A nondeterministic nominal Σλ -tree automaton is a (Σλ , Pω )tree automaton (Q, δ, i, o) with O = 1, the one-element nominal set with trivial group
action. We have that i and the components of δ are equivariant relations. For instance,
δlambda ⊆ [A]Q × Q, and o is an equivariant subset of Q.
We now study language semantics of (Σ, S)-tree automata. Languages are defined via free
b are closely
algebras (see Section 3). It turns out that the free algebras in Alg(Σ) and Alg(Σ)
related. To see this, we use the following result, which follows from [24, Theorem 2.14].

5

This is the finitary version of the powerset functor in Nom.

G. van Heerdt, T. Kappé, J. Rot, M. Sammartino, A. Silva

XX:15

b : K`(S) → K`(S) an
I Lemma 6.5. Let Σ : C → C be a functor, S : C → C a monad, and Σ
extension of Σ. Let λ : ΣS ⇒ SΣ be the corresponding distributive law.
Then the Kleisli adjunction J a V : C  K`(S) lifts to an adjunction in: J a V
J

Alg(Σ)

b
Alg(Σ)

⊥

b →
• Q)
J(Q, δ : ΣQ → Q) = (Q, J(δ) : ΣQ

V

b →
• Q)= (SQ, V (γ) ◦ λ
V (Q, γ : ΣQ
Q : ΣSQ → SQ)

J

C

K`(S)

⊥
V

From Lemma 6.5, and using that free algebras can be obtained as colimits of transfinite
sequences [2, 28], it follows that any free Σ-algebra (Σ X, αX ) is mapped by the left adjoint
b
b
J to a free Σ-algebra
with the same carrier. Concretely, given a Σ-algebra
(Q, δ) and a

• Q, a (unique) morphism rch : Σ I → SQ makes the diagram on the left
morphism i : I →
commute in C iff it makes the diagram on the right commute in K`(S):
ΣΣ I

α

rch

Σrch

ΣSQ

η

Σ I

V (Q,δ)

I

i

SQ

b I
ΣΣ

J(Σ I,α)
•

brch •
Σ
b
ΣQ

Σ I
rch •

δ
•

Jη
•
•

I
(2)

i

Q

Note that the adjoint transpose of rch is the same morphism, seen in K`(S). The functor V
can be viewed as a determinisation construction for (Σ, S)-tree automata.
I Definition 6.6. Given an (Σ, S)-tree automaton (Q, δ, i, o), let δ : ΣS(Q) → S(Q) be the
algebra structure of V (Q, δ), i.e., (S(Q), δ) = V (Q, δ), and o = V (o). The Σ-tree automaton
(SQ, δ, i, o) is called the determinisation of (Q, δ, i, o).
The following shows correctness of this determinisation construction, using the correspondence
in (2), and provides a concrete description of the language semantics of (Σ, S)-tree automata.
I Corollary 6.7. Let (Q, δ, i, o) be a (Σ, S)-tree automaton. Then L(SQ, δ, i, o) = L(Q, δ, i, o).
We conclude this section with some example instantiations of determinisation, and of how
they can be used to compute languages.
I Example 6.8.
1. The determinisation of a (Σ, Pf )-tree automaton (Q, δ, i, o) is
[
[
δ γ (X1 , . . . , Xk ) =
δγ (x1 , . . . , xk )
o(X) =
o(x)
x1 ∈X1 ,...,xk ∈Xk

x∈X

for γ ∈ Γ with k = ar(γ), and X1 , . . . , Xk , X finite subsets of Q. This definition precisely
corresponds to the usual determinisation of bottom-up tree automata (see e.g. [22]). The
reachability function is then given by


if t ∈ I
i(t)
rch(t) = S x ∈rch(t ) δγ (x1 , . . . , xk ) if t = (γ, x1 , . . . , xk ), k = ar(γ).

 1 ... 1
xk ∈rch(tk )

Using Corollary 6.7, we have that the language of (Q, δ, i, o) is
[
L(Q, δ, i, o)(t) =
o(s).
s∈rch(t)

XX:16

Tree Automata as Algebras: Minimisation and Determinisation

That is: a tree t is accepted by (Q, δ, i, o) whenever there is a final state among those
reached by parsing t.
2. The determinisation of a (Σ, MF )-tree automaton is given by
δ γ (ϕ1 , . . . , ϕk ) = (ϕ1 ⊗ · · · ⊗ ϕk ) • δγ

o(ϕ) = ϕ • o

where γ ∈ Γ and ar(γ) = k; also, ⊗ is the Kronecker product and • is matrix multiplication.
Explicitly, δ γ takes a k-tuple of vectors over Q and turns it into a vector ϕ over k-tuples
of states via the distributive law (defined as the Kronecker product, see Example 6.2),
i.e., ϕ(q1 , . . . , qk ) = ϕ1 (q1 ) · · · ϕk (qk ), for q1 , . . . , qk ∈ Q. The result is then multiplied by
the matrix δγ to compute the successor vector.
Similarly, the reachability function becomes
(
i(t)
if t ∈ I
rch(t) =
(rch(t1 ) ⊗ · · · ⊗ rch(tk )) • δγ if t = (γ, t1 , . . . , tk ), k = ar(γ).
Hence we obtain the language L(Q, δ, i, o)(t) = rch(t) • o, which corresponds to the
language semantics given in [29].
3. The case of (Σλ , Pω )-tree automata is completely analogous to point 1. For instance,
[
δ lambda (X) =
δlambda (x)
x∈X

for X a finitely supported orbit-finite subset of [A]Q.

7

Future work

The algorithmic side of the iterative minimisation construction presented in Section 4
is left open. For classical tree automata there exist sophisticated variants of partition
refinement [25, 1], akin to Hopcroft’s classical algorithm. A generalisation to the current
algebraic setting is an interesting direction of research, for which a natural starting point
would be to try and integrate in our setting the efficient coalgebraic algorithm presented
in [18].
Further, we characterised the minimal automaton as the greatest fixed point of a monotone
function, recovering the notion of forward bisimulations as its post-fixed points (although it
is perhaps more natural to think of these as congruences). This characterisation suggests an
integration with up-to techniques [42, 14, 15], which have, to the best of our knowledge, not
been applied to tree automata. In particular, we are interested in applying these algorithms
to decide equivalence of series-parallel rational and series-rational expressions [38].
Since completeness of Kleene Algebra is connected to minimality of deterministic finite
automata [33], we wonder whether a completeness proof can be recovered using automata as
presented in this paper. In particular, our abstract framework might allow us to transpose
such a proof to settings such as Bi-Kleene Algebra [37] or Concurrent Kleene Algebra [27].
References
1
2

P. A. Abdulla, J. Högberg, and L. Kaati. Bisimulation minimization of tree automata. Int. J.
Found. Comput. Sci., 18(4):699–713, 2007.
J. Adámek. Free algebras and automata realizations in the language of categories. Commentationes Mathematicae Universitatis Carolinae, 15(4):589–602, 1974.

G. van Heerdt, T. Kappé, J. Rot, M. Sammartino, A. Silva

3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30

J. Adámek. Realization theory for automata in categories. J. Pure and Appl. Algebra, 9(2):281
– 296, 1977.
J. Adámek, F. Bonchi, M. Hülsbusch, B. König, S. Milius, and A. Silva. A coalgebraic
perspective on minimization and determinization. In FoSSaCS, pages 58–73, 2012.
J. Adámek, H. Herrlich, and G. Strecker. Abstract and concrete categories: The joy of cats,
volume 17 of Reprints in Theory and Applications of Categories. TAC, 2006.
J. Adámek and V. Trnková. Automata and algebras in categories. Kluwer, 1989.
B. D. Anderson, M. A. Arbib, and E. G. Manes. Foundations of system theory: finitary and
infinitary conditions, volume 115 of Lecture Notes in Econ. and Math. Syst. Springer, 1976.
M. A. Arbib and E. G. Manes. Machines in a category: An expository introduction. SIAM
review, 16(2):163–192, 1974.
M. A. Arbib and E. G. Manes. Adjoint machines, state-behavior machines, and duality.
Journal of Pure and Applied Algebra, 6(3):313–344, 1975.
S. Barlocco, C. Kupke, and J. Rot. Coalgebra learning via duality. In FoSSaCS, pages 62–79,
2019.
A. Blok. Interaction, observation and denotation. Master’s thesis, ILLC Amsterdam, 2012.
M. Bojańczyk. Recognisable languages over monads. In DLT, pages 1–13. Springer, 2015.
M. Bojańczyk, B. Klin, and S. Lasota. Automata theory in nominal sets. Logical Methods in
Computer Science, 10(3), 2014.
F. Bonchi, D. Petrisan, D. Pous, and J. Rot. A general account of coinduction up-to. Acta
Inf., 54(2):127–190, 2017.
F. Bonchi and D. Pous. Hacking nondeterminism with induction and coinduction. Commun.
ACM, 58(2):87–95, 2015.
F. Borceux. Handbook of Categorical Algebra, volume 1 of Encyclopedia of Mathematics and
its Applications. Cambridge University Press, 1994.
B. Borchardt and H. Vogler. Determinization of finite state weighted tree automata. Journal
of Automata, Languages and Combinatorics, 8(3):417–463, 2003.
U. Dorsch, S. Milius, L. Schröder, and T. Wißmann. Efficient coalgebraic partition refinement.
In CONCUR, pages 32:1–32:16, 2017.
F. Drewes and J. Högberg. Query learning of regular tree languages: How to avoid dead states.
Theory of Computing Systems, 40(2):163–185, 2007.
M. P. Fiore. Discrete generalised polynomial functors (extended abstract). In ICALP, pages
214–226, 2012.
M. J. Gabbay and A. Mathijssen. Nominal (universal) algebra: Equational logic with names
and binding. J. Log. Comput., 19(6):1455–1508, 2009.
A. Habrard and J. Oncina. Learning multiplicity tree automata. In ICGI, volume 4201 of
Lecture Notes in Computer Science, pages 268–280. Springer, 2006.
I. Hasuo, B. Jacobs, and A. Sokolova. Generic trace semantics via coinduction. Logical Methods
in Computer Science, 3(4), 2007.
C. Hermida and B. Jacobs. Structural induction and coinduction in a fibrational setting. Inf.
Comput., 145(2):107–152, 1998.
J. Högberg, A. Maletti, and J. May. Backward and forward bisimulation minimization of tree
automata. Theoretical Computer Science, 410(37):3539–3552, 2009.
W. M. Holcombe. Algebraic Automata Theory. Cambridge University Press, 1982.
T. Kappé, P. Brunet, A. Silva, and F. Zanasi. Concurrent Kleene algebra: Free model and
completeness. In ESOP, pages 856–882, 2018.
G. M. Kelly. A unified treatment of transfinite constructions for free algebras, free monoids,
colimits, associated sheaves, and so on. Bull. Austr. Math. Soc., 22(1):1–83, 1980.
S. Kiefer, I. Marusic, and J. Worrell. Minimisation of multiplicity tree automata. Logical
Methods in Computer Science, 13(1), 2017.
B. Klin and J. Rot. Coalgebraic trace semantics via forgetful logics. Logical Methods in
Computer Science, 12(4), 2016.

XX:17

XX:18

Tree Automata as Algebras: Minimisation and Determinisation

31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46

A. Kock. Monads on symmetric monoidal closed categories. Arch. der Math., 21(1):1–10, 1970.
B. König and S. Küpper. Generic partition refinement algorithms for coalgebras and an
instantiation to weighted automata. In Theory Comput. Syst., pages 311–325, 2014.
D. Kozen. A completeness theorem for Kleene algebras and the algebra of regular events. Inf.
Comput., 110(2):366–390, 1994.
A. Kurz and D. Petrisan. On universal algebra over nominal sets. Mathematical Structures in
Computer Science, 20(2):285–318, 2010.
S. Lack and J. Rosickỳ. Notions of Lawvere theory. Appl. Categ. Struct., 19(1):363–391, 2011.
S. M. Lane. Categories for the working mathematician, volume 5. Springer, 2013.
M. R. Laurence and G. Struth. Completeness theorems for bi-Kleene algebras and series-parallel
rational pomset languages. In RAMiCS, pages 65–82, 2014.
K. Lodaya and P. Weil. Series-parallel languages and the bounded-width property. Theoretical
Computer Science, 237(1):347–380, 2000.
P. S. Mulry. Lifting theorems for Kleisli categories. In MFPS, pages 304–319, 1993.
J. E. Pin. Mathematical foundations of automata theory. Version of March 13, 2019.
A. M. Pitts. Nominal Sets: Names and Symmetry in Computer Science. Cambridge University
Press, 2013.
D. Pous and D. Sangiorgi. Advanced Topics in Bisimulation and Coinduction, chapter
Enhancements of the coinductive proof method. Cambridge University Press, 2011.
J. J. M. M. Rutten. Automata and coinduction (an exercise in coalgebra). In CONCUR, pages
194–218, 1998.
Y. Sakakibara. Learning context-free grammars from structural data in polynomial time.
Theoretical Computer Science, 76(2-3):223–242, 1990.
A. Silva, F. Bonchi, M. M. Bonsangue, and J. J. M. M. Rutten. Generalizing determinization
from automata to coalgebras. Logical Methods in Computer Science, 9(1), 2013.
T. Wißmann, S. Milius, S. Katsumata, and J. Dubut. A coalgebraic view on reachability.
arXiv e-prints, Jan 2019. https://arxiv.org/abs/1901.10717.

G. van Heerdt, T. Kappé, J. Rot, M. Sammartino, A. Silva

A

XX:19

Proofs for Section 5

In the proofs below, we will use the following basic adjunction properties, in particular for
]
the adjunction F a U : C  EM(T ) with adjoint transpose (−) :
]
The transpose f : F A → B for f : A → U B in C can be defined as f ] = y ◦ T f , where y
is the T -algebra structure on Y .
]
For all f : X → U Y and g : U Y → U Z in C we have U (g ] ) ◦ T f = U ((g ◦ f ) ).
]
We have U (ηX
) = idT X .
We need the following additional lemmas in the proofs below.
I Lemma A.1. If f : A → B and h : A → C in EM(T ) are such that there exists g : U B →
U C in C with g ◦ f = h and T f is an epi, then g is a T -algebra homomorphism B → C.
Proof. Let α : T A → A, β : T B → B, and γ : T C → C be the respective T -algebra structures
on A, B, and C. By commutativity of
Tf

TA

TB

Th

Tg

α

A

Tf

TC
h

f

TB

β

γ

g

B

C

and T f being an epi, we directly conclude that g is a T -algebra homomorphism B → C. J
I Lemma A.2. Given a language L and q1 , q2 : S → T I making the diagram below on the
left commute, the diagram on the right commutes.
T q2

TS

TTI

TTS

µ

µ

L

TI

Tµ

TTI
µ

TTTI

TI

Tµ

L

TTI

TTTI

T T q1

TI

T q1

T T q2

O

TTI

L
µ

TI

L

O

Furthermore, if (q1 , q2 ) is a reflexive pair, then so is (µI ◦ T q1 , µI ◦ T q2 ).
Proof. We extend the assumption to the following commutative diagram.
T T q2

TTS
µ

1

TTTI
Tµ

TTI

µ

1

TS

T T q1

TTTI
T q2

Tµ

µ

TTI

1

µ

T q1
µ

TTI

2

2

TTI

TI
µ

2

µ

naturality of µ
monad law

L

TI

L

O

As for reflexivity, (µI ◦ T q1 , µI ◦ T q2 ) is the composition of the reflexive pairs (µI , µI ) and
(T q1 , T q2 ).
J
I Lemma 5.4. Suppose T maps reflexive coequalisers to epimorphisms. If i : B → U C is
such that U (i] ) reflexively coequalises q1 , q2 : A → T B in C, then i] reflexively coequalises
q1] , q2] : F A → F B.

XX:20

Tree Automata as Algebras: Minimisation and Determinisation

Proof. For k ∈ {1, 2} we have U (i] ◦ qk] ) ◦ ηA = rch ◦ U (qk] ) ◦ ηA = rch ◦ qk , so by U (i] )
coequalising q1 and q2 we have i] ◦ q1] = i] ◦ q2] . If a T -algebra homomorphism f : T B → Z is
such that f ◦ q1] = f ◦ q2] , then
U f ◦ q1 = U f ◦ U (q1] ) ◦ ηA = U f ◦ U (q2] ) ◦ ηA = U f ◦ q2 ,
which because U (i] ) coequalises q1 and q2 yields a unique function u : U C → U Z such that
u ◦ rch = f . Remains to show that u is a T -algebra homomorphism. Note that since U (i] ) is a
reflexive coequaliser, T U (i] ) is an epi by assumption on T . Precomposing u with U (i] ) yields
the T -algebra homomorphism f , so by T U (i] ) being an epi and Lemma A.1 we conclude u is
a T -algebra homomorphism C → Z. Reflexivity of the pair follows from Lemma 5.11.
J
I Proposition 5.7. For C = Set and T any finitary monad, every language L : T I → O has
a Nerode equivalence given by
R = {(u, v) ∈ T I × T I | L ◦ µ ◦ T [idT I , 1u ] = L ◦ µ ◦ T [idT I , 1v ] : T (T I + 1) → O}
with the corresponding projections p1 , p2 : R → T I.
Proof. For each subset X ⊆ R, we define pX : R → T I by
(
p1 (r) if r 6∈ X
pX (r) =
p2 (r) if r ∈ X.
We have T p1 = T p∅ by definition. Consider any t ∈ T R and let a finite E ⊆ R with inclusion
map e : E → R and t0 ∈ T E be such that T (e)(t0 ) = t. These exist because T is finitary. We
will show by induction on E that
(L ◦ µ ◦ T p∅ )(t) = (L ◦ µ ◦ T pE )(t).
The case where E = ∅ is
is substituted for E. We


(κ1 ◦ p1 )(r)

d(r) = (κ1 ◦ p2 )(r)


κ ()
2

(3)

clear, so assume E = E 0 ∪ {z} with z 6∈ E 0 and (3) holds when E 0
fix the singleton 1 = {} and define d : R → T I + 1 by
if r 6∈ E
if r ∈ E 0
if r = z,

where κ1 and κ2 are the coproduct injections. By this definition, we have [idT I , 1p1 (z) ]◦d = pE 0
and [idT I , 1p2 (z) ] ◦ d = pE , so
(L ◦ µ ◦ T p∅ )(t) = (L ◦ µ ◦ T pE 0 )(t)

(induction hypothesis)

= (L ◦ µ ◦ T ([idT I , 1p1 (z) ] ◦ d))(t)
= (L ◦ µ ◦ T ([idT I , 1p2 (z) ] ◦ d))(t)

(definition of R)

= (L ◦ µ ◦ T pE )(t),
thus concluding the proof of (3). Now T p1 = T p∅ by definition and
T pE (t) = T (pE ◦ e)(t0 ) = T (p2 ◦ e)(t0 ) = T p2 (t),
from which we find that (L ◦ µ ◦ T p1 )(t) = (L ◦ µ ◦ T p∅ )(t) = (L ◦ µ ◦ T pE )(t) = (L ◦ µ ◦ T p2 )(t).
As this argument works for any t ∈ T R, we have L ◦ µ ◦ T p1 = L ◦ µ ◦ T p2 .

G. van Heerdt, T. Kappé, J. Rot, M. Sammartino, A. Silva

XX:21

Now consider any set S with q1 , q2 : S → T I making
T q2

TS

TTI
µ

(4)

TI

T q1

L
µ

TTI

L

TI

O

commute, and assume q1 and q2 have a common section j : T I → S. We define u : S → R by
u(s) = (q1 (s), q2 (s)). To see that this is indeed an element of R, note that for k ∈ {1, 2},
L ◦ µ ◦ T [idT I , 1qk (s) ] = L ◦ µ ◦ T [idT I , qk ◦ 1s ]
= L ◦ µ ◦ T [qk ◦ j, qk ◦ 1s ]

(section)

= L ◦ µ ◦ T qk ◦ T [j, 1s ],
and therefore L ◦ µ ◦ T [idT I , 1q1 (s) ] = L ◦ µ ◦ T [idT I , 1q2 (s) ] follows from (4). By definition, u
is the unique map making the diagram below commute.
S

q1
p1

TI

q2

u

p2

R

TI

J

I Lemma 5.8. If C has coproducts, then for any Nerode equivalence (R, p1 , p2 ) there exists
a unique T -algebra structure u : T R → R making p1 and p2 T -algebra homomorphisms
(R, u) → (T I, µ) that have a common section.
Proof. Let L : T I → O be a language with Nerode equivalence (R, p1 , p2 ). Then (p1 , p2 )
is a reflexive pair by the Nerode equivalence property, since (idT I , idT I ) is a reflexive pair
trivially satisfying the Nerode equivalence condition. We apply Lemma A.2 to obtain from
the Nerode equivalence property a unique morphism r : T R → R making the diagram below
commute.
TTI

T p1

TR

µ

TTI

T p2

TTI

p1

(5)

µ

r
p2

R

TI

We need to show that (R, r) is a T -algebra. The first commutative diagram below shows
that r ◦ ηR preserves p1 and p2 , so since idR also does this we must have r ◦ ηR = idR by the
uniqueness property of the Nerode equivalence.
R

p1

TI

2

η

p2

2

η
1

µ

TI

TTI
p1

1

TI

2

η
T p1

(5)

TR
r

R

T p2

(5)

TTI
p2

3

1

µ

TI

monad law
naturality of η
naturality of µ

XX:22

Tree Automata as Algebras: Minimisation and Determinisation

TTTI

T T p1

(5)

Tµ

TTI

T p1

Tr

TI

Tµ

T p2

TTI

(5)

r

p1

TTTI

(5)

TR

(5)

µ

T T p2

TTR

µ

p2

R

TI

T T p1

TTTI
µ

Tµ

TTI
µ

3

TTI

1

p1

TI

T p2

TR
r

TTI

(5)

1

Tµ

TTI
µ

µ
p2

R

TTTI
µ

3

µ
T p1

(5)

µ

T T p2

TTR

TI

As for the other two, we use a double application of Lemma A.2 to see that the pair
(µ ◦ T µ ◦ T T p1 , µ ◦ T µ ◦ T T p2 ) satisfies the Nerode equivalence conditions. Commutativity of
the two diagrams then shows that both r ◦ T r and r ◦ µ are the unique map commuting with
the pairs (µ ◦ T µ ◦ T T p1 , µ ◦ T µ ◦ T T p2 ) and (p1 , p2 ), so they must be equal and (T R, r) is
a T -algebra.
It remains to show that p1 and p2 have a common section in EM(T ). To this end, note that
([ηI , idT I ], [ηI , idT I ]) is a reflexive pair trivially satisfying the Nerode equivalence condition.
Thus, we obtain by the Nerode equivalence property a unique morphism u : I + T I → R
making
I + TI
[η,id]

TI

[η,id]

u
p1

p2

R

TI

commute. Then for k ∈ {1, 2},
]

]

]

pk ◦ (u ◦ κ1 ) = (pk ◦ u ◦ κ1 ) = (pk ◦ [ηI , idT I ]) = ηI] = id(T I,µ) .

J

I Lemma 5.11. If q1 , q2 : A → T B is a reflexive pair in C, then so is (q1] , q2] ) in EM(T ).
Proof. Assume j : T B → A is the common section of q1 and q2 . Then, for k ∈ {1, 2},
]

]

]

]
qk] ◦ (ηA ◦ j ◦ ηB ) = U ((U (qk] ) ◦ ηA ◦ j ◦ ηB ) ) = U ((qk ◦ j ◦ ηB ) ) = U (ηB
) = idT B .

J

