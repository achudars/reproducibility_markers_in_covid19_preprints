Redactable Blockchain in the Permissionless Setting
Dominic Deuber1 , Bernardo Magri2∗and Sri Aravinda Krishnan Thyagarajan1
1

2

Friedrich-Alexander-Universität Erlangen-Nürnberg, Germany
Concordium Blockchain Research Center, Aarhus University, Denmark

arXiv:1901.03206v3 [cs.CR] 9 Oct 2019

E-mail: {deuber,thyagarajan}@cs.fau.de
magri@cs.au.dk
October 10, 2019

Abstract
Bitcoin is an immutable permissionless blockchain system that has been extensively
used as a public bulletin board by many diﬀerent applications that heavily relies on its
immutability. However, Bitcoin’s immutability is not without its fair share of demerits. Interpol exposed the existence of harmful and potentially illegal documents, images and links
in the Bitcoin blockchain, and since then there have been several qualitative and quantitative analysis on the types of data currently residing in the Bitcoin blockchain. Although
there is a lot of attention on blockchains, surprisingly the previous solutions proposed for
data redaction in the permissionless setting are far from feasible, and require additional
trust assumptions. Hence, the problem of harmful data still poses a huge challenge for law
enforcement agencies like Interpol (Tziakouris, IEEE S&P’18).
We propose the ﬁrst eﬃcient redactable blockchain for the permissionless setting that is
easily integrable into Bitcoin, and that does not rely on heavy cryptographic tools or trust
assumptions. Our protocol uses a consensus-based voting and is parameterised by a policy
that dictates the requirements and constraints for the redactions; if a redaction gathers
enough votes the operation is performed on the chain. As an extra feature, our protocol
oﬀers public veriﬁability and accountability for the redacted chain. Moreover, we provide
formal security deﬁnitions and proofs showing that our protocol is secure against redactions
that were not agreed by consensus. Additionally, we show the viability of our approach with
a proof-of-concept implementation that shows only a tiny overhead in the chain validation
of our protocol when compared to an immutable one.

∗

Work done while the author was affiliated with Friedrich-Alexander University Erlangen-Nürnberg.

Contents
1 Introduction
1.1 State of the Art . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Our Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3 Our Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1
2
2
3

2 Preliminaries
2.1 Blockchain Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Properties of a Secure Blockchain . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Execution Model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4
4
5
5

3 Editing the Blockchain
3.1 Blockchain Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Editable Blockchain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 Protocol Description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

6
6
6
7

4 Security Analysis

10

5 Integrating into Bitcoin
12
5.1 Bitcoin Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
5.2 Modifying the Bitcoin Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
6 Proof-of-Concept Implementation
16
6.1 Benchmarking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
7 Discussion

18

8 Related work

19

A Protocol extension for multiple redactions

23

1

Introduction

Satoshi Nakamoto’s 2008 proposal of Bitcoin [38] has revolutionised the ﬁnancial sector. It
helped realise a monetary system without relying on a central trusted authority, which has
since then given rise to hundreds of new systems known as cryptocurrencies. Interestingly
however, a closer look into the basics of Bitcoin sheds light on a new technology, blockchains.
Ever since, there has been a lot of ongoing academic research [21, 28, 14, 16] on the security
and applications of blockchains as a primitive. A blockchain in its most primitive form is a
decentralised chain of agreed upon blocks containing timestamped data.
A consensus mechanism supports the decentralised nature of blockchains. There are diﬀerent
types of consensus mechanisms that are based on diﬀerent resources, such as Proof of Work
(PoW) based on computational power, Proof of Stake (PoS) based on the stake in the system,
Proof of Space based on storage capacity, among many others. Typically, users in the system
store a local copy of the blockchain and run the consensus mechanism to agree on a uniﬁed view
of the blockchain. These mechanisms must rely on non-replicability of resources to be resilient
against simple sybil attacks where the adversary spawn multiple nodes under his control.
Apart from its fundamental purpose of being a digital currency, Bitcoin exploits the properties of its blockchain, as in being used as a tool for many diﬀerent applications, such as
timestamp service [23, 22], to achieve fairness and correctness in secure multi-party computation [9, 7, 15, 31], and to build smart contracts [30]. It acts as an immutable public bulletin
board, supporting the storage of arbitrary data through special operations. For instance, the
OP RETURN code, can take up to 80 bytes of arbitrary data that gets stored in the blockchain.
With no requirement for centralised trust and its capability of supporting complex smart contracts, communication through the blockchain has become practical, reasonably inexpensive
and very attractive for applications.
Blockchain and Immutability. The debate about the immutability of blockchain protocols
has gained worldwide attention lately due to the adoption of the new General Data Protection
Regulation (GDPR) by European states. Several provisions of the GDPR regulation are inherently incompatible with current permissionless immutable blockchain proposals (e.g., Bitcoin
and Ethereum) [26] as it is not possible to remove any data (addresses, transaction values,
timestamp information) that has stabilised1 in the chain in such protocols. Since permissionless
blockchains are completely decentralised and allow for any user to post transactions to the chain
for a small fee, malicious users can post transactions to the system containing illegal and/or
harmful data, such as (child) pornography, private information or stolen private keys, etc. The
existence of such illicit content was ﬁrst reported in [2] and has remained a challenge for law
enforcement agencies like Interpol [46]. Moreover, quantitative analysis in the recent work of
Matzutt et al. [34] shows that it is not feasible to “ﬁlter” all data from incoming transactions to
check for malicious contents before the transaction is inserted into the chain. Therefore, once it
becomes public knowledge that malicious data was inserted (and has stabilised) into the chain,
the honest users are faced with the choice of either, willingly broadcast illicit (and possibly
illegal [34, 5]) data to other users, or to stop using the system altogether.
This eﬀect greatly hinders the adoption of permissionless blockchain systems, as honest users
that are required to comply with regulations, such as GDPR, are forced to withdraw themselves
from the system if there is no recourse in place to deal with illicit data inserted into the chain.
1

A transaction (or data) is considered stable in the blockchain when it is “deep” enough into the chain. We
formally define this property in Section 2.2.

1

1.1

State of the Art

Speciﬁcally to tackle the problem of arbitrary harmful data insertions in the blockchain, the
notion of redacting the contents of a blockchain was ﬁrst proposed by Ateniese et al. [13].
The authors propose a solution more focused on the permissioned blockchain setting2 based
on chameleon hashes [18]. In their protocol, a chameleon hash function replaces the regular
SHA256 hash function when linking consecutive blocks in the chain. When a block is modiﬁed,
a collision for the chameleon hash function can be eﬃciently computed (with the knowledge
of the chameleon trapdoor key) for that block, keeping the state of the chain consistent after
arbitrary modiﬁcations.
In a permissioned setting where the control of the chain is shared among a few semi-trusted
parties, the solution from [13] is elegant and works nicely, being even commercially adopted
by a large consultancy company [4, 3, 11]. However, in permissionless blockchains such as
Bitcoin, where the inﬂux of users joining and leaving the system is ever changing and without
any regulation, their protocol clearly falls short in this scenario, as their techniques of secret
sharing the chameleon trapdoor key and running a MPC protocol to compute a collision for
the chameleon hash function do not scale to the thousands of users in the Bitcoin network.
Moreover, when a block is removed in their protocol it is completely unnoticeable to the users,
leaving no trace of the old state. Although this could make sense in a permissioned setting, in a
permissionless setting one would like to have some public accountability as to when and where
a redaction has occurred.
Later, Puddu et al. [42] proposed a blockchain protocol where the sender of a transaction can
encrypt alternate versions of the transaction data, known as “mutations”; the only unencrypted
version of the transaction is considered to be the active transaction. The decryption keys are
secret shared among the miners, and the sender of a transaction establishes a mutation policy
for his transaction, that details how (and by whom) his transaction is allowed to be mutated.
On receiving a mutate request, the miners run a MPC protocol to reconstruct the decryption
key and decrypt the appropriate version of the transaction. The miners then publish this new
version as the active transaction. In case of permissionless blockchains, they propose the usage
of voting for gauging approval based on computational power. However, in a permissionless
setting a malicious user can simply not include a mutation for his transaction, or even set a
mutation policy where only he himself is able to mutate the transaction. Moreover, to tackle
transaction consistency, where a mutated transaction aﬀects other transactions in the chain,
they propose to mutate all aﬀected transactions through a cascading eﬀect. This however,
completely breaks the notion of transaction stability, e.g., a payment made in the past to a
user could be altered as a result of this cascading mutation. The proposal of [42] also suﬀers
from scalability issues due to the MPC protocol used for reconstructing decryption keys across
diﬀerent users.
It is clear that for a permissionless blockchain without centralised trust assumptions, a
practical solution for redacting harmful content must refrain from employing large-scale MPC
protocols that hinders the performance of the blockchain. It also must accommodate public
veriﬁability and accountability such that rational miners are incentivised to follow the protocol.

1.2

Our Contributions

Editable Blockchain Protocol. We propose the ﬁrst editable blockchain protocol for permissionless systems in Section 3, which is completely decentralised and does not rely on heavy
2

The permissioned blockchain setting is when there is a trusted third party (TTP) that deliberates on the
users’ entry into the system.

2

cryptographic primitives or additional trust assumptions. This makes our protocol easily integrable in systems like Bitcoin (as described in Section 5). The edit operations can be proposed
by any user and they are voted in the blockchain through consensus; the edits are only performed if approved by the blockchain policy (e.g., voted by the majority). The protocol is based
on a PoW consensus, however, it can be easily adapted to any consensus mechanism, since the
core ideas are inherently independent of the type of consensus used. Our protocol also oﬀers
accountability for edit operations, where any edit in the chain can be publicly veriﬁed.
Formal Analysis. We build our protocol on ﬁrm theoretical grounds, as we formalise all
the necessary properties of an editable blockchain in Section 4, and later show that our generic
protocol of Section 3.3 satisﬁes these properties. We borrow the fundamental properties of a
secure blockchain protocol from [21] and adapt them to our setting.
Implementation. We demonstrate the practicality of our protocol with a proof-of-concept
implementation in Python. We ﬁrst show in Section 6 that adding our redaction mechanism
incurs in just a small overhead for chain validation time compared to that of the immutable
protocol. Then, we show that for our protocol the overhead incurred for diﬀerent numbers of
redactions in the chain against a redactable chain with no redactions is minimal (less than 3% for
5, 000 redactions on a 50, 000 blocks chain). Finally, we analyse the eﬀect of the parameters in
our protocol by measuring the overhead introduced by diﬀerent choices of the system parameters
when validating chains with redactions.

1.3

Our Protocol

Our protocol extends the immutable blockchain of Garay et al. [21] to accommodate for edit
operations in the following way: We extend the block structure to accommodate another copy
of the transaction’s Merkle root, that we denote by old state. We also consider an editing policy
for the chain, that determines the constraints and requirements for approving edit operations.
To edit a block in the chain, our protocol (Fig. 1) executes the following steps:
a) A user ﬁrst proposes an edit request to the system. The request consists of the index of
the block he wants to edit, and a candidate block to replace it.
b) When miners in the network receives an edit request, they ﬁrst validate the candidate
block using its old state information and verifying the following conditions: (1) it contains
the correct information about the previous block, (2) it has solved the proof of work and
(3) it does not invalidate the next block in the chain. If the candidate block is valid,
miners can vote for it during the request’s voting period by simply including the hash of
the request in the next block they mine. The collision resistance property of the hash
function ensures that a vote for an edit request cannot be considered as a vote for any
other edit request.
c) After the voting period for a request is over, everyone in the network can verify if the edit
request was approved in accordance to the policy (e.g., by checking the number of votes it
received). If the request was approved, then the edit operation is performed by replacing
the original block with the candidate block.
To validate an edited chain, the miners validate each block exactly like in the immutable
protocol; if a “broken” link is found between blocks, the miner checks if the link still holds for
the old state information3 . In the aﬃrmative case, the miner ensures that the edited block has
gathered enough votes and is approved, according to the policy of the chain.
The process of a redaction in our generic protocol as described in Fig. 2 is pictorially presented in Fig. 1.
3

A similar technique is used in [10] to “scar” a block that was previously redacted.

3

Bk⋆

R
Bn⋆

R

Bl⋆
Bj⋆

H(Bj⋆)

By⋆

Bz⋆

propose Bj⋆
Bj

Bx⋆

P(C, Bj⋆) = accept

Voting period (ℓ)
H(Bj⋆)

H(Bj⋆)

Bj⋆

H(Bj⋆)

H(Bj⋆ )

H(Bj⋆ )

H(Bj⋆ )

H(Bj⋆ )

(b) After a successful voting phase, Bj⋆ replaces Bj
in the chain

(a) Proposing a redaction Bj⋆ for the block Bj

Figure 1: The candidate block pool R stores the candidate blocks that are proposed and that
can be endorsed in the voting phase. A block is linked to its predecessor by two links, the old
link (solid arrow) and the new link (dashed arrow). In (a), a redact request Bj⋆ is proposed as
a redaction for Bj and added to R, then the hash of Bj⋆ is included in the chain to denote a
new candidate redaction; its voting phase starts just after its proposal. In (b), the candidate
block Bj⋆ has gathered enough votes and was approved by the redaction policy P of the chain;
Bj⋆ replaces Bj and the redacted chain is propagated. Note that new link from the block to the
right of Bj⋆ is broken (marked by a cross), however the old link to Bj⋆ still holds. For simplicity,
we consider the parameters k = 0 (persistence), ℓ = 4 (voting period) and ρ ≥ 3/4 (threshold
for policy approval).

2

Preliminaries

Throughout this work we denote by κ ∈ N the security parameter and by a ← A(in) the output
of an algorithm A on input in. We also use the terms “redact” and “edit” interchangeably in
this paper.

2.1

Blockchain Basics

We make use of the notation of [21] to describe a blockchain. A block is a triple of the form
B := hs, x, ctr i, where s ∈ {0, 1}κ , x ∈ {0, 1}∗ and ctr ∈ N. Here s is the state of the previous
block, x is the data and ctr is the proof of work of the block. A block B is valid iﬀ
validateBlockD (B) := H(ctr , G(s, x)) < D.
Here, H : {0, 1}∗ → {0, 1}κ and G : {0, 1}∗ → {0, 1}κ are cryptographic hash functions, and
the parameter D ∈ N is the block’s diﬃculty level.
The blockchain is simply a chain (or sequence) of blocks, that we call C. The rightmost
block is called the head of the chain, denoted by Head(C). Any chain C with a head Head(C) :=
hs, x, ctr i can be extended to a new longer chain C ′ := C||B ′ by attaching a (valid) block
B ′ := hs′ , x′ , ctr ′ i such that s′ = H(ctr , G(s, x)); the head of the new chain C ′ is Head(C ′ ) := B ′ .
A chain C can also be empty, and in such a case we let C := ε. The function len(C) denotes the
length of a chain C (i.e., its number of blocks). For a chain C of length n and any q ≥ 0, we
denote by C ⌈q the chain resulting from removing the q rightmost blocks of C, and analogously
we denote by q⌉ C the chain resulting in removing the q leftmost blocks of C; note that if q ≥ n
(where len(C) = n) then C ⌈q := ε and q⌉ C := ε. If C is a preﬁx of C ′ we write C ≺ C ′ . We also
note that the diﬃculty level D can be diﬀerent among blocks in a chain.

4

2.2

Properties of a Secure Blockchain

In this section we detail the relevant aspects of the underlying blockchain system that is required
for our protocol.
We consider time to be divided into standard discrete units, such as minutes. A well deﬁned
continuous amount of these units is called a slot. Each slot sl l is indexed for l ∈ {1, 2, 3, . . .}.
We assume that users have a synchronised clock that indicates the current time down to the
smallest discrete unit. The users execute a distributed protocol to generate a new block in each
slot, where a block contains some data. We assume the slots’ real time window properties as
in [28]. In [21, 39, 28] it is shown that a “healthy” blockchain must satisfy the properties of
persistence and liveness, which intuitively guarantee that after some time period, all honest
users of the system will have a consistent view of the chain, and transactions posted by honest
users will eventually be included. We informally discuss the two properties next.
Persistence: Once a user in the system announces a particular transaction as stable, all of the
remaining users when queried will either report the transaction in the same position in the
ledger or will not report any other conﬂicting transaction as stable. A system parameter k
determines the number of blocks that stabilise a transaction. That is, a transaction is stable if
the block containing it has at least k blocks following it in the blockchain. We only consider a
transaction to be in the chain after it becomes stable.
Liveness: If all the honest users in the system attempt to include a certain transaction into their
ledger, then after the passing of time corresponding to u slots which represents the transaction
confirmation time, all users, when queried and responding honestly, will report the transaction
as being stable.
Throughout the paper we refer to the user as both a user and a miner interchangeably.

2.3

Execution Model.

In the following we deﬁne the notation for our protocol executions. Our deﬁnitions follow along
the same lines of [41].
A protocol refers to an algorithm for a set of interactive Turing Machines (also called nodes)
to interact with each other. The execution of a protocol Π that is directed by an environment/outer game Z(1κ ), which activates a number of parties U = {p1 , . . . , pn } as either honest or
corrupted parties. Honest parties would faithfully follow the protocol’s prescription, whereas
corrupt parties are controlled by an adversary A, which reads all their inputs/messages and
sets their outputs/messages to be sent.
• A protocol’s execution proceeds in rounds that model atomic time steps. At the beginning
of every round, honest parties receive inputs from an environment Z; at the end of every
round, honest parties send outputs to the environment Z.
• A is responsible for delivering all messages sent by parties (honest or corrupted) to all
other parties. A cannot modify the content of messages broadcast by honest parties.
• At any point Z can corrupt an honest party j, which means that A gets access to its local
state and subsequently controls party j.
• At any point of the execution, Z can uncorrupt a corrupted party j, which means that
A no longer controls j. A party that becomes uncorrupt is treated in the same way as a
newly spawning party, i.e., the party’s internal state is re-initialised and then the party
starts executing the honest protocol no longer controlled by A.
Note that a protocol execution can be randomised, where the randomness comes from honest
parties as well as from A and Z. We denote by view ← EXECΠ (A, Z, κ) the randomly sampled
5

execution trace. More formally, view denotes the joint view of all parties (i.e., all their inputs,
random coins and messages received, including those from the random oracle) in the above
execution; note that this joint view fully determines the execution.

3

Editing the Blockchain

In this section we introduce an abstraction Γ of a blockchain protocol, and we describe how to
extend Γ into an editable blockchain protocol Γ′ .

3.1

Blockchain Protocol

We consider an immutable blockchain protocol (for instance [21]), denoted by Γ, where nodes
receive inputs from the environment Z, and interact among each other to agree on an ordered
ledger that achieves persistence and liveness. The blockchain protocol Γ is characterised by a
set of global parameters and by a public set of rules for validation. The protocol Γ provides
the nodes with the following set of interfaces which are assumed to have complete access to the
network and its users.
• {C ′ , ⊥} ← Γ.updateChain: returns a longer and valid chain C in the network (if it exists),
otherwise returns ⊥.
• {0, 1} ← Γ.validateChain(C): The chain validity check takes as input a chain C and returns
1 iﬀ the chain is valid according to a public set of rules.
• {0, 1} ← Γ.validateBlock(B): The block validity check takes as input a block B and returns
1 iﬀ the block is valid according to a public set of rules.
• Γ.broadcast(x ): takes as input some data x and broadcasts it to all the nodes of the
system.
The nodes in the Γ protocol have their own local chain C which is initialised with a common
genesis block. The consensus in Γ guarantees the properties of persistence and liveness discussed
in Section 2.2.

3.2

Editable Blockchain

We build our editable blockchain protocol Γ′ by modifying and extending the aforementioned
protocol Γ. The protocol Γ′ has copies of all the basic blockchain functionalities exposed by
Γ through the interfaces described above, and modiﬁes the validateChain and validateBlock
algorithms in order to accommodate for edits in C. In addition, the protocol Γ′ provides the
following interfaces:
• Bj⋆ ← Γ′ .proposeEdit(C, j, x ⋆ ): takes as input the chain C, an index j of a block to edit
and some data x ⋆ . It then returns a candidate block for Bj .
• {0, 1} ← Γ′ .validateCand(Bj⋆ , C): takes as input a candidate block Bj⋆ and the chain C and
returns 1 iﬀ the candidate block Bj⋆ is valid.
The modiﬁed chain validation and block validation algorithms are presented in Algorithm 1
and Algorithm 2, respectively, while the new algorithms to propose an edit to a block and to
validate candidate blocks are presented in Algorithm 3 and Algorithm 4, respectively. In Fig. 2
we formally describe the protocol Γ′ .
Intuitively, we need modiﬁcations for chain validation and block validation algorithms to
account for an edited block in the chain. A block that has been edited possesses a diﬀerent
state, that does not immediately correlate with its neighbouring blocks. Therefore, for such an
6

edited block we need to ensure that the old state of the block (the state before the edit) is still
accessible for veriﬁcation.4 We do this by storing the old state information in the block itself.
This therefore requires a modiﬁed block validation algorithm and a modiﬁed chain validation
algorithm overall.
We note that for simplicity our protocol is restricted to perform a single edit operation
per block throughout the run of the protocol. In Appendix A we describe an extension of the
protocol to accommodate for an arbitrary number of redactions per block.
Blockchain Policy. We introduce the notion of a blockchain policy P, that determines if an
edit to the chain C should be approved or not. The protocol Γ′ is parameterised by a policy
P that is a function that takes as input a chain C and a candidate block B ⋆ (that proposes a
modiﬁcation to the chain C) and it returns accept if the candidate block B ⋆ complies with the
policy P, otherwise it outputs reject; in case the modiﬁcation proposed by B ⋆ is still being
deliberated in the chain C, then P returns voting.
In its most basic form, a policy P requires that a candidate block B ⋆ should only be accepted
if B ⋆ was voted by the majority of the network within some predeﬁned interval of blocks (or
voting period ℓ). A formal deﬁnition follows.
Definition 1 (Policy). A candidate block B ⋆ generated in round r is said to satisfy the policy
P of chain C := (B1 , . . . , Bn ), i.e., P(C, B ⋆ ) = accept, if it holds that Br+ℓ ∈ C ⌈k and the ratio
of blocks between Br and Br+ℓ containing H(B ⋆ ) (a vote for B ⋆ ) is at least ρ, for k, ℓ ∈ N, and
0 < ρ ≤ 1, where k is the persistence parameter, ℓ is the voting period, and ρ is the ratio of
votes necessary within the voting period ℓ.

3.3

Protocol Description

We denote a block to be of the form B := hs, x, ctr , yi, where s ∈ {0, 1}κ is the hash of the
previous block, x ∈ {0, 1}∗ is the block data, and y ∈ {0, 1}κ is the old state of the block
data. To extend an editable chain C to a new longer chain C ′ := C||B ′ , the newly created block
B ′ := hs′ , x′ , ctr ′ , y ′ i sets s′ := H(ctr , G(s, x), y), where Head(C) := hs, x, ctr , yi. Note that
upon the creation of block B ′ , the component y ′ takes the value G(s′ , x′ ), that represents the
initial state of block B ′ .
During the setup of the system, the chain C is initialised as C := genesis, and all the users
in the system maintain a local copy of the chain C and a pool R consisting candidate blocks for
edits, that is initially empty. The protocol runs in a sequence of rounds r (starting with r := 1).
In the beginning of each round r, the users try to extend their local chain using the interface
Γ′ .updateChain, that tries to retrieve new valid blocks from the network and append them to the
local chain. Next, the users collect all the candidate blocks Bj⋆ from the network and validate
them by using Γ′ .validateCand (Algorithm 4); then, the users add all the valid candidate blocks
to the pool R. For each candidate block Bj⋆ in R, the users compute P(C, Bj⋆ ) to verify if the
candidate block Bj⋆ should be adopted by the chain or not; if the output is accept they replace
the original block Bj in the chain by the candidate block Bj⋆ and remove Bj⋆ from R. If the
output is reject, the users remove the candidate block Bj⋆ from R, otherwise if the output
is voting they do nothing. To create a new block B the users collect transactions from the
network and store them in x; if a user wishes to endorse the edit proposed by a candidate block
Bj⋆ ∈ R that is still in voting stage, the user can vote for the candidate block Bj⋆ by simply
adding H(Bj⋆ ) to the data x. After the block is created and the new extended chain C ′ := C||B is
built, the users broadcast the new chain C ′ iﬀ Γ′ .validateChain(C ′ ) = 1 (Algorithm 1). Finally, if
4

Note that the protocol does not need to maintain the redacted data for verification, and therefore all redacted
data is completely removed from the chain.

7

The protocol Γ′ consists of a sequence of rounds r, and is parameterised by the liveness and
persistence parameters, denoted by u, k, respectively, and by a policy P that among other rules
and constraints, determines the parameter ℓ (that is the duration of the voting period) and ρ
(that is the threshold of votes within the period ℓ for a candidate block to be accepted and
incorporated into the chain). A pictorial representation of the protocol can be found in Fig. 1.
Initialisation. Set the chain C ← genesis, set round r ← 1 and initialise an empty list of
candidate blocks for edits R := ∅.
For each round r of the protocol, we describe the following sequence of execution.
Chain update. At the beginning of a new round r, the nodes try to update their local chain
by calling C ← Γ′ .updateChain.
Candidate blocks pool. Collect all candidate blocks Bj⋆ from the network and add Bj⋆ to
the pool of candidate blocks R iﬀ Γ′ .validateCand(C, Bj⋆ ) = 1; otherwise discard Bj⋆ .
Editing the chain. For all candidate blocks Bj⋆ ∈ R do:
• If P(C, Bj⋆ ) = accept, then build the new chain as C ← C ⌈(n−j+1) ||Bj⋆ ||j⌉ C and remove
Bj⋆ from R. For policy P to accept Bj⋆ , it must be the case that the ratio of votes for Bj⋆
within its voting period (ℓ blocks) is at least ρ.
• If P(C, Bj⋆ ) = reject, then remove Bj⋆ from R. For policy P to reject Bj⋆ it must be the
case that the ratio of votes for Bj⋆ within its voting period (ℓ blocks) is less than ρ.
• If P(C, Bj⋆ ) = voting, then do nothing.
Creating a new block. Collects all the transaction data x from the network for the r-th
round and tries to build a new block Br by performing the following steps:
• (Voting for candidate blocks). For all candidate blocks Bj⋆ ∈ R that the node is willing
to endorse, if P(C, Bj⋆ ) = voting then set x ← x||H(Bj⋆ ).
• Create a new block B := hs, x, ctr , G(s, x)i, such that s = H(ctr ′ , G(s′ , x′ ), y ′ ), for
hs′ , x′ , ctr ′ , y ′ i ← Head(C).
• Extend its local chain C ← C||B and iﬀ Γ′ .validateChain(C) = 1 then broadcast C to the
network.
Propose an edit. The node willing to propose an edit for the block Bj , for j ∈ [n], creates a
candidate block Bj⋆ ← Γ′ .proposeEdit(C, j, x ⋆ ) using the new data x ⋆ , and broadcasts it to the
network by calling Γ′ .broadcast(Bj⋆ ).
Figure 2: Accountable permissionless editable blockchain protocol Γ′P

8

a user wishes to propose an edit to block Bj in the chain C, she ﬁrst creates the new data x⋆j , that
represents the modiﬁcations that she proposes to make to the data xj , and calls proposeEdit
(Algorithm 3) using the interface Γ′ .proposeEdit with the chain C, index j of the block in C
and the new data x⋆j . The algorithm returns a candidate block Bj⋆ that is broadcasted to the
network.
Chain Validation. Given a chain C, the user needs to validate C according to some set
of validation rules. To do this, she uses the Γ′ .validateChain interface, that is implemented
by Algorithm 1. The algorithm takes as input a chain C and starts validating from the head
of C. In Line 5, the validity of the block Bj is checked. If the assertion in Line 6 is false and
if the check in Line 7 is successful, then the block Bj−1 is a valid edited block. In Line 7, the
validity of Bj−1 is checked in the context of a candidate block and whether the block is accepted
according to the voting policy P of the chain.
Algorithm 1: validateChain (implements Γ′ .validateChain)
input : Chain C = (B1 , · · · , Bn ) of length n.
output: {0, 1}
1:
2:
3:
4:
5:
6:
7:

8:
9:

j := n;
if j = 1 then return Γ′ .validateBlock(B1 );
while j ≥ 2 do
Bj := hsj , xj , ctr j , yj i ;
⊲ Bj := Head(C) when j = n
if Γ′ .validateBlock(Bj ) = 0 then return 0;
if sj = H(ctr j−1 , G(sj−1 , xj−1 ), yj−1 ) then j := j − 1;
else if
(sj = H(ctr j−1 , yj−1 , yj−1 )) ∧ (Γ′ .validateCand(C, Bj−1 ) = 1) ∧ (P(C, Bj−1 ) = accept)
then j := j − 1;
else return 0;
return 1;

Block Validation. To validate a block, the validateBlock algorithm (described in Algorithm 2)
takes as input a block B and ﬁrst validates the data included in the block according to some
pre-deﬁned validation predicate. It then checks if the block indeed satisﬁes the constraints of
the PoW puzzle. Apart from this check, the or (∨) condition is to ensure that in case of dealing
with an edited block B, the old state of B still satisﬁes the PoW constraints.
Algorithm 2: validateBlock (implements Γ′ .validateBlock)
input : Block B := hs, x, ctr , yi.
output: {0, 1}
1:
2:
3:

Validate data x, if invalid return 0;
if H(ctr , G(s, x), y) < D ∨ H(ctr , y, y) < D then return 1;
else return 0;

Proposing an Edit. Any user in the network can propose for a particular data to be removed
or replaced from the blockchain. She uses the proposeEdit algorithm as described in Algorithm 3
and constructs a candidate block to replace the original block. The algorithm takes as input a
chain C, the index j of the original block and new data x⋆j that will replace the original data. If
the user’s intention is simply to remove all data from block Bj then x⋆j := ε. It then generates
a candidate block as the tuple Bj⋆ := hsj , x⋆j , ctr j , yj i.
9

Algorithm 3: proposeEdit (implements Γ′ .proposeEdit)
input : Chain C = (B1 , · · · , Bn ) of length n, an index j ∈ [n], and the new data x⋆j .
output: A candidate block Bj⋆ .
1:
2:
3:

Parse Bj := hsj , xj , ctr j , yj i;
Build the candidate block Bj⋆ := hsj , x⋆j , ctr j , yj i;
return Bj⋆ ;

Validating Candidate Blocks. When the user wishes to validate a candidate block Bj⋆ :=
hsj , x⋆j , ctr j , yj i for the j-th block of a chain C, she uses validateCand which is described in Algorithm 4. It retrieves the blocks Bj−1 and Bj+1 of index j − 1 and j + 1 respectively from the
chain C. In Line 5 it is checked if the link s⋆j from Bj⋆ to Bj−1 holds and that the link sj+1 from
Bj+1 to Bj⋆ also satisﬁes the condition sj+1 = H(ctrj , yj , yj ). The latter condition checks if the
“old link” still holds. If both checks are successful the candidate block Bj⋆ is considered valid,
otherwise it is considered invalid.
Algorithm 4: validateCand (implements Γ′ .validateCand)
input : Chain C = (B1 , · · · , Bn ) of length n, and a candidate block Bj⋆ for an edit.
output: {0, 1}
1:
2:
3:
4:
5:
6:

4

Parse Bj⋆ := hsj , x⋆j , ctr j , yj i;
if Γ′ .validateBlock(Bj⋆ ) = 0 then return 0;
Parse Bj−1 := hsj−1 , xj−1 , ctr j−1 , yj−1 i;
Parse Bj+1 := hsj+1 , xj+1 , ctr j+1 , yj+1 i;
if s⋆j = H(ctr j−1 , yj−1 , yj−1 ) ∧ sj+1 = H(ctr j , yj , yj ) then return 1;
else return 0;

Security Analysis

In this section we analyse the security of our editable blockchain protocol of Fig. 2.
We assume the existence of an immutable blockchain protocol Γ, as described in Section 3.1,
that satisﬁes the properties of chain growth, chain quality and common preﬁx [21]. The basic
intuition behind our security analysis is that, given that Γ satisﬁes the aforementioned properties, our editable blockchain protocol Γ′P , (which is Γ′ parameterised by a policy P), preserves
the same properties (or a variation of the property in the case of common preﬁx). Therefore,
our protocol behaves exactly like the immutable blockchain Γ when there are no edits in the
chain, and if an edit operation was performed, it must have been approved by the policy P. We
discuss each individual property next.
Chain Growth. The chain growth property from Γ is automatically preserved in our editable
blockchain Γ′ , since the possible edits do not allow the removal of blocks or inﬂuence the
growth of the chain. We present the formal deﬁnition next, followed by a theorem stating that
Γ′ preserves chain growth whenever Γ satisﬁes chain growth.
Definition 2 (Chain Growth [21]). Consider the chains C1 , C2 possessed by two honest parties
at the onset of two slots sl 1 , sl 2 , with sl 2 at least s slots ahead of sl 1 . Then it holds that
len(C2 ) − len(C1 ) ≥ τ · s, for s ∈ N and 0 < τ ≤ 1, where τ is the speed coefficient.

10

Theorem 1. If Γ satisfies (τ, s)-chain growth, then Γ′P satisfies (τ, s)-chain growth for any
policy P.
Proof. We note that Γ′ extends Γ, that by assumption satisﬁes chain growth. Also, note that in
Γ′ it is not possible to remove a block from the chain (for any policy P), thereby reducing the
length of C. In other words, the edits performed do not alter the length of the chain. Therefore,
we conclude that Γ′ satisﬁes chain growth whenever Γ satisﬁes chain growth.

Chain Quality. The chain quality property informally states that the ratio of adversarial
blocks in any segment of a chain held by a honest party is no more than a fraction µ, where µ
is the fraction of resources controlled by the adversary.
Definition 3 (Chain Quality [21]). Consider a portion of length ℓ-blocks of a chain possessed
by an honest party during any given round, for ℓ ∈ N. Then, the ratio of adversarial blocks in
this ℓ segment of the chain is at most µ, where 0 < µ ≤ 1 is the chain quality coefficient.
Theorem 2. Let H be a collision-resistant hash function. If Γ satisfies (µ, ℓ)-chain quality,
then Γ′P satisfies (µ, ℓ)-chain quality for any (k, ℓ, ρ)-policy where ρ > µ.
Proof. We note that the only diﬀerence in Γ′P in relation to Γ is that blocks can be edited.
An adversary A could edit an honest block B in the chain C into a malicious block B ⋆ (e.g.,
that contains illegal content), increasing the proportion of malicious blocks in the chain, and
therefore breaking the chain quality property. We show below that A has only a negligible
probability of violating chain quality of Γ′ .
Let A propose a malicious candidate block Bj⋆ for editing an honest block Bj ∈ C. Since
A possesses only µ computational power, by the chain quality property of Γ we know that the
adversary mines at most µ ratio of blocks in the voting phase. As the policy stipulates, the
ratio of votes has to be at least ρ for B ⋆ to be approved, where ρ > µ. Therefore, B ⋆ can only
be approved by the policy P if honest nodes vote for it. Observe that the adversary could try
f⋆ 6= B ⋆ such that
to build an “honest looking” (e.g., without illegal contents) candidate block B
f⋆ ) = H(B ⋆ ), in an attempt to deceive the honest nodes during the voting phase; the honest
H(B
nodes could endorse the candidate block B ⋆ during the voting phase, and the adversary would
f⋆ . The adversary has only a negligible chance
instead edit the chain with the malicious block B
⋆
f⋆ ) = H(B ⋆ ), since this would violate the
of producing such a candidate block B where H(B
collision-resistance property of the hash function H.
Moreover, B ⋆ is incorporated to the chain only if it is an honest candidate block. This
concludes the proof.

Common Prefix. The common preﬁx property informally says that if we take the chains of
two honest nodes at diﬀerent time slots, the shortest chain is a preﬁx of the longest chain (up
to the common preﬁx parameter k). We show the formal deﬁnition next.
Definition 4 (Common Preﬁx [21]). The chains C1 , C2 possessed by two honest parties at the
⌈k
⌈k
onset of the slots sl 1 < sl 2 are such that C1  C2 , where C1 denotes the chain obtained by
removing the last k blocks from C1 , where k ∈ N is the common prefix parameter.
We remark however, that our protocol Γ′P inherently does not satisfy Deﬁnition 4. To see
this, consider the case where two chains C1 and C2 are held by two honest parties P1 and P2 at
slots sl 1 and sl 2 respectively, such that sl 1 < sl 2 . In slot r starts the voting phase (that lasts ℓ
blocks) for a candidate block Bj⋆ proposing to edit block Bj , such that j + k ≤ r < sl 1 ≤ ℓ + k <
11

sl 2 . Note that at round sl 1 the voting phase is still on, therefore P(C1 , Bj⋆ ) = voting. By round
sl 2 , the voting phase is complete and in case P(C2 , Bj⋆ ) = accept the block Bj is replaced by
⌈k

Bj⋆ in C2 . However, in chain C1 the j-th block is still Bj , since the edit of Bj⋆ is waiting to be
⌈k

conﬁrmed. Therefore, C1 ⊀ C2 , thereby violating Deﬁnition 4.
The pitfall in Deﬁnition 4 is that it does not account for edits or modiﬁcations in the chain.
We therefore introduce a new deﬁnition that is suited for an editable blockchain (with respect
to an editing policy). The formal deﬁnition follows.
Definition 5 (Editable Common preﬁx). The chains C1 , C2 of length l1 and l2 , respectively,
possessed by two honest parties at the onset of the slots sl 1 ≤ sl 2 satisfy one of the following:
⌈k

1. C1  C2 , or
⌈(l −l )+k
⌈k
2. for each Bj⋆ ∈ C2 2 1
such that Bj⋆ ∈
/ C1 , it must be the case that P(C2 , Bj⋆ ) = accept,
for j ∈ [l1 − k],
⌈(l −l )+k

denotes the chain obtained by pruning the last (l2 − l1 ) + k blocks from C2 , P
where C2 2 1
denotes the chain policy, and k ∈ N denotes the common prefix parameter.
Intuitively, the above deﬁnition states that if there exists a block that violates the common
preﬁx as deﬁned in Deﬁnition 4, then it must be the case that this block is an edited block
whose adoption was voted and approved according to the policy P in chain C2 . We show that
our protocol Γ′ satisﬁes Deﬁnition 5 next.
Theorem 3. Let H be a collision-resistant hash function. If Γ satisfies k-common prefix, then
Γ′P satisfies k-editable common prefix for a (k, ℓ, ρ)-policy.
Proof. If no edits were performed in a chain C, then the protocol Γ′P behaves exactly like the
immutable protocol Γ, and henceforth the common preﬁx property follows directly.
However, in case of an edit, consider an adversary A that proposes a candidate block Bj⋆ to
edit Bj in chain C2 , which is later edited by an honest party P2 at slot sl 2 . Observe that by the
collision resistance property of H, A is not able to eﬃciently produce another candidate block
f⋆ 6= B ⋆ such that H(B
f⋆ ) = H(B ⋆ ). Therefore, since P2 is honest and adopted the edit B ⋆
B
j
j
j
j
j
in C2 , it must be the case that Bj⋆ received enough votes such that P(C2 , Bj⋆ ) = accept. This
concludes the proof.
How the properties play together : By showing that Γ′ satisﬁes the three aforementioned properties, we show that Γ′P is a live and persistent blockchain protocol immutable against edits not
authorised by the policy P.
The editable common preﬁx property ensures that only policy approved edits are performed
on the chain. The Chain quality property, for a (k, ℓ, ρ)-policy P where ρ > µ, ensures that an
adversary does not get a disproportionate contribution of blocks to the chain.

5

Integrating into Bitcoin

In this section we describe how our generic editable blockchain protocol (Fig. 2) can be integrated
into Bitcoin. For simplicity, we consider one redaction per block and the redaction is performed
on one or more transactions included in the block. The extension of the generic protocol for
multiple redactions (described in Appendix A) can be immediately applied to the construction
described in this section. Next, we give a brief background on the Bitcoin protocol.

12

Tx′

Tx
in: . . .

in: TxID

out-script: τ1
amount: α1

out-script: τ2
amount: α2

witness: . . .

witness: x, s.t., τ1 (x) = 1

Figure 3: The structure of a transaction in Bitcoin. The transaction Tx′ is spending the output
τ1 of transaction Tx.

5.1

Bitcoin Basics

Transactions. A simple transaction Tx in Bitcoin has the following basic structure: an input
script, an output script with a corresponding amount, and a witness. More complex transactions
may have multiple input and output scripts and/or more complex scripts. A transaction Tx′
that spends some output τ of Tx, has the ID of Tx in its input, denoted by TxID := H(Tx), and
a witness x that satisﬁes the output script τ of Tx (as shown in Fig. 3). The amount α2 being
spent by the output script τ2 needs to be smaller (or equal) than the amount α1 of τ1 . The
most common output scripts in Bitcoin consists of a public key, and the witness x is a signature
of the transaction computed using the corresponding secret key. We refer the reader to [1] for
a comprehensive overview of the Bitcoin scripting language.
Insertion of Data. Users are allowed to propose new transactions containing arbitrary data,
that are then sent to the Bitcoin network for a small fee. Data can be inserted into speciﬁc
parts of a Bitcoin transaction, namely the output script, input script and witness. Matzutt
et al. [34] provide a quantitative analysis of data insertion methods in Bitcoin. According to
their analysis, OP RETURN and coinbase transactions are the major pockets apart from some
non-standard transactions, where data is inserted.
Block Structure. A Bitcoin block consists of two parts, namely the block header, and a list
of all transactions within the block. The structure of the block header is detailed in Fig. 6,
whereas a pictorial representation of the list of transactions can be found in Fig. 7.

5.2

Modifying the Bitcoin Protocol

In this section we detail the modiﬁcations to the Bitcoin protocol necessary to integrate it to
our generic editable blockchain protocol of Section 3. The resulting protocol is a version of
Bitcoin that allows for redaction of (harmful) data from its transactions.
By redaction of transactions, we mean removing data from a transaction without making
other changes to the remaining components of the transaction. As shown in Fig. 5a, consider a
transaction Tx1 that contains some harmful data in its output script, and let Tx⋆1 be a candidate
transaction to replace Tx in the chain, where Tx⋆1 is exactly the same as Tx1 , except that the
harmful data is removed ( Fig. 5b).
editTx
in: . . .
out-script: Tx1ID , Tx⋆1ID
witness: . . .

Figure 4: The special transaction editTx is broadcasted to the network to propose a redaction
of transaction Tx1 for the candidate transaction Tx⋆1 .

13

Tx⋆1

Tx1
in: . . .

in: . . .

out-script 1: τ1
amount: α1

out-script 1: τ1
amount: α1

out-script 2: τ2 , harmful data

out-script 2: τ3 , harmful data

witness: x

witness: x

(a) Non-redacted

(b) After Redaction

Figure 5: (a) The transaction Tx1 contains harmful data, and (b) the candidate transaction
Tx⋆1 contains a copy of all the ﬁelds of Tx1 , with exception of the harmful data.
Proposing Redactions. A user who wishes to propose a redaction proceeds as follows: First,
constructs a special transaction editTx (as shown in Fig. 4) containing Tx1ID and Tx⋆1ID , that
respectively denotes the hash of the transaction Tx1 being redacted, and the hash of Tx⋆1 that is
the candidate transaction to replace Tx1 in the chain5 . Then, broadcasts the special transaction
editTx and the candidate transaction Tx⋆1 to the network; editTx requires a transaction fee to
be included in the blockchain, while Tx⋆1 is added to a pool of candidate transactions6 . The
candidate transaction Tx⋆1 is validated by checking its contents with respect to Tx1 , and if it is
valid, then it can be considered for voting.
Redaction Policy. The redactable Bitcoin protocol is parameterised by a policy parameter P
(Deﬁnition 1). The policy P dictates the requirements and constraints for redaction operations
in the blockchain. An informal description of a (basic) policy for Bitcoin would be:
A proposed redaction is approved valid if the following conditions hold:
•
•
•
•

It is identical to the transaction being replaced, except that it can remove data.
It can only remove data that can never be spent, e.g., OP RETURN output scripts.
It does not redact votes for other redactions in the chain.
It received more than 50% of votes in the 1024 consecutive blocks (voting period) after
the corresponding editTx is stable in the chain.

where voting for a candidate transaction Tx⋆1 simply means that the miner includes editTxID =
H(Tx1ID ||Tx⋆1ID ) in the coinbase (transaction) of the new block he produces. After the voting
phase is over, the candidate transaction is removed from the candidate pool.
The reason for restricting the redactions to non-spendable components of a transaction (e.g.,
OP RETURN) is that, permitting redactions on spendable content could lead to potential misuse
(Section 7) and future inconsistencies within the chain. We stress however, that this is not a
technical limitation of our solution, but rather a mechanism to remove the burden of the user
on deciding what redactions could cause inconsistencies on the chain in the future. We feel that
the aforementioned policy is suitable for Bitcoin, but as policies are highly dependent on the
application, a diﬀerent policy can be better suited for diﬀerent settings.
New Block Structure. To account for redactions, the block header must accommodate
an additional ﬁeld called old merkle root. When a block is initially created, i.e., prior to any
redaction, this new ﬁeld takes the same value as merkle root. For a redaction request on block
Bj , that proposes to replace Tx1 with the candidate transaction Tx⋆1 , the transactions list of
the candidate block Bj⋆ (that will replace Bj ) must contain Tx1ID = H(Tx1 ) in addition to
5

We note that our transaction ID is Segwit compatible, as the witness is not used with the hash H to generate
a transaction’s ID.
6
If a candidate transaction does not have a corresponding editTx in the blockchain then the transaction is not
included in the candidate pool, and it is treated as spam instead.

14

the remaining transactions. A new merkle root is computed for the new set of transactions,
while old merkle root remains unchanged. To draw parallels with the abstraction we described
in Section 3.1, G(s, x) is analogous to merkle root and y is analogous to old merkle root.
Value
hash prev
merkle root
difficulty
timestamp
nonce
old merkle root

Description
hash of the previous block header
root of the merkle tree (whose the leaves are the
transactions)
the diﬃculty of the proof-of-work
the timestamp of the block
nonce used in proof-of-work
root of the merkle tree of old set of transactions

Figure 6: Structure of the Bitcoin block header. The last highlighted ﬁeld (old merke root) is
only included in the block header of the extended (editable) protocol.
Block Validation. The validation of a block consists of the steps described below.
• Validating transactions: The block validates all the transactions contained in its transactions list; the validation of non-redacted transactions is performed in the same way as in
the immutable version of the protocol. Transactions that have been previously redacted
require a special validation that we describe next. Consider the case presented in Fig. 5,
where Tx1 is replaced by Tx⋆1 . The witness x was generated with respect to Tx1ID and
is not valid with respect to Tx⋆1ID . Fortunately, the old state Tx1ID (hash of the redacted
transaction) is stored, as shown in Fig. 7b, ensuring that the witness x can be successfully
validated with respect to the old version of the transaction. Therefore, we can ensure
that all the transactions included in the block have a valid witness, or in case of redacted
transactions, the old version of the transaction had a valid witness. To verify that the
redaction was approved in the chain one needs to ﬁnd a corresponding editTx (Fig. 4) in
the chain, and verify that it satisﬁes the chain’s policy.
• PoW verification: The procedure to verify the PoW puzzle is described in Algorithm 2.
If the block contains an edited transaction, i.e., old merkle root 6= merkle root, then substitute the value in hash merkle root with that in old merkle root and check if the hash of
this new header is within T .
Tx1

Tx⋆1 , Tx1ID

Tx2

Tx2

Tx3

Tx3

..
.

..
.

(a) Non-redacted.

(b) Redacted transaction Tx1 .

Figure 7: List of transactions contained within a block before (left) and after (right) redacting
a transaction in the block.
Chain Validation. To validate a full chain a miner needs to validate all the blocks within the
chain. The miner can detect if a block has been redacted by verifying its hash link with the next
block; in case of a redacted block, the miner veriﬁes if the redaction was approved according
to the chain’s policy. The miner rejects a chain as invalid if any of the following holds: (1)
15

a block’s redaction was not approved according to the policy, (2) the merkle root value of the
redacted block is incorrect with respect to the set of transactions (that contains the hash of the
redacted transaction) or (3) a previously approved redaction was not performed on the chain.
Transaction Consistency. Removing a transaction entirely or changing spendable data
of a transaction may result in serious inconsistencies in the chain. For example, consider a
transaction Tx1 that has two outputs denoted by A and B, where the second output B has a
data entry and the ﬁrst output A contains a valid spendable script that will be eventually spent
by some other transaction Tx′ . If the redaction operation performed on Tx1 aﬀects the output
script of A, Tx′ may become invalid, causing other transactions to become invalid. A similar
problem may arise if the redaction is performed on the input part of Tx1 enabling the user who
generated Tx1 to possibly double spend the funds. Therefore, we only allow redactions that do
not aﬀect a transaction’s consistency with past and future events.
Redaction and Retrievability. The redaction policy P for Bitcoin restricts redactions to
only those operations that do not violate a transaction’s consistency. This means that we do not
allow monetary transactions to be edited (such as standard coin transfer). We stress, however
that the main objective of redacting a transaction Tx is to prevent some malicious content x,
that is stored inside Tx, from being broadcasted as part of the chain, thereby ensuring that the
chain and its users are legally compliant. Note that we cannot prevent an adversary from locally
storing and retrieving the data x, even after its redaction, since the content was publicly stored
in the blockchain. In this case, the user that willingly keeps the malicious (and potentially
illegal) data x will be liable.
Accountability. Our proposal oﬀers accountability during and after the voting phase is
over. Moreover, the accountability during the voting phase prevents the problem of transaction
inconsistencies discussed above.
• Voting Phase Accountability: During the voting phase, anyone can verify all the details of
a redaction request. The old transaction and the proposed modiﬁcation (via the candidate
transaction) are up for public scrutiny. It is publicly observable if a miner misbehaves by
voting for a redaction request that, apart from removing data, also tampers with the input
or (a spendable) output of the transaction, in turn aﬀecting its transaction consistency.
This could discourage users from using the system due to its unreliability as a public
ledger for monetary purposes. Since the miners are heavily invested in the system and
are expected to behave rationally, they would not vote for such an edit request (that is
against the policy) during the voting phase.
• Victim Accountability: After a redaction is performed, our protocol allows the data owner,
whose data was removed, to claim that it was indeed her data that was removed. Since
we store the hash of the old transaction along with the candidate transaction in the
edited block (refer to Fig. 7b), it is possible for a user that possesses the old data (that
was removed) to verify it against the hash that is stored in the redacted block. This
enforces accountability on the miners of the network who vote for a redaction request by
discouraging them from removing benign data. At the same time, our protocol guarantees
protection against false claims, as the hash veriﬁcation would fail.

6

Proof-of-Concept Implementation

In this section we report on a Python proof-of-concept implementation used for evaluating our
approach. We implement a full-ﬂedged Blockchain system based on Python 3 that mimics all
the basic functionalities of Bitcoin. Speciﬁcally, we include a subset of Bitcoin’s script language
that allows us to insert arbitrary data into the chain, which can be redacted afterwards. The
16

4%

4%

4%

2%

2%

2%

0%

0%

0%

10K 20K 30K 40K 50K

Chain size (in # of blocks)

1K

2K

3K

4K

5K

# of redactions in the chain

(a)

(b)

15 20 25 30 35 40 45 50 55

Voting period ℓ

(c)

Figure 8: The graphs above show the overhead (in percentage) of our proof-of-concept implementation in each experiment performed. In (a) the graph shows the validation time overhead
required to validate a redactable chain (with no redactions) compared to an immutable chain; in
(b) the graph shows the validation time overhead required to validate a chain for an increasing
number of redactions, compared to a redactable chain with no redactions, and ﬁnally in (c) the
graph shows the validation time overhead required to validate a chain (with 1% of the blocks
redacted) for increasing voting periods, compared to a chain (with 1% of the blocks redacted)
on a ﬁxed voting period of ℓ = 5.
redacting mechanism is built upon the proposed modiﬁcations to Bitcoin that we describe
in Section 5. For conceptual simplicity we rely on PoW as the consensus mechanism.

6.1

Benchmarking

We detail the performance achieved by our implementation running several experiments. The
benchmarking was performed in a virtual environment on a Linux server with the following
speciﬁcations.
•
•
•
•

Intel Xeon Gold 6132 CPU @ 2.60GHz
128GB of RAM
Debian Linux 4.9.0-6-amd64
Python 3.5.3.

We measure the run time of Algorithm 1 by validating chains of varying lengths (i.e., number
of blocks) and with diﬀerent numbers of redactions in the chain. For each experiment, a new
chain is created and validated 50 times, then the arithmetic mean of the run time is taken
over all runs. Each chain consists of up to 50, 000 blocks, where each block contains 1, 000
transactions. Note that a chain of size 50, 000 blocks approximates a one year snapshot of the
bitcoin blockchain.
The great variation of the results shown in the experiments is due to the randomness involved
in the chain creation and validation process, since each chain will contain its own set of (diﬀerent)
transactions, slightly inﬂuencing the run time.
Overhead Compared to Immutable Blockchain. For the ﬁrst series of experiments,
we generate chains of length ranging from 10, 000 up to 50, 000 blocks. We generate both,
immutable and redactable chains (with no redactions). The goal here is to measure the overhead that comes with the integration of our redactable blockchain protocol with an immutable
blockchain when there are no redactions performed. The results in Fig. 8a indicate that there
is only a tiny overhead. Interestingly, we note that as the size of the chain grows, the overhead
tends to get smaller; this is because on a chain without redactions the only extra step required
17

is to check if there are any votes in the coinbase transaction of a new block, what becomes
negligible compared to the veriﬁcation time as the chain grows larger.
Overhead by Number of Redactions. For the second series of experiments, we generate
redactable chains with the number of redactions ranging from 2% (1, 000 redactions) to 10%
(5, 000 redactions) of the blocks. The redacted transactions within a block contains dummy data
consisting of 4 bytes that are removed during the experiment. This experiment is intended to
measure the overhead with respect to the number of redactions performed in a chain compared
to a redactable chain with no redactions. The results in Fig. 8b show that the overhead tends
to be at most linear in the number of redactions, since in our prototype instead of looking
ahead whether there is a redaction request and a suﬃcient number of votes, we keep track of
the redaction request and wait for its votes and eventual conﬁrmation.
Overhead by the Voting Parameters ℓ and ρ. In the last series of experiments, we
consider chains with 1% of the blocks redacted. We vary the voting period ℓ to measure how
it inﬂuences the validation time compared to a chain with 1% of blocks redacted but with a
voting period of ℓ = 5. The threshold of votes ρ is set to ⌊ 2ℓ ⌋ + 1 /ℓ (i.e., requiring majority
number of blocks in the voting period to contain votes for approving a redaction). The results
in Fig. 8c show that the overhead is very small (even negligible for small sizes of ℓ) and tends
to be at most linear in ℓ. This meets our expectations, since the overhead in validation time
originates from keeping and increasing the voting counts over the voting period ℓ. In the worst
case, where ρ = 1 we need to keep track of the voting count over the entire voting period.

7

Discussion

In this section we discuss some of the generic attacks on our system and how it is immune to
such attacks.
Unapproved Editing. A malicious miner could pass oﬀ an edit on the blockchain that does
not satisfy the network’s policy. This can occur if the miner presents the blockchain with an
edit that has not been considered for voting, or has gathered insuﬃcient votes. In any of the
above cases, it is possible for any user in the network to account for an edit by verifying in the
chain if the exact edit presented by the miner is approved or not. And since majority of the
miners in the network is honest, the user accepts an approved edit as an honest edit.
Scrutiny of Candidate Blocks. It is in the interest of the (honest) miners and the system
as a whole, to actively scrutinise a candidate block and decide on voting based on its merit.
Therefore, the miners are strongly discouraged from using a default strategy in voting, e.g.,
always vote for a candidate block without scrutiny, using a pre-determined strategy that is
agnostic to what the candidate block is proposing.
Denial of Service. A malicious miner may try to ﬂood the network with edit requests as an
attempt to slow down transaction conﬁrmation in the chain. However, the miner is deterred
from doing this because he incurs the cost of a transaction fee for the editTx that is part of his
edit request similar to other standard transactions. Moreover, it may also be the case for the
editTx to incur a higher transaction fee as a strong deterrent against spamming.
False Victim. A malicious user may wrongly claim that a particular transaction related
to him was edited. For example, he may claim that some monetary information was changed
where he was the beneﬁciary. Since such an edit could aﬀect the trust in the system, the user
could potentially aﬀect the credibility of the entire system. We prevent such an attack through
victim accountability of our protocol. We can verify the user’s claim against the hash of the old
version of the transaction that is stored in the chain itself. Given the hash function is collision

18

resistant, a wrong claim would fail the check.
Double Spend Attacks. Consider a scenario where a malicious user is the recipient of a
transaction. If this transaction was edited by removing some data stored in it, the hash of the
new version of the transaction is diﬀerent. If the miner had already spent the funds from the
old version of this transaction, after the edit, he may attempt a double spend by exploiting the
new version of the transaction. This is prevented by associating the new version and the old
version of the edited transaction with each other, thereby noticing such a double spend. If the
funds had already been spent, the old version would be a spent transaction. Because the edit
that is performed does not conﬂict with the consistency of the transaction, the new version of
the transaction would also be a spent transaction.
Consensus delays. Consider a scenario where two diﬀerent users hold chains with a diﬀerent
set of redacted blocks, and therefore cannot arrive at a consensus on the ﬁnal state of the chain,
what may result in delays. Assuming the miners have not locally redacted blocks on their
own and have behaved honestly according to the protocol, this scenario would mean that the
diﬀerent set of redacted blocks in the chains held by the two miners have been approved by the
policy. However, this would be a blatant violation of the Editable common preﬁx property of
our protocol (Theorem 3).

8

Related work

Bitcoin and Applications. Several works [8, 12, 40] have analysed the properties and extended the features of the Bitcoin protocol. Bitcoin as a public bulletin board has found several
innovative applications far beyond its initial scope, e.g., to achieve fairness and correctness
in secure multi-party computation [9, 7, 15, 31], to build smart contracts [30], to distributed
cryptography [6], and more [32, 29, 16].
Content Insertion in Bitcoin. There have been several works [13, 35, 36, 42, 44, 45] on
analysing and assessing the consequences of content insertions in public blockchains. They shed
light on the distribution and the usage of such inserted data entries. The most recent work
of Matzutt et al. [34] gives a comprehensive quantitative analysis of illicit content insertions
including, insertion techniques, potential risks and rational incentives. They also show that
compared to other attacks [20, 24] on Bitcoin system, illicit content insertion can pose immediate
risks to all users of the system.
Proactive Countermeasures. Proactive measures to detect illicit material circulated in the
network and detecting them have been studied [43, 27, 25]. In a blockchain setting, preventive
solutions [19, 17, 37] focus on maintaining only monetary information instead of the entire
ledger history. Matzutt et al. [33] use a rational approach of discouraging miners from inserting
harmful content into the blockchain. They advocate a minimum transaction fee and mitigation
of transaction manipulatability as a deterrent for the same.

Acknowledgment
This work is a result of the collaborative research project PROMISE (16KIS0763) by the German
Federal Ministry of Education and Research (BMBF). FAU authors were also supported by
the German research foundation (DFG) through the collaborative research center 1223, and
by the state of Bavaria at the Nuremberg Campus of Technology (NCT). NCT is a research
cooperation between the Friedrich-Alexander-Universität Erlangen-Nürnberg (FAU) and the
Technische Hochschule Nürnberg Georg Simon Ohm (THN).

19

References
[1] Bitcoin script. https://en.bitcoin.it/wiki/Script.
[2] Interpol cyber research identiﬁes malware threat to virtual currencies. Interpol, 2015.
https://tinyurl.com/y9wfekr6.
[3] Accenture ﬁles patent for editable blockchain.
https://tinyurl.com/yblq9zdp.

Business Insider Deutschland, 2016.

[4] Downside of bitcoin: A ledger that can’t be corrected. The New York Times, 2016.
https://tinyurl.com/ydxjlf9e.
[5] Child porn on bitcoin? why this doesn’t mean what you might think. Coindesk, 2018.
https://tinyurl.com/y8yo8ml3.
[6] Marcin Andrychowicz and Stefan Dziembowski. PoW-based distributed cryptography with
no trusted setup. In Rosario Gennaro and Matthew J. B. Robshaw, editors, Advances in
Cryptology – CRYPTO 2015, Part II, volume 9216 of Lecture Notes in Computer Science,
pages 379–399. Springer, Heidelberg, August 2015.
[7] Marcin Andrychowicz, Stefan Dziembowski, Daniel Malinowski, and Lukasz Mazurek. Fair
two-party computations via bitcoin deposits. In Rainer Böhme, Michael Brenner, Tyler
Moore, and Matthew Smith, editors, FC 2014 Workshops, volume 8438 of Lecture Notes
in Computer Science, pages 105–121. Springer, Heidelberg, March 2014.
[8] Marcin Andrychowicz, Stefan Dziembowski, Daniel Malinowski, and Lukasz Mazurek.
Modeling bitcoin contracts by timed automata. In International Conference on Formal
Modeling and Analysis of Timed Systems, pages 7–22. Springer, 2014.
[9] Marcin Andrychowicz, Stefan Dziembowski, Daniel Malinowski, and Lukasz Mazurek. Secure multiparty computations on bitcoin. In 2014 IEEE Symposium on Security and Privacy, pages 443–458. IEEE Computer Society Press, May 2014.
[10] Giuseppe Ateniese, Michael T Chiaramonte, David Treat, Bernardo Magri, and Daniele
Venturi. Multiple-link blockchain, October 10 2017. US Patent 9,785,369.
[11] Giuseppe Ateniese, Michael T Chiaramonte, David Treat, Bernardo Magri, and Daniele
Venturi. Rewritable blockchain, May 8 2018. US Patent 9,967,096.
[12] Giuseppe Ateniese, Antonio Faonio, Bernardo Magri, and Breno De Medeiros. Certiﬁed
bitcoins. In International Conference on Applied Cryptography and Network Security, pages
80–96. Springer, 2014.
[13] Giuseppe Ateniese, Bernardo Magri, Daniele Venturi, and Ewerton Andrade. Redactable
blockchain–or–rewriting history in bitcoin and friends. In Security and Privacy (EuroS&P),
2017 IEEE European Symposium on, pages 111–126. IEEE, 2017.
[14] Christian Badertscher, Peter Gaži, Aggelos Kiayias, Alexander Russell, and Vassilis Zikas.
Ouroboros genesis: Composable proof-of-stake blockchains with dynamic availability. In
Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications
Security, CCS ’18, pages 913–930.

20

[15] Iddo Bentov and Ranjit Kumaresan. How to use bitcoin to design fair protocols. In Juan A.
Garay and Rosario Gennaro, editors, Advances in Cryptology – CRYPTO 2014, Part II,
volume 8617 of Lecture Notes in Computer Science, pages 421–439. Springer, Heidelberg,
August 2014.
[16] Lorenz Breidenbach, IC Cornell Tech, Philip Daian, Florian Tramer, and Ari Juels. Enter
the hydra: Towards principled bug bounties and exploit-resistant smart contracts. In 27th
USENIX Security Symposium (USENIX Security 18). USENIX Association, 2018.
[17] JD Bruce. The mini-blockchain scheme. White paper, 2014.
[18] Jan Camenisch, David Derler, Stephan Krenn, Henrich C Pöhls, Kai Samelin, and Daniel
Slamanig. Chameleon-hashes with ephemeral trapdoors. In IACR International Workshop
on Public Key Cryptography, pages 152–182. Springer, 2017.
[19] Alexander Chepurnoy, Mario Larangeira, and Alexander Ojiganov. Rollerchain, a
blockchain with safely pruneable full blocks. arXiv preprint arXiv:1603.07926, 2016.
[20] Ittay Eyal and Emin Gün Sirer. Majority is not enough: Bitcoin mining is vulnerable.
In Nicolas Christin and Reihaneh Safavi-Naini, editors, FC 2014: 18th International Conference on Financial Cryptography and Data Security, volume 8437 of Lecture Notes in
Computer Science, pages 436–454. Springer, Heidelberg, March 2014.
[21] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol:
Analysis and applications. In Elisabeth Oswald and Marc Fischlin, editors, Advances in
Cryptology – EUROCRYPT 2015, Part II, volume 9057 of Lecture Notes in Computer
Science, pages 281–310. Springer, Heidelberg, April 2015.
[22] Bela Gipp, Jagrut Kosti, and Corinna Breitinger. Securing video integrity using decentralized trusted timestamping on the bitcoin blockchain. In MCIS, page 51, 2016.
[23] Bela Gipp, Norman Meuschke, and André Gernandt. Decentralized trusted timestamping
using the crypto currency bitcoin. arXiv preprint arXiv:1502.04015, 2015.
[24] Ethan Heilman, Alison Kendler, Aviv Zohar, and Sharon Goldberg. Eclipse attacks on
bitcoin’s peer-to-peer network. In USENIX Security Symposium, pages 129–144, 2015.
[25] Hongxin Hu, Wonkyu Han, Gail-Joon Ahn, and Ziming Zhao. Flowguard: building robust
ﬁrewalls for software-deﬁned networks. In Proceedings of the third workshop on Hot topics
in software defined networking, pages 97–102. ACM, 2014.
[26] Luis-Daniel Ibanez, Kieron O’Hara, and Elena Simperl. On blockchains and the general
data protection regulation. 2018.
[27] Sotiris Ioannidis, Angelos D. Keromytis, Steven M. Bellovin, and Jonathan M. Smith.
Implementing a distributed ﬁrewall. In S. Jajodia and P. Samarati, editors, ACM CCS 00:
7th Conference on Computer and Communications Security, pages 190–199. ACM Press,
November 2000.
[28] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros:
A provably secure proof-of-stake blockchain protocol. In Annual International Cryptology
Conference, pages 357–388. Springer, 2017.

21

[29] Aggelos Kiayias and Qiang Tang. Traitor deterring schemes: Using bitcoin as collateral for
digital content. In Indrajit Ray, Ninghui Li, and Christopher Kruegel:, editors, ACM CCS
15: 22nd Conference on Computer and Communications Security, pages 231–242. ACM
Press, October 2015.
[30] Ahmed E. Kosba, Andrew Miller, Elaine Shi, Zikai Wen, and Charalampos Papamanthou.
Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. In
2016 IEEE Symposium on Security and Privacy, pages 839–858. IEEE Computer Society
Press, May 2016.
[31] Ranjit Kumaresan and Iddo Bentov. How to use bitcoin to incentivize correct computations.
In Gail-Joon Ahn, Moti Yung, and Ninghui Li, editors, ACM CCS 14: 21st Conference on
Computer and Communications Security, pages 30–41. ACM Press, November 2014.
[32] Ranjit Kumaresan, Tal Moran, and Iddo Bentov. How to use bitcoin to play decentralized
poker. In Indrajit Ray, Ninghui Li, and Christopher Kruegel:, editors, ACM CCS 15:
22nd Conference on Computer and Communications Security, pages 195–206. ACM Press,
October 2015.
[33] Roman Matzutt, Martin Henze, Jan Henrik Ziegeldorf, Jens Hiller, and Klaus Wehrle.
Thwarting unwanted blockchain content insertion. In Cloud Engineering (IC2E), 2018
IEEE International Conference on, pages 364–370. IEEE, 2018.
[34] Roman Matzutt, Jens Hiller, Martin Henze, Jan Henrik Ziegeldorf, Dirk Müllmann, Oliver
Hohlfeld, and Klaus Wehrle. A quantitative analysis of the impact of arbitrary blockchain
content on bitcoin. In Proceedings of the 22nd International Conference on Financial
Cryptography and Data Security (FC). Springer, 2018.
[35] Roman Matzutt, Oliver Hohlfeld, Martin Henze, Robin Rawiel, Jan Henrik Ziegeldorf,
and Klaus Wehrle. Poster: I don’t want that content! on the risks of exploiting bitcoin’s
blockchain as a content store. In Proceedings of the 2016 ACM SIGSAC conference on
computer and communications security, pages 1769–1771. ACM, 2016.
[36] Emily McReynolds, Adam Lerner, Will Scott, Franziska Roesner, and Tadayoshi Kohno.
Cryptographic currencies from a tech-policy perspective: Policy issues and technical directions. In International Conference on Financial Cryptography and Data Security, pages
94–111. Springer, 2015.
[37] Albert Molina and Herman Schoenfeld. Pascalcoin version 2. White paper, 2017.
[38] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.
[39] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. In Advances in Cryptology - EUROCRYPT 2017 - 36th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Paris,
France, April 30 - May 4, 2017, Proceedings, Part II, pages 643–673, 2017.
[40] Rafael Pass and Abhi Shelat. Micropayments for decentralized currencies. In Indrajit
Ray, Ninghui Li, and Christopher Kruegel:, editors, ACM CCS 15: 22nd Conference on
Computer and Communications Security, pages 207–218. ACM Press, October 2015.
[41] Rafael Pass and Elaine Shi. Fruitchains: A fair blockchain. In Proceedings of the ACM
Symposium on Principles of Distributed Computing, pages 315–324. ACM, 2017.
22

[42] Ivan Puddu, Alexandra Dmitrienko, and Srdjan Capkun. µchain: How to forget without
hard forks. IACR Cryptology ePrint Archive, 2017:106, 2017.
[43] Martin Roesch et al. Snort: Lightweight intrusion detection for networks. In Lisa, volume 99, pages 229–238, 1999.
[44] Ken Shirriﬀ. Hidden surprises in the bitcoin blockchain and how they are stored: Nelson
mandela, wikileaks, photos, and python software. Ken Shirriff ’s blog (accessed July 2017)
http://www. righto. com/2014/02/ascii-bernanke-wikileaks-photographs. html, 2014.
[45] Matthew D Sleiman, Adrian P Lauf, and Roman Yampolskiy. Bitcoin message: Data insertion on a proof-of-work cryptocurrency system. In Cyberworlds (CW), 2015 International
Conference on, pages 332–336. IEEE, 2015.
[46] Giannis Tziakouris. Cryptocurrencies—a forensic challenge or opportunity for law enforcement? an interpol perspective. IEEE Security & Privacy, 16(4):92–94, 2018.

A

Protocol extension for multiple redactions

In this section we sketch an extension to the protocol of Fig. 2 to accommodate multiple redactions per block.
The intuition behind the extension is simple enough to be explained in this paragraph; a
block can potentially be redacted n times and each redaction Bj⋆ of the block Bj that is approved
must contain information about the entire history of previous redactions. In our extension, this
information is stored in the yj⋆ component of the candidate block Bj⋆ . We now sketch the
required protocol changes.
Proposing an Edit.
To propose a redaction for block Bj := hsj , xj , ctr j , yj i the user
must build a candidate block Bj⋆ of the following form: Bj⋆ := hsj , x⋆j , ctr j , yj⋆ i, where yj⋆ :=
yj ||G(sj , xj ) iﬀ yj 6= G(sj , xj ). Note that for the ﬁrst redaction of Bj , we have that yj =
G(sj , xj ), and therefore yj⋆ := G(sj , xj ).
Block Validation. To validate a block, the users run the validateBlockExt algorithm described
in Algorithm 5. Intuitively, the algorithm performs the same operations as Algorithm 2, except
that it takes into account the possibility of the block being redacted multiple times. Observe
that by parsing y as y (1) ||y (2) ||...||y (l) , we are considering a block that has been redacted a total
of l times and y (1) denotes the original state information of the unredacted version of the block.
Algorithm 5: validateBlockExt
input : Block B := hs, x, ctr , yi.
output: {0, 1}
1:
2:
3:
4:
5:

Validate data x, if invalid return 0;
(i)
Parse y as y (1) ||y (2) ||...||y (l) , where yj ∈ {0, 1}κ ∀i ∈ [l];
if (H(ctr , G(s, x), y) < D) ∨ (H(ctr , y (1) , y (1) ) < D)
then return 1;
else return 0;

Voting for Candidate Blocks. To vote for a redaction, we additionally deﬁne the following
interface.
• H(ctr , G(s, x⋆ ), y ⋆ ) ← Γ′ .Vt(B ⋆ ): takes as input a candidate block B ⋆ and parses B ⋆ as
(s, x⋆ , ctr , y ⋆ ). It outputs the hash value H(ctr , G(s, x⋆ ), y ⋆ ) as a vote for the candidate
block B ⋆ .
23

Algorithm 6: validateCandExt
input : Chain C = (B1 , · · · , Bn ) of length n, and a candidate block Bj⋆ for an edit.
output: {0, 1}
1:
2:
3:
4:
5:
6:
7:
8:
9:

10:

Parse Bj⋆ := hsj , x⋆j , ctr j , yj i;
(1)
(2)
(l)
(i)
Parse yj as yj ||yj ||...||yj , where yj ∈ {0, 1}κ ∀i ∈ [l];
′
⋆
if Γ .validateBlockExt(Bj ) = 0 then return 0;
Parse Bj−1 := hsj−1 , xj−1 , ctr j−1 , yj−1 i;
(1)

(2)

(l′ )

(i)

Parse yj−1 as yj−1 ||yj−1 ||...||yj−1 , where yj−1 ∈ {0, 1}κ ∀i ∈ [l′ ];
Parse Bj+1 := hsj+1 , xj+1 , ctr j+1 , yj+1 i;
(1)
(1)
(1)
(1)
if sj 6= H(ctr j−1 , yj−1 , yj−1 ) ∨ sj+1 6= H(ctr j , yj , yj ) then return 0;
for i ∈ {2, . . . , n} do
(i)
(1)
(i−1)
if the fraction of votes for H(ctr , yj , yj || . . . ||yj
) in the chain C is not at least ρ within its
voting period of ℓ blocks then return 0;
return 1

Algorithm 7: validateChainExt
input : Chain C = (B1 , · · · , Bn ) of length n.
output: {0, 1}
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:

11:
12:

j := n;
if j = 1 then return Γ′ .validateBlockExt(B1 );
while j ≥ 2 do
Bj := hsj , xj , ctr j , yj i ;
Bj−1: := hsj−1 , xj−1 , ctr j−1 , yj−1 i;
(1)
(l)
(i)
Parse yj as yj || . . . ||yj , where yj ∈ {0, 1}κ ∀i ∈ [l];
(1)

(l′ )

(i)

⊲ Bj := Head(C) when j = n

Parse yj−1 as yj−1 || . . . ||yj−1 , where yj−1 ∈ {0, 1}κ ∀i ∈ [l′ ];
if Γ′ .validateBlockExt(Bj ) = 0 then return 0;
if sj = H(ctr j−1 , G(sj−1 , xj−1 ), yj−1 ) then j := j − 1;
(1)
(1)
else if sj = H(ctr j−1 , yj−1 , yj−1 ) ∧ Γ′ .validateCandExt(C, Bj−1 ) = 1 ∧ P(C, Bj−1 ) = accept then
j := j − 1;
else return 0;
return 1;

24

The voting interface is invoked by users that wish to endorse a candidate block by including
a vote in the newly mined block (if the candidate block is still in its voting phase). Accordingly
the policy P of the chain for redactions checks if a candidate block has received at least a ratio
of ρ votes (as output by the Γ′ .Vt) in a span of ℓ blocks after immediately its proposal.
Candidate Block Validation. If a block Bj is being redacted more than once, then the corresponding candidate block Bj⋆ needs to be validated for accounting for the multiple redactions
that happened before; for each redaction of Bj , the votes for that redaction must exist in the
chain C. validateCandExt (described in Algorithm 6) validates such a candidate block.
Chain Validation. To validate a chain, the user runs the validateChainExt algorithm (described in Algorithm 7). The only change compared to Algorithm 1 is that now yj is parsed as
(1)
(l)
yj || . . . ||yj where the initial unredacted state of the block is stored in y (1) .

25

