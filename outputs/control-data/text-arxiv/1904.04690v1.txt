Article

Guidelines for Experimental Algorithmics in
Network Analysis
Eugenio Angriman1,‡ , Alexander van der Grinten1,‡ , Moritz von Looz1,‡ , Henning
Meyerhenke1,‡,∗ , Martin Nöllenburg2,‡ , Maria Predari1,‡ and Charilaos Tzovas1,‡

arXiv:1904.04690v1 [cs.SI] 25 Mar 2019

1

2

*
‡

Department of Computer Science, Humboldt-Universität zu Berlin, Germany; {angrimae, avdgrinten,
loozmori, meyerhenke, predarim, charilat}@hu-berlin.de
Institute of Logic and Computation, Vienna University of Technology, Austria; noellenburg@ac.tuwien.ac.at
Correspondence: meyerhenke@hu-berlin.de
These authors contributed equally to this work.

Version April 10, 2019 submitted to Algorithms

Abstract: The field of network science is a highly interdisciplinary area; for the empirical analysis of
network data, it draws algorithmic methodologies from several research fields. Hence, research procedures
and descriptions of the technical results often differ, sometimes widely.
In this paper we focus on methodologies for the experimental part of algorithm engineering for network
analysis – an important ingredient for a research area with empirical focus. More precisely, we unify
and adapt existing recommendations from different fields and propose universal guidelines – including
statistical analyses – for the systematic evaluation of network analysis algorithms. This way, the behavior
of newly proposed algorithms can be properly assessed and comparisons to existing solutions become
meaningful. Moreover, as the main technical contribution, we provide SimexPal, a highly automated tool
to perform and analyze experiments following our guidelines. To illustrate the merits of SimexPal and our
guidelines, we apply them in a case study: we design, perform, visualize and evaluate experiments of a
recent algorithm for approximating betweenness centrality, an important problem in network analysis.
In summary, both our guidelines and SimexPal shall modernize and complement previous efforts in
experimental algorithmics; they are not only useful for network analysis, but also in related contexts.
Keywords: Experimental algorithmics, network analysis, applied graph algorithms, statistical analysis
of algorithms

1. Introduction
The traditional algorithm development process in theoretical computer science typically involves (i)
algorithm design based on abstract and simplified models and (ii) analyzing the algorithm’s behavior
within these models using analytical techniques. This usually leads to asymptotic results, mostly regarding
the worst-case performance of the algorithm. (While average-case [1] and smoothed analysis [2] exist
and gained some popularity, worst-case bounds still make up the vast majority of running time results.)
Such worst-case results are, however, not necessarily representative for algorithmic behavior in real-world
situations, both for N P-complete problems [3,4] and poly-time ones [5,6]. In case of such a discrepancy,
deciding upon the best-fitted algorithm solely based on worst-case bounds is ill-advised.
Algorithm engineering has been established to overcome such pitfalls [7–9]. In essence, algorithm
engineering is a cyclic process that consists of five iterative phases: (i) modeling the problem (which

Submitted to Algorithms, pages 1 – 38

www.mdpi.com/journal/algorithms

Version April 10, 2019 submitted to Algorithms

2 of 38

usually stems from real-world applications), (ii) designing an algorithm, (iii) analyzing it theoretically, (iv)
implementing it, and (v) evaluating it via systematic experiments (also known as experimental algorithmics).
Note that not all phases have to be reiterated necessarily in every cycle [10]. This cyclic approach aims at
a symbiosis: the experimental results shall yield insights that lead to further theoretical improvements and
vice versa. Ideally, algorithm engineering results in algorithms that are asymptotically optimal and have
excellent behavior in practice at the same time. Numerous examples where surprisingly large improvements
could be made through algorithm engineering exist, e. g., routing in road networks [11] and mathematical
programming [12].
In this paper, we investigate and provide guidance on the experimental algorithmics part of algorithm
engineering – from a network analysis viewpoint. It seems instructive to view network analysis, a subfield
of network science, from two perspectives: on the one hand, it is a collection of methods that study the
structural and algorithmic aspects of networks (and how these aspects affect the underlying application).
The research focus here is on efficient algorithmic methods. On the other hand, network analysis can be the
process of interpreting network data using the above methods. We briefly touch upon the latter; yet, this
paper’s focus is on experimental evaluation methodology, in particular regarding the underlying (graph)
algorithms developed as part of the network analysis toolbox.1
In this view, network analysis constitutes a subarea of empirical graph algorithmics and statistical
analysis (with the curtailment that networks constitute a particular data type) [13]. This implies that, like
general statistics, network science is not tied to any particular application area. Indeed, since networks are
abstract models of various real-world phenomena, network science draws applications from very diverse
scientific fields such as social science, physics, biology and computer science [14]. It is interdisciplinary
and all fields at the interface have their own expertise and methodology. The description of algorithms
and their theoretical and experimental analysis often differ, sometimes widely – depending on the target
community. We believe that uniform guidelines would help with respect to comparability and systematic
presentation. That is why we consider our work (although it has limited algorithmic novelty) important for
the field of network analysis (as well as network science and empirical algorithmics in general). After all,
emerging scientific fields should develop their own best practices.
To stay focused, we concentrate on providing guidelines for the experimental algorithmics part of the
algorithm engineering cycle – with emphasis on graph algorithms for network analysis. To this end, we
combine existing recommendations from fields such as statistical analysis and data mining / machine learning
and adjust them to fit the idiosyncrasies of networks. Furthermore, and as main technical contribution, we
provide SimexPal, a highly automated tool to perform and analyze experiments following our guidelines. For
illustration purposes, we use this tool in a case study – the experimental evaluation of a recent algorithm
for approximating betweenness centrality, a well-known network analysis task. The target audience we
envision consists of network analysts who develop algorithms and evaluate them empirically. Experienced
undergraduates and young PhD students will probably benefit most, but even experienced researchers in
the community may benefit substantially from SimexPal.

1

We use the terms network and graph interchangeably.

Version April 10, 2019 submitted to Algorithms

3 of 38

2. Common Pitfalls (and How to Avoid Them)
2.1. Common Pitfalls
Let us first of all consider a few pitfalls to avoid.2 We leave problems in modeling the underlying
real-world problem aside and focus on the evaluation of the algorithmic method for the problem at hand.
Instead, we discuss a few examples from two main categories of pitfalls: (i) inadequate justification of
claims on the paper’s results and (ii) repeatability/replicability/reproducibility3 issues.
Clearly, a paper’s claims regarding the algorithm’s empirical behavior need an adequate justification
by the experimental results and/or their presentation. Issues in this regard may happen for a variety of
reasons; not uncommon is a lack of instances in terms of their number, variety and/or size. An inadequate
literature search may lead to not comparing against the current state of the art or if doing so, choosing
unsuitable parameters. Also noteworthy is an inappropriate usage of statistics. For example, arithmetic
averages over a large set of instances might be skewed towards the more difficult instances. Reporting only
averages would not be sufficient then. Similarly, if the difference between two algorithms is small, it is
hard to decide whether one of the algorithms truly performs better than the other one or if the perceived
difference is only due to noise. Even if no outright mistakes are made, potential significance can be wasted:
Coffin and Saltzmann [15] discuss papers whose claims could have been strengthened by an appropriate
statistical analysis, even without gathering new experimental data.
Reproducibility (the algorithm is implemented and evaluated independently by a different team) is a
major cornerstone of science and should receive sufficient attention. Weaker notions include replicability
(different team, same source code and experimental setup) and repeatability (same team, same source code
and experimental setup). An important weakness of a paper would thus be if the description does not allow
the (independent) reproduction of the results. First of all, this means that the proposed algorithm needs
to be explained adequately. If the source code is not public, it is all the more important to explain all
important implementation aspects – the reader may judge whether this is the current community standard.
Pseudocode allows to reason about correctness and asymptotic time and space complexity and is thus very
important. But the empirical running time of a reimplementation may deviate from the expectation when
the paper omitted crucial implementation details.
Even the repetition of one’s own results (which is mandated by major funding organizations for time
spans such as 10 years) can become cumbersome if not considered from the beginning. To make this task
easier, not only source code needs to documented properly, but also input and output data of experiments
as well as the scripts containing the parameters. Probably every reader has heard about this one project
where this documentation part has been neglected to some extent...
2.2. Outline of the Paper
How do we avoid such pitfalls? We make this clear by means of a use case featuring betweenness
approximation; it is detailed in Section 3. A good start when designing experiments is to formulate a
hypothesis (or several ones) on the algorithm’s behavior (see Section 4.1). This approach is not only
part of the scientific method; it also helps in structuring the experimental design and evaluation, thereby
decreasing the likelihood of some pitfalls. Section 4.2 deals with how to select and describe input instances

2
3

Such pitfalls are probably more often on a reviewer’s desk than one might think. Note that we do not claim that we never
stumbled into such pitfalls ourselves, nor that we always followed our guidelines in the past.
The terms will be explained below; for more detailed context please visit ACM’s webpage on artifact review and badging:
https://www.acm.org/publications/policies/artifact-review-badging.

Version April 10, 2019 submitted to Algorithms

4 of 38

to support a certain generality of the algorithmic result. With a similar motivation, Section 4.3 provides
guidance on how many instances should be selected. It also discusses how to deal with variance in case of
non-determinism, e. g., by stating how often experiments should be repeated.
If the algorithm contains a reasonable amount of tunable parameters, a division of the instances into a
tuning set and an evaluation set may be advisable, which is discussed in Section 4.4.
In order to compare against the best competitors, one must have defined which algorithms and/or
software tools constitute the state of the art. Important aspects of this procedure are discussed in Section 4.5.
One aspect can be the approximation quality: while an algorithm may have the better quality guarantee in
theory, its empirical solution quality may be worse – which justifies to consider not only the theoretical
reference in experiments. The claim of superiority refers to certain measures – typically related to resources
such as running time or memory and/or related to solution quality. Several common measures of this kind
and how to deal with them are explained in Section 4.6. Some of them are hardware-independent, many of
them are not.
A good experimental design can take you far – but it is not sufficient if the experimental pipeline is
not efficient or lacks clarity. In the first case, obtaining the results may be tedious and time-consuming. Or
the experiments simply consume more computing resources than necessary and take too long to generate
the results. In the second case, in turn, the way experimental data are generated or stored may not
allow easy reproducibility. Guidelines on how to setup your experimental pipeline and how to avoid these
pitfalls are thus presented in Section 5. The respective subsections deal with implementation issues (5.1),
repeatability/replicability/reproducibility (5.2), job submission (5.3), output file structure for long-term
storage (5.4), retrieval and aggregation of results (5.5).
As mentioned, betweenness approximation and more precisely the KADABRA [16] algorithm will serve
as our prime example. We have implemented this algorithm as part of the NetworKit toolbox [17]. As part
of our experimental evaluation, a meaningful visualization (Section 6) of the results highlights many major
outcomes to the human reader. Since visualization is typically not enough to show statistical significance
in a rigorous manner, an appropriate statistical analysis (Section 7) is recommended. Both, visualization
and statistical analysis, shall lead to a justified interpretation of the results.
3. Use Case
Typically, algorithmic network analysis papers (i) contribute a new (graph) algorithm for an already
known problem that improves on the state of the art in some respect or (ii) they define a new algorithmic
problem and present a method for its solution. To consider a concrete example contribution, we turn
towards betweenness centrality, a widely used and very popular measure for ranking nodes (or edges) in
terms of their structural position in the graph [18].
3.1. Betweenness Approximation as Concrete Example
Betweenness centrality [19] measures the participation of nodes in shortest paths. More precisely, let
G = (V , E ) be a graph; the (normalized) betweenness centrality of a node v ∈ V is defined as
b (v ) : =

1
n(n − 1)

X
s,t∈V ,s6=v6=t

σst (v )
,
σst

(1)

where σst is the number of shortest paths from s to t, and σst (v ) is the number of shortest paths from
s to t that cross v (as intermediate node). Computing the exact betweenness scores for all nodes of an
unweighted graph can be done in O (nm) time with Brandes’s algorithm [20], where n is the number of
nodes and m the number of edges in G. Since this complexity is usually too high for graphs with millions

Version April 10, 2019 submitted to Algorithms

5 of 38

Algorithm 1 KADABRA algorithm (absolute error variant)
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:

procedure KADABRA(G = (V , E ), , δ)
ω ← non-adaptive number of iterations
compute δL , δU from δ
. Requires upper bound of the diameter.
τ ←0
. Number of sampled paths.
for all v ∈ V do
xe(v ) ← 0
. Occurrences of v in sampled paths.
end for
while τ < ω do
if f ( xe(v )/τ , δL (v ), ω, τ ) <  and g ( xe(v )/τ , δU (v ), ω, τ ) <  then
break
. Approximation is already good enough.
end if
for i ∈ {1, . . . , c} do
. Draw c samples per round.
s, t ← samplePair(G)
. Uniformly at random.
π ← sampleShortestPath(G, s, t)
. Uniformly at random.
for all v ∈ π do
xe(v ) ← xe(v ) + 1
end for
τ ← τ +1
end for
end while
return xe/τ
. Betweenness centrality is estimated as: e
b = xe/τ .
end procedure

of nodes and edges, several approximation algorithms have been devised [16,21–24]. These algorithms trade
solution quality for speed and can be much faster.
For illustration purposes, we put ourselves now in the shoes of the authors of the most recent of the
cited algorithms, which is called KADABRA [16]: we describe (some of) the necessary steps in the process
of writing an algorithm engineering paper on KADABRA4 – with a focus on the design and evaluation of
the experiments.
3.2. Overview of the KADABRA Algorithm
The KADABRA algorithm approximates the betweenness centrality of (un)directed graphs within a
given absolute error of at most  with probability (1 − δ ) [16]. The main rationale of the algorithm is to
iteratively select two nodes s, t uniformly at random and then sample a shortest path π from s to t (again
uniformly at random). This leads to a sequence of randomly selected shortest paths π1 , π2 , . . . , πτ . The
betweenness centrality of each node v ∈ V is then estimated as:
τ
1X
e
b (v ) =
xei (v ),
τ

(2)

i=1

where xei is 1 iff v occurs in πi and 0 otherwise.
Compared to earlier approximation algorithms that employ similar sampling techniques (e. g., [23]),
the novelty of KADABRA relies on the clever stopping condition, used to determine the number of rounds τ .

4

We select KADABRA not because the authors of the original paper did a bad job in their presentation – au contraire. Our
main reasons are (i) the high likelihood that the betweenness problem is already known to the reader due to its popularity
in the field and (ii) the fact that approximation algorithms display important aspects of experimental algorithmics quite
clearly.

Version April 10, 2019 submitted to Algorithms

6 of 38

Clearly, there is a number ω, depending on the input size but not the graph itself, such that if τ ≥ ω, the
algorithm achieves the desired solution quality with probability (1 − δ ).5 KADABRA, however, avoids to run
a fixed number of ω rounds by using adaptive sampling. At each round of the algorithm, it is guaranteed
that




Pr b(v ) ≤ e
b(v ) − f ≤ δL (v ) and Pr b(v ) ≥ e
b ( v ) + g ≤ δU ( v ) ,
(3)
where f = f (e
b(v ), δL (v ), ω, τ ) and g = g (e
b(v ), δU (v ), ω, τ ) are (rather lengthy) expressions depending on
e
b(v ), per-vertex probabilities δL (v ) and δU (v ), the current number of rounds τ and the static round count
P
ω. δL (v ) and δU (v ) are chosen such that v∈V δL (v ) + δU (v ) ≤ 2δ . Once f , g <  during some round, the
algorithm terminates.6 Algorithm 1 displays the corresponding pseudocode with some expository comments.
Besides adaptive sampling, KADABRA relies on a balanced bidirectional BFS to sample shortest paths. For
details we refer the interested reader to the original paper.
4. Guidelines for the Experimental Design
Now, we want to set up experiments that give decisive and convincing empirical evidence whether
KADABRA is better than the state of the art. This section discusses the most common individual steps of
this process.
4.1. Determining Your Hypotheses
Experiments are mainly used for two reasons; as an exploratory tool to reveal unknown properties
and/or as a means to answer specific questions regarding the proposed algorithm. The latter suggests the
development of certain hypotheses on the behavior of our algorithm that can be confirmed or contradicted
by experiments. In the following, we group common hypotheses of algorithm engineering papers in network
analysis into two categories:
1. Hypotheses on how our algorithm performs compared to the state of the art in one of the following
metrics: running time, solution quality or (less often) memory usage. Ideally, an algorithm is deemed
successful when it outperforms existing algorithms in terms of all three metrics. However, in practice,
we are content with algorithms that exhibit a good tradeoff between two metrics, often running time
performance and solution quality. As an example, in real-time applications, we may be willing to
sacrifice the solution quality (until a certain threshold), in order to meet running time bounds crucial
for the application.
2. Hypotheses on how the input instances or a problem-/algorithm-specific parameter affects our
algorithm in terms of the aforementioned metrics. For example, a new algorithm might only
outperform the existing algorithms on a certain type of graphs or an approximation algorithm might
only be fast(er) if the desired approximation quality is within a certain range. If a hypothesis involves
such restrictions, it should still be general enough for the algorithmic result to be relevant – overtuning
of algorithms to uninteresting classes of inputs should be avoided. Other aspects of investigation
may be decoupled from the state of the art to some extent and explore the connection between
instance and algorithm properties: for instance, a hypothesis on how the empirical approximation
error behaves over a range of input sizes.

5
6

For example, if ω is chosen so that almost all vertex pairs are sampled. In reality, ω can be chosen to be much smaller
than that.
Note also that for each round, the algorithm draws a number of samples and performs occurrence updates without checking
the stopping condition. This number is determined by parameter c. In the original implementation of KADABRA (but not
reported in the paper), c is fixed to 10 (without further explanation).

Version April 10, 2019 submitted to Algorithms

7 of 38

KADABRA Example
In the context of our betweenness approximation study, we formulate three basic hypotheses:
1. KADABRA has a better running time and scalability (with respect to the graph size) than other
algorithms, specifically the main competitor RK [23].
2. There is a significant difference between the solution quality of KADABRA and that of RK. (In
Section 4.6, we explain how to evaluate the solution quality for approximation algorithms in more
detail.)
3. The diameter of input graphs has an effect on the running time of KADABRA: The KADABRA
algorithm computes the betweenness values faster for graphs with low diameter than for graphs with
large diameter.
The first two hypotheses belong to the first category, since we compare our implementation of the
KADABRA algorithm to a number of related algorithms. The other hypothesis belongs to the second category
and is related to the performance of the KADABRA algorithm itself. Namely, we test how a data-specific
parameter may influence the running time in practice. To evaluate these hypotheses experimentally, we
need to select instances with both low and high diameter values, of course.
4.2. Gathering Instances
Selecting appropriate data sets for an experimental evaluation is a crucial design step. For sake of
comparability, a general rule is to gather data sets from public sources; for network analysis purposes,
well-known repositories are KONECT [25], SNAP [26], DIMACS10 [27], SuiteSparse [28], LWA [29] and
Network Repository [30].
An appropriate data collection contains the type(s) of networks which the algorithm is designed for,
and, for every type, a large enough number of instances to support our conclusions [7]. For instance, the
data collection of an influence maximization algorithm should include social networks rather than street
networks; a data collection to evaluate distributed algorithms should include instances that exceed the
memory of a typical shared-memory machine.
The selection of an appropriate subset of instances for our experimental analysis is simpler if we first
categorize the available networks in different classes. There exist several ways to do this: first, we can
simply distinguish real-world and synthetic (= (randomly) generated) networks. Even though network
analysis algorithms generally target real-world networks, one should also use synthetic networks, e. g., to
study the asymptotic scalability of an algorithm, since we can easily generate similar synthetic networks of
different scales.
Classification of real-world networks generally follows the phenomena they are modeling. Common
examples are social networks, hyperlink networks or citation networks, which also fall under the umbrella of
complex networks.7 Examples of real-world non-complex networks are certain infrastructure networks such
as road networks. If our algorithm targets real-world data, we want to carefully build a diverse collection
of instances that is representative of the graph classes we are targeting.
Another interesting classification is one based on specific topological features of the input data such as
the diameter, the clustering coefficient, the triangle count, etc. Classifying based on a certain property
and reporting it should definitely be done when the property in question is relevant to the algorithm and

7

As the name suggests, complex networks have highly non-trivial (complex) topological features. Most notably, such
features include a small diameter (small-world effect) and a skewed degree distribution (many vertices with low degree
and a few vertices with high degree).

Version April 10, 2019 submitted to Algorithms

8 of 38

Table 1. Graphs (taken from KONECT) for our evaluation of the betweenness approximation algorithms.
Network name
moreno_blogs
petster-hamster
ego-facebook
openflights
opsahl-powergrid
p2p-Gnutella08
advogato
wiki-Vote
p2p-Gnutella05
p2p-Gnutella04
foldoc
twin
cfinder-google
ca-AstroPh
ca-cit-HepTh
subelj_cora
ego-twitter
ego-gplus
p2p-Gnutella24
ca-cit-HepPh
cit-HepPh
facebook-wosn-wall
edit-frwikibooks
dblp-cite
loc-brightkite_edges
edit-frwikinews
dimacs9-BAY
dimacs9-COL
roadNet-PA
roadNet-TX

# of nodes

# of edges

Diameter

Class

1 224
2 426
2 888
3 425
4 941
6 301
6 539
7 115
8 846
10 876
13 356
14 274
15 763
18 771
22 908
23 166
23 370
23 628
26 518
28 093
34 546
46 952
47 905
49 789
58 228
59 546
321 270
435 666
1 088 092
1 379 917

16 715
16 631
2 981
19 256
6 594
20 777
39 285
100 762
31 839
39 994
91 471
20 573
148 585
198 050
2 444 798
89 157
32 831
39 194
65 369
3 148 447
420 877
183 412
139 141
49 759
214 078
157 970
397 415
521 200
1 541 898
1 921 660

8
10
9
13
46
9
9
7
9
10
8
25
7
14
9
20
15
8
11
9
14
18
8
2
18
7
837
1 255
794
1 064

Hyperlink
Social
Social
Infrastructure
Infrastructure
Peer-to-peer
Social
Social
Peer-to-peer
Peer-to-peer
Hyperlink
Intl. Relations
Hyperlink
Coauthorship
Coauthorship
Citation
Social
Social
Peer-to-peer
Citation
Citation
Social
Authorship
Citation
Social
Authorship
Road
Road
Road
Road

may have an impact on its behavior. For instance, reporting the clustering coefficient could help with the
interpretation of results concerning algorithms that perform triangle counting.
A source of instances especially suited for scalability experiments are synthetic graphs generated with
graph generators [31]. An advantage is easier handling especially for large graphs, since no large files need
to be transferred and stored. Also, desired properties can often be specified in advance and in some models,
a ground truth beneficial to test analysis algorithms is available. Important drawbacks include a lack of
realism, especially when choosing an unsuitable generative model.
KADABRA Example
In a real-world scenario, we want to show the improvement of the KADABRA algorithm with respect
to the competition. Clearly, the graph class of highest relevance should be most prominent in our data
collection. With this objective in mind, we show a collection for the KADABRA experiments in Table 1.
Note that in Table 1 we report the diameter of each graph, along with its size and application class. We
include the diameter because it is part of our hypotheses, i. e., the performance of KADABRA depends
on the diameter of the input graph (see Section 4.1). In a different scenario, such as triangle counting or
community detection, a more pertinent choice would be the average local clustering coefficient. Finally, we

Version April 10, 2019 submitted to Algorithms

9 of 38

focus on complex networks, but include a minority of non-complex infrastructure networks. All of these
instances were gathered from one of the aforementioned public repositories.
4.3. Scale of Experiments
Clearly, we cannot test all possible instances, even if they are small [32]. On the other hand, we want
to draw significant conclusions about our new algorithm (and here not about a particular data set). This
means that our experimental results should justify the later conclusions and allow to clearly distinguish
between hypotheses. While Section 4.2 discusses which instances to select, we proceed with the question
“how many?”. Also, if the results are affected by randomness, how many repeated runs should we make for
each?
Too few instances may be insufficient to support a conclusion. Plots then look sparse, hypothesis tests
(Section 7.3.1) are inconclusive and inferred parameters are highly uncertain, which is reflected in unusably
wide confidence and credible intervals (Sections 7.3.2 and 7.4). Choosing too many instances, though,
costs unnecessary time and expense. As a very rough rule of thumb reflecting community custom, we
recommend at least 10-15 instances for an experimental paper. If you want to support specific conclusions
about algorithmic behavior within a subclass of instances, you should have that many instances in that
subclass. Yet, the noisier the measurements and the stronger the differences of output between instances,
the more experiments are needed for a meaningful (statistical)
analysis. More formally, the uncertainty of
q
2

many test statistics and inferred parameters8 scales with sn , where s2 is the sample variance. Generally
speaking, if we want a result that is twice as precise, we need to quadruple the number of measurements.
The same applies for the number of repetitions for each instance. When plotting results affected by
randomness, it is often recommended to average over the results of multiple runs. The expected deviation
2
of such an average from the true mean9 is called the standard error and also scales with √s n [34]. For
plotting purposes, we suggest that this standard error for the value of one plotted point (i. e., the size of
the error bars) should be one order of magnitude smaller than the variance between plotted points. In the
companion notebook, we give an example of code which calculates the number of repetitions required for
a desired smoothness. Frameworks exist that automate the repeated measurements, for example Google
Benchmark.10
In the context of binary hypothesis tests, the statistical power of a test is the probability that it
correctly distinguishes between hypotheses, i. e., rejects a false null hypothesis in the classical approach. A
larger sample size, a stronger effect or less variance in measurements all lead to a more powerful test. For
further reading, see the extensive literature about statistical power [35,36].
All these calculations for the number of necessary experiments require an estimate of the variance of
results – which might be unavailable before conducting the experiments. It might thus be necessary to
start with a small initial set of instances to plan and prepare for the main experiments.11
4.4. Parameter Tuning
Experiments are not only a necessary ingredient to validate our hypothesis, but also a helpful discovery
tool in a previous stage [9]. Some algorithm’s behavior depends on tunable parameters. For example, the

8

9
10
11

Most importantly the t-statistic used in confidence intervals and t-tests. In Bayesian statistics, the marginal posterior
distribution of a parameter with a Gaussian likelihood also follows a t-distribution, at least when using a conjugate
prior [33].
The mean that would result given infinite samples.
https://github.com/google/benchmark.
Also called pilot study, as opposed to the main experiments called workhorse study, see [37] and [38].

Version April 10, 2019 submitted to Algorithms

10 of 38

well-known hybrid implementation of Quicksort switches between Insertionsort and Quicksort depending
on whether the current array size is above or below a tunable threshold M [39]. An example from
network analysis includes a plethora of approximation methods that calculate some centrality measure
using sampling [22,23,40]. In such cases the number of selected samples may highly impact the performance
of the algorithm. Experiments are thus used to determine the adequate number of samples that achieves a
good approximation.
The KADABRA algorithm consists of two phases, in which bounds for a sampling process are first
computed (Line 3 in Algorithm 1 of Section 3.2) and then used (when checking the stopping condition
in line 9). Tighter bounds are more expensive to compute but save time in the later phase; their quality
is thus an important tradeoff. When evaluating a newly developed algorithm, there is the risk (or even
temptation) to tune its parameters for optimal performance in the experiments while using general default
parameters for all competitors. This may often happen with no ill intent – researchers usually know their
own algorithm best. To ensure generalizability of results, we recommend to split the set of instances into a
tuning set and an evaluation set. The tuning set is used to find good tuning parameters for all algorithms,
while the main experiments are performed on the evaluation set. Only results from the evaluation set
should be used to draw and support conclusions. Note that the tuning set can also be used to derive an
initial variance estimate, as discussed in Section 4.3.
How to Create the Tuning Set and the Evaluation Set
The tuning set should be structurally similar to the whole data set, so that parameter tuning yields
good general performance and is representative for the evaluation set.12 Tuning and evaluation sets should
be disjoint. For large data sets, simple random sampling (i. e., simply picking instances from the data set
uniformly at random and without replacement) yields such a representative split in expectation. Stratified
sampling (i. e., partitioning the data set, applying simple random sampling to each partition and merging
the result) [41] guarantees it.
In our example, note that our data set is already partitioned into different classes of networks (hyperlink,
social, infrastructure, etc.), and that those classes are fairly balanced (see Table 2). We can thus select a
certain fraction of instances in each network class as tuning set.
In case of computationally expensive tuning, it is advantageous to keep the tuning set small, for large
data sets it can be much smaller than the evaluation set. In our example, we select a single instance per
network class, as seen in Table 3. Note that these considerations are similar to the creation of training,
test and validation sets in machine learning. While some other sampling methods are equally applicable,
more sophisticated methods like statistical learning theory optimize for different objectives and are thus
not considered here [42–44].
4.5. Determining Your Competition
Competitor algorithms solve the same or a similar problem and are not dominated in the relevant
metrics by other approaches in the literature. Since we focus on the design of the experimental pipeline, we
consider only competitors that are deemed implementable. The best ones among them are considered the
state of the art (SotA), here with respect to the criteria most relevant for our claims about KADABRA.
Other considerations are discussed next.

12

Due to symmetry, this also requires that the tuning set is structurally similar to the evaluation set.

Version April 10, 2019 submitted to Algorithms

11 of 38

Table 2. Network class frequency of the data set in Table 1
Class

Frequency

Social
Citation
Peer-to-peer
Road
Hyperlink
Infrastructure
Coauthorship
Authorship
Intl. Relationship

26.67
13.33
13.33
13.33
10.00
6.67
6.67
6.67
3.33

%
%
%
%
%
%
%
%
%

Table 3. Split of instances into tuning and evaluation set.
Tuning set
Network name
opsahl-powergrid
advogato
foldoc
p2p-Gnutella24
dblp-cite
edit-frwikinews
dimacs9-BAY

Evaluation set

|V |

|E|

4 941
6 539
13 356
26 518
12 591
25 042
321 270

6 594
43 277
91 471
65 369
49 635
68 679
397 415

Network name
moreno_blogs
petster-hamster
ego-facebook
openflights
p2p-Gnutella08
wiki-Vote
p2p-Gnutella05
p2p-Gnutella04
twin
cfinder-google
ca-AstroPh
ca-cit-HepTh
subelj_cora
ego-twitter
ego-gplus
edit-frwikibooks
ca-cit-HepPh
cit-HepPh
loc-brightkite_edges
dimacs9-COL
roadNet-PA
roadNet-TX

|V |

|E|

1 224
2 426
2 888
3 425
6 301
7 115
8 846
10 876
14 274
15 763
18 771
22 908
23 166
23 370
23 628
27 754
28 093
34 546
58 228
435 666
1 088 092
1 379 917

16 718
16 631
19 257
2 981
20 777
100 762
31 839
39 994
20 573
149 456
198 050
2 444 798
89 157
32 831
39 194
67 584
3 148 447
420 921
214 078
521 200
1 541 898
1 921 660

Version April 10, 2019 submitted to Algorithms

12 of 38

Unavailable Source Code
The source code of a competing algorithm may be unavailable and sometimes even the executable
is not shared by its authors. If one can implement the competing algorithm with reasonable effort (to
be weighted against the importance of the competitor), you should do so. If this is not possible, a viable
option is to compare experimental results with published data. For a fair comparison, the experimental
settings should then be replicated as closely as possible. In order to avoid this scenario, we recommend
open-source code; it offers better transparency and replicability (also see 5.2).
Solving a Different Problem
In some cases, the problem our algorithm solves is different from established problems and there is
no previous algorithm solving it. Here, it is often still meaningful to compare against the SotA for the
established problem. For example, if we consider the dynamic case of a static problem for the first time
[45–47] or an approximation version for an exact problem [21,22,48] or provide the first parallel version of
an algorithm [49]. Another example can be an optimization problem with a completely new constraint.
While this may change optimal solutions dramatically compared to a previous formulation, a comparison
to the SotA for the previous formulation may still be the best assessment. If the problem is so novel that
no comparison is meaningful, however, there is no reason for an experimental comparison.13
Comparisons on Different Systems
Competitors may be designed to run on different systems. Recently, many algorithms take advantage
of accelerators, mainly GPUs, and this trend has also affected the algorithmic network analysis community
[50–52]. A direct comparison between CPU and GPU implementations is not necessarily meaningful due to
different architectural characteristics and memory sizes. Yet, such a comparison may be the only choice
if no other GPU implementation exists. In this case, one should compare against a multithreaded CPU
implementation that should be tuned for high performance as well. Indirect comparisons can, and should,
be done using system independent measures (4.6).
KADABRA Example
The most relevant candidates to compare against KADABRA are the SotA algorithms RK [23] and
ABRA [24]. The same algorithms are chosen as competitors in the original KADABRA paper. However, in
our paper we focus only on a single comparison, the one between KADABRA and RK. This is intended in
order to highlight the main purpose of our work – to demonstrate the benefits of a thoughtful experimental
design for meaningful comparisons of network-related algorithms. Reporting the actual results of such
a comparison is of secondary importance. Furthermore, RK and ABRA exhibit similar behavior in the
original KADABRA paper, with RK being overall slightly faster. Again, for the purpose of our paper, this is
an adequate reason to choose RK over ABRA.14
4.6. Metrics
The most common metric for an algorithm’s performance is its wall-clock running time. For solution
quality, the metrics are usually problem-specific; often, the gap between an algorithm’s solution and the

13
14

Nonetheless, experiments can still reveal empirical insights into the behavior of the new algorithm.
Of course, if we were to perform experiments for a new betweenness approximation algorithm, we would include all relevant
solutions in the experiments.

Version April 10, 2019 submitted to Algorithms

13 of 38

optimum is reported as a percentage (if known). In the following, we highlight situations that require more
specific metrics. First, we discuss metrics for evaluating an algorithm’s running time.
4.6.1. Running Time
CPU Time vs. Wall-clock Time
For sequential algorithms, evaluations should prefer CPU time over wall-clock time. Indeed, this is
the running time metric that we use in our KADABRA experiments. Compared to wall-clock time, CPU
time is less influenced by external factors such as OS scheduling or other processes running on the same
machine. The exception to this rule are algorithms that depend on those external factors such as external
memory algorithms (where disregarding the time spent in system-level I/O routines would be unfair). In
the same line of reasoning, evaluations of parallel algorithms would be based on wall-clock time as they
depend on specifics of the OS scheduler.
Architecture-specific Metrics
CPU and wall-clock times heavily depend on the microarchitecture of the CPU the algorithm is executed
on. If comparability with data generated on similar CPUs from other vendors or microarchitectures is desired,
other metrics should be taken into account. Such metrics can be accessed by utilizing the performance
monitoring features of modern CPUs: these allow determining the number of executed instructions, the
number of memory accesses (both are mostly independent of the CPU microarchitecture) or the number of
cache misses (which depends on the cache size and cache strategy, but not necessarily the CPU model). If
one is interested in how efficient algorithms are in exploiting the CPU architecture, the utilization of CPU
components can be measured (example: the time spent on executing ALU instructions compared to the
time that the ALU is stalled while waiting for results of previous instructions or memory fetches). Among
some common open-source tools to access CPU performance counters are the perf profiler, Oprofile (on
linux only) and CodeXL.
System-independent Metrics
It is desirable to compare different algorithms on the same system. However, in reality, this is not
always possible, e. g., because systems required to run competitors are unavailable. For such cases, even if
we do not run into such issues ourselves, we should also consider system-independent metrics. For example,
this can be the speedup of a newly proposed algorithm against some base algorithm that can be tested on all
systems. As an example, for betweenness centrality, some papers re-implement the Brandes [20] algorithm
and compare their performance against it [24,45,53]. As this metric is independent of the hardware, it can
even be used to compare implementations on different systems, e. g., CPU versus GPU implementations.
System-independent metrics also include algorithm-specific metrics, like the number of iterations of an
algorithm or the number of edges visited. Those are particularly useful when similar algorithms are
compared, e. g., if the algorithms are iterative and only differ in their choice of the stopping condition.
Aggregation and Algorithmic Speedup
Running time measurements are generally affected by fluctuations, so that the same experiment is
repeated multiple times. To arrive at one value per instance, one usually computes the arithmetic mean
over the experiments (unless the data are highly skewed). A comparison between the running times
(or other metrics) of two algorithms A and B on different data sets may result in drastically different
values, e. g., because the instances differ in size or complexity. For a concise evaluation, one is here also
interested in aggregate values. In such a case it is recommended to aggregate over ratios of these metrics;

Version April 10, 2019 submitted to Algorithms

14 of 38

regarding running time, this would mean to compute the algorithmic speedup15 of A with respect to B.16
To summarize multiple ratios, one can use the geometric mean [55]:


# ofY
values

GM(speedup) = 



1
# of values

speedup on instance i

i=1
GM(running times of A)

as it has the fundamental property that GM(speedup) = GM(running times of B ) . Which mean is most
appropriate for which aggregation is a matter of some discussion [56–58].
4.6.2. Solution Quality
Next, we discuss metrics for solution quality. Here, the correct measurements are naturally
problem-specific; often, there is no single quality indicator but multiple orthogonal indicators are used.
Empirical vs. Worst-case Solution Quality
As mentioned in the introduction, worst-case guarantees proven in theoretical models are rarely
approached in real-world settings. For example, the accuracy of the ABRA algorithm for betweenness
approximation has been observed to be always below the fixed absolute error, even in experiments where
this was only guaranteed for 90% of all instances [24]. Thus, experimental comparisons should include also
metrics for which theoretical guarantees are known.
Comparing Against (Unknown) Ground Truth
For many problems and instances beyond a certain size, ground truth (in the sense of the exact value of
a centrality score or the true community structure of a network) is neither known nor feasible to compute.
For betweenness centrality, however, AlGhamdi et al. [59] have computed exact scores for large graphs by
investing into considerable supercomputing time. The absence of ground truth or exact values, in turn,
clearly requires the comparison to other algorithms in order to evaluate an algorithm’s solution quality.
5. Guidelines for the Experimental Pipeline
Organizing and running all the required experiments can be a time-consuming activity, especially if
not planned and carried out carefully. That is why we propose techniques and ideas to orchestrate this
procedure efficiently. The experimental pipeline can be divided into four phases. In the first one, we finalize
the algorithm’s implementation as well as the scripts/code for the experiments themselves.17 Next, we
submit the experiments for execution (even if the experiments are to be executed locally, we advise to
use some scheduling/batch system). In the third phase, the experiments run and create the output files.
Finally, we parse the output files to gather the information about the relevant metrics.

15

16
17

The parallel speedup of an algorithm A is instead the speedup of the parallel execution of A against its sequential execution,
more precisely the ratio of the running time of the fastest sequential algorithm and the running time of the parallel
algorithm. It can be used to analyze how efficiently an algorithm has been parallelized.
To achieve a fair comparison of the algorithmic aspects of A and B, the algorithmic speedup is often computed over their
sequential executions [54]. In view of today’s ubiquitous parallelism, this perspective may need to be reconsidered, though.
It is important to use scripts or some external tool in order to automate the experimental pipeline. This also helps to
reduce human errors and simplifies repeatability and replicability.

Version April 10, 2019 submitted to Algorithms

15 of 38

5.1. Implementation Aspects
Techniques for implementing algorithms are beyond the scope for this paper; however, we give an
overview of tooling that should be used for developing algorithmic code.
Source code should always be stored in version control systems (VCS); nowadays, the most commonly
used VCS is Git [60]. For scientific experiments, a VCS should also be used to version scripts that drive
experiments, valuable raw experimental data and evaluation scripts. Storing instance names and algorithm
parameters of experiments in VCS is beneficial, e. g., when multiple iterations of experiments are done due
to the AE cycle.
The usual principles for software testing (e. g., unit tests and assertions) should be applied to ensure
that code behaves as expected. This is particularly important in growing projects where seemingly local
changes can affect other project parts with which the developer is not very familiar. It is often advantageous
to open-source code.18 The Open Source Initiative keeps a list19 of approved open source licenses. An
important difference is whether they require users to publish derived products under the same license. If
code is open-sourced, we suggest well-known platforms like Github [61], Gitlab [62], or Bitbucket [63] to
host it. An alternative is to use a VCS server within one’s own organization, which reduces the dependence
on commercial interests. In an academic context, a better accessibility can have the benefit of a higher
scientific impact of the algorithms. For long-term archival storage, in turn, institutional repositories may
be necessary.
Naturally, code should be well-structured and documented to encourage further scientific participation.
Code documentation highly benefits from documentation generator tools such as Doxygen.20 Profiling is
usually used to find bottlenecks and optimize implementations, e. g., using tools such as the perf profiler
on Linux, Valgrind [64] or a commercial profiler such as VTune [65].
5.2. Repeatability, Replicability and Reproducibility
Terminology differs between venues; the Association of Computing Machinery defines repeatability as
obtaining the same results when the same team repeats the experiments, replicability for a different team
but the same programs and reproducibility for the case of a reimplementation by a different team. Our
recommendations are mostly concerned with replicability.
In a perfect world scenario, the behavior of experiments is completely determined by their code version,
command line arguments and configuration files. From that point of view, the ideal case for replicability,
which is increasingly demanded by conferences and journals21 in experimental algorithms, looks like this:
A single executable program automatically downloads or generates the input files, compiles the programs,
runs the experiments and recreates the plots and figures shown in the paper from the results.
Unfortunately, in reality some programs are non-deterministic and give different outputs for the
same settings. If randomization is used, this problem is usually avoided by fixing an initial seed of a
pseudo-random number generator. This seed is just another argument to the program and can be handled
like all others. However, parallel programs might still cause genuine non-determinism in the output, e. g., if
the computation depends on the order in which a large search space is explored [66,67] or on the order

18
19
20
21

We acknowledge that open-sourcing code is not always possible, e. g., due to intellectual property or political reasons.
https://opensource.org/licenses/alphabetical.
http://www.doxygen.nl.
For example, see the Replicated Computational Results Initiative of the Journal on Experimental Algorithms, http:
//jea.acm.org.

Version April 10, 2019 submitted to Algorithms

16 of 38

instances:
konect:
- ’advogato’
- ’ego-twitter’
- ’ego-facebook’
- ’ego-gplus’
# ... (more instances follow)
configurations:
- name: kadabra-1t
args: [’./run’, ’--threads=1’, ’kadabra’, ’@INSTANCE@’]
output: stdout
- name: kadabra-2t
args: [’./run’, ’--threads=2’, ’kadabra’, ’@INSTANCE@’]
output: stdout
# ... (more configurations follow)
- name: rk
args: [’./run’, ’rk’, ’@INSTANCE@’]
output: stdout

Figure 1. SimexPal configuration (experiments.yml) for KADABRA

in which messages from other processors arrive.22 If these effects are of a magnitude that they affect the
final result, these experiments need to be repeated sufficiently often to cover the distribution of outputs.
A replication would then aim at showing that its achieved results are, while not identical, equivalent in
practice. For a formal way to show such practical equivalence, see Section 7.4.1.
Implementations often depend on libraries or certain compiler versions. This might lead to complications
in later replications when dependencies are no longer available or incompatible with modern systems.
Providing a virtual machine image or container addresses this problem.
5.3. Running Experiments
Running experiments means to take care of many details: Instances need to be generated or downloaded,
jobs need to be submitted to batch systems23 or executed locally, running jobs need to be monitored,
crashes need to be detected, crashing jobs need to be restarted without restarting all experiments, etc.
To avoid human errors, improve reproducibilty and accelerate those tasks, scripts and tooling should be
employed.
To help with these recurring tasks, we provide as a supplement to this paper SimexPal, a command-line
tool to automate the aforementioned tasks (among others).24 This tool allows the user to manage instances
and experiments, launch jobs and monitor the status of those jobs. While our tool is not the only possible
way to automate these tasks, we do hope that it improves over the state of writing custom scripts for
each individual experiment. SimexPal is configured using a simple YAML [69] file and only requires a
minimal amount of user-supplied code. To illustrate this concept, we give an example configuration in
Figure 1. Here, run is the only piece of user-supplied code that needs to be written. run executes the
algorithm and prints the output (e.g. running times) to stdout. Given such a configuration file, the graph
instances can be downloaded using simex instances download. After that is done, jobs can be started
using the command simex experiments launch. SimexPal takes care of not launching experiments twice
and never overwrites existing output files. simex experiments list monitors the progress of all jobs. If

22
23

24

As an example, some associative calculations are not associative when implemented with floating point numbers [68]. In
such a case, the order of several, say, additions, matters.
Note that the exact submission mechanism is beyond the scope of this paper, as it heavily depends on the batch system in
question. Nevertheless, our guidelines and tooling suggestions can easily be adapted to all common batch system, such as
Slurm (https://slurm.schedmd.com/) or PBS (https://www.pbspro.org/).
SimexPal can be found at https://github.com/hu-macsy/simexpal.

Version April 10, 2019 submitted to Algorithms

17 of 38

a job crashes, simex experiments purge can be used to remove the corresponding output files. The next
launch command will rerun that particular job.
5.4. Structuring Output Files
Output files typically store three kinds of data: (i) experimental results, e. g., running times and
measures of solution quality, (ii) metadata that completely specify the parameters and the environment
of the run, so that the run can be replicated (see Section 5.2), and (iii) supplementary data, e. g., the
solution to the input problem that can be used to understand the algorithm’s behavior and to verify its
correctness. Care must be taken to ensure that output files are suitable for long-term archival storage
(which is mandated by good scientific practices [70]). Furthermore, carefully designing output files helps to
accelerate experiments by avoiding unnecessary runs that did not produce all relevant information (e. g., if
the focus of experiments changes after exploration).
Choosing which experimental results to output is problem-specific but usually straightforward. For
metadata, we recommend to include enough information to completely specify the executed algorithm
version, its parameters and input instance, as well as the computing environment. This usually involves the
following data: The VCS commit hash of the implementation and compiler(s) as well as all libraries the
implementation depends on25 name (or path) of the input instance, values of parameters of the algorithm
(including random seeds 26 ), host name of the machine and current date and time.27 Implementations that
depend on hardware details (e. g., parallel algorithms or external-memory algorithms) want to log CPU,
GPU and/or memory configurations, as well as versions of relevant libraries and drivers.
The relevance of different kinds of supplementary data is highly problem-dependent. Examples include
(partial) solutions to the input problem, numbers of iterations that an algorithm performs, snapshots of
the algorithm’s state at key points during the execution or measurements of the time spent in different
parts of the algorithm. Such supplementary data is useful to better understand an algorithm’s behavior, to
verify the correctness of the implementation or to increase confidence in the experimental results (i. e., that
the running times or solution qualities reported in a paper are actually correct). If solutions are stored,
automated correctness checks can be used to find and debug problems or to demonstrate that no such
problems exist.
The output format itself should be chosen to be both human readable and machine parsable. Human
readability is particularly important for long-term archival storage, as parsers for proprietary binary
formats (and the knowledge of how to use them) can be lost over time. Machine parsability enables
automated extraction of experimental results; this is preferable over manual extraction, which is inefficient
and error-prone. Thus, we recommend structured data formats like YAML (or JSON [71]). Those formats
can be easily understood by humans; furthermore, there is a large variety of libraries to process them in any
commonly used programming language. If plain text files are used, we suggest to ensure that experimental
results can be extracted by simple regular expressions or similar tools.
KADABRA Example
Let us apply these guidelines to our example of the KADABRA algorithm using SimexPal with the
YAML file format. For each instance, we report KADABRA’s running time, the values of the parameters 

25
26
27

Experiments should never run uncommitted code. If there are any uncommitted changes, we suggest to print a comment
to the output file to ensure that the experimental data in question does enter a paper.
If the implementation’s behavior can be controlled by a large number of parameters, it makes sense to print command line
arguments as well as relevant environment variables and (excerpts from) configuration files to the output file.
Date and time help to identify the context of the experiments based on archived output data.

Version April 10, 2019 submitted to Algorithms

18 of 38

info:
commit: fef6c5ca
date: ’2018-09-14T12:21:55.497368’
host: erle
iterations: 12598
parameters:
delta: 0.1
epsilon: 0.015
seed: 0
run_time: 1.6034371852874756
topk_nodes:
- 156
- 45
- 596
# ... (more nodes follow)
topk_scores:
- 0.0651690744562629
- 0.04643594221304969
- 0.0349261787585331
# ... (more scores follow)

Figure 2. Output of KADABRA example in YAML format
import simex
import yaml
cfg = simex.config_for_dir(’.’)
res = cfg.collect_successful_results(yaml.load)
for algo in ’kadabra’, ’rk’:
rts = [r[’run_time’] for r in res if r[’algo’] == algo and r[’threads’] == 1]
print(algo, sum(rts)/len(rts))

Figure 3. Script to collect KADABRA output

and δ, the random seed that was used for the run, the number τ of samples that the run required and the
top-25 nodes of the resulting betweenness centrality ranking and their betweenness scores. The number 25
here is chosen arbitrarily, as a good balance between the amount of information that we store to verify
the plausibility of the results and the amount of space consumed by the output. To fully identify the
benchmark setting, we also report the hostname, our git commit hash, our random generator seed and the
current date and time. Figure 2 gives an example how the resulting output file looks like.
5.5. Gathering Results
When the experiments are done, one has to verify that all runs were successful. Then, the output data
has to be parsed to extract the desired experimental data for later evaluation. Again, we recommend the
use of tools for parsing. In particular, SimexPal offers a Python package to collect output data. Figure 3
depicts a complete script that computes average running times for different algorithms on the same set of
instances, using only seven lines of Python code. Note that SimexPal takes care of reading the output files
and checking that all runs indeed succeeded (using the function collect_successful_results()).
In our example, we assume that the output files are formatted as YAML (thus we use the function
yaml.load() to parse them). In case a custom format is used (e. g., when reading output from a competitor
where the output format cannot be controlled), the user has to supply a small function to parse the output.
Fortunately, this can usually be done using regular expressions (e. g., with Python’s regex module).
Now would also a good time to aggregate data appropriately (unless this has been taken care of before,
also see Section 4.6).
6. Visualizing Results
After the experiments have finished, the recorded data and results need to be explored and analyzed
before they can finally be reported. Data visualization in the form of various different plots is a helpful tool
both in the exploration phase and also in the final communication of the experimental results and the formal

Version April 10, 2019 submitted to Algorithms

19 of 38

statistical analysis. The amount of data collected during the experiments is typically too large to report in
its entirety and hence meaningful and faithful data aggregations are needed.28 While descriptive summary
statistics such as means, medians, quartiles, variances, standard deviations, or correlation coefficients, as
well as results from statistical testing like p-values or confidence intervals provide a well-founded summary
of the data, they do so, by design, only at a very coarse level. The same statistics can even originate from
very different underlying data: a famous example is Anscombe’s quartet [72], a collection of four sets of
eleven points in R2 with very different point distributions, yet (almost) the same summary statistics such
as mean, variance, or correlation.29 It is a striking example of how important it can be not to rely on
summary statistics alone, but to visualize experimental data graphically. A more recent example is the
datasaurus.30
Here we discuss a selection of plot types for data visualization with focus on algorithm engineering
experiments, together with guidelines when to use which type of plot depending on the properties of the
data. For a more comprehensive introduction to data visualization, we refer the reader to some of the
in-depth literature on the topic [73–75]. Furthermore, there are many powerful libraries and tools for
generating data plots, e. g., R31 and the ggplot2 package32 , gnuplot33 , matplotlib.34 Also mathematical
software such as MATLAB35 (or even spreadsheet tools) can generate various types of plots from your
data. For more details about creating plots in one of these tools, we refer to the respective user manuals
and various available tutorials.
When presenting data in two-dimensional plots, marks are the basic graphical elements or geometric
primitives to show data. They can be points (zero-dimensional), lines (1D), or areas (2D). Each mark
can be further refined and enriched by visual variables or channels such as their position, size, shape,
color, orientation, texture, etc. to encode different aspects of the data. The most important difference
between those channels is that some are more suitable to represent categorical data (e. g., graph properties,
algorithms, data sources) by assigning different shapes or colors to them, whereas others are well suited
for showing quantitative and ordered data (e. g., input sizes, timings, quantitative quality measures) by
mapping them to a spatial position, size, or lightness. For instance, in Figure 6 we use blue circles as marks
for one of the algorithms, while for the other we use orange crosses. Using different shapes makes sure that
the plots are still readable if printed in grey-scale. Not all channels are equally expressive and effective in
encoding information for the human visual system, so that one has to carefully select which aspects of the
data to map to which channels, possibly also using redundancy. For more details see the textbooks [76]
and [77].
As discussed in Section 4.6, the types of metrics from algorithmic experiments comprise two main
aspects: running time data and solution quality data. Both types of metrics can consist of absolute or relative
values. Typically, further attributes and parameters of the experimental data, of the algorithms, and of the
input instances are relevant to include in a visualization to communicate the experimental findings. These
can range from hardware-specific parameters, over the set of algorithms and possible algorithm-specific
parameters, to instance-dependent parameters such as certain graph properties. Depending on the
experiment’s focus, one needs to decide on the parameters to show in a plot and on how to map them

28
29
30
31
32
33
34
35

For future reference and repeatability, it may make sense to include relevant raw data in tables in the appendix. But raw
data tables are rarely good for illustrating trends in the data.
For example plots of the four point sets see https://commons.wikimedia.org/w/index.php?curid=9838454.
https://www.autodeskresearch.com/publications/samestats.
https://www.r-project.org.
https://ggplot2.tidyverse.org.
http://www.gnuplot.info.
https://matplotlib.org.
https://www.mathworks.com/products/matlab.html.

Version April 10, 2019 submitted to Algorithms

algorithmic speedup

2
2

9

20 of 38

geometric mean=145.1

7 145.1

2

5

2

3

nb ts fb en 08 o 05 04 in fin As Th bc it pl h h o bo cb L A
mr pe eg op Gn wkVGn Gn tw c ca ca su tw eg caP ciP fbw wk lo dCO rdP
Figure 5. The running time speedup of KADABRA over RK for all the instances in the evaluation set for
c = 4375. Every bar is the ratio of the arithmetic means for 5 repeated runs per instance. The smallest
speedup is 4.5 for instance roadNet-PA (rdPA) and the largest speedup is 478.7 for instance ca-AstroPh
(caAs). The geometric mean for all speedups is around 145.1. Instances are sorted by their number of
nodes. The y-axis is in log scale.

to marks and channels. Typically, the most important metric to answer the guiding research question
(e. g., running time or solution quality) is plotted along the y-axis. The x-axis, in turn, is used for the
most relevant parameter describing the instances (e. g., instance size for a scalability evaluation or a graph
parameter for evaluating its influence on the solution quality). Additional parameters of interest can then
be represented by using distinctly colored or shaped marks for different experimental conditions such as
the respective algorithm, an algorithmic parameter or properties of the used hardware, see for example
that, in Figures 6 instance roadNet-TX is plotted differently because RK did not finish within the allocated
time frame of 7 hours.
Before starting to plot the data, one needs to decide whether raw absolute data should be visualized
(e. g., running times or objective function values) or whether the data should be shown relative to some
baseline value, or be normalized prior to plotting. This decision typically depends on the specific algorithmic
problem, the experimental setup and the underlying research questions to be answered. For instance, when
the experiment is about a new algorithm for a particular problem, the algorithmic speedup or possible
improvement in solution quality with respect to an earlier algorithm may be of interest; hence, running
time ratios or quality ratios can be computed as a variable to plot – as shown in Figure 5 with respect
to KADABRA and RK. Another possibility of data preprocessing is to normalize certain aspects of the
experimental data before creating a plot. For example, to understand effects caused by properties of the
hardware, such as cache sizes and other memory effects, one may normalize running time measurements
by the algorithm’s time complexity in terms of n and m, the number of vertices and edges of the input
graph, and examine if the resulting computation times are constant or not. A wide range of meaningful
data processing and analysis can be done before showing the resulting data in a visualization. While we
just gave a few examples, the actual decision of what to show in a plot needs to be made by the designers
of the experiment after carefully exploring all relevant aspects of the data from various perspectives. For
the remainder of this section, we assume that all data values to be visualized have been selected.

Version April 10, 2019 submitted to Algorithms

21 of 38

Figure 6. Scatter plot for running times of KADABRA for c = 4375 and RK for all instances in the
evaluation set. Both axes are in log scale. Every point is the (arithmetic) mean running time for
5 repeated runs for each instance. The one square represents the run of KADABRA for the network
roadNet-TX for which RK did not finish within the cutoff time of 7 hours.

running time (secods)

A very fundamental plot is the scatter
400
plot, which maps two variables of the data
best tuning value
150
(e. g., size and running time) onto the x- and
for c = 4375
y-axis, see Figure 6. Every instance of the
300
experiment produces its own point mark in
140
11
12
13
the plot, by using its values of the two chosen
2
2
2
200
variables as coordinates. Further variables
of the data can be mapped to the remaining
5
2
8
11
14
17
channels such as color, symbol shape, symbol
2
2
2
2
2
2
size, or texture. If the number of instances
tunning parameter value
is not too large, a scatter plot can give an
accurate visualization of the characteristics Figure 4. Tuning parameter search. Every point is the
and trends of the data. However, for large (arithmetic) mean running time for all the instances in the
numbers of instances, overplotting can quickly tuning set. Experiments on each instance are repeated 3 times
lead to scatter plots that become hard to read. for the respective value of the parameter. The value that gives
In such cases, the data needs to be the best results is picked; here it is 4375 as it provides the lowest
aggregated before plotting, by grouping similar running time of about 142 seconds.
instances and showing summaries instead. The
simplest way to show aggregated data, such as repeated runs of the same instances, is to plot a single point
mark for each group, e. g., using the mean or median, and then optionally putting a vertical error bar on
top of it showing one standard deviation or a particular confidence interval of the variable within each
group. Such a plot can be well suited for showing how running times scale with the instance size. If the
sample sizes in the experiment have been chosen to cover the domain well, one may amplify the salience of

16.0%
12.0%
8.0%
4.0%
0.0%
-4.0%
-8.0%
-12.0%
-16.0%

22 of 38

relative deviation in running time

relative deviation in running time

Version April 10, 2019 submitted to Algorithms

nb ts fb en 08 o 05 04 in fin As Th bc it pl h h o bo cb L A X
mr pe eg op Gn wkVGn Gn tw c ca ca su tw eg caP ciP fbw wk lo dCOrdP rdT

4.0%
3.0%
2.0%
1.0%
0.0%
-1.0%
-2.0%
-3.0%
-4.0%

nb ts fb en 08 o 05 04 in fin As Th bc it pl h h o bo cb L A
mr pe eg op Gn wkV Gn Gn tw c ca ca su tw eg caP ciP fbw wk lo dCO rdP

(a) A violin plot for running time deviation of (b) A box plot for running time deviation of RK. The
KADABRA.
orange line indicates the median.
Figure 7. Plots on variance of running times. For each instance in the evaluation set, we perform 5
repeated runs and calculate the mean. Shown in the plot are, for each run, the distance to the mean,
divided by the mean. This way we get the relative running time variance for every instance. Here, we
use a box and a violin plot for illustration purposes; in a scientific paper one of the two should be chosen.
Notice also that instance roadNet-TX is missing for RK since it did not finish within the 7 hours limit.

the trend in the data by linking the point marks by a line plot. However, this visually implies a linear
interpolation between neighboring measurements and therefore should only be done if sufficiently many
sample points are included and the plot is not misleading. Obviously, if categorical data are represented on
the x-axis, one should never connect the point marks by a line plot.
At the same time, the scale of the two coordinate axes is also of interest. While a linear scale is the
most natural and least confusing for human interpretation, some data sets contain values that may grow
exponentially. On a linear scale, this results in the large values dominating the entire plot and the small
values disappear in a very narrow band. In such cases, axes with a logarithmic scale can be used; however,
this should always be made explicit in the axis labeling and the caption of the plot.
A more advanced summary plot is the box plot (or box-and-whiskers plot), where all repeated runs
of the same instance or sets of instances with equal or similar size form a group, see Figure 7a. This
group is represented as a single glyph showing simultaneously the median, the quartiles, the minimum and
maximum values or another percentile, as well as possibly outliers as individual marks. If the x-axis shows
an ordered variable such as instance size, one can still clearly see the scalability trend in the data as well as
the variability within each homogeneous group of instances.
Violin plots take the idea of box plots even further and draw the contour of the density distribution of
the variable mapped to the y-axis within each group, see Figure 7b. It is thus visually more informative
than a simple box plot, but also more complex and thus possibly more difficult to read. When deciding
for a particular type of plot, one has to explore the properties of the data and choose a plot type that is
neither oversimplifying them nor more complex than needed.
Data from algorithmic experiments may also often be aggregated by some attribute into groups of
different sizes. In order to show the distribution of the instances into these groups, bar charts (for categorical
data) or histograms (for continuous data) can be used to visualize the cardinality of each group. Such
diagrams are often available in public repositories like KONECT.36 For a complex network, for example,
one may want to plot the degree distribution of its nodes with the degree (or bins with a specific degree
range) on the x-axis and the number of vertices with a particular degree (or in a particular degree range)

36

For example, one can find this information for moreno_blogs in http://konect.uni-koblenz.de/networks/moreno_blogs.

Version April 10, 2019 submitted to Algorithms

23 of 38

on the y-axis. Such a histogram can then quickly reveal how skewed the degree distribution is. Similarly,
histograms can be useful to show solution quality ratios obtained by one or more algorithms by defining
bins based on selected ranges of quality ratios. Such a plot quickly indicates to the reader what percentage
of instances could be solved within a required quality range, e. g., at least 95% of the optimum. of the
algorithm(s) and the y-axis displays the quality. This allows
A single plot can contain multiple experimental conditions simultaneously. For instance, when showing
running time behavior and scalability of a new algorithm compared to previous approaches, a single plot
with multiple trend lines in different colors or textures or with visually distinct mark shapes can be very
useful to make comparisons among the competing algorithms. Clearly, a legend needs to specify the
mapping between the data and the marks and channels in the plot. Here it is strongly advisable to use the
same mapping if multiple plots are used that all belong together. But, as a final remark, bear in mind the
size and resolution of the created figures. Avoid clutter and ensure that your conclusion remains clearly
visible!
7. Evaluating Results with Statistical Analysis
Even if a result looks obvious37 , it can benefit from a statistical analysis to quantify it, especially if
random components or heuristics are involved. The most common questions for a statistical analysis are:
• Do the experimental results support a given hypothesis, or is the measured difference possibly just
random noise? This question is addressed by hypothesis testing.
• How large is a measured effect, i. e., which underlying real differences are plausible given the
experimental measurements? This calls for parameter estimation.
• If we want to answer the first two questions satisfactorily, how many data points do we need? This is
commonly called power analysis. As this issue affects the planning of experiments, we discussed it
already in Section 4.3.
The two types of hypotheses we discussed in Section 4.1 roughly relate to hypothesis tests and
parameter estimation. Papers proposing new algorithms mostly have hypotheses of the first type: The
newly proposed algorithm is faster, yields solutions with better quality or is otherwise advantageous.
In many empirical sciences, the predominant notion has been null hypothesis significance testing
(NHST), in which a statistic of the measured data is compared with the distribution of this statistic under
the null hypothesis, an assumed scenario where all measured differences are due to chance. Previous works
on statistical analysis of experimental algorithms, including the excellent overviews of McGeoch [37] and
Coffin and Saltzmann [15], use this paradigm.
Due to some limitations of the NHST model, a shift towards parameter estimation [78–81] and also
Bayesian methods [82–84] is taking place in the statistical community.
We aim at applying the current state of the art in statistical analysis to algorithm engineering, but
since no firm consensus has been reached [80], we discuss both frequentist and Bayesian approaches. As an
example for null hypothesis testing, we investigate whether the KADABRA and the RK algorithms give
equivalent results for the same input graphs. While this equivalence test could also be performed using
Bayesian inference, we use a null hypothesis test for illustration purposes.
It is easy to see from running time plots (e. g., Figure 6) that KADABRA is faster than RK. To quantify
this speedup, we use Bayesian methods to infer plausible values for the algorithmic speedup and different
scaling behavior. We further evaluate the influence of the graph diameter on the running time.

37

It fulfills the “inter-ocular trauma test”, as the saying goes, the evidence hitting you between the eyes.

Version April 10, 2019 submitted to Algorithms

24 of 38

7.1. Statistical Model
A statistical model defines a family of probability distribution over experimental measurements.
Many experimental running times have some degree of randomness: Caching effects, network traffic and
influence of other processes contribute to this, sometimes the tested algorithm is randomized itself. Even a
deterministic implementation on deterministic hardware can only be tested on a finite set of input data,
representing a random draw from the infinite set of possible inputs. A model encodes our assumptions
about how these sources of randomness combine to yield the distribution of outputs we see. If, for example,
the measurement error consists of many additive and independent parts, the central limit theorem justifies
a normal distribution.
To enable useful inferences, the model should have at least one free parameter corresponding to a
quantity of interest. Any model is necessarily an abstraction, as expressed in the aphorism “all models are
wrong, but some are useful” [85].
7.1.1. Example
Suppose we want to investigate whether KADABRA scales better than RK on inputs of increasing size.
Figure 6 shows running times of KADABRA and RK with respect to the instance size. These are spread
out, implying either that the running time is highly variable, or that it depends on aspects other than the
instance size.
A companion Jupyter notebook including this example and the following inferences is included in the
supplementary materials.
In general, running times are modeled as functions of the input size, sometimes with additional
properties of the input. The running time of KADABRA, for example, possibly depends on the diameter of
the input graph. Algorithms in network analysis often have polynomial running times where a reasonable
upper bound for the leading exponent can be found. Thus, the running time can be modeled as such a
polynomial, written as a + bn + cn2 + dn3 + . . . + α log n + β log log n + . . ., with the unknown coefficients
of the polynomial being the free parameters of the model.
However, a large number of free model parameters makes inference difficult. This includes the danger
of overfitting, i. e., inferring parameter values that precisely fit the measured results but are unlikely to
generalize.
To evaluate the scaling behavior, it is thus often more useful to focus on the largest exponent
instead. Let TA (n) be the running time of the implementation of RK and TB (n) the running time of the
implementation of KADABRA on inputs of size n, with unknown parameters αA , αB , βA and βB .38
TA (n) = αA · nβA · 
TB (n) = αB · nβB · 
The term  explicitly models the error; it can be due to variability in inputs (some instances might be
harder to process than others of the same size) and measurement noise (some runs suffer from interference
or caching effects). Since harder inputs are not constrained to additive difficulty and longer runs have more

38

For estimating asymptotic upper bounds, see the work of McGeoch et al. [32] on curve bounding.

Version April 10, 2019 submitted to Algorithms

25 of 38

opportunity to experience adverse hardware effects, we choose a multiplicative error term.39 Taking the
logarithms of both sides makes the equations linear:
log(TA (n)) = log(αA ) + βA log(n) + log()

(4)

log(TB (n)) = log(αB ) + βB log(n) + log()

(5)

A commonly chosen distribution for additive errors is Gaussian, justified by the central limit
theorem [86]. Since longer runs have more exposure to possibly adverse hardware or network effects
we consider multiplicative error terms to be more likely and use a log-normal distribution.40 Since the
logarithm of the log-normal distribution is a normal (Gaussian) distribution, Equations 4 and 5 can be
rewritten as normally distributed random variables:
log(TA (n)) ∼ N (log(αA ) + βA log(n), σ2 )

(6)

σ2 )

(7)

log(TB (n)) ∼ N (log(αB ) + βB log(n),

This form shows more intuitively the idea that a statistical model is a set of probability measures on
experimental outcomes. In this example, the set of probability measures modeling the performance of an
algorithm are parametrized by the tuple (α, β, σ ) ∈ R3 .
A problem remains if the input instances are very inhomogeneous. In that case, both A and B have a
large estimated variance (σ 2 ). Even if the variability of performance on the same instance is small, any
genuine performance difference might be wrongly attributed to the large inter-instance variance. This issue
can be addressed with a combined model as recommended by Coffin and Saltzmann [15], in which the
running time TA (x) of A is a function of the running time TB (x) of B on the same instance x:
log(TA (x)) ∼ N (log(αA/B ) + βA/B log(TB (x)), σ 2 )

(8)

For a more extensive overview of modeling experimental algorithms, see [37].
7.1.2. Model Fit
Several methods exist to infer parameters when fitting a statistical model to experimental data. The
most well-known is arguably the maximum-likelihood fit, choosing parameters for a distribution that give
the highest probability for the observed measurements. In the case of a linear model with a normally
distributed error, this is equivalent to a least-squares fit [87]. Such a fit yields a single estimate for plausible
parameter values.
Given random variations in the measurement, we are also interested in the range of plausible values,
quantifying the uncertainty involved in measurement and instance selection. This is covered in Sections
7.3.2 and 7.4.
7.2. Formalizing Hypotheses
Previously (Section 4.1), we discussed two types of hypotheses. The first type is that a new algorithm
is better in some aspect than the state of the art. The second type claims insight into how the behavior of

39
40

Summands with smaller exponents are also subsumed within the error term. If they have a large effect, an additive error
might reflect this more accurately.
In some cases, it might even make sense to use a hierarchical model with two different error terms: One for the input
instances, the other one for the differences on the same input.

Version April 10, 2019 submitted to Algorithms

26 of 38

an algorithm depends on settings and properties of the input. We now express these same hypotheses more
formally, as statements about the parameters in a statistical model. The two types are then related to the
statistical approaches of hypothesis testing and parameter estimation.
Considering the scaling model presented in Equation (8) and the question whether implementation A
scales better than implementation B, the parameter in question is the exponent βA/B . The hypothesis
that A scales better than B is equivalent to log(βA/B ) < 0; both scaling the same implies log(βA/B ) = 0.
Note that the first hypothesis does not imply a fully specified probability distribution on βA/B , merely
restricting it to the negative half-plane. The hypothesis of log(βA/B ) = 0 does completely specify such a
distribution (i. e., a point mass of probability 1 at 0), which is useful for later statistical inference.
7.3. Frequentist Methods
Frequentist statistics defines the probability of an experimental outcome as the limit of its relative
frequency when the number of experiments trends towards infinity. This is usually denoted as the classical
approach.
7.3.1. Null Hypothesis Significance Testing
As discussed above, null hypothesis significance testing evaluates a proposed hypothesis by contrasting
it with a null hypothesis, which states that no true difference exists and the observed difference is due to
chance. As an example application, we compare the approximation quality of KADABRA and RK. From
theory, we would expect higher approximation errors from KADABRA, since it samples fewer paths. We
investigate whether the measured empirical difference supports this theory, or could also be explained with
random measurement noise, i. e., with the null hypothesis (denoted with H0 ) of both algorithms having the
same distribution of errors and just measuring higher errors from KADABRA by coincidence. Here it is an
advantage that the proposed alternate hypothesis (i. e., the distributions are meaningfully different) does
not need an explicit modeling of the output distribution, as the distribution of differences in our case does
not follow an easily parameterizable distribution.
When deciding whether to reject a null hypothesis (and by implication, support the alternate
hypothesis), it is possible to make one of two errors: (i) rejecting a null hypothesis, even though it
is true (false positive), (ii) failing to reject a false null hypothesis (false negative). In such probabilistic
decisions, the error rate deemed acceptable often depends on the associated costs for each type of error.
For scientific research, Fisher suggested that a false positive rate of 5% is acceptable [88], and most fields
follow that suggestion. This threshold is commonly denoted as α.
Controlling for the first kind of error, the p-value is defined as the probability that a summary statistic
as extreme as the observed one would have occurred given the null hypothesis [89]. Please note that this
is not the probability P (H0 |observations), i. e., the probability that the null hypothesis is true given the
observations.
For practical purposes, a wide range of statistical hypothesis tests have been developed, which aggregate
measurements to a summary statistic and often require certain conditions. For an overview of which of
them are applicable in which situation, see the excellent textbook of Young and Smith [89]. In our example
the paired results are of very different instances and clearly not normally distributed. We thus avoid the
common t-test and use a Wilcoxon test of pairs [90] from the SciPy [91] stats module, yielding a p-value
of 5.9 · 10−5 , see cell 14 of the statistics notebook in the supplementary materials. Since this is smaller
than our threshold α of 0.05, one would thus say that this result allows us to reject the null hypothesis at
the level of 5.9 · 10−5 . Such a difference is commonly called statistically significant. To decide whether it
is actually significant in practice, we look at the magnitude of the difference: The error of KADABRA is
about one order of magnitude higher for most instances, which we would call significant.

Version April 10, 2019 submitted to Algorithms

27 of 38

Multiple Comparisons
The NHST approach guarantees that of all false hypotheses, the expected fraction that seem significant
when tested is at most α. Often though, a publication tests more than one hypotheses. For methods to
address this problem and adjust the probability that any null hypothesis in an experiment is falsely rejected
(also called the familywise error rate), see Bonferroni [92] and Holm [93].
7.3.2. Confidence Intervals
One of the main criticism of NHST is that it ignores effect sizes; the magnitude of the p-value says
nothing about the magnitude of the effect. More formally, for every true effect with size  > 0 and every
significance level α, there exists an n0 so that all experiments containing n ≥ n0 measurements are likely to
reject the null hypothesis at level α. Following this, Coffin and Saltzmann [15] caution against overly large
data sets - a recommendation which comes with its own set of problems.
The statistical response to the problem of small but meaningless p-values with large data sets is
a shift away from hypothesis testing to parameter estimation. Instead of asking whether the difference
between populations is over a threshold, the difference is quantified as a parameter in a statistical model,
see also Section 7.2. As Kruschke et al. [83] put it, the null hypothesis test asks whether the null value
of a parameter would be rejected at a given significance level. A confidence interval merely asks which
other parameter values would not be rejected [83]. We refer to [94,95] for a formal definition and usage
guidelines.
7.4. Bayesian Inference
Bayesian statistics defines the probability of an experimental outcome as the uncertainty of knowledge
about it. Bayes’s theorem gives a formal way to update probabilities on new observations. In its simplest
form for discrete events and hypotheses, it can be given as:
P (H1 |A) =

P (A|H1 )P (H1 )
P (A)

(9)

When observing outcome A, the probability of hypothesis H1 is proportional to the probability of A
conditioned on H1 multiplied by the prior probability P (H1 ). The conditional probability P (A|H1 ) of an
outcome A given an hypothesis H1 is also called the likelihood of H1 . The prior probability reflects the
estimation before making observations, based on background knowledge.
Extended to continuous distributions, Bayes’s rule allows to combine a statistical model with a set of
measurements and a prior probability distribution over parameters to yield a posterior probability distribution
over parameters. This posterior distribution reflects both the uncertainty in measurements and possible
prior knowledge about parameters. A thorough treatment is given by Gelman et al. [96].
For our example model introduced in Section 7.1, we model the running times of implementation B as
a function of the time of implementation A, as done in Equation (8):
2
log(TA (n)) ∼ N (αA/B + βA/B · log(TB (n)), σA/B
)

This defines the likelihood function as a Gaussian noise with variance σ 2 . Since this variance is unknown,
we keep it as a model parameter. As we have no specific prior information about plausible values of α and
β, we define the following vague prior distributions:
αA/B ∼ N (0, 10), βA/B ∼ N (1, 10), σA/B ∼ InvGamma(1, 1)

Version April 10, 2019 submitted to Algorithms

28 of 38

import pymc3 as pm
from scipy import optimize
basic_model = pm.Model()
with basic_model:
alpha = pm.Normal(’alpha’, mu=0, sd=10)
beta = pm.Normal(’beta’, mu=0, sd=10)
sigma = pm.InverseGamma(’sigma’, alpha=1,beta=1)
mu = alpha + beta*logTimeRK
Y_obs = pm.Normal(’Y_obs’, mu=mu, sd=sigma, observed=logTimeKadabra)
with basic_model:
# approximate posterior distribution with 10000 samples
trace = pm.sample(10000)
pm.summary(trace)

Figure 8. Example listing for inference of parameters αA/B , βA/B and σA/B .

αA/B
βA/B
σA/B

HPD 2.5

Mean

HPD 97.5

-6.87
0.70
0.80

-5.22
1.01
1.13

-3.58
1.29
1.54

Table 4. Posterior distribution of parameter values.

The first two distributions represent our initial – conservative – belief that the two implementations are
equivalent in terms of scaling behavior and constants. We model the variance of the observation noise σ 2
as an inverse gamma distribution instead of a normal distribution, since a variance cannot be negative.
Figure 8 shows a listing to compute and show the posterior distribution of these three parameters
using SciPy [91] and PyMC3 [97]. Results are listed in Table 4. The interval of Highest Probability
Density (HPD) is constructed to contain 95% of the probability mass of the respective posterior distribution.
It is the Bayesian equivalent of the confidence interval (Section 7.3.2) and also called credible interval.
The most probable values for αA/B and βA/B are -5.22 and 1.01, respectively. Taking measurement
uncertainty into account, the true values are within the intervals [−6.87, −3.58] respective [0.70, 1.29] with
95% probability. This shows that KADABRA is faster on average, but results about the relative scaling
behavior are inconclusive. While the average for βA/B is 1.01 and suggests similar scaling, the interval
[0.7, 1.29] neither excludes the hypothesis that KADABRA scales better, nor the hypothesis that it scales
worse.
7.4.1. Equivalence Testing
Computing the highest density interval can also be used for hypothesis testing. In Section 7.3.1 we
discussed how to show that two distributions are different. Sometimes, though, we are interested in showing
that they are sufficiently similar. An example would be wanting to show that two sampling algorithms give
the same distribution of results. This is not easily possible within the NHST paradigm, as the two answers
of a classical hypothesis test are “probably different” and “not sure”.
This problem can be solved by calculating the posterior distribution of the parameter of interest and
defining a region of practical equivalence (ROPE), which covers all parameter values that are effectively
indistinguishable from 0. If x% of the posterior probability mass are in the region of practical equivalence,
the inferred parameter is practically indistinguishable with probability x%. If x% of the probability mass
are outside the ROPE, the parameter is meaningfully different with probability x%. If the intervals overlap,
the observed data is insufficient to come to either conclusion. In our example, the scaling behavior of two
algorithms is equivalent if the inferred exponent modeling their relative running times is more or less 1. We
could define practical equivalence as ±5%, resulting in a region of practical equivalence of [0.95, 1.05]. The

Version April 10, 2019 submitted to Algorithms

29 of 38

interval [0.7, 1.29] containing 95% of the probability mass for β is neither completely inside [0.95, 1.05] nor
completely outside it, implying that more experiments are needed to come to a conclusion.
7.4.2. Bayes Factor
Bayes factors are a way to compare the relative fit of several models and hypotheses to a given set
of observations. While NHST (Section 7.3.1) evaluates the fit of observations to the null hypothesis and
confidence intervals and credible intervals infer the range of plausible values of parameters in a model, the
Bayes factor between two hypotheses gives the ratio between their posterior probabilities. This probability
ratio of hypotheses is then:
P (H1 |obs)
P (obs|H1 ) P (H1 )
=
P (H0 |obs)
P (obs|H0 ) P (H0 )
Crucially, the ratio of prior probabilities, which is subjective, is a separate factor from the ratio of likelihoods,
P (obs|H )
which is objective. This objective part, the ratio P (obs|H1 ) , is called the Bayes factor.
0
The first obvious difference to NHST is that calculating a Bayes Factor consists of comparing the fit of
both hypotheses to the data, not only the null hypothesis. It thus requires that an alternate hypothesis is
stated explicitly, including a probability distribution over observable outcomes. If the alternative hypothesis
is meant to be vague, for example just that two distributions are different, an uninformative prior with a
high variance should be used. However, specific hypotheses like “the new algorithm is at least 20% faster”
can also be modeled explicitly.
This explicit modeling allows inference in both directions; using NHST, on the other hand, one can
only ever infer that a null hypothesis is unlikely or that the data is insufficient to infer this. Using Bayes
factors, it is possible to infer that H1 is more probable than H0 , or that the observations are insufficient to
support this statement, or that H0 is more probable than H1 .
In the previous running time analysis, we hypothesized a better scaling behavior, which was not
confirmed by the experimental measurements. However, the graphs with high diameter are larger than
average and a cursory complexity analysis of the KADABRA algorithm suggests that the diameter has an
influence on the running time. Might the relative scaling of KADABRA and RK depend on the running
time?
To answer this question, we compare the fit of two models: The first model is the same as discussed
earlier (Equation 8), it models the expected running time of KADABRA on instance x as eα · TRK (x)β ,
where TRK (x) is the running time of RK on the same instance. The second model has the additional free
parameter γ, controlling the interaction between the diameter and running times:
log(T (x)) ∼ N (log(α) + β log(TRK (x)) + γ log(diamx ), σ ).

(10)

Comparing for example the errors of a least-squares fit of the two models would not give much insight,
since including an additional free parameter in a model almost always results in a better fit. This does not
have to mean that the new parameter captures something interesting.
Instead, we calculate the Bayes factor, for which we integrate over the prior distribution in each model.
Since this integral over the prior distribution also includes values of the new parameter which are not a
good fit, models with too many additional parameters are automatically penalized. Our two models are
similar, thus we can phrase them as a hierarchical model with the additional parameter controlled by a
boolean random variable, see Listing 9.
The posterior for the indicator variable selected_model is 0.945, yielding a Bayes factor of ≈ 17 in
support of including the diameter in the model. We can thus conclude that it is very probable that the
diameter has an influence on the relative scaling between KADABRA and RK. The inferred mean of the
variable γ is 0.79, meaning that higher diameter values lead to higher running times.

Version April 10, 2019 submitted to Algorithms

30 of 38

import pymc3 as pm
from scipy import optimize
basic_model = pm.Model()
with basic_model:
pi = (0.5, 0.5)
selected_model = pm.Bernoulli(’selected_model’, p=pi[1])
alpha = pm.Normal(’alpha’, mu=0, sd=10)
beta = pm.Normal(’beta’, mu=0, sd=10)
gamma = pm.Normal(’gamma’, mu=0, sd=10)
sigma = pm.InverseGamma(’sigma’, alpha=1, beta=1)
mu = alpha + beta*logTimesRK + gamma*logDiameters*selected_model
Y_obs = pm.Normal(’Y_obs’, mu=mu, sd=sigma, observed=logTimeKadabra)

Figure 9. Listing to compute the Bayes factor, the relative likelihood of two models, between the model
including the graph diameter and the model with just the graph sizes. The variable selected_model is an
indicator for which model is selected.

Estimation

Frequentist

Bayesian

Confidence Interval

Posterior

Equivalence
TOST
Posterior + ROPE or BF
Difference
NHST
Model Selection
AIC
Bayes Factor (BF)
Table 5. Overview of different statistical methods. TOST stands for Two One-Sided T-Tests and AIC
is the Akaike Information Criterion [98], a combined measure for model fit and model complexity.
Hypothesis

7.5. Recommendations
Which statistical method is best, depends on what needs to be shown. For almost all objectives, both
Bayesian and frequentist methods exist, see Table 5. In experimental algorithmics, most hypotheses can
be expressed as statements constraining parameters in a statistical model, i. e., “the average speedup of
A over B is at least 20%”. Thus, in contrast to earlier statistical practice, we recommend to approach
evaluation of hypotheses by parameter estimation and to only use the classical hypothesis tests when
parameter estimation is not possible. The additional information gained by parameter estimates has a
couple of advantages. For example, when using only hypothesis tests, small differences in large data sets
can yield impressively small p-values and thus claims of statistical significance even when the difference is
irrelevant in practice and the significance is statistical only [15]. Using confidence intervals (Section 7.3.2)
or the posterior distribution in addition with a region of practical equivalence avoids this problem [83].
Below is a rough guideline (also shown in Figure 10) outlining our method selection process. It favors
Bayesian methods, since the python library PyMC3 [97] offering them fits well into our workflow.
1. Define a model that captures the parts of the measured results that interest you, see Section 7.1.
2. Using confidence intervals (Section 7.3.2) or credible intervals (Section 7.4), estimate plausible
values for the model parameters, including their uncertainty. If this proves intractable and you are
only interested in whether a measured difference is due to chance, use a significance test instead
(Section 7.3.1).
3. If you want to show that two distributions (of outcomes of algorithms) are similar, use an equivalence
test, in which you define a region of practical equivalence.
4. If you want to show that two distributions (of outcomes of algorithms) are different, you may also
use an equivalence test or alternatively, a significance test.
5. If you want to compare how well different hypotheses explain the data, for example compare whether
the diameter has an influence on relative scaling, compare the relative fit using a Bayes factor
(Section 7.4.2).
Needless to say, these are only recommendations.

Version April 10, 2019 submitted to Algorithms

31 of 38

Hypothesis test or Parameter estimation?

Parameter

Hypothesis

Difference,
Equivalence
or Model Comparison?

Bayesian or Frequentist
preference?

Bayesian

Frequentist

Model
Comparison

Difference

Credible Interval
7.4

Equivalence

Hypothesis of difference
possible to model?

Yes

Confidence Interval
7.3.2

Bayes Factor
7.4.2

Region of
Practical Equivalence
7.4.1

No

Null Hypothesis
Statistical Tests
7.3.1

Figure 10. Flowchart outlining our method selection.

8. Conclusions
Besides setting guidelines for experimental algorithmics, this paper provides a tool for simplifying the
typical experimental workflow. We hope that both are useful for the envisioned target group – and beyond,
of course. We may have omitted material some consider important. This happened on purpose to keep the
exposition reasonably concise. To account for future demands, we could imagine an evolving “community
version” of the paper, updated with the help of new co-authors in regular time intervals. That is why we
invite the community to contribute comments, corrections and/or text.41
Let us conclude by reminding the reader: most of the guidelines in the paper are not scientific laws
nor set in stone. Always apply common sense to adapt a guideline to your concrete situation! Also, we
cannot claim that we always followed the guidelines in the past. But this was all the more motivation for
us to write this paper, to develop SimexPal and to have a standard to follow – we hope that the community
shares this motivation.
Acknowledgments: We thank Michael Hamann and Sebastian Schlag for their timely and thorough feedback on
a working draft of the paper. We also thank Alexander Meier and Dimitri Ghouse for valuable advice on statistics.
A subset of the authors was partially supported by grant ME 3619/3-2 within German Research Foundation (DFG)
Priority Programme 1736 Algorithms for Big Data.

41

The source files of this paper can be found at https://github.com/hu-macsy/ae-tutorial-paper. We encourage readers post
suggestions via GitHub issues and welcome pull requests.

Version April 10, 2019 submitted to Algorithms

1.
2.

3.
4.
5.
6.
7.

8.
9.
10.
11.
12.
13.
14.
15.
16.

17.
18.
19.
20.
21.
22.

23.

32 of 38

Bogdanov, A.; Trevisan, L. Average-Case Complexity. Foundations and Trends R in Theoretical Computer
Science 2006, 2, 1–106. doi:10.1561/0400000004.
Spielman, D.; Teng, S.H. Smoothed Analysis of Algorithms: Why the Simplex Algorithm Usually Takes
Polynomial Time. Proceedings of the Thirty-third Annual ACM Symposium on Theory of Computing;
ACM: New York, NY, USA, 2001; STOC ’01, pp. 296–305. doi:10.1145/380752.380813.
Heule, M.J.H.; Järvisalo, M.J.; Suda, M., Eds. Proceedings of SAT Competition 2018; Solver and Benchmark
Descriptions, 2018.
Applegate, D.L.; Bixby, R.E.; Chvatal, V.; Cook, W.J. The Traveling Salesman Problem: A Computational
Study (Princeton Series in Applied Mathematics); Princeton University Press: Princeton, NJ, USA, 2007.
Mehlhorn, K.; Sanders, P. Algorithms and Data Structures: The Basic Toolbox; SpringerLink: Springer
e-Books, Springer, 2008.
Puglisi, S.J.; Smyth, W.F.; Turpin, A.H. A Taxonomy of Suffix Array Construction Algorithms. ACM
Comput. Surv. 2007, 39. doi:10.1145/1242471.1242472.
Johnson, D.S. A theoretician’s guide to the experimental analysis of algorithms. Data Structures, Near
Neighbor Searches, and Methodology: Fifth and Sixth DIMACS Implementation Challenges, Proceedings of
a DIMACS Workshop, USA, 1999, 1999, pp. 215–250.
Muller-Hannemann, M.; Schirra, S., Eds. Algorithm Engineering: Bridging the Gap Between Algorithm
Theory and Practice; Springer-Verlag: Berlin, Heidelberg, 2010.
Moret, B., Towards a discipline of experimental algorithmics; American Mathematical Society, 2002; pp.
197–213. doi:10.1090/dimacs/059/10.
Sanders, P. Algorithm Engineering - An Attempt at a Definition Using Sorting as an Example. ALENEX.
SIAM, 2010, pp. 55–61.
Bast, H.; Delling, D.; Goldberg, A.; Müller-Hannemann, M.; Pajor, T.; Sanders, P.; Wagner, D.; Werneck,
R.F. Route planning in transportation networks. In Algorithm engineering; Springer, 2016; pp. 19–80.
Applegate, D.L.; Bixby, R.E.; Chvatal, V.; Cook, W.J. The traveling salesman problem: a computational
study; Princeton university press, 2006.
Brandes, U.; Robins, G.; McCranie, A.; Wasserman, S. What is network science? Network Science 2013,
1, 1–15. doi:10.1017/nws.2013.2.
Newman, M. Networks; Oxford university press, 2018.
Coffin, M.; Saltzman, M.J. Statistical Analysis of Computational Tests of Algorithms and Heuristics.
INFORMS Journal on Computing 2000, 12, 24–44.
Borassi, M.; Natale, E. KADABRA is an ADaptive Algorithm for Betweenness via Random Approximation.
LIPIcs-Leibniz International Proceedings in Informatics. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik,
2016, Vol. 57.
Staudt, C.L.; Sazonovs, A.; Meyerhenke, H. NetworKit: A tool suite for large-scale complex network analysis.
Network Science 2016, 4, 508–530.
Boldi, P.; Vigna, S. Axioms for centrality. Internet Mathematics 2014, 10, 222–262.
Freeman, L.C. A set of measures of centrality based on betweenness. Sociometry 1977, pp. 35–41.
Brandes, U. A faster algorithm for betweenness centrality. Journal of mathematical sociology 2001,
25, 163–177.
Bader, D.A.; Kintali, S.; Madduri, K.; Mihail, M. Approximating betweenness centrality. International
Workshop on Algorithms and Models for the Web-Graph. Springer, 2007, pp. 124–137.
Geisberger, R.; Sanders, P.; Schultes, D. Better Approximation of Betweenness Centrality. Proceedings of
the Meeting on Algorithm Engineering & Expermiments; Society for Industrial and Applied Mathematics:
Philadelphia, PA, USA, 2008; pp. 90–100.
Riondato, M.; Kornaropoulos, E.M. Fast approximation of betweenness centrality through sampling. Data
Mining and Knowledge Discovery 2016, 30, 438–475.

Version April 10, 2019 submitted to Algorithms

24.
25.
26.
27.
28.
29.
30.
31.
32.

33.
34.
35.
36.
37.
38.
39.
40.

41.
42.
43.

44.
45.

46.

33 of 38

Riondato, M.; Upfal, E. ABRA: Approximating betweenness centrality in static and dynamic graphs with
rademacher averages. ACM Transactions on Knowledge Discovery from Data (TKDD) 2018, 12, 61.
Kunegis, J. Konect: the koblenz network collection. Proceedings of the 22nd International Conference on
World Wide Web. ACM, 2013, pp. 1343–1350.
Leskovec, J.; Krevl, A. SNAP Datasets: Stanford Large Network Dataset Collection. http://snap.stanford.
edu/data, 2014.
Bader, D.; Meyerhenke, H.; Sanders, P.; Wagner, D., Eds. Proc. of the 10th DIMACS Implementation
Challenge, Contemporary Mathematics. American Mathematical Society, 2012.
Davis, T.A.; Hu, Y. The University of Florida sparse matrix collection. ACM Transactions on Mathematical
Software (TOMS) 2011, 38, 1.
Boldi, P.; Vigna, S. The WebGraph Framework I: Compression Techniques. Proc. of the Thirteenth
International World Wide Web Conference (WWW 2004); ACM Press: Manhattan, USA, 2004; pp. 595–601.
Rossi, R.A.; Ahmed, N.K. An Interactive Data Repository with Visual Analytics. SIGKDD Explor. 2016,
17, 37–41.
Goldenberg, A.; Zheng, A.X.; Fienberg, S.E.; Airoldi, E.M.; others. A survey of statistical network models.
Foundations and Trends R in Machine Learning 2010, 2, 129–233.
McGeoch, C.C.; Sanders, P.; Fleischer, R.; Cohen, P.R.; Precup, D. Using Finite Experiments to Study
Asymptotic Performance. Experimental Algorithmics, From Algorithm Design to Robust and Efficient
Software [Dagstuhl seminar, September 2000], 2000, pp. 93–126.
Bernardo, J.M.; Smith, A.F. Bayesian theory; Vol. 405, John Wiley & Sons, 2009.
Altman, D.G.; Bland, J.M. Standard deviations and standard errors.
BMJ 2005, 331, 903,
[https://www.bmj.com/content/331/7521/903.full.pdf].
Ellis, P.D. The essential guide to effect sizes: Statistical power, meta-analysis, and the interpretation of
research results; Cambridge University Press, 2010.
Cohen, J. Statistical power analysis for the behavioral sciences; Routledge, 1988.
McGeoch, C.C. A Guide to Experimental Algorithmics, 1st ed.; Cambridge University Press: New York, NY,
USA, 2012.
Rardin, R.L.; Uzsoy, R. Experimental Evaluation of Heuristic Optimization Algorithms: A Tutorial. Journal
of Heuristics 2001, 7, 261–304. doi:10.1023/A:1011319115230.
Sedgewick, R. Implementing quicksort programs. Communications of the ACM 1978, 21, 847–857.
Eppstein, D.; Wang, J. Fast Approximation of Centrality. Proceedings of the Twelfth Annual ACM-SIAM
Symposium on Discrete Algorithms; Society for Industrial and Applied Mathematics: Philadelphia, PA,
USA, 2001; SODA ’01, pp. 228–229.
James, G.; Witten, D.; Hastie, T.; Tibshirani, R. An Introduction to Statistical Learning – with Applications
in R, 2013.
Hinton, G.E. A practical guide to training restricted Boltzmann machines. In Neural networks: Tricks of the
trade; Springer, 2012; pp. 599–619.
Larochelle, H.; Erhan, D.; Courville, A.; Bergstra, J.; Bengio, Y. An empirical evaluation of deep architectures
on problems with many factors of variation. Proceedings of the 24th international conference on Machine
learning. ACM, 2007, pp. 473–480.
LeCun, Y.; Bottou, L.; Bengio, Y.; Haffner, P. Gradient-based learning applied to document recognition.
Proceedings of the IEEE 1998, 86, 2278–2324.
Bergamini, E.; Meyerhenke, H.; Staudt, C.L., Approximating Betweenness Centrality in Large Evolving
Networks. In 2015 Proceedings of the Seventeenth Workshop on Algorithm Engineering and Experiments
(ALENEX); SIAM, 2015; pp. 133–146, [https://epubs.siam.org/doi/pdf/10.1137/1.9781611973754.12].
doi:10.1137/1.9781611973754.12.
Green, O.; McColl, R.; Bader, D.A. A Fast Algorithm for Streaming Betweenness Centrality. Proceedings
of the 2012 ASE/IEEE International Conference on Social Computing and 2012 ASE/IEEE International

Version April 10, 2019 submitted to Algorithms

47.
48.
49.
50.

51.

52.
53.
54.
55.
56.
57.
58.
59.

60.
61.
62.
63.
64.
65.
66.
67.

68.
69.
70.
71.

34 of 38

Conference on Privacy, Security, Risk and Trust; IEEE Computer Society: Washington, DC, USA, 2012;
SOCIALCOM-PASSAT ’12, pp. 11–20. doi:10.1109/SocialCom-PASSAT.2012.37.
Kourtellis, N.; Morales, G.D.F.; Bonchi, F. Scalable Online Betweenness Centrality in Evolving Graphs.
CoRR 2014, abs/1401.6981.
Brandes, U.; Pich, C. Centrality estimation in large networks. INTL. JOURNAL OF BIFURCATION AND
CHAOS, SPECIAL ISSUE ON COMPLEX NETWORKS’ STRUCTURE AND DYNAMICS, 2007.
Bader, D.; Madduri, K. Parallel Algorithms for Evaluating Centrality Indices in Real-world Networks.
Proceedings of the 2006 International Conference on Parallel Processing (ICPP ’06), 2006, pp. 539 – 550.
McLaughlin, A.; Bader, D.A. Scalable and High Performance Betweenness Centrality on the GPU. SC ’14:
Proceedings of the International Conference for High Performance Computing, Networking, Storage and
Analysis, 2014, pp. 572–583. doi:10.1109/SC.2014.52.
Sariyüce, A.E.; Kaya, K.; Saule, E.; Çatalyürek, U.V. Betweenness Centrality on GPUs and Heterogeneous
Architectures. Proceedings of the 6th Workshop on General Purpose Processor Using Graphics Processing
Units; ACM: New York, NY, USA, 2013; GPGPU-6, pp. 76–85. doi:10.1145/2458523.2458531.
Shi, Z.; Zhang, B. Fast network centrality analysis using GPUs. BMC Bioinformatics 2011, 12, 149.
doi:10.1186/1471-2105-12-149.
Crescenzi, P.; D’Angelo, G.; Severini, L.; Velaj, Y. Greedily Improving Our Own Centrality in A Network.
Experimental Algorithms; Bampis, E., Ed.; Springer International Publishing: Cham, 2015; pp. 43–55.
Hennessy, J.L.; Patterson, D.A. Computer architecture: a quantitative approach; Elsevier, 2011.
Bixby, R.E. Solving real-world linear programs: A decade and more of progress. Operations research 2002,
50, 3–15.
Mitchell, D.W. 88.27 more on spreads and non-arithmetic means. The Mathematical Gazette 2004,
88, 142–144.
Smith, J.E. Characterizing Computer Performance with a Single Number. Commun. ACM 1988,
31, 1202–1206. doi:10.1145/63039.63043.
Fleming, P.J.; Wallace, J.J. How Not To Lie With Statistics: The Correct Way To Summarize Benchmark
Results. Commun. ACM 1986, 29, 218–221. doi:10.1145/5666.5673.
AlGhamdi, Z.; Jamour, F.; Skiadopoulos, S.; Kalnis, P. A Benchmark for Betweenness Centrality
Approximation Algorithms on Large Graphs.
Proceedings of the 29th International Conference on
Scientific and Statistical Database Management, Chicago, IL, USA, June 27-29, 2017, 2017, pp. 6:1–6:12.
doi:10.1145/3085504.3085510.
git. git. https://git-scm.com/, 2005.
GitHub. GitHub. https://github.com/, 2007.
GitLab. GitLab. https://gitlab.com/, 2011.
Bitbucket. Bitbucket. https://bitbucket.org/, 2008.
Nethercote, N.; Seward, J. Valgrind: a framework for heavyweight dynamic binary instrumentation. ACM
Sigplan notices. ACM, 2007, Vol. 42, pp. 89–100.
Reinders, J. VTune performance analyzer essentials. Intel Press 2005.
Hamadi, Y.; Wintersteiger, C.M. Seven Challenges in Parallel SAT Solving. Proceedings of the Twenty-Sixth
AAAI Conference on Artificial Intelligence, 2012.
Kimmig, R.; Meyerhenke, H.; Strash, D. Shared Memory Parallel Subgraph Enumeration.
2017
IEEE International Parallel and Distributed Processing Symposium Workshops, IPDPS Workshops 2017,
Orlando / Buena Vista, FL, USA, May 29 - June 2, 2017. IEEE Computer Society, 2017, pp. 519–529.
doi:10.1109/IPDPSW.2017.133.
Goldberg, D. What Every Computer Scientist Should Know About Floating-point Arithmetic. ACM
Comput. Surv. 1991, 23, 5–48. doi:10.1145/103162.103163.
YAML. The YAML Project. https://yaml.org/, 2002.
(DFG), G.R.F., 2010.
JSON. JSON. https://www.json.org/index.html, 2001.

Version April 10, 2019 submitted to Algorithms

72.
73.
74.

75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.

88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.

35 of 38

Anscombe, F.J. Graphs in Statistical Analysis.
The American Statistician 1973, 27, 17–21.
doi:10.1080/00031305.1973.10478966.
Healy, K. Data Visualization: A Practical Introduction; Princeton University Press, 2018.
Sanders, P. Presenting Data from Experiments in Algorithmics. In Experimental Algorithmics; Fleischer, R.;
Moret, B.; Schmidt, E.M., Eds.; Springer-Verlag Berlin Heidelberg, 2002; Vol. 2547, LNCS, chapter 9, pp.
181–196.
Tufte, E.R. The Visual Display of Quantitative Information; Graphics Press, 2001.
Munzner, T. Visualization Analyis and Design; CRC Press, 2014.
Ware, C. Information Visualization: Perception for Design, 3rd ed.; Morgan Kaufmann, 2012.
Anderson, D.R.; Burnham, K.P.; Thompson, W.L. Null hypothesis testing: problems, prevalence, and an
alternative. The journal of wildlife management 2000, pp. 912–923.
Trafimow, D.; Marks, M. Editorial. Basic and Applied Social Psychology 2015, 37, 1–2.
Wasserstein, R.L.; Lazar, N.A. The ASA’s statement on p-values: context, process, and purpose, 2016.
Lash, T.L. The harm done to reproducibility by the culture of null hypothesis significance testing. American
journal of epidemiology 2017, 186, 627–635.
Cumming, G.
The New Statistics: Why and How.
Psychological Science 2014, 25, 7–29,
[https://doi.org/10.1177/0956797613504966]. PMID: 24220629, doi:10.1177/0956797613504966.
Kruschke, J.K.; Liddell, T.M. The Bayesian New Statistics: Hypothesis testing, estimation, meta-analysis,
and power analysis from a Bayesian perspective. Psychonomic Bulletin & Review 2018, 25, 178–206.
Murtaugh, P.A. In defense of P values. Ecology 2014, 95, 611–617.
Box, G.E.P. Science and Statistics. Journal of the American Statistical Association 1976, 71, 791–799.
Pólya, G. Über den zentralen Grenzwertsatz der Wahrscheinlichkeitsrechnung und das Momentenproblem.
Mathematische Zeitschrift 1920, 8, 171–181.
Charnes, A.; Frome, E.L.; Yu, P.L.
The Equivalence of Generalized Least Squares and
Maximum Likelihood Estimates in the Exponential Family.
Journal of the American Statistical
Association 1976, 71, 169–171, [https://www.tandfonline.com/doi/pdf/10.1080/01621459.1976.10481508].
doi:10.1080/01621459.1976.10481508.
Fisher, R.A. Statistical methods for research workers. In Breakthroughs in Statistics; Springer, 1992; pp.
66–70.
Young, G.A.; Smith, R.L.; others. Essentials of statistical inference; Vol. 16, Cambridge University Press,
2005.
Wilcoxon, F. Individual comparisons by ranking methods. Biometrics bulletin 1945, 1, 80–83.
Jones, E.; Oliphant, T.; Peterson, P.; others. SciPy: Open source scientific tools for Python, 2001–. [Online;
accessed <today>].
Dunn, O.J. Multiple comparisons among means. Journal of the American Statistical Association 1961,
56, 52–64.
Holm, S. A Simple Sequentially Rejective Multiple Test Procedure. Scandinavian Journal of Statistics 1979,
6, 65–70.
Smithson, M. Confidence Intervals; SAGE Publications, Inc., 2003.
Neyman, J. Outline of a Theory of Statistical Estimation Based on the Classical Theory of Probability. Phil.
Trans. R. Soc. Lond. A 1937, 236, 333–380.
Gelman, A.; Stern, H.S.; Carlin, J.B.; Dunson, D.B.; Vehtari, A.; Rubin, D.B. Bayesian data analysis;
Chapman and Hall/CRC, 2013.
Salvatier, J.; Wiecki, T.V.; Fonnesbeck, C. Probabilistic programming in Python using PyMC3. PeerJ
Computer Science 2016, 2, e55.
Akaike, H. A new look at the statistical model identification. IEEE Transactions on Automatic Control
1974, 19, 716–723. doi:10.1109/TAC.1974.1100705.
Barr, R.S. Designing and Reporting on Computational Experiments with Heuristic Methods; Technical report,
Department of Computer Science and Engineering, Southern Methodist University, 1995.

Version April 10, 2019 submitted to Algorithms

100.
101.
102.
103.
104.
105.
106.
107.
108.
109.

110.
111.
112.
113.
114.
115.

116.

117.
118.
119.

120.
121.

36 of 38

Moret, B.M.E.; Shapiro, H.D.D. Algorithms and Experiments: The New (and Old) Methodology. j-jucs
2001, 7, 434–446.
Gent, I.P.; Grant, S.A.; MacIntyre, E.; Prosser, P.; Shaw, P.; Smith, B.M.; Walsh, T. How Not To Do It.
Research Report 97.27 (School of Computer Studies, University of Leeds) 1997.
McGeoch, C.C.; Moret, B.M.E. How to present a paper on experimental work with algorithms. SIGACT
News 1999, 30, 85–90.
McGeoch, C.C. Toward an Experimental Method for Algorithm Simulation. INFORMS Journal on
Computing 1996, 8, 1–15.
McGeoch, C.C. Analyzing Algorithms by Simulation: Variance Reduction Techniques and Simulation
Speedups. ACM Comput. Surv. 1992, 24, 195–212. doi:10.1145/130844.130853.
Council, N.R. Network Science; The National Academies Press: Washington, DC, 2005. doi:10.17226/11516.
Hanks, S.; Pollack, M.E.; Cohen, P.R. Benchmarks, Test Beds, Controlled Experimentation, and the Design
of Agent Architectures. AI Magazine 1993, 14, 17–42.
Cohen, P.R. Empirical Methods for Artificial Intelligence; MIT Press: Cambridge, MA, USA, 1995.
Eckles, D.; Brian, K.; Johan, U. Design and Analysis of Experiments in Networks: Reducing Bias from
Interference. Journal of Causal Inference 2017, 5.
Gui, H.; Xu, Y.; Bhasin, A.; Han, J. Network A/B Testing: From Sampling to Estimation. Proceedings
of the 24th International Conference on World Wide Web; International World Wide Web Conferences
Steering Committee: Republic and Canton of Geneva, Switzerland, 2015; WWW ’15, pp. 399–409.
doi:10.1145/2736277.2741081.
Jensen, D.D.; Cohen, P.R. Multiple comparisons in induction algorithms. Machine Learning 2000,
38, 309–338.
Kuhn, M.; Johnson, K. Applied predictive modeling; Vol. 26, Springer, 2013.
Funke, D.; Sanders, P. Parallel d-D Delaunay Triangulations in Shared and Distributed Memory. ALENEX.
SIAM, 2017, pp. 207–217.
Booth, A.; Papaioannou, D.; Sutton, A. Systematic Approaches to a Successful Literature Review; SAGE
Publications, 2012.
Keshav, S. How to Read a Paper.
SIGCOMM Comput. Commun. Rev. 2007, 37, 83–84.
doi:10.1145/1273445.1273458.
Kaijanaho, A.J. Teaching Master’s Degree Students to Read Research Literature: Experience in a
Programming Languages Course 2002–2017. Proceedings of the 17th Koli Calling International Conference
on Computing Education Research; ACM: New York, NY, USA, 2017; Koli Calling ’17, pp. 143–147.
doi:10.1145/3141880.3141893.
Garousi, V.; Felderer, M. Experience-based Guidelines for Effective and Efficient Data Extraction in
Systematic Reviews in Software Engineering. Proceedings of the 21st International Conference on Evaluation
and Assessment in Software Engineering; ACM: New York, NY, USA, 2017; EASE’17, pp. 170–179.
doi:10.1145/3084226.3084238.
Brooks, A. Searching and Reviewing the Computer Science Literature: A Guide for Research Students, 1990.
Karger, D.R.; Stein, C. A new approach to the minimum cut problem. Journal of the ACM (JACM) 1996,
43, 601–640.
Brandes, U.; Delling, D.; Gaertler, M.; Görke, R.; Hoefer, M.; Nikoloski, Z.; Wagner, D. On Finding Graph
Clusterings with Maximum Modularity. Proceedings of the 33rd International Conference on Graph-theoretic
Concepts in Computer Science; Springer-Verlag: Berlin, Heidelberg, 2007; WG’07, pp. 121–132.
Hijazi, H.L.; Bonami, P.; Cornuéjols, G.; Ouorou, A. Mixed Integer NonLinear Programs featuring "On/Off"
constraints: convex analysis and applications. Electronic Notes in Discrete Mathematics 2010, 36, 1153–1160.
Morey, R.D.; Hoekstra, R.; Rouder, J.N.; Lee, M.D.; Wagenmakers, E.J. The fallacy of placing confidence in
confidence intervals. Psychonomic bulletin & review 2016, 23, 103–123.

Version April 10, 2019 submitted to Algorithms

122.

123.
124.

125.
126.
127.
128.
129.
130.
131.
132.
133.
134.
135.
136.
137.
138.
139.
140.
141.
142.
143.
144.
145.
146.

147.
148.

37 of 38

Greenland, S.; Senn, S.J.; Rothman, K.J.; Carlin, J.B.; Poole, C.; Goodman, S.N.; Altman, D.G. Statistical
tests, P values, confidence intervals, and power: a guide to misinterpretations. European journal of
epidemiology 2016, 31, 337–350.
Ioannidis, J.P. Why most published research findings are false. PLoS medicine 2005, 2, e124.
Tukey, J.W.
We Need Both Exploratory and Confirmatory.
The American Statistician
1980,
34,
23–25,
[https://amstat.tandfonline.com/doi/pdf/10.1080/00031305.1980.10482706].
doi:10.1080/00031305.1980.10482706.
Amdahl, G.M. Validity of the single processor approach to achieving large scale computing capabilities.
Proceedings of the April 18-20, 1967, spring joint computer conference. ACM, 1967, pp. 483–485.
Gustafson, J.L. Reevaluating Amdahl’s law. Communications of the ACM 1988, 31, 532–533.
Shi, Y. Reevaluating Amdahl’s law and Gustafson’s law. Computer Sciences Department, Temple University
(MS: 38-24) 1996.
Costa, L.d.F.; Rodrigues, F.A.; Travieso, G.; Villas Boas, P.R. Characterization of complex networks: A
survey of measurements. Advances in physics 2007, 56, 167–242.
Kim, J.; Wilhelm, T. What is a complex graph? Physica A: Statistical Mechanics and its Applications 2008,
387, 2637–2652.
Boccaletti, S.; Latora, V.; Moreno, Y.; Chavez, M.; Hwang, D.U. Complex networks: Structure and dynamics.
Physics reports 2006, 424, 175–308.
Watts, D.J.; Strogatz, S.H. Collective dynamics of ‘small-world’networks. nature 1998, 393, 440.
Barabási, A.L.; Albert, R. Emergence of scaling in random networks. science 1999, 286, 509–512.
Newman, M.E. Assortative mixing in networks. Physical review letters 2002, 89, 208701.
Milo, R.; Shen-Orr, S.; Itzkovitz, S.; Kashtan, N.; Chklovskii, D.; Alon, U. Network motifs: simple building
blocks of complex networks. Science 2002, 298, 824–827.
Newman, M.E. Modularity and community structure in networks. Proceedings of the national academy of
sciences 2006, 103, 8577–8582.
Barabási, A.L.; Bonabeau, E. Scale-free networks. Scientific american 2003, 288, 60–69.
Amaral, L.A.N.; Scala, A.; Barthelemy, M.; Stanley, H.E. Classes of small-world networks. Proceedings of
the national academy of sciences 2000, 97, 11149–11152.
Sedgewick, R. The analysis of quicksort programs. Acta Informatica 1977, 7, 327–355.
Easley, D.; Kleinberg, J. Networks, crowds, and markets: Reasoning about a highly connected world;
Cambridge University Press, 2010.
Bavelas, A. A mathematical model for group structures. Applied anthropology 1948, 7, 16–30.
Shimbel, A. Structural parameters of communication networks. The bulletin of mathematical biophysics
1953, 15, 501–507.
Shaw, M.E. Group structure and the behavior of individuals in small groups. The Journal of psychology
1954, 38, 139–149.
Cohn, B.S.; Marriott, M. Networks and centres of integration in Indian civilization. Journal of social
Research 1958, 1, 1–9.
Borgatti, S.P.; Everett, M.G. A graph-theoretic perspective on centrality. Social networks 2006, 28, 466–484.
Chung, F.; Chung, F.R.; Graham, F.C.; Lu, L.; Chung, K.F.; others. Complex graphs and networks;
American Mathematical Soc., 2006.
Lü, J.; Chen, G.; Ogorzalek, M.J.; Trajković, L. Theory and applications of complex networks: Advances
and challenges. Circuits and Systems (ISCAS), 2013 IEEE International Symposium on. IEEE, 2013, pp.
2291–2294.
Clauset, A.; Shalizi, C.R.; Newman, M.E. Power-law distributions in empirical data. SIAM review 2009,
51, 661–703.
Fan, R.; Xu, K.; Zhao, J. A GPU-Based Solution to Fast Calculation of Betweenness Centrality on Large
Weighted Networks. PeerJ Computer Science 2017, 3.

Version April 10, 2019 submitted to Algorithms

149.

150.

151.

152.
153.
154.
155.
156.
157.
158.
159.
160.
161.
162.
163.

164.
165.

38 of 38

D’Angelo, G.; Severini, L.; Velaj, Y. On the Maximum Betweenness Improvement Problem. Electronic
Notes in Theoretical Computer Science 2016, 322, 153 – 168. Proceedings of ICTCS 2015, the 16th Italian
Conference on Theoretical Computer Science, doi:https://doi.org/10.1016/j.entcs.2016.03.011.
Jacob, R.; Koschützki, D.; Lehmann, K.A.; Peeters, L.; Tenfelde-Podehl, D., Algorithms for Centrality
Indices. In Network Analysis: Methodological Foundations; Springer Berlin Heidelberg: Berlin, Heidelberg,
2005; pp. 62–82. doi:10.1007/978-3-540-31955-9_4.
Hong, C.T.; Chen, D.H.; Chen, Y.B.; Chen, W.G.; Zheng, W.M.; Lin, H.B. Providing Source Code Level
Portability Between CPU and GPU with MapCG. Journal of Computer Science and Technology 2012,
27, 42–56. doi:10.1007/s11390-012-1205-4.
Hayashi, T.; Akiba, T.; Yoshida, Y. Fully Dynamic Betweenness Centrality Maintenance on Massive Networks.
Proc. VLDB Endow. 2015, 9, 48–59. doi:10.14778/2850578.2850580.
Nemhauser, G.L.; Wolsey, L.A. Best algorithms for approximating the maximum of a submodular set
function. Mathematics of operations research 1978, 3, 177–188.
Chacon, S.; Straub, B. Pro Git, 2nd ed.; Apress: Berkely, CA, USA, 2014.
R Core Team. R-project. https://www.r-project.org/, 1993.
R Core Team. R: A Language and Environment for Statistical Computing. R Foundation for Statistical
Computing, Vienna, Austria, 2012. ISBN 3-900051-07-0.
Williams, T.; Kelley, C. gnuplot. https://www.r-project.org/, 1986.
Hunter, J.D. Matplotlib: A 2D graphics environment. Computing In Science & Engineering 2007, 9, 90–95.
doi:10.1109/MCSE.2007.55.
The MathWorks, Inc.. Matlab 8.0. https://www.mathworks.com/products/matlab.html, 1984.
Cox, D.R. Principles of statistical inference; Cambridge university press, 2006.
Cox, N.J. Stata tip 96: Cube roots. Stata Journal 2011, 11, 149–154(6).
Demsar, J. Statistical Comparisons of Classifiers over Multiple Data Sets. Journal of Machine Learning
Research 2006, 7, 1–30.
García, S.; Fernández, A.; Luengo, J.; Herrera, F. Advanced nonparametric tests for multiple comparisons in
the design of experiments in computational intelligence and data mining: Experimental analysis of power.
Inf. Sci. 2010, 180, 2044–2064. doi:10.1016/j.ins.2009.12.010.
Garcia, S.; Herrera, F. An extension on“statistical comparisons of classifiers over multiple data sets”for all
pairwise comparisons. Journal of Machine Learning Research 2008, 9, 2677–2694.
Knuth, D.E. The art of computer programming; Vol. 3, Pearson Education, 1997.

c 2019 by the authors. Submitted to Algorithms for possible open access publication under the terms and
conditions of the Creative Commons Attribution (CC BY) license (http://creativecommons.org/licenses/by/4.0/).

