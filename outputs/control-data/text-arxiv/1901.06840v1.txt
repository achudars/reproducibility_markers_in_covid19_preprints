Anchor-Based Correction of Substitutions
in Indexed Sets
Andreas Lenz‚àó, Paul H. Siegel‚Ä† , Antonia Wachter-Zeh‚àó, and Eitan Yaakobi‚Ä°
‚àó Institute

for Communications Engineering, Technical University of Munich, Germany
of Electrical and Computer Engineering, CMRR, University of California, San Diego, California
‚Ä° Computer Science Department, Technion ‚Äì Israel Institute of Technology, Haifa, Israel
Emails: andreas.lenz@mytum.de, psiegel@ucsd.edu, antonia.wachter-zeh@tum.de, yaakobi@cs.technion.ac.il

arXiv:1901.06840v1 [cs.IT] 21 Jan 2019

‚Ä† Department

Abstract‚ÄîMotivated by DNA-based data storage, we investigate a system where digital information is stored in an unordered
set of several vectors over a finite alphabet. Each vector begins
with a unique index that represents its position in the whole data
set and does not contain data. This paper deals with the design
of error-correcting codes for such indexed sets in the presence
of substitution errors. We propose a construction that efficiently
deals with the challenges that arise when designing codes for
unordered sets. Using a novel mechanism, called anchoring, we
show that it is possible to combat the ordering loss of sequences
with only a small amount of redundancy, which allows to use
standard coding techniques, such as tensor-product codes to
correct errors within the sequences. We finally derive upper and
lower bounds on the achievable redundancy of codes within the
considered channel model and verify that our construction yields
a redundancy that is close to the best possible achievable one.
Our results surprisingly indicate that it requires less redundancy
to correct errors in the indices than in the data part of vectors.

adenine (A), cytosine (C), guanine (G), and thymine (T). Single DNA strands can be synthesized chemically and modern
DNA synthesizers can concatenate the four DNA nucleotides
to form almost any possible sequence. This process enables
the storage of digital data in DNA. The data can be read back
with common DNA sequencers, while the most popular ones
use DNA polymerase enzymes.

Consider a system where digital information is embodied
in an unordered set of vectors and each vector holds a share
of the whole data set. To combat the unordered nature of the
data storage, such systems almost exclusively rely on indices,
which are prepended to each vector and denote the position of
that vector in the data set. An important example for a modern
communication system of such a type is internet routing,
where data is split into packets and transmitted over a network.
Since packets can have different propagation times over the
network, they might be received in a different order and hence
the ordering of the packets is lost. Another important example
for such a system is deoxyribonucleic acid (DNA)-based data
storage, which is the main focus of this paper.
Data storage in DNA is a novel technology that, due to
recent advancements in biochemical mechanisms of synthesizing and sequencing DNA molecules, has advanced to be
a highly competitive candidate for long-term archival storage
of digital data. This is since DNA-based storage has several
important features that stand out with respect to conventional
digital data storage systems, such as tapes and hard disk drives.
These include outstandingly high data densities and longterm robustness. Due to its chemical structure, from a coding
theoretic point of view, DNA can be seen as a vector over
symbols {A,C,G,T}, which abbreviate the four nucleotides

Using DNA as a storage medium for digital data was
envisioned by Feynman in his famous speech ‚ÄúThere‚Äôs plenty
of room at the bottom‚Äù and also by Baum [1]. It took
several decades until first experiments of Church et al. [4]
and later Goldman et al. [6] demonstrated the viability of
in vitro DNA storage on a large scale. In the next years,
many experiments followed, including Grass et al. [7] who
successfully employed error-correcting codes to recover the
data. Since then, several more groups have elaborated the
methods, storing ever larger amounts of data. For example,
Erlich and Zielinski [5] stored 2.11MB of data in DNA, Blawat
et al. [2] recovered a data archive of 22MB, and Organick
et al. [12] stored 200MB of digital information. Yazdi et
al. [20] developed a method that offers random read access and
rewritable storage using constrained codes. On the other hand,
coding theoretic aspects of DNA storage systems have received
significant attention recently. The work of [9] discusses errorcorrecting codes for the DNA sequencing channel, where a
possibly erroneous collection of substrings of the original
strand is obtained. Codes over unordered sets of sequences,
where sequences are affected by a certain number of point
errors, such as insertions, deletions and substitutions, have
been discussed in [11], [15], [16]. In [15], codes and bounds
for a given number of substitutions have been proposed, which
require a redundancy that is both logarithmic in the number of
sequences and the length of the sequences. Based on a slight
adaptation of the model in [11], the sequence-subset distance
has been introduced and analyzed in [16] and Singleton-like
and Plotkin-like code size upper bounds have been derived.
In contrast, [10] proposes codes for errors that affect whole
strands in a storage system that stores multiset of sequences.
Recently, codes that can be equipped as primer addresses have
been proposed in [18], [3]. A comprehensive survey for DNAbased storage can be found in [19].

This work was done in part while A. Lenz was visiting the computer science
faculty of Technion ‚Äì Israel Institute of Technology, Israel. This work was
supported by the Institute for Advanced Study (IAS), Technische UniversitaÃàt
MuÃànchen (TUM), with funds from the German Excellence Initiative and the
European Union‚Äôs Seventh Framework Program (FP7) under grant agreement
no. 291763. This work was also supported by NSF Grant CCF-BSF-1619053
and by the United States-Israel BSF grant 2015816.

From an information theoretic point of view DNA is fundamentally different than other storage media due to the fact
that all information about the ordering of the DNA strands
is lost during synthesis. One efficient and practical way to
circumvent this limitation is to prepend an index to each strand
that denotes the position of the strand in the archive. However,

I. I NTRODUCTION

Index

Data

x1

1

u1

x‚Ä≤1

4

u‚Ä≤1

x2

2

u2

x2

2

u2

Perturb x2

2

u2

x‚Ä≤5

1

u‚Ä≤5

Permute

..
.
xM

M

..
.

..
.
uM

x‚Ä≤M

7

u‚Ä≤M

x‚Ä≤M

7

u‚Ä≤M

Fig. 1. Channel model for information storage in indexed sets. First, some sequences xi are perturbed by substitution errors, resulting in x‚Ä≤i = xi + ei .
Afterwards, the sequences can be permuted arbitrarily and hence all inherent information about their ordering is lost. Since the indices can be erroneous, too,
it is not necessarily directly possible to reconstruct their ordering.

due to errors during synthesis or sequencing, these indices
might be erroneous when reading the archive. A naive solution
to combat these errors is to protect each index by an errorcorrecting code. Such an approach however already incurs a
redundancy that grows linearly with the number of strands,
which is suboptimal, especially for the practically important
case, when not all sequences contain errors. In this paper we
will analyze the approach of indexing sequences in the presence of errors inside the strands. We propose constructions that
efficiently cope with these errors and only have a redundancy
that is logarithmic in both the number and length of sequences.
Note that the employment of indices is not a necessity and the
more general setup of storing an arbitrary set of sequences has
been analyzed in [11]. However, the discussion of indexedbased schemes is practically important due to its simplicity.
In this work we study only substitution errors, while insertion
and deletion errors are deferred for future work. Also, we
present our results for the binary case, while the extension to
non-binary alphabets is straightforward.
II. C HANNEL M ODEL
In this work we study a system where user data is stored
in an indexed set S = {x1 , . . . , xM } of M unordered vectors
x i ‚àà Œ£L
2 , where i ‚àà [M ] , {1, 2, . . . , M } and Œ£2 = {0, 1}.
The vectors are also called sequences or strands in reference
to the DNA-based storage system. Hereby, each vector xi has
the same length L. Throughout the paper, we use that M =
2Œ≤L for some 0 < Œ≤ < 1 such that Œ≤L ‚àà N is an integer.
Mathematically, an indexed set is characterized as
S = {(I(1), u1 ), (I(2), u2 ), . . . , (I(M ), uM )} ‚äÜ Œ£L
2,
with sequences xi = (I(i), ui ) ‚àà Œ£L
2 . Each sequence hereby
M
consists of two parts. It begins with a prefix I(i) ‚àà Œ£log
,
2
also referred to as index, of length log M . This prefix is a
unique binary representation of the index i and designates
the position of this specific sequence in the data set S.
Note that in general it is possible to use any bijective map
M
I(i) : {1, . . . , M } 7‚Üí Œ£log
as index, however in practice
2
this map is usually realized by a standard decimal to binary
conversion. The second part of each sequence, ui ‚àà Œ£2L‚àílog M ,
will be referred to as the data part of a sequence and can be
filled arbitrarily by either user information or redundancy from
an error-correcting code, as illustrated later. For convenience,
we will abbreviate LM , L ‚àí log M throughout the paper.
The set of all indexed data sets is


S = {(I(1), u1 ), (I(2), u2 ), . . . , (I(M ), uM )} :
L
,
IM =
M
ui ‚àà Œ£L
‚àÄ i = 1, . . . , M
2

L
L
and their total number is |IM
| = 2MLM . Therefore, IM
denotes all feasible channel inputs of the channel, when using
indexed sets. The stored set can be corrupted by substitution
errors, caused by, e.g., synthesis or sequencing errors and
we model the errors by a channel that takes an indexed set
L
S ‚àà IM
as input and outputs an erroneous outcome of this set
based on the following procedure as visualized in Fig. 1. When
L
an indexed data set S = {x1 , . . . , xM } ‚àà IM
has been stored,
M ‚àít strands are read correctly and t strands are read in error.
These sequences result from clustering and reconstructing a
large number of sequences, which has been illustrated and discussed in [12], [11]. Denote by F = {f1 , f2 , . . . , ft } ‚äÜ [M ]
with 1 ‚â§ f1 < f2 < ¬∑ ¬∑ ¬∑ < ft ‚â§ M the ordered indices of the
sequences that are received in error and ef1 , . . . , eft ‚àà Œ£L
2
the corresponding error patterns. The index I(i) of each
erroneous sequence xi , i ‚àà F is affected by at most «´1
substitution errors and the data part ui is affected by at most
«´2 substitutions. Therefore, each error vector is composed of
two parts efi = (eIfi , eD
fi ) of lengths log M and LM , with
Hamming weights wt(eIfi ) ‚â§ «´1 and wt(eD
fi ) ‚â§ «´2 for all
i ‚àà [t]. The received set S ‚Ä≤ ‚äÜ Œ£L
can
then
be
written as
2
M 
[
xi ,
if i ‚àà
/ F,
.
S‚Ä≤ =
xi + ei , if i ‚àà F
i=1

Throughout the paper the (t, «´1 , «´2 )-channel will refer to the
L
entity which, given an input set S ‚àà IM
, outputs a received
‚Ä≤
set S resulting from arbitrary F and ef1 , . . . , eft as described
above. This set of all possible channel outputs is denoted by
B(S). Note that when there are errors in the indices, the erroneous sequences x‚Ä≤fj , xfj + efj , j ‚àà [t] are not necessarily
distinct from each other or from the error-free sequences and
in this case these sequences adjoin and appear as a single
sequence at the receiver. Therefore the number of received
sequences can be less than M , i.e., M ‚àí t ‚â§ |S ‚Ä≤ | ‚â§ M . In
L
particular here it is also possible that the received set S ‚Ä≤ ‚àà
/ IM
,
since some indices might not be present in the received set or
others might appear multiple times. Another particularity of
the channel is that different error patterns F and ef1 , . . . , eft
might lead to the same channel output S ‚Ä≤ . We will use the
following standard definition of an error-correcting code.
L
Definition 1 ((t, «´1 , «´2 )-indexed-set code). A code C ‚äÜ IM
is called a (t, «´1 , «´2 )-indexed-set code, if B(S1 ) ‚à© B(S2 ) = ‚àÖ
for every pair S1 , S2 ‚àà C with S1 6= S2 . Accordingly, the
L
is defined to be
redundancy of an indexed-set code C ‚äÜ IM

r(C) = M LM ‚àí log |C|.

By this definition, an indexed-set code is a set of codewords
Index
Anchor
TPC
for which, for each channel output S ‚Ä≤ ‚äÜ Œ£L
2 , there exists at
most one codeword which could have resulted in this exact
x1
a1
v1
1
channel output S ‚Ä≤ . Note that here, each codeword is not a
vector, as in the standard channel coding problem, but a set of
x2
a2
v2
2
indexed vectors. In this paper, we distinguish between errors
..
in the index of sequences and data part of the sequences due
.
to the following reasons. It is observed that the sequencing
aM‚àír2
v M‚àír2
xM‚àír2 M ‚àí r2
error rates at the beginning of DNA strands are lower with
several sequencing technologies [5], [8], [12]. Second, from xM‚àír +1 M‚àír +1 aM‚àír +1
v M‚àír2 +1
2
2
2
a theoretical point of view, errors inside the indices have a
..
different character than those in the data part, as they do
.
r2
not affect data directly but hinder the correct identification
xM‚àí1 M ‚àí 1
aM‚àí1
v M‚àí1
of the strand order. We will also elaborate in this paper that
the redundancy required to correct errors in the indices is
xM
aM
vM
M
significantly smaller than that in the data part of sequences.
Finally, the channel model is strongly connected to the more
r1
log M
l
general model presented in [11] as follows.
1) Each (0, t, «´)S -correcting code [11] is a (t, «´1 , «´2 )L
indexed-set code, if «´1 + «´2 ‚â§ «´.
Fig. 2. Schematic of Construction 1
2) Each (t, «´1 , «´2 )-indexed-set code is a (0, t, «´)S -correcting
require only one bit of redundancy and can be encoded and
code [11], if «´ ‚â§ min(«´1 , «´2 ).
decoded efficiently can be found in [14]. The anchoring propIII. C ONSTRUCTION
erty will be used to reconstruct the ordering of the sequences.
Finding codes that can correct errors from the DNA-storage After the ordering of sequences is restored, it is possible to
channel, one faces two main challenges that have to be tackled. correct the errors in the sequences using tensor-product codes
To begin with, substitution errors that are solely in the data part [17], which are defined as follows.
of the sequences can be corrected by standard error-correcting Definition 3 (Tensor-product code). Let C ‚äÜ Œ£ be a linear
1
2
schemes, such as tensor-product codes [17], which we will [L , L ‚àí r , «´ ] binary «´ -error-correcting code of length
M
M
1 2
2
discuss in more detail later. However, errors in the indices of L , redundancy r and parity-check matrix H ‚àà Œ£r1 √óLM
M
1
1
2
sequences will corrupt the ordering of the sequences, which and let C ‚äÜ Œ£ r1 be a linear [M, M ‚àí r , t] code over the
2
2
2
hinders the direct employment of tensor-product codes. We field Œ£ r1 . The tensor-product code is then defined to be
2
therefore will construct a code that first enables to reconstruct


M
(u1 , . . . , uM ) ‚àà Œ£ML
:
2
the correct ordering of the sequences using so called anchors,
TPC(t, «´2 ) =
,
(s1 , . . . , sM ) ‚àà C2
and then uses a tensor-product code to correct the errors in the
data part of the sequences. The anchors are defined as follows. where si = ui H T are syndromes whose equivalents in
1
Definition 2 (Anchor). Let l, t, «´1 , «´2 ‚àà N and a1 , . . . , aM ‚àà the finite field Œ£2r1 form a codeword of C2 . The overall
Œ£l2 be M vectors of length l with 2l ‚â• M . Further, denote redundancy of the tensor-product code is r1 r2 bits.
by MDS[M, 2t] a maximum-distance-separable (MDS) code
Correcting errors using the tensor-product code is done as
of length M and redundancy 2t over the field Œ£2l . The set of follows [17]. Assume the word U = (u‚Ä≤ , . . . , u‚Ä≤ ) is received,
1
M
anchor vectors A(l, t, «´1 , «´2 ) is defined to be
where at most t vectors u‚Ä≤i have been affected by at most «´2
Ô£±
Ô£º
errors each. The receiver first computes the syndromes s‚Ä≤i =
Ô£≤ (a1 , . . . , aM ) ‚àà Œ£Ml
2 : ‚àÄi, j ‚àà[M ], i 6= j : Ô£Ω
T
‚Ä≤
A(l, t, «´1 , «´2 )= d(ai , aj ) > 2«´2 , if d(I(i), I(j)) ‚â§ 2«´1 ,
. ui H 1 of all vectors. Since there are at most t syndromes
Ô£≥
Ô£æ corrupted, the correct syndromes si can be recovered using
(a1 , . . . , aM ) ‚àà MDS[M, 2t]
the code C2 . Now, in each row, «´2 errors can be corrected
That is, if the indices I(i), I(j) of two vectors ai , aj have using the knowledge of the correct syndrome s and the code
i
distance at most 2«´1 , the vectors have distance more than 2«´2 . C . Combining the anchoring property with the tensor-product
1
Further, the equivalents of the vectors a1 , . . . , aM in Œ£2l are code leads to the following construction.
a codeword of an MDS code with minimum distance 2t + 1.
Construction 1. Let l, t, «´1 , «´2 ‚àà N with l ‚â• log M . Further,
This definition implies that the anchor vectors have both TPC(t, «´ ) denotes a tensor-product code over an array of
2
a large intra-anchor distance between vectors of one anchor size M √ó L . We define the construction C ‚äÜ I L as
M
A
M
Ô£±
Ô£º
and a large inter-anchor distance between two anchors due to
S
=
{(I(1),
a
,
v
),
.
.
.
,
(I(M
),
a
,
v
Ô£≤
1
1
M
M )} : Ô£Ω
the MDS code. Note that for 2«´1 = log M and t = 0 this
(a1 , . . . , aM ) ‚àà A(l, t, «´1 , «´2 ),
CA =
.
definition is equivalent to a standard error-correcting code,
Ô£≥
Ô£æ
((a
,
v
),
.
.
.
,
(a
,
v
))
‚àà
TPC(t,
«´
)
1
1
M
M
2
which corrects «´2 errors. The redundancy required to force
Note that with this construction, the anchors a1 , . . . , aM
such a constraint on a collection of vectors will be calculated
later. For the case of t = 0, the set A(l, 0, «´1 , «´2 ) is called can also contain user data. The correctness of Construction 1
clustering-correcting code, and explicit constructions which and its decoding algorithm are presented in the following.

Lemma 1. Construction 1 is a (t, «´1 , «´2 )-indexed-set code.
Proof. We will prove the correctness of Construction 1 by
providing an algorithm that can be used to correct errors from
the (t, «´1 , «´2 )-channel. The decoding algorithm can be split
into the following two steps.
1) Retrieve the correct order of sequences using the anchoring property of a1 , . . . , aM .
2) Correct errors inside the sequences using the tensorproduct code TPC(t, «´2 ).
Assume S = {x1 , . . . , xM } ‚àà CA has been stored and S ‚Ä≤ =
{x‚Ä≤1 , . . . , x‚Ä≤M } ‚àà B(S) has been received after transmission
over a (t, «´1 , «´2 )-channel. We will write x‚Ä≤i = (I(i‚Ä≤ ), a‚Ä≤i , v ‚Ä≤i ),
which is either x‚Ä≤i = xi , if the sequence was received correctly,
i.e., i ‚àà
/ F , or x‚Ä≤i = xi + ei , if the sequence was received in
error, i.e., i ‚àà F . This correct ordering of received sequences is
however only used to simplify notation and is not known to the
receiver, as the indices I(i‚Ä≤ ) can be erroneous. Note that due
to the anchoring property, it is guaranteed that an erroneous
sequence can never adjoin with another sequence and therefore
|S ‚Ä≤ | = M . The anchors can be fully recovered using their
MDS property as follows. Declare all positions i ‚àà [M ], where
there is not exactly one index present, i.e., i : |{j : I(j ‚Ä≤ ) =
I(i)}| 6= 1 as erasures, and fill all remaining positions with the
corresponding anchors a‚Ä≤i . Although some anchors might have
the wrong position, decoding the resulting vector of length M
with a unique decoding algorithm yields the correct anchors
a1 , . . . , aM (cf. [11, Con. 1]). Using the anchors, it is possible
to assign each sequence x‚Ä≤j to its correct position i by finding
the single sequence x‚Ä≤j ‚àà S ‚Ä≤ with d(I(i), I(j ‚Ä≤ )) ‚â§ «´1 and
d(ai , a‚Ä≤j ) ‚â§ «´2 . There is exactly one sequence j = i with
that property. Assume on the contrary, there is more than
one sequence (apart from the correct sequence x‚Ä≤i ), which
fulfills this property. Then, there would be a sequence x‚Ä≤j ,
j 6= i with d(I(i), I(j ‚Ä≤ )) ‚â§ «´1 and d(ai , a‚Ä≤j ) ‚â§ «´2 , which
implies that d(I(i), I(j)) ‚â§ 2«´1 and also d(ai , aj ) ‚â§ 2«´2 ,
which contradicts the anchoring property. We therefore can
reconstruct the array ((a‚Ä≤1 , v ‚Ä≤1 ), . . . , (a‚Ä≤M , v ‚Ä≤M )) in the correct
order. Since each row (a‚Ä≤1 , v ‚Ä≤1 ) has at most «´2 errors, these
errors can be corrected using the tensor-product code, which
completes the proof of the correctness of Construction 1.
The redundancy of Construction 1 can be decomposed into
the redundancy required for the anchoring property and the
redundancy of the tensor-product code and is given as follows.
Theorem 1. For any t, «´1 , «´2 the redundancy of CA is
r(CA ) = rA + r1 r2 ,
where rA = 2tl ‚àí M log(1 ‚àí 2‚àílB2«´1 (log M )B2«´2 (l)). Therefore, for fixed t, «´1 , «´2 , and arbitrary small Œ¥ > 0, for M ‚Üí ‚àû
there exists an explicit construction CA with redundancy
r(CA ) ‚â§ (4t + 2Œ¥) log M + 2t«´2 ‚åàlog LM ‚åâ + 1 + o(1).
Proof. From the cardinality of clustering-correcting codes [14]
and the fact that the MDS code with redundancy 2t has 22tl
cosets, there exists one coset of the MDS code with
|A(l, t, «´1 , «´2 )| ‚â•

1
(2l ‚àí B2«´1 (log M )B2«´2 (l))M
22tl

by the pigeonhole principle. From this follows the redundancy
rA required for the anchoring property. Next, the redundancy
of the tensor-product codes is r1 r2 . Using alternant codes [13,
ch. 5] C1 and C2 , we obtain redundancies r1 = «´2 ‚åàlog LM ‚åâ
and r2 = 2t‚åà logr1M ‚åâ, if r1 ‚â§ log M and r2 = 2t, otherwise.
Using l = (1 + Œ¥) log M yields rA = 2t(1 + Œ¥) log M + o(1)
and the asymptotic bound follows.
Note that for t = 1, the construction can be improved
by using a Hamming code for C2 and an MDS[M, 1] code
with redundancy 1 for the anchors is sufficient, which yields
a redundancy of approximately 2 log M + «´2 log LM + o(1).
IV. S PHERE PACKING B OUND
The derivation of the sphere packing bound is based on the
L
sets B(S) of possible outputs of the channel, when S ‚àà IM
is the input. The bound is derived by using the fact that B(S)
must be distinct for different codewords S to guarantee unique
decoding to one codeword. In this and the following section,
we will abbreviate
Pn the size of the Hamming ball of radius r
by Br (n) , i=0 ni . The main result is as follows.

Theorem 2. The cardinality of any (t, «´1 , «´2 )-indexed-set code
L
C ‚äÜ IM
is at most
|C| ‚â§

2MLM
.

M
t
t (B«´2 (LM ) ‚àí 1)

Therefore, the redundancy is at least

r(C) ‚â• t log M + t«´2 log(LM ) ‚àí t log(t«´«´22 ).
L
Proof. Let C ‚äÜ IM
be a (t, «´1 , «´2 )-indexed-set code. We
consider first the case that «´1 = 0, i.e., there are only
errors outside the indices and therefore all erroneous outL
comes S ‚Ä≤ ‚àà B(S) ‚à© IM
are again indexed sets. Due to
L
the distinctness of error balls, every code C ‚äÜ IM
satisfies
L
L
|C| ¬∑ minS‚ààIM
L |B(S) ‚à© I
|
‚â§
|I
|.
Using
this
inequality
M
M
we bound the code size |C| from above. Specifically, for
L
all S ‚àà IM
, we bound the number of erroneous outcomes
L
|B(S)‚à©IM | which are again indexed sets from below. Distinct
L
elements S ‚Ä≤ ‚àà B(S) ‚à© IM
are obtained as follows. For «´1 = 0
the indices of each sequence can be omitted and the stored set
can be viewed as a binary array of M rows and LM columns,
where each row corresponds to one sequence. The number of
possible error patterns is therefore
 
M
L
|B(S) ‚à© IM
|‚â•
(B«´2 (LM ) ‚àí 1)t ,
t

as there are Mt ways to choose the erroneous rows and
B«´2 (LM ) ‚àí 1 possible substitution patterns per row. Finally,
the case «´1 = 0 is a special case of «´1 > 0, as there are up
to «´1 errors inside the indices and thus the above bound also
holds for arbitrary «´1 > 0 which concludes the proof.

Note that by the definition of the channel it is possible that
errors occur in the index of a sequence. However considering
these errors for the sphere packing bound does not improve
the bound, as we will illustrate in the following. Let us for
simplicity assume that there has only been one error in the i-th
sequence, and compare the two cases, where first, the error is
in the data part, i.e., t = «´2 = 1 and «´1 = 0, and second, the

error is in the index, i.e., t = «´1 = 1 and «´2 = 0. In the first
case, it is sufficient to use a Hamming code of length M LM
and redundancy log(M LM ), which is able to correct the
single substitution, as the receiver can correctly concatenate
the received sequences. On the other hand, when the error
occurs inside the index of sequence i, resulting in index j, the
receiver will see two sequences with the same index j and no
sequence with index i. In this case, the receiver only has to
decide which of the two sequences with the index j belongs
to the position i. As this is merely a binary decision, from a
sphere packing point of view, a redundancy of roughly a single
bit is sufficient to correct this error. This surprisingly indicates
that errors inside indices of sequences are less harmful than
those inside the data fields of sequences.
V. G ILBERT-VARSHAMOV B OUND
In the last section we have derived upper bounds on the
cardinality of error-correcting codes for indexed-set codes. On
the other hand, we will now show how to find lower bounds on
the achievable size of such error-correcting indexed-set codes
based on Gilbert-Varshamov-like sphere covering arguments.
For convenience, in the following we denote by V (S) the set
L
of indexed sets SÃÉ ‚àà IM
which have intersecting errors ball
L
Àú 6= ‚àÖ.
with S ‚àà IM , i.e., B(S) ‚à© B(S)
Theorem 3. There exists a (t, «´1 , «´2 )-indexed-set code C ‚äÜ
L
IM
with cardinality at least
|C| ‚â•

2MLM

M 2
t

(B«´2 (LM ))2t (t!2 +

t
2t
M‚àít (B«´1 (log M )) )

.

Therefore, for fixed t, «´1 , «´2 and M ‚Üí ‚àû, there exists a
L
(t, «´1 , «´2 )-indexed-set code C ‚äÜ IM
with redundancy at most
r(C) ‚â§ 2t log M + 2t«´2 log LM ‚àí 2t log «´2 ! + o(1).
Proof. Based on an iterative procedure, it can be shown
L
that there exists a (t, «´1 , «´2 )-indexed-set code C ‚äÜ IM
with
L
L |V (S)| ‚â• |I
|C| ¬∑ maxS‚ààIM
M |. Bounding |V (S)| from above
L
for all S ‚àà IM
will be the main task in the following. Let
L
BI (S) , B(S) ‚à© IM
be the set of erroneous sets which are
indexed sets and BN (S) , B(S) \ BI (S). Further distinguish
L
between VI (S) , {SÃÉ ‚àà IM
: BI (S) ‚à© B(SÃÉ) 6= ‚àÖ} and
VN (S) , V (S) \ VI (S) and note that V (S) = VI (S) ‚à™
VN (S). We first count |VI (S)|. To begin
with, |BI (S)| ‚â§

M
M
t
(L
))
,
as
there
are
t!(B
ways
to choose the
M
«´
2
t
t
erroneous sequences F . For one fixed F , there are at most
(1)
(1)
t! error patterns for the errors in the indices ef1 , . . . , eft that
yield indexed sets, as any permutation of erroneous sequences
is potentially possible. For each such choice there are again
at most (B«´2 (LM ))t ways to distribute the errors in the data
fields of the t erroneous sequences. From each S ‚Ä≤ ‚àà BI (S),
there are again at most |BI (S ‚Ä≤ )| ways to arrive at a valid
L
set SÃÉ ‚àà IM
and thus |VI (S)| ‚â§ |BI (S)|2 . Next we count
|VN (S)|. The number
of elements in the error ball is at most

|BN (S)| ‚â§ Mt B«´1 (log M )B«´2 (LM ), as this is the maximum
number of error patterns. Let S ‚Ä≤ ‚àà BN (S) and denote by
tN (S ‚Ä≤ ) the number of indices that are not present in S ‚Ä≤ . Then
L
Àú is at most
the number of sets SÃÉ ‚àà IM
with S ‚Ä≤ ‚àà B(S)
M
t
t
(B«´1 (log M )) t‚àítN (S ‚Ä≤ ) (B«´2 (LM )) , as tN (S ‚Ä≤ ) sequences
have to be distorted in a way such that their indices match

the missing indices. And thus, there are only B«´1 (log M )
options per missing index in S ‚Ä≤ . The remaining erroneous
sequences can be chosen arbitrarily. Using tN (S ‚Ä≤ ) ‚â• 1 for
all S ‚Ä≤ ‚àà BN (S) yields the theorem.
VI. C ONCLUSION
In this paper, we have discussed codes, where each codeword is an indexed set of several vectors. The proposed
construction significantly improves the redundancy 2tL from
[11, Con. 1] to 4t log M + 2t«´2 log LM , and approaches the
sphere-packing bound t log M + t«´2 log LM up to a factor of
4 and a factor of 2 for t = 1. Further, our results surprisingly
indicate that errors within the index of sequences seem to be
less harmful than errors in the data part of sequences. This
is in sharp contrast to current technologies that often rely on
extra codes, which only protect the index of sequences in order
to guarantee correct ordering of sequences.
R EFERENCES
[1] E. B. Baum, ‚ÄúBuilding an associative memory vastly larger than the
brain,‚Äù Science, vol. 268, no. 5210, pp. 583‚Äì585, 1995.
[2] M. Blawat et al., ‚ÄúForward error correction for DNA data storage,‚Äù in
Int. Conf. Computational Science, San Diego, Jun. 2016, pp. 1011‚Äì1022.
[3] Y. M. Chee, H. M. Kiah, and H. Wei, ‚ÄúEfficient and
explicit balanced primer codes,‚Äù 2019. [Online]. Available:
http://arxiv.org/abs/1901.01023
[4] G. M. Church, Y. Gao, and S. Kosuri, ‚ÄúNext-generation digital information storage in DNA,‚Äù Science, no. 6102, pp. 1628‚Äì1628, Sep. 2012.
[5] Y. Erlich and D. Zielinski, ‚ÄúDNA fountain enables a robust and efficient
storage architecture,‚Äù Science, no. 6328, pp. 950‚Äì954, Mar. 2017.
[6] N. Goldman et al., ‚ÄúTowards practical, high-capacity, low-maintenance
information storage in synthesized DNA,‚Äù Nature, no. 7435, pp. 77‚Äì80,
Jan. 2013.
[7] R. N. Grass, R. Heckel, M. Puddu, D. Paunescu, and W. J. Stark, ‚ÄúRobust
chemical preservation of digital information on DNA in silica with errorcorrecting codes,‚Äù Angewandte Chemie Int. Edition, no. 8, pp. 2552‚Äì
2555, Feb. 2015.
[8] R. Heckel, G. Mikutis, and R. Grass, ‚ÄúA characterization
of the DNA data storage channel,‚Äù 2018. [Online]. Available:
http://arxiv.org/abs/1803.03322
[9] H. M. Kiah, G. J. Puleo, and O. Milenkovic, ‚ÄúCodes for DNA sequence
profiles,‚Äù IEEE Trans. Inf. Theory, vol. 62, no. 6, pp. 3125‚Äì3146, Jun.
2016.
[10] M. KovacÃåevicÃÅ and V. Y. F. Tan, ‚ÄúCodes in the space of multisets ‚Äì coding
for permutation channels with impairments,‚Äù IEEE Trans. Inf. Theory,
no. 7, pp. 5156‚Äì5169, Jul. 2018.
[11] A. Lenz, P. H. Siegel, A. Wachter-Zeh, and E. Yaakobi, ‚ÄúCoding over
sets for DNA storage,‚Äù 2018, submitted to IEEE Trans. Inform. Theory.
[Online]. Available: https://arxiv.org/abs/1812.02936
[12] L. Organick et al., ‚ÄúRandom access in large-scale DNA data storage,‚Äù
Nature, pp. 242‚Äì248, Mar. 2018.
[13] R. M. Roth, Introduction to Coding Theory. New York: Cambridge
University Press, 2006.
[14] T. Shinkar, E. Yaakobi, A. Lenz, and A. Wachter-Zeh, ‚ÄúClusteringcorrecting codes,‚Äù submitted to ISIT 2019.
[15] J. Sima, N. Raviv, and J. Bruck, ‚ÄúOn coding over sliced information,‚Äù
2018. [Online]. Available: http://arxiv.org/abs/1809.02716
[16] W. Song and K. Cai, ‚ÄúSequence-subset distance and coding for
error control in DNA-based data storage,‚Äù 2018. [Online]. Available:
http://arxiv.org/abs/1809.05821
[17] J. K. Wolf, ‚ÄúAn introduction to tensor product codes and applications to
digital storage systems,‚Äù in IEEE Inform. Theory Workshop, Chengdu,
China, Oct. 2006, pp. 6‚Äì10.
[18] S. M. H. T. Yazdi, H. M. Kiah, R. Gabrys, and O. Milenkovic, ‚ÄúMutually
uncorrelated primes for DNA-based data storage,‚Äù IEEE Trans. Inf.
Theory, vol. 64, no. 9, pp. 6283‚Äì6296, Sep. 2018.
[19] S. M. H. T. Yazdi, H. M. Kiah, E. Garcia-ruiz, J. Ma, H. Zhao, and
O. Milenkovic, ‚ÄúDNA-based storage: Trends and methods,‚Äù IEEE Trans.
Mol. Biol. Multi-Scale Commun., vol. 1, no. 3, pp. 230‚Äì248, Sep. 2015.
[20] S. M. H. T. Yazdi, Y. Yuan, J. Ma, H. Zhao, and O. Milenkovic, ‚ÄúA
rewritable, random-access DNA-based storage system,‚Äù Nature Scientific
Reports, no. 14138, Aug. 2015.

