Empirical Analysis of Session-Based Recommendation Algorithms
A Comparison of Neural and Non-Neural Approaches

arXiv:1910.12781v2 [cs.IR] 27 Sep 2020

MALTE LUDEWIG, TU Dortmund, Germany
NOEMI MAURO, University of Torino, Italy
SARA LATIFI, University of Klagenfurt, Austria
DIETMAR JANNACH, University of Klagenfurt, Austria
Recommender systems are tools that support online users by pointing them to potential items of interest in situations of
information overload. In recent years, the class of session-based recommendation algorithms received more attention in the
research literature. These algorithms base their recommendations solely on the observed interactions with the user in an
ongoing session and do not require the existence of long-term preference profiles. Most recently, a number of deep learning
based (“neural”) approaches to session-based recommendations were proposed. However, previous research indicates that
today’s complex neural recommendation methods are not always better than comparably simple algorithms in terms of
prediction accuracy.
With this work, our goal is to shed light on the state-of-the-art in the area of session-based recommendation and on the
progress that is made with neural approaches. For this purpose, we compare twelve algorithmic approaches, among them six
recent neural methods, under identical conditions on various datasets. We find that the progress in terms of prediction accuracy
that is achieved with neural methods is still limited. In most cases, our experiments show that simple heuristic methods based
on nearest-neighbors schemes are preferable over conceptually and computationally more complex methods. Observations
from a user study furthermore indicate that recommendations based on heuristic methods were also well accepted by the
study participants. To support future progress and reproducibility in this area, we publicly share the session-rec evaluation
framework that was used in our research.1
CCS Concepts: • Information systems → Recommender systems; • General and reference → Evaluation.

1

INTRODUCTION

Recommender systems (RS) are software applications that help users in situations of information overload and
they have become a common feature on many modern online services. Collaborative filtering (CF) techniques,
which are based on behavioral data collected from larger user communities, are among the most successful
technical approaches in practice. Historically, these approaches mostly rely on the assumption that information
about longer-term preferences of the individual users are available, e.g., in the form of a user-item rating matrix
[46]. In many real-world applications, however, such longer-term information is often not available, because users
are not logged in or because they are first-time users. In such cases, techniques that leverage behavioral patterns
in a community can still be applied [26]. The difference is that instead of the long-term preference profiles only
the observed interactions with the user in the ongoing session can be used to adapt the recommendations to the
assumed needs, preferences, or intents of the user. Such a setting is usually termed a session-based recommendation
problem [41].
Interestingly, research on session-based recommendation was very scarce for many years despite the high
practical relevance of the problem setting. Only in recent years, we can observe an increased interest in the topic
in academia [55], which is at least partially caused by the recent availability of public datasets in particular from
1 This

work combines and significantly extends our own previous work published in [33] and [35]. This paper is void of plagiarism or
self-plagiarism as defined by the Committee on Publication Ethics and Springer Guidelines.
Authors’ addresses: Malte Ludewig, TU Dortmund, Germany, malte.ludewig@tu-dortmund.de; Noemi Mauro, University of Torino, Italy,
noemi.mauro@unito.it; Sara Latifi, University of Klagenfurt, Austria, sara.latifi@aau.at; Dietmar Jannach, University of Klagenfurt, Austria,
dietmar.jannach@aau.at.

2

• Ludewig et al.

the e-commerce domain. This increased interest in session-based recommendations coincides with the recent
boom of deep learning (neural) methods in various application areas. Accordingly, it is not surprising that several
neural session-based recommendation approaches were proposed in recent years, with gru4rec being one of the
pioneering and most cited works in this context [20].
From the perspective of the evaluation of session-based algorithms, the research community—at the time
when the first neural techniques were proposed—had not yet established a level of maturity as is the case for
problem setups that are based on the traditional user-item rating matrix. This led to challenges that concerned
both the question what represents the state-of-the-art in terms of algorithms and the question of the evaluation
protocol when time-ordered user interaction logs are the input instead of a rating matrix. Partly due to this
unclear situation, it soon turned out that in some cases comparably simple non-neural techniques, in particular
ones based on nearest-neighbors approaches, can lead to very competitive or even better results than neural
techniques [24, 32]. Besides being competitive in terms of accuracy, such more simple approaches often have
the advantage that their recommendations are more transparent and can more easily be explained to the users.
Furthermore, these simpler methods can often be updated online when new data becomes available, without
requiring expensive model retraining.
However, during the last few years after the publication of gru4rec, we have mostly observed new proposals
in the area of complex models. With this work, our aim is to assess the progress that was made in the last few
years in a reproducible way. To that purpose, we have conducted an extensive set of experiments in which we
compared twelve session-based recommendation techniques under identical conditions on a number of datasets.
Among the examined techniques, there are six recent neural approaches, which were published at highly-ranked
publication outlets such as KDD, AAAI, or SIGIR after the publication of the first version of gru4rec in 2015.2
The main outcome of our offline experiments is that the progress that is achieved with neural approaches to
session-based recommendation is still limited. In most experiment configurations, one of the simple techniques
outperforms all the neural approaches. In some cases, we could also not confirm that a more recently proposed
neural method consistently outperforms the much earlier gru4rec method. Generally, our analyses point to
certain underlying methodological issues, which were also observed in other application areas of applied machine
learning. Similar observations regarding the competitiveness of established and often more simple approaches
were made before, e.g., for the domains of information retrieval, time-series forecasting, and recommender
systems, [2, 12, 36, 57], and it is important to note that these phenomena are not tied to deep learning approaches.
To help overcome some of these problems for the domain of session-based recommendation, we share our
evaluation framework session-rec online3 . The framework not only includes the algorithms that are compared
in this paper, it also supports different evaluation procedures, implements a number of metrics, and provides
pointers to the public datasets that were used in our experiments.
Since offline experiments cannot inform us about the quality of the recommendation as perceived by users, we
have furthermore conducted a user study. In this study, we compared heuristic methods with a neural approach
and the recommendations produced by a commercial system (Spotify) in the context of an online radio station.
The main outcomes of this study are that heuristic methods also lead to recommendations—playlists in this
case—that are well accepted by users. The study furthermore sheds some light on the importance of other quality
factors in the particular domain, i.e., the capability of an algorithm to help users discover new items.
The paper is organized as follows. Next, in Section 2, we provide an overview of the algorithms that were used
in our experiments. Section 3 describes our offline evaluation methodology in more detail and Section 4 presents
2 Compared

to our previous work presented in [32] and [35], our present analysis includes considerably more recent deep learning techniques
and baseline approaches. We also provide the outcomes of additional measurements regarding the scalability and stability of different
algorithms. Finally, we also contrast the outcomes of the offline experiments with the findings obtained in a user study [33].
3 https://github.com/rn5l/session-rec

Empirical Analysis of Session-Based Recommendation Algorithms •

3

the outcomes of the experiments. In Section 5, we report the results of our user study. Finally, we summarize our
findings and their implications in Section 7.

2

ALGORITHMS

Algorithms of various types were proposed over the years for session-based recommendation problems. A detailed
overview of the more general family of sequence-aware recommender systems, where session-based ones are a
part of, can be found in [41]. In the context of this work, we limit ourselves to a brief summary of parts of the
historical development and how we selected algorithms for inclusion in our evaluations.

2.1

Historical Development and Algorithm Selection

Nowadays, different forms of session-based recommendations can be found in practical applications. The recommendation of related items for a given reference object can, for example, be seen as a basic and very typical
form of session-based recommendations in practice. In such settings, the selection of the recommendations is
usually based solely on the very last item viewed by the user. Common examples are the recommendation of
additional articles on news web sites or recommendations of the form “Customers who bought . . . also bought” on
e-commerce sites. Another common application scenario is the creation of automated playlists, e.g., on YouTube,
Spotify, or Last.fm. Here, the system creates a virtually endless list of next-item recommendations based on
some seed item and additional observations, e.g., skips or likes, while the media is played. These application
domains—web page and news recommendation, e-commerce, music playlists—also represent the main driving
scenarios in academic research.
For the recommendation of web pages to visit, Mobasher et al. proposed one of the earliest session-based
approaches based on frequent pattern mining in 2002 [38]. In 2005, Shani et al. [50] investigated the use of an
MDP-based (Markov Decision Process) approach for session-based recommendations in e-commerce and also
demonstrated its value from a business perspective. Alternative technical approaches based on Markov processes
were later on proposed in 2012 and 2013 for the news domain in [13] and [14].
An early approach to music playlist generation was proposed in 2005 [42], where the selection of items was
based on the similarity with a seed song. The music domain was however also very important for collaborative
approaches. In 2012, the authors of [16] used a session-based nearest-neighbors technique as part of their approach
for playlist generation. This nearest-neighbors method and improved versions thereof later on turned out to be
highly competitive with today’s neural methods [32]. More complex methods were also proposed for the music
domain, e.g., an approach based on Latent Markov Embeddings [6] from 2012.
Some novel technical proposals in the years 2014 and 2015 were based on a non-public e-commerce dataset from
a European fashion retailer and either used Markov processes and side information [53] or a simple re-ranking
scheme based on short-term intents [23]. More importantly, however, in the year 2015, the ACM RecSys conference
hosted a challenge, where the problem was to predict if a consumer will make a purchase in a given session,
and if so, to predict which item will be purchased. A corresponding dataset (YOOCHOOSE) was released by an
industrial partner, which is very frequently used today for benchmarking session-based algorithms. Technically,
the winning team used a two-stage classification approach and invested a lot of effort into feature engineering to
make accurate predictions [47].
In late 2015, Hidasi et al. [20] then published the probably first deep learning based method for session-based
recommendation called gru4rec, a method which was continuously improved later on, e.g., in [19] or [52]. In
their work, they also used the mentioned YOOCHOOSE dataset for evaluation, although with the slightly different
optimization goal, i.e., to predict the immediate next item click event. As one of their baselines, they used an
item-based nearest-neighbors technique. They found that their neural method is significantly better than this
technique in terms of prediction accuracy. The proposal of their method and the booming interest in neural

4 •

Ludewig et al.

approaches subsequently led to a still ongoing wave of new proposals that apply deep learning approaches to
session-based recommendation problems.
In this present work, we consider a selection of algorithms that reflects these historical developments. We
consider basic algorithms based on item co-occurrences, sequential patterns and Markov processes as well
as methods that implement session-based nearest-neighbors techniques. Looking at neural approaches, we
benchmark the latest versions of gru4rec as well as five other methods that were published later and which
state that they outperform at least the initial version of gru4rec to a significant extent.
Regarding the selected neural approaches, we limit ourselves to methods that do not use side information
about the items in order to make our work easily reproducible and not dependent on such meta-data. Another
constraint for the inclusion in our comparison is that the work was published in a major conferences, i.e., one
that is rated A or A* according to the Australian CORE scheme. Finally, while in theory algorithms should be
reproducible based on the technical descriptions in the paper, there are usually many small implementation
details that can influence the outcome of the measurement. Therefore, like in [12], we only considered approaches
where the source code was available and could be integrated in our evaluation framework with reasonable effort.

2.2

Considered Algorithms

In total, we considered 12 algorithms in our comparison. Table 1 provides an overview of the non-neural methods.
Table 2 correspondingly shows the neural methods considered in our analysis, ordered by their publication date.
Except for the ct method, the non-neural methods from Table 1 are conceptually very simple or almost trivial.
As mentioned above, this can lead to a number of potential practical advantages compared to more complex
models, e.g., regarding online updates and explainability. From the perspective of the computational costs, the time
needed to “train” the simple methods is often low, as this phase often reduces to counting item co-occurrences in
the training data or to preparing some in-memory data structures. To make the nearest-neighbors technique
scalable, we implemented the internal data structures and data sampling strategies proposed in [24]. Specifically,
we pre-process the training data to build fast in-memory look-up tables. These tables can then be used to almost
immediately retrieve a set of potentially relevant neighbor sessions in the training data given an item in the test
session. Furthermore, to speed up processing times, we sample only a fraction (e.g., 1,000) of the most recent
training sessions when we look for neighbors, as this proved effective in several application domains. In the end,
the ct method was the only one from the set of non-neural methods for which we encountered scalability issues
in the form of memory consumption and prediction time when the set of recommendable items is huge.
Regarding alternative non-neural approaches, note that in our previous evaluation in [32] only one neural
method, but several other machine learning approaches were benchmarked. We do not include these alternative
machine learning methods (iknn, fpmc, mc, smf, bpr-mf, fism, fossil)4 . in our present analysis because the
findings in [32] showed that they either are generally not competitive or only lead to competitive results in few
special cases.
The development over time regarding the neural approaches is summarized in Table 3. The table also indicates
which baselines were used in the original papers. The analysis shows that gru4rec was considered as a baseline
in all papers. Most papers refer to the original gru4rec publication from 2016 or an early improved version that
was proposed shortly afterwards (which we term gru4rec+ here, see [52]). Most papers, however, do not refer to
the improved version (gru4rec2) discussed in [19]. Since the public code for gru4rec was constantly updated,
we however assume that the authors ran benchmarks against the updated versions. narm, as one of the earlier
4 iknn:

Item-based kNN [20], fpmc: Factorized Personalized Markov Chains [45], mc: Markov Chains [39], smf: Session-based Matrix
Factorization [32], bpr-mf: Bayesian Personalized Ranking [44], fism: Factored Item Similarity Models [27], fossil: FactOrized Sequential
Prediction with Item SImilarity ModeLs [18].

Empirical Analysis of Session-Based Recommendation Algorithms •

5

Table 1. Overview of the non-neural methods compared in our analysis.

ar

This simple “Association Rules” method counts pairwise item co-occurrences in the training sessions.
Recommendations for an ongoing session are generated by this method by returning those items that
most frequently co-occurred with the last item of the current session in the past. For a formal definition,
see [32].

sr

This method called “Sequential Rules” was proposed in [32]. It is similar to ar in that it counts pairwise
item co-occurrences in the training sessions. In addition to ar, however, it considers the order of the
items in a session and the distance between them using a decay function. The method often led to
competitive results in particular in terms of the Mean Reciprocal Rank in the analysis in [32].

sknn/
v-sknn

The analysis in [24] showed that a simple session-based nearest-neighbors method similar to the one
from [17] was competitive with the first version for gru4rec. Conceptually, the idea is to find past
sessions that contain the same elements as the ongoing session. The recommendations are then based
by selecting items that appeared in the most similar past session.
Since the sequence in which items are consumed in the ongoing user session might be of importance in
the recommendation process, a number of “sequential extensions” to the sknn method were proposed
in [32]. Here, the order of the items in a session proved to be helpful, both when calculating the
similarities as well as in the item scoring process. Furthermore, according to [34] it can be beneficial to
put more emphasis on less popular items by applying an Inverse-Document-Frequency(IDF) weighting
scheme. In this paper, all those extensions are implemented in the v-sknn method.

stan

This method called “Sequence and Time Aware Neighborhood” was presented at SIGIR ’19 [15].
stan is based on sknn [24], but it additionally takes into account the following factors for making
recommendations: i) the position of an item in the current session, ii) the recency of a past session
w.r.t. to the current session, and iii) the position of a recommendable item in a neighboring session.
Their results show that stan significantly improves over sknn, and is even comparable to recently
proposed state-of-the-art deep learning approaches.

vstan

This method, which we propose in this present paper, combines the ideas from stan and v-sknn in a
single approach. It incorporates all three previously mentioned particularities of stan, which already
share some similarities with the v-sknn method. Furthermore, we add a sequence-aware item scoring
procedure as well as the IDF weighting scheme from v-sknn.

ct

This technique is based on Context Trees, which were originally proposed for lossless data compression.
It is a non-parametric method and based on variable-order Markov models. The method was proposed
in [37], where it showed promising results.

neural techniques, is the only neural method other than gru4rec that is considered quite frequently by more
recent works.
The analysis of the used baselines furthermore showed that only one of the more recent papers proposing a
neural method (csrm) considers, i.e., [54], session-based nearest-neighbors techniques as a baseline, even though
their competitiveness was documented in a publication at the ACM Recommender Systems conference in 2017
[24]. The authors of [54] (csrm) however only consider the original proposal and not the improved versions from
2018 [32]. The only other papers in our analysis, which consider session-based nearest-neighbors techniques as
baselines, are about non-neural techniques (ct and stan). The paper proposing stan furthermore is an exception
in that since it considers quite a number of neural approaches (gru4rec2, stamp, narm, sr-gnn) in its comparison.

6

• Ludewig et al.

Table 2. Overview of the neural methods compared in our analysis.

gru4rec gru4rec [20] was the first neural approach that employed RNNs for session-based recommendation.
This technique uses Gated Recurrent Units (GRU) [7] to deal with the vanishing gradient problem.
The technique was later on improved using more effective loss functions [19].
narm

This model [29] extends gru4rec and improves its session modeling with the introduction of a hybrid
encoder with an attention mechanism. The attention mechanism is in particular used to consider items
that appeared earlier in the session and which are similar to the last clicked one. The recommendation
scores for each candidate item are computed with a bilinear matching scheme based on the unified
session representation.

stamp

In contrast to narm, this model [31] does not rely on an RNN. A short-term attention/memory priority
model is proposed, which is (a) capable of capturing the users’ general interests from the long-term
memory of a session context, and which (b) also takes the users’ most recent interests from the
short-term memory into account. The users’ general interests are captured by an external memory
built from all the historical clicks in a session prefix (including the last click). The attention mechanism
is built on top of the embedding of the last click that represents the user’s current interests.

nextitnetThis recent model [58] also discards RNNs to model user sessions. In contrast to stamp, convolutional
neural networks are adopted with a few domain-specific enhancements. The generative model is
designed to explicitly encode item inter-dependencies, which allows to directly estimate the distribution
of the output sequence (rather than the desired item) over the raw item sequence. Moreover, to ease
the optimization of the deep generative architecture, the authors propose to use residual networks to
wrap convolutional layer(s) by residual block.
sr-gnn

This method [56] models session sequences as graph structured data (i.e., directed graphs). Based on
the session graph, sr-gnn is capable of capturing transitions of items and generating item embedding
vectors correspondingly, which are difficult to be revealed by conventional sequential methods like
MC-based and RNN-based methods. With the help of item embedding vectors, sr-gnn furthermore
aims to construct reliable session representations from which the next-click item can be inferred.

csrm

This method [54] is a hybrid framework that uses collaborative neighborhood information in sessionbased recommendations. csrm consists of two parallel modules: an Inner Memory Encoder (IME) and
an Outer Memory Encoder (OME). The IME models a user’s own information in the current session
with the help of Recurrent Neural Networks (RNNs) and an attention mechanism. The OME exploits
collaborative information to better predict the intent of current sessions by investigating neighborhood
sessions. Then, a fusion gating mechanism is used to selectively combine information from the IME and
OME to obtain the final representation of the current session. Finally, csrm obtains a recommendation
score for each candidate item by computing a bi-linear match with the final representation of the
current session.

3

EVALUATION METHODOLOGY

We benchmarked all methods under the same conditions, using the evaluation framework that we share online to
ensure reproducibility of our results.

Empirical Analysis of Session-Based Recommendation Algorithms •

7

Table 3. Overview of the baseline techniques that each neural session-based approach was originally compared to. The
methods are ordered chronologically by the date of publication. The marks (✗) indicate which baselines were used in the
comparison.
Method

Publication

gru4rec
gru4rec+
narm
stamp
gru4rec2
nextitnet
sr-gnn
csrm

ICLR (05/16)
RecSys (09/16)
CIKM (11/17)
KDD (08/18)
CIKM (10/18)
WSDM (02/19)
AAAI (02/19)
SIGIR (07/19)

3.1

iknn sknn bpr-mf fpmc gru4rec narm stamp
✗
✗
✗
✗
✗
✗
✗

✗
✗

✗

✗
✗

✗
✗

✗
✗

✗
✗
✗
✗
✗
✗
✗

✗

✗
✗

✗

Datasets

We considered eight datasets from two domains for our evaluation, e-commerce and music. Six of them are public
and several of them were previously used to benchmark session-based recommendation algorithms. Table 4
briefly describes the datasets.
Table 4. Datasets used in the experiments

RSC15
RETAIL
DIGI
ZALANDO
30MU
NOWP
AOTM
8TRACKS

E-commerce dataset used in the 2015 ACM RecSys Challenge.
An e-commerce dataset from the company Retail Rocket.
An e-commerce dataset shared by the company Diginetica.
A non-public dataset consisting of interaction logs from the European fashion retailer Zalando.
Music listening logs obtained from Last.fm.
Music listening logs obtained from Twitter.
A public music dataset containing music playlists.
A private music dataset with hand-crafted playlists.

We pre-processed the original datasets in a way that all sessions with only one interaction were removed.
As done in previous works, we also removed items that appeared less than 5 times in the dataset. Multiple
interactions with the same item in one session were kept in the data. While the repeated recommendation of an
item does not lead to item discovery, such recommendations can still be helpful from a user’s perspective, e.g., as
reminders [25, 28, 43]. Furthermore, we use an evaluation procedure where we run repeated measurements on
several subsets (splits) of the original data, see Section 3.2. The average characteristics of the subsets for each
dataset are shown in Table 5. We share all datasets except ZALANDO and 8TRACKS online.

3.2

Evaluation Procedure and Metrics

Data and Splitting Approach. We apply the following procedure to create train-test splits. Since most datasets
consist of time-ordered events, usual cross-validation procedures with the randomized allocation of events
across data splits cannot be applied. Several authors only use one single time-ordered training-test split for their
measurements. This, however, can lead to undesired random effects. We therefore rely on a protocol where we
create five non-overlapping and contiguous subsets (splits) of the datasets. As done in previous works, we use

8

• Ludewig et al.

Table 5. Characteristics of the datasets. The values are averaged over all five splits.
Dataset

RSC15

RETAIL

DIGI

ZALANDO

30MU

NOWP

AOTM

8TRACKS

Actions
Sessions
Items
Days cov.

5.4M
1.4M
29k
31

210k
60k
32k
27

264k
55k
32k
31

4.5M
365k
189k
90

640k
37k
91k
90

271k
27k
75k
90

307k
22k
91k
90

1.5M
132k
376k
90

Actions/Sess.
Items/Sess.
Actions/Day
Sessions/Day

3.95
3.17
175k
44k

3.54
2.56
8k
2.2k

4.78
4.01
8.5k
1.7k

12.43
8.39
50k
4k

17.11
14.47
7k
300

10.04
9.38
3.0k
243

14.02
14.01
3.4k
243

11.32
11.31
16.6k
1.4k

the last n days of each split for evaluation (testing) and the other days for training the models.5 The reported
measurements correspond to the averaged results obtained for each split. The playlist datasets (AOTM and
8TRACKS) are exceptions here as they do not have timestamps. For these datasets, we therefore randomly
generated timestamps, which allows us to use the same procedure as for the other datasets. Note that during the
evaluation, we only considered items in the test split that appeared at least once in the training data.
Hyperparameter Optimization. Proper hyperparameter tuning is essential when comparing machine learning
approaches. We therefore tuned all hyperparameters for all methods and datasets in a systematic approach,
using MRR@20 as an optimization target as done in previous works. Technically, we created subsets from the
training data for validation. The size of the validation set was chosen in a way that it covered the same number
of days that was used in the final test set. We applied a random hyperparameter optimization approach with 100
iterations as done in [19, 29, 31]. Since narm and csrm only have a smaller set of hyperparameters, we only had
to do 50 iterations for these methods. Since the tuning process was particularly time-consuming for sr-gnn and
nextitnet, we had to limit the number of iterations to 50 both for sr-gnn on the ZALANDO dataset and for
nextitnet on the RSC15 dataset. The final hyperparameter values for each method and dataset can be found
online, along with a description of the investigated ranges.
Accuracy Measures. For each session in the test set, we incrementally reveal one event of a session after the
other, as was proposed in [20]6 . The task of the recommendation algorithm is to generate a prediction for the
next event(s) in the session in the form of a ranked list of items. The resulting list can then be used to apply
standard accuracy measures from information retrieval. The measurement can be done in two different ways.
• As in [20] and other works, we can measure if the immediate next item is part of the resulting list and at
which position it is ranked. The corresponding measures are the Hit Rate and the Mean Reciprocal Rank.
• In typical information retrieval scenarios, however, one is usually not interested in having one item right
(e.g., the first search result), but in having as many predictions as possible right in a longer list that is
displayed to the user. For session-based recommendation scenarios, this applies as well, as usually, e.g., on
music and e-commerce sites, more than one recommendation is displayed. Therefore, we measure Precision
and Recall in the usual way, by comparing the objects of the returned list with the entire remaining session,
assuming that not only the immediate next item is relevant for the user. In addition to Precision and Recall,
we also report the Mean Average Precision metric.
5 The

number of days used for testing (n) was determined based on the characteristics of the dataset. We, for example, used the last day for
the RSC15 dataset, two for RETAIL, five for the music datasets, and seven for DIGI to ensure that train-test splits are comparable.
6 Note that the revealed items from a session can be used by an algorithm for the subsequent predictions, but the revealed interactions are not
added to the training data.

Empirical Analysis of Session-Based Recommendation Algorithms •

9

The most common cut-off threshold in the literature is 20, probably because this was the chosen threshold
by the authors of gru4rec [20]. We have made measurements for alternative list lengths as well, but will only
report the results when using 20 as a list length in this paper. We report additional results for cut-off thresholds
of 5 and 10 in an online appendix.7
Coverage and Popularity. Depending on the application domain, factors other than prediction accuracy might
be relevant as well, including coverage, novelty, diversity, or serendipity [49]. Since we do not have information
about item characteristics, we focus on questions of coverage and novelty in this work.
With coverage, we here refer to what is sometimes called “aggregate diversity” [1]. Specifically, we measure
the fraction of items of the catalog that ever appears in any top-n list presented to the users in the test set. This
coverage measure in a way also evaluates the level of context adaptation, i.e., if an algorithm tends to recommend
the same set of items to everyone or specifically varies the recommendations for a given session.
We approximate the novelty level of an algorithm by measuring how popular the recommended items are on
average. The underlying assumption is that recommending more unpopular items leads to higher novelty and
discovery effects. Algorithms that mostly focus on the recommendation of popular items might be undesirable
from a business perspective, e.g., when the goal is to leverage the potential of the long tail in e-commerce settings.
Technically, we measure the popularity level of an algorithm as follows. First, we compute min-max normalized
popularity values of each item in the training set. Then, during evaluation, we compute the popularity level of an
algorithm by determining the average popularity value of each item that appears in its top-n recommendation
list. Higher values correspondingly mean that an algorithm has a tendency to recommend rather popular items.
Running Times. Complex neural models can need substantial computational resources to be trained. Training a
“model”, i.e., calculating the statistics, for co-occurrence based approaches like sr or ar can, in contrast, be done
very efficiently. For nearest-neighbors based approaches, actually no model is learned at all. Instead, some of
our nearest-neighbors implementations need some time to create internal data structures that allow for efficient
recommendation at prediction time. In the context of this paper, we will report running times for some selected
datasets from both domains.
We executed all experiments on the same physical machine. The running times for the neural methods were
determined using a GPU; the non-neural methods used a CPU. In theory, running times should be compared on
the same hardware. Therefore, since the running times of the neural methods are much longer even when a GPU
can be used, we can assume that the true difference in computational complexity is in fact even higher than we
can see in our measurements.
Stability with Respect to New Data. In some application domains, e.g., news recommendation or e-commerce,
new user-item interaction data can come in at a high rate. Since retraining the models to accommodate the new
data can be costly, a desirable characteristic of an algorithm can be that the performance of the model does not
degenerate too quickly before the retraining happens. To put it differently, it is desirable that the models do not
overfit too much to the training data.
To investigate this particular form of model stability, we proceeded as follows. First, we trained a model on the
training data T0 of a given train-test split8 . Then, we made measurements using two different protocols, which
we term retraining and no-retraining, respectively.
• In the retraining configuration, we first evaluated the model that was trained on T0 using the data of the
first day of the test set. Then, we added this first day of the test set to T0 and retrained the model on this
extended dataset, which we name T1 . Then, we continued with the evaluation with the data from the second
7 https://rn5l.github.io/session-rec/umuai
8 We

also optimized the hyperparameters on a subset of T0 that was used as a validation set. The hyperparameters were kept constant for the
remaining measurements.

10 •

Ludewig et al.

day of the test data, using the model trained on T1 . This process of adding more data to the training set,
retraining the full model, and evaluating on the next day of the test set was done for all days of the test set
except the last one.
• In the no-retraining configuration, we also evaluated the performance day by day on the test data, but did
not retrain the models, i.e., we used the model trained on T0 for all days in the test data.
To enable a fair comparison in both configurations, we only considered items in the evaluation phase that
appeared at least once in the original training data T0 .
Note that the absolute accuracy values for a given test day depends on the characteristics of the recorded data
on that day. In some cases, the accuracy for the second test day can therefore even be higher than for the first
test day, even if there was no retraining. An exact comparison of absolute values is therefore not too meaningful.
However, we consider the relative accuracy drop when using the initial model T0 for a number of consecutive
days as an indicator of the generalizability or stability of the learned models, provided that the investigated
algorithms start from a comparable accuracy level.

4

RESULTS

In this section, we report the results of our offline evaluation. We will first focus on accuracy, then look at
alternative quality measures, and finally discuss aspects of scalability and the stability of different models over
time.

4.1

Accuracy Results

E-Commerce Datasets. Table 6 shows the results for the e-commerce datasets, ordered by the values obtained
for the MAP@20 metric. The non-neural models are marked with full circles while the neural ones can be
identified by empty ones. The highest value across all techniques is printed in bold; the highest value obtained
by the other family of algorithms—neural or non-neural—is underlined. Stars indicate significant differences
(p<0.05) according to a Kruskal–Wallis test between all the models and a Wilcoxon signed-rank test between the
best-performing techniques from each category. The results for the individual datasets can be summarized as
follows.
• On the RETAIL dataset, the nearest-neighbors methods consistently lead to the highest accuracy results on
all the accuracy measures. Among the complex models, the best results were obtained by gru4rec on all
the measures except for MRR, where sr-gnn led to the best value. The results for narm and gru4rec are
almost identical on most measures.
• The results for the DIGI dataset are comparable, with the neighborhood methods leading to the best
accuracy results. gru4rec is again the best method across the complex models on all the measures.
• For the ZALANDO dataset, the neighborhood methods dominate all accuracy measures, except for the
MRR. Here, gru4rec is minimally better than the simple sr method. Among the complex models, gru4rec
achieves the best HR value, and the recent sr-gnn method is the best one on the other accuracy measures.
• Only for the RSC15 dataset, we can observe that a neural method (narm) is able to slightly outperform
our best simple baseline vstan in terms of MAP, Precision and Recall. Interestingly, however, narm is one
of the earlier neural methods in this comparison. The best Hit Rate is achieved by vstan; the best MRR
by sr-gnn. The differences between the best neural and non-neural methods are often tiny, in most cases
around or less than 1 %.
Looking at the results across the different datasets, we can make the following additional observations.
• Across all e-commerce datasets, the vstan method proposed in this paper is, for most measures, the
best neighborhood-based method. This suggests that it is reasonable to include it as a baseline in future
performance comparisons.

Empirical Analysis of Session-Based Recommendation Algorithms • 11

Table 6. Results for the e-commerce datasets, ordered by MAP@20. The best results for each metric are highlighted in bold
font. The next best results for algorithms from the other category (either neural or non-neural) are underlined. Non-neural
methods are marked with full circles, neural ones with empty ones.
Metrics

MAP@20

P@20

R@20

HR@20

MRR@20

COV@20

POP@20

0.0543
0.0542
0.0532
0.0531
0.0502
0.0501
0.0467
0.0441
0.0420
0.0387
0.0362
0.0320
0.0308

0.4748
0.4741
0.4707
0.4632
0.4559
0.4526
0.4246
0.4125
0.3806
0.3533
0.3359
0.3051
0.2902

0.5938
0.5932
0.5788
0.5745
0.5669
0.5549
0.5169
0.4998
0.4620
0.4367
0.4174
0.3779
0.3632

∗0.3638
0.3636
0.3370
0.3395
0.3237
0.3196
0.2955
0.3252
0.2527
0.2407
0.2453
0.2038
0.2305

0.5929
0.5982
0.5709
0.5562
∗0.7973
0.6472
0.6049
0.5521
0.4865
0.5444
0.5185
0.5737
0.4026

0.0518
0.0488
0.0540
0.0598
0.0347
0.0569
0.0496
0.0743
0.0677
0.0527
0.0424
0.0703
0.3740

0.0596
0.0588
0.0589
0.0584
0.0577
0.0544
0.0528
0.0489
0.0463
0.0451
0.0401
0.0380
0.0294

0.3715
0.3723
0.3720
0.3668
0.3617
0.3335
0.3254
0.3040
0.2872
0.2840
0.2489
0.2416
0.1860

0.4748
∗0.4803
0.4800
0.4729
0.4639
0.4258
0.4188
0.3917
0.3720
0.3638
0.3277
0.2922
0.2494

0.1714
∗0.1837
0.1828
0.1784
0.1644
0.1421
0.1392
0.1314
0.1280
0.1564
0.1216
0.1424
0.1075

0.8701
0.9384
0.9161
0.9419
0.9498
0.7337
0.8696
0.9188
0.8892
0.8593
0.8736
0.7935
0.7554

0.1026
0.0858
0.0964
0.0840
0.0567
0.0833
0.0832
0.0799
0.0863
0.1092
0.0707
0.0947
0.4262

∗0.0777
0.0774
0.0740
0.0738
0.0700
0.0692
0.0695
0.0666
0.0638
0.0631
0.0564
0.0515

∗0.2073
0.2062
0.1956
0.1891
0.1823
0.1795
0.1764
0.1797
0.1739
0.1690
0.1573
0.1359

∗0.5362
0.5328
0.5162
0.4352
0.4755
0.4598
0.4500
0.4925
0.4824
0.4665
0.4561
0.3687

0.2488
0.2468
0.2487
0.1724
0.2804
0.2248
0.2347
0.3069
0.3043
0.2579
0.2993
0.2065

0.5497
0.4918
0.6246
0.3316
0.3845
0.3695
0.2767
0.6365
0.5849
0.4672
0.4653
0.2234

0.0664
0.0734
0.0680
0.0843
0.0865
0.0837
0.0789
∗0.0403
0.0696
0.0886
0.2564
0.0868

0.0735
0.0725
0.0722
0.0718
0.0714
0.0713
0.0701
0.0707
0.0682
0.0684
0.0673
0.0657
0.0654

0.5109
0.5060
0.5033
0.5080
0.4952
0.4979
0.4986
0.4937
0.4837
0.4853
0.4760
0.4658
0.4710

0.6751
0.6713
0.6691
0.6761
0.6566
0.6654
0.6656
0.6512
0.6480
0.6506
0.6361
0.5996
0.6359

0.3047
0.3142
0.3132
0.2943
0.2961
0.3033
0.2933
0.2872
0.2826
0.3010
0.2894
0.2620
0.3072

0.6399
0.5105
0.5295
0.6762
0.5929
0.5803
0.6828
0.6333
0.7482
0.6674
0.6297
0.6099
0.6270

0.0638
0.0720
0.0677
0.0634
0.0626
0.0655
0.0773
0.0777
0.0294
0.0716
0.0926
0.0796
0.1446

RETAIL

• stan
• vstan
• sknn
• v-sknn
◦ gru4rec
◦ narm
◦ csrm
◦ sr-gnn
◦ stamp
• ar
• sr
◦ nextitnet
• ct

0.0285
0.0284
0.0283
0.0278
0.0272
0.0270
0.0252
0.0241
0.0223
0.0205
0.0194
0.0173
0.0162
DIGI

• sknn
• vstan
• stan
• v-sknn
◦ gru4rec
◦ csrm
◦ narm
◦ stamp
• ar
◦ sr-gnn
• sr
◦ nextitnet
• ct

0.0255
0.0252
0.0252
0.0249
0.0247
0.0227
0.0218
0.0201
0.0189
0.0186
0.0161
0.0149
0.0115
ZALANDO

• vstan
• stan
• v-sknn
• sknn
◦ sr-gnn
◦ narm
◦ csrm
◦ gru4rec
• sr
• ar
• ct
◦ stamp

0.0168
0.0167
0.0158
0.0157
0.0146
0.0144
0.0143
0.0143
0.0136
0.0133
0.0118
0.0104
RSC15

◦ narm
◦ sr-gnn
◦ nextitnet
• vstan
◦ csrm
◦ stamp
• stan
• v-sknn
◦ gru4rec
• sr
• ar
• sknn
• ct

0.0357
0.0351
0.0350
0.0350
0.0346
0.0344
0.0342
0.0341
0.0334
0.0332
0.0325
0.0318
0.0316

12 •

Ludewig et al.

• The ranking of the neural methods varies largely across the datasets and does not follow the order in which
the methods were proposed. Like for the non-neural methods, the specific ranking therefore seems to be
strongly depending on the dataset characteristics. This makes it particularly difficult to judge the progress
that is made when only one or two datasets are used for the evaluation.
• The results for the RSC15 dataset are generally different from the other results. Specifically, we found that
some neural methods (narm, sr-gnn, nextitnet) are competitive and sometimes even slightly outperform
our baselines. Moreover, stamp and nextitnet are usually not among the top performers, but work well
for this dataset. Unlike for other e-commerce datasets, ct works particularly well for this dataset in terms
of the MRR. Given these observations, it seems that the RSC15 dataset has some unique characteristics
that are different from the other e-commerce datasets. Therefore, it seems advisable to consider multiple
datasets with different characteristics in future evaluations.
• We did not include measurements for nextitnet, one of the most recent methods, for some of the datasets
(ZALANDO, 30MU, 8TRACKS, NOWP), because our machines ran out of memory (> 32 GB). These datasets
were either comparably large or had longer sessions on average.
Music Domain. In Table 7 we present the results for the music datasets. In general, the observations are in line
with what we observed for the e-commerce domain regarding the competitiveness of the simple methods.
• Across all datasets excluding the 8TRACKS dataset, the nearest-neighbors methods are consistently favorable in terms of Precision, Recall, MAP and the Hit Rate, and the ct method leads to the best MRR.
Moreover, the simple sr technique often leads to very good MRR values.
• For 8TRACKS dataset, the best Recall, MAP and the Hit Rate values are again achieved by neighborhood
methods. The best Precision and the MRR values are, however, achieved by a neural method (narm).
• Again, no consistent ranking of the algorithms can be found across the datasets. In particular the neural
approaches take largely varying positions in the rankings across the datasets. Generally, narm seems to be
a technique which performs consistently well on most datasets and measures.

4.2

Coverage and Popularity

Table 6 and Table 7 also contain information about the popularity bias of the individual algorithms and coverage
information. Remember that we described in Section 3.2 how the numbers were calculated. From the results, we
can identify the following trends regarding individual algorithms and the different algorithm families.
Popularity Bias.
• The ct method is very different from all other methods in terms of its popularity bias, which is much higher
than for any other method.
• The gru4rec method, on the other hand, is the method that almost consistently recommends the most
unpopular (or: novel) items to the users.
• The neighborhood-based methods are often in the middle. There are, however, also neural methods, in
particular sr-gnn, which seem to have a similar or sometimes even stronger popularity bias than the nearestneighbors approaches. The assumption that nearest-neighbors methods are in general more focusing on
popular items than neural methods can therefore not be confirmed through our experiments.
Coverage.
• In terms of coverage, we found that gru4rec often leads to the highest values.
• The coverage of the neighborhood-based methods varies quite a lot, depending on the specific algorithm
variant. In some configurations, their coverage is almost as high as for gru4rec, while in others the coverage
can be low.

Empirical Analysis of Session-Based Recommendation Algorithms • 13

Table 7. Results for the music domain datasets. The best results for each metric are highlighted in bold font. The next best
results for algorithms from the other category (either neural or non-neural) are underlined. Again, non-neural methods are
marked with a full circle, neural ones with an empty one.
Metrics

MAP@20

P@20

R@20

HR@20

MRR@20

COV@20

POP@20

0.0664
0.0655
0.0585
0.0609
0.0564
0.0466
0.0490
0.0463
0.0449
0.0456
0.0388
0.0287

∗0.1828
0.1809
0.1696
0.1795
0.1544
0.1366
0.1400
0.1274
0.1361
0.1244
0.1065
0.0893

0.2534
0.2450
0.2414
∗0.2597
0.2076
0.2002
0.2113
0.1849
0.2261
0.1954
0.1508
0.1679

0.0810
0.0687
0.0871
0.0853
0.0710
0.1052
0.0935
0.0894
0.1076
0.0921
0.0594
0.1094

0.4661
0.3150
0.5128
0.4299
0.4531
0.4661
0.3265
0.4715
∗0.5795
0.2148
0.2445
0.2714

0.0582
0.0619
0.0473
0.0505
0.0511
0.0383
0.0576
0.0488
0.0286
0.0714
0.0494
0.2984

∗0.1090
0.1003
0.1073
0.0949
0.0886
0.0816
0.0675
0.0617
0.0536
0.0482
0.0411
0.0308

∗0.2347
0.2306
0.2217
0.2227
0.1930
0.1937
0.1486
0.1529
0.1236
0.1151
0.0875
0.0885

0.3830
∗0.3904
0.3443
0.3830
0.3088
0.3327
0.2956
0.3273
0.2652
0.2883
0.1539
0.2882

0.1162
0.1564
0.0898
0.1533
0.0960
0.2410
0.1945
0.2369
0.1503
0.1894
0.0819
∗0.2502

0.3667
0.4333
0.1913
0.4315
0.3524
0.4131
0.3858
0.4881
0.2290
0.3965
0.0852
0.1932

0.0485
0.0293
0.0574
0.0347
0.0393
0.0317
0.0425
0.0255
0.0390
0.0412
0.0491
0.4255

∗0.0139
0.0116
0.0126
0.0083
0.0076
0.0047
0.0050
0.0043
0.0032
0.0040
0.0024
0.0020
0.0020

∗0.0390
0.0312
0.0357
0.0231
0.0200
0.0134
0.0146
0.0126
0.0096
0.0109
0.0071
0.0063
0.0063

∗0.0417
0.0352
0.0402
0.0271
0.0233
0.0186
0.0202
0.0191
0.0148
0.0100
0.0139
0.0128
0.0130

0.0054
0.0057
0.0054
0.0060
0.0059
0.0074
0.0088
∗0.0111
0.0082
0.0021
0.0065
0.0088
0.0074

0.2937
0.5886
0.2979
∗0.6907
0.5532
0.5669
0.4816
0.3357
0.4283
0.0056
0.4851
0.5168
0.5898

0.1467
0.1199
0.1667
0.0566
0.1049
0.0711
0.1119
0.4680
0.0812
0.6478
0.0960
0.0872
0.0594

0.0129
0.0119
0.0110
0.0086
0.0131
0.0123
0.0088
0.0114
0.0067
0.0087
0.0060
0.0054

∗0.0343
0.0313
0.0276
0.0227
0.0311
0.0301
0.0219
0.0256
0.0166
0.0189
0.0132
0.0127

∗0.0377
0.0357
0.0312
0.0265
0.0345
0.0330
0.0255
0.0272
0.0201
0.0204
0.0161
0.0170

0.0054
0.0052
0.0056
0.0056
∗0.0083
0.0077
0.0071
0.0061
0.0071
0.0048
0.0051
0.0071

0.2352
0.2971
0.4572
∗0.5192
0.0788
0.0211
0.4529
0.0405
0.4897
0.0417
0.2839
0.2732

0.1622
0.1382
0.1064
0.0757
0.1589
0.1833
0.0912
0.1374
∗0.0657
0.1587
0.0825
0.2685

NOWP

• v-sknn
• sknn
• stan
• vstan
• ar
• sr
◦ sr-gnn
◦ narm
◦ gru4rec
◦ stamp
◦ csrm
• ct

∗0.0193
0.0186
0.0175
0.0174
0.0166
0.0133
0.0125
0.0118
0.0116
0.0111
0.0095
0.0065
30MU

• v-sknn
• vstan
• sknn
• stan
• ar
• sr
◦ narm
◦ gru4rec
◦ csrm
◦ sr-gnn
◦ stamp
• ct

∗0.0309
0.0296
0.0290
0.0278
0.0254
0.0240
0.0155
0.0150
0.0118
0.0108
0.0093
0.0058
AOTM

• sknn
• v-sknn
• stan
• vstan
• ar
• sr
◦ narm
• ct
◦ sr-gnn
◦ csrm
◦ nextitnet
◦ stamp
◦ gru4rec

∗0.0037
0.0032
0.0031
0.0024
0.0018
0.0010
0.0009
0.0006
0.0006
0.0005
0.0004
0.0003
0.0003
8TRACKS

• sknn
• stan
• v-sknn
• vstan
◦ narm
◦ sr-gnn
• ar
◦ stamp
• sr
◦ csrm
◦ gru4rec
• ct

∗0.0024
0.0022
0.0021
0.0018
0.0018
0.0017
0.0016
0.0015
0.0012
0.0011
0.0007
0.0007

14 •

Ludewig et al.

• The coverage values of the other neural methods also do not show a clear ranking, and they are often in
the range of the neighborhood-based methods and sometimes even very low.

4.3

Scalability

We present selected results regarding the running times of the algorithms for two e-commerce datasets and one
music dataset in Table 8. The reported times were measured for training and predicting for one data split. The
numbers reported for predicting correspond to the average time needed to generate a recommendation for a
session beginning in the test set. For this measurement, we used a workstation computer with an Intel Core
i7-4790k processor and an Nvidia Geforce GTX 1080 Ti graphics card (Cuda 10.1/CuDNN 7.5).
Table 8. Running times for selected algorithms on two datasets.

Algorithm
◦ gru4rec2
◦ stamp
◦ narm
◦ sr-gnn
◦ csrm
◦ nextitnet
• ar
• sr
• sknn
• v-sknn
• stan
• vstan
• ct

RSC15
43.14
32.51
225.82
827.37
156.89
1577.40
0.40
0.41
0.18
0.19
0.18
0.18
11.00

Training (min)
ZALANDO 8TRACKS
39.65
133.17
797.72
1527.17
203.15
–
1.00
0.53
0.13
0.13
0.20
0.13
15.60

12.54
112.84
623.76
482.46
96.83
–
0.34
0.25
0.05
0.05
0.05
0.06
4.35

RSC15
7.72
14.94
7.83
27.67
24.98
8.98
4.66
4.66
37.82
18.75
36.78
21.33
73.34

Predicting (ms)
ZALANDO 8TRACKS
25.97
55.45
25.00
120.15
66.93
–
12.00
11.77
27.77
30.56
33.26
55.58
484.87

278.23
423.94
211.35
797.97
250.23
–
105.43
101.98
291.26
278.51
317.23
288.40
1452.71

The results generally show that the computational complexity of neural methods is, as expected, much higher
than for the non-neural approaches. In some cases, researchers therefore only use a smaller fraction of the original
datasets, e.g., 1/4 or 1/64 of the RSC15 dataset. Several algorithms—both neural ones and the ct method—exhibit
major scalability issues when the number of recommendable items increases. Furthermore, for the nextitnet
method, we found that it is consuming a lot of memory for some datasets, as mentioned above, leading to
out-of-memory errors.
In some cases, like for ct or sr-gnn, not only the training time increases, but also the prediction times. In
particular the prediction times can, however, be subject to strict time constraints in production settings. The
prediction times for the nearest-neighbors methods are often slightly higher than those measured for methods
like gru4rec, but usually lie within the time constraints of real-time recommendation (e.g., requiring about 30ms
for one prediction for the ZALANDO dataset).
Since datasets in real-world environments can be even larger, this leaves us with questions regarding the
practicability of some of the approaches. In general, even in case where a complex neural method would slightly
outperform one of the more simple ones in an offline evaluation, it remains open if it is worth the effort to put
such complex methods into production. For the ZALANDO dataset, for example, the best neural method (sr-gnn)

Empirical Analysis of Session-Based Recommendation Algorithms • 15

needs several orders of magnitude9 more time to train than the best non-neural method vstan, which also only
needs half the time for recommending.
A final interesting observation is that there can be a large spread, i.e., in the range of an order of magnitude
and more, between the running times of the neural methods. For example, the methods that use convolution
(nextitnet) or graph structures (sr-gnn) often need much more time than other techniques like gru4rec or
narm. A detailed theoretical analysis of the computational complexity of the different algorithms and their
underlying architectures is, however, beyond the scope of our present work, which compares the effectiveness
and efficiency in an empirical way.

4.4

Stability With Respect to New Data

We report the stability results for the examined neural and non-neural algorithms in Table 9. Given the computational requirements for this simulation-based analysis, which requires multiple full re-training phases, we
selected one of the smaller datasets for each domain in this analysis, DIGI and NOWP.
We used two months of training data and 10 days of test data for both datasets, DIGI and NOWP. The reported
values show how much the accuracy results of each algorithm degrades (in percent), averaged across the test
days when there is no daily retraining.
Table 9. Relative accuracy decrease (in percent) for the evaluated algorithms on two datasets, ordered by HR@20 for the
DIGI dataset. The best results for each metric are highlighted in bold font. The next best results from the other category
(neural or non-neural) are underlined.

Metrics

DIGI
HR@20 MRR@20

NOWP
HR@20 MRR@20

• sknn
• v-sknn
• vstan
• stan
• ar
• sr
• ct

-1.90 %
-2.28 %
-2.53 %
-2.97 %
-4.83 %
-6.22 %
-7.98 %

-0.17 %
-0.64 %
-0.64 %
-0.29 %
-5.33 %
-6.14 %
-6.94 %

-23.42 %
-27.20 %
-28.53 %
-27.21 %
-29.76 %
-32.38 %
-50.49 %

-14.29 %
-14.36 %
-28.22 %
-27.92 %
-33.94 %
-70.05 %
-85.97 %

◦ narm
◦ gru4rec
◦ nextitnet
◦ sr-gnn
◦ csrm
◦ stamp

-1.84 %
-2.79 %
-3.75 %
-3.76 %
-4.20 %
-7.80 %

0.30 % -35.10 %
-1.84 % -46.03 %
-4.69 %
-2.14 % -46.05 %
-4.68 % -17.84 %
-7.28 % -46.48 %

-70.28 %
-74.11 %
-75.74 %
-41.27 %
-45.78 %

We can see from the results that the drop in accuracy without retraining can vary a lot across datasets (domains).
For the DIGI dataset, the decrease in performance ranges between 0 and 10 percent across the different algorithms
and performance measures. The NOWP dataset from the music domain seems to be more short-lived, with more
recent trends that have to be considered. Here, the decrease in performance ranges from about 15 to 50 percent
in terms of HR and from about 15 to 85 percent in terms of MRR.10
9 The

training time for sr-gnn is 10.000 times higher than for vstan.
comparing the numbers across the datasets is not meaningful due to their different characteristics.

10 Generally,

16 •

Ludewig et al.

Looking at the detailed results, we see that in both families of algorithms, i.e., neural and non-neural ones, some
algorithms are much more stable than others when new data are added to a given dataset. For the non-neural
approaches, we see that nearest-neighbor approaches are generally better than the other baselines techniques
based on association rules or context trees.
Among the neural methods, narm is the most stable one on the DIGI dataset, but often falls behind the other
deep learning methods on the NOWP dataset.11 On this latter dataset, the csrm method leads to the most stable
results. In general, however, no clear pattern across the datasets can be found regarding the performance of the
neural methods when new data comes in and no retraining is done.
Overall, given that the computational costs of training complex models can be high, it can be advisable to look
at the stability of algorithms with respect to new data when choosing a method for production. According to
our analysis, there can be strong differences across the algorithms. Furthermore, the nearest-neighbors methods
appear to be quite stable in this comparison.

5

OBSERVATIONS FROM A USER STUDY

Offline evaluations, while predominant in the literature, can have certain limitations, in particular when it
comes to the question of how the quality of the provided recommendations is perceived by users. We therefore
conducted a controlled experiment, in which we compared different algorithmic approaches for session-based
recommendation in the context of an online radio station. In the following sections, we report the main insights
of this experiment. While the study did not include all algorithms from our offline analysis, we consider it helpful
to obtain a more comprehensive picture regarding performance of session-based recommenders. More details
about the study can be found in [33].

5.1

Research Questions and Study Setup

Research Questions. Our offline analysis indicated that simple methods are often more competitive than the
more complex ones. Our main research question therefore was how the recommendations generated by such
simple methods are perceived by its users in different dimensions, in particular compared to recommendations by
a complex method. Furthermore, we were interested how users perceive the recommendations of a commercial
music streaming service, in our case Spotify, in the same situation.
Study Setup. An online music listening application in the form of an “automated radio station” was developed
for the purpose of the study. Similar to existing commercial services, users of the application could select a track
they like (called a “seed track”), based on which the application created a playlist of subsequent tracks.
The users could then listen to an excerpt of the next track and were asked to provide feedback about it as
shown in in Figure 1. Specifically, they were asked if (i) if they already knew the track, (ii) to what extent the track
matched the previously played track, and (iii) to what extent they liked the track (independent of the playlist).
In addition, the participants could press a “like” button before skipping to the next track. In case of such a like
action, the list of upcoming tracks was updated. Users were visually hinted that such an update takes place. This
update of the playlist was performed for all methods including Spotify, i.e., in that case we re-fetched a new
playlist through Spotify’s API after each like statement.
Once the participants had listened to and rated at least 15 tracks, they were forwarded to a post-task questionnaire. In this questionnaire, we asked the participants 11 questions about how they perceived the service, see also
[40]. Specifically, the participants were asked to provide answers to the questions using seven-point Likert scale
items, ranging from “completely disagree” to “completely agree”. The questions, which include a twelfth question
11 The experiments for nextitnet could not be completed on this dataset because the method’s resource requirements exceeded our computing

capacities.

Empirical Analysis of Session-Based Recommendation Algorithms • 17

Fig. 1. Track Rating Interface of the Application

as an attention check, are listed in Table 10. In the table, we group the questions according to the different quality
dimensions they refer to, inspired by [40]. This grouping was not visible for participants in the online study.
The study itself was based on a between-subjects design, where the treatments for each user group correspond
to different algorithmic approaches to generate the recommendations. We included algorithms from different
families in our study.
• ar: Association rules of length two, as described in Section 2. We included this method as a simple baseline.
• cagh: Another relatively simple baseline, which recommends the greatest hits of artists similar to those
liked in the current session. This music-specific method is often competitive in offline evaluations as well,
see [3].
• sknn: The basic nearest-neighbors method described above. We took the simple variant as a representative
for the family of such approaches, as it performed particularly well in the ACM RecSys 2018 challenge [34].
• gru4rec: The RNN-based approach discussed above, used as a representative for neural methods. narm
would have been a stable alternative, but did not scale well for the used dataset.
• spotify: Recommendations in this treatment group were retrieved in real time from Spotify’s API.
We optimized and trained all models on the Million Playlist Dataset Million Playlist Dataset (MPD) 12 provided
by Spotify. We then recruited study participants using Amazon’s Mechanical Turk crowdsourcing platform. After
excluding participants who did not pass the attention checks, we ended up with N=250 participants, i.e., 50 for
each treatment group, for which we were confident that they provided reliable feedback.
12 https://recsys-challenge.spotify.com/

18 •

Ludewig et al.

Table 10. Questions about Users’ Quality Perceptions.
Question
Suitability of Tracks and Perceived Personalization
Q1
Q2
Q3
Q4

I liked the automatically generated radio station.
The radio suited my general taste in music.
The tracks on the radio musically matched the track I selected in the beginning.
The radio was tailored to my preferences the more positive feedback I gave.

Perceived Diversity, Serendipity, and Familiarity
Q5
Q6
Q7

The radio was diversified in a good way.
The tracks on the radio surprised me.
I discovered some unknown tracks that I liked in the process.

Attention Check
Q8

I am participating in this study with care so I change this slider to two.

Intention to Reuse and to Recommend to Others
Q9
Q10
Q11
Q12

I would listen to the same radio station based on that track again.
I would use this system again, e.g., with a different first song.
I would recommend this radio station to a friend.
I would recommend this system to a friend.

Most of the recruited participants (almost 80%) were US-based. The most typical age range was between 25
and 34, with more than 50% of the participants falling into this category. On average, the participants considered
themselves to be music enthusiasts, with an average response of 5.75 (on the seven-point scale) to a corresponding
survey question. As usual, the participants received a compensation for their efforts through the crowdsourcing
platform.

5.2

User Study Outcomes

The main observations can be summarized as follows.
Feedback the Listening Experience. Looking at the feedback that was observed during the listening session, we
observed the following.
• Number of Likes. There were significant differences regarding the number of likes we observed across the
treatment groups. Recommendations by the simple ar method received the highest number of likes (6.48),
followed by sknn (5.63), cagh (5.38), gru4rec (5.36) and spotify (4.48).
• Popularity of Tracks. We found a clear correlation (r=0.89) between the general popularity of a track in the
MPD dataset and the number of likes in the study. The ar and cagh methods recommended, on average,
the most popular tracks. The recommendations by spotify and gru4rec were more oriented towards
tracks with lower popularity.
• Track Familiarity. There were also clear differences in terms of how many of the recommended tracks were
already known by the users. The cagh (10.83 %) and sknn (10.13 %) methods recommended the largest
number of known tracks. The ar method, even though it recommended very popular tracks, led to much
more unfamiliar recommendations (8.61 %). gru4rec was somewhere in the middle (9.30 %), and spotify
recommended the most novel tracks to users (7.00 %).
• Suitability of Track Continuations. The continuations created by sknn and cagh were perceived to be the
most suitable ones. The differences between sknn and ar, gru4rec, and spotify were significant. The

Empirical Analysis of Session-Based Recommendation Algorithms • 19

recommendations made by the ar method were considered to match the playlist the least. This is not too
surprising because the ar method only considers the very last played track for the recommendation of
subsequent tracks.
• Individual Track Ratings. The differences regarding the individual ratings for each track ratings are generally
small and not significant. Interestingly, the playlist-independent ratings for tracks recommended by the ar
method were the lowest ones, even though these recommendations received the highest number of likes.
An analysis of the rating distribution shows that the ar method often produces very bad recommendations,
with a mode value of 1 on the 1-7 rating scale.
Table 11. Descriptive statistics and outcomes of the statistical significance tests for the post-task questionnaire. We report
Mean, Standard Deviation (Mean ± Std), Median (Md), and Mode (Mo) for the Post-Task Questionnaire. We furthermore
applied a Kruskal-Wallis test and subsequently a Mann-Whitney-U test when appropriate. Significant pairwise differences
between the algorithms according to the Mann-Whitney-U test (p < 0.05) are noted with k for sknn, c for cagh, g for gru4rec,
a for ar, and s for Spotify.
s-knn
Mean ± Std Md Mo
Q1
Q2
Q3
Q4
Q5
Q6
Q7

дas 5.980 ±1.145
a 5.673 ±1.231

Q9
Q10
Q11
Q12

cagh
Mean ± Std Md Mo

7
6
7
6

дas 5.796 ±1.369
a 5.735 ±1.483

дas 5.673 ±1.281
a 5.633 ±1.202

6
6
6
6

5.204 ±1.399
3.878 ±1.589
4.061 ±2.155

5
4
4

as 5.653 ±1.422
дa 6.204 ±1.000
a 5.449 ±1.487

6
6
6
6

дa 5.816 ±1.269

gru4rec
Mean ± Std Md Mo

a 5.286 ±1.646
a 5.510 ±1.697

6
6
6
6

6
6
6
6

5.224 ±1.504
a 5.490 ±1.502
a 4.673 ±2.125

5
3
7

5.224 ±1.545
3.755 ±1.774
3.939 ±2.193

5
4
4

6
7
7
6

a 5.347 ±1.809
дa 6.000 ±1.258
a 5.408 ±1.790

ar

дa 5.735 ±1.455

5.224 ±1.531

5
6
6
5

5
7
6
6

5
5
1

4.653 ±1.786
4.000 ±1.720
4.041 ±1.848

5
4
5

4
3
5

6
6
6
6

7
7
7
7

5.082 ±1.730
5.388 ±1.681
4.959 ±1.744
5.122 ±1.654

5
6
5
5

7
7
6
5

spotify

Q1
Q2
Q3
Q4

4.776 ±1.598
4.735 ±1.765
4.245 ±1.843
5.082 ±1.205

5
5
4
5

3
3
2
4

a 5.367 ±1.453

5.306 ±1.475
4.980 ±1.548
a 5.592 ±1.273

6
5
5
6

6
5
5
7

Q5
Q6
Q7

4.633 ±1.603
4.204 ±1.384
4.286 ±2.189

5
5
6

3
5
6

4.959 ±1.707
4.286 ±1.620
k cдa 5.224 ±1.476

5
4
5

5
3
5

Q9
Q10
Q11
Q12

4.755 ±1.362
5.245 ±1.465
4.490 ±1.647
4.796 ±1.720

4
5
4
5

4
4
3
3

a 5.224 ±1.476
дa 6.041 ±1.274
a 5.265 ±1.524

5
6
5
6

6
7
7
7

a 5.551 ±1.473

Post-Task Questionnaire. The detailed statistics of the answers to the post-task questionnaire are shown in
Table 11. The analysis of the data revealed the following aspects:
• Q1: The radio station based on sknn was significantly more liked than the stations that used gru4rec, ar,
and spotify.

20

• Ludewig et al.

• Q2: All radio stations matched the users general taste quite well, with median values between 5 and 6 on a
seven-point scale. Only the station based on the ar method received a significantly lower rating than the
others.
• Q3: The sknn method was found to perform significantly better than ar and gru4rec with respect to
identifying tracks that musically match the seed track.
• Q4: The adaptation of the playlist based on the like statements was considered good for all radio stations.
Again, the feedback for the ar method was significantly lower than for the other methods.
• Q5 and Q6: No significant differences were found regarding the surprise level of the different recommendation strategies.
• Q7: Regarding the capability of recommending unknown tracks that the users liked, the recommendations
by spotify were perceived to be much better than for the other methods, with significant differences
compared to all other methods.
• Q9 to Q12: The best performing methods in terms of the intention to reuse and the intention to recommend
the radio station to others were sknn, cagh, and spotify. gru4rec and ar were slightly worse, sometimes
with differences that were statistically significant.
Overall, the study confirmed that methods like sknn do not only perform well in an offline evaluation, but are
also able, according to our study, to generate recommendations that are well perceived in different dimensions by
the users. The study also revealed a number of additional insights.
First, we found that optimizing for like statements can be misleading. The ar method received the highest
number of likes, but was consistently worse than other techniques in almost all other dimensions. Apparently,
this was caused by the fact that the ar method made a number of bad recommendations; see also [5] for an
analysis of the effects on bad recommendations in the music domain.
Second, it turned out that discovery support seems to be an important factor in this particular application
domain. While the recommendations of spotify were slightly less appreciated than those by sknn, we found no
difference in terms of the user’s intention to reuse the system or to recommend it to friends. We hypothesize that
the better discovery support of spotify’s recommendations was an important factor for this phenomenon. This
observation points to the importance of considering multiple potential quality factors when comparing systems.

6

RESEARCH LIMITATIONS

Our work does not come without limitations, both regarding the offline evaluations and the user study.
Potential Data Biases. One general problem of offline evaluations based on historical data is that we often
know very little about the circumstances and environment in which the data was collected. For the e-commerce
datasets, for example, what we see as interactions in the log can be at least partially the result of the recommender
system that was in place during the time of data collection, or it can simply be the result of how certain items or
categories were promoted in the online shop. For the music datasets, and in particular for data obtained from
Last.fm (30MU), it might be that the logs to some extent reflect what the Last.fm radio station functionality was
playing automatically given a seed track. Well-performing algorithms, i.e., those that predict the next items in the
log accurately, might therefore be the ones that are able to “reconstruct” the logic of an existing recommender in
some ways. The results of such a biased offline evaluation might therefore not fully reflect the effectiveness of a
system.
Over the years, a number of approaches were proposed to deal with such problems, e.g., by using evaluation
measures that take biases into account or by trying to “de-bias” the datasets [4, 51]. In particular in the context of
reinforcement learning and bandit-based approaches, a number of research proposals were made for unbiased
offline evaluation protocols to obtain more realistic performance estimates from log data, see [30] for an early
work. The analysis or consideration of such biases was, however, not in the scope of the work, which aimed

Empirical Analysis of Session-Based Recommendation Algorithms • 21

at the comparison of different existing algorithms using standard evaluation protocols. While the outcomes of
these analyses (and of the original works) maybe therefore suffer from potential biases, the conducted user study
provided us with strong indications that the generated recommendations were also liked by users.
Empirical Nature of the Work. Generally, our work—like the papers that proposed the analyzed neural models—is
mainly an empirical one in terms of the research approach. Algorithmic papers that propose new models in many
cases do not start with a theoretical model, but probably more often with an intuition of what kind of signals
there could be in the data. In case performance increases are found when using model that is designed to capture
these signals, a common approach in that context is to use ablation studies to determine, again empirically, to
what extent certain parts of the network architecture contribute to the overall performance. In the context of our
comparative work, in contrast, it would be interesting to understand why even computationally very complex
models are not consistently performing better than the more simple models. Possible explanations could be that
some underlying assumptions do not hold for the majority of the datasets. In some domains, the sequential
ordering of the events, as captured by RNNs, might for example not be very important. Another problem could
lie in a certain tendency of overfitting of the complex models, even when the hyperparameters are optimized on
a held-out validation set. A detailed analytical investigation of the potential reasons why each of the six complex
models in our comparison does not perform consistently better than the more simple ones, however, lies beyond
the scope of this present work and is left for future work.
User Study Limitations. Finally, the user study discussed in Section 5—like most studies of that type—has certain
limitations as well. Typical issues that apply also to our study are questions related the representativeness of the
user population. Furthermore, while we developed a realistic and fully functional online radio station, the setting
remains artificial and users were paid for their participation. The attention checks and the statistics of how users
interacted with the system however make us confident that the majority of the participants completed the task
with care and that the results are reliable. Another potential limitation of our study design is that we used one
single item for each of the investigated quality dimensions in the post-task questionnaire. Since we mainly used
established questions from the literature, e.g., from [40], the associated risks are low.

7

CONCLUSIONS AND WAYS FORWARD

Our work reveals that despite a continuous stream of papers that propose new neural approaches for session-based
recommendation, the progress in the field seems still limited. According to our evaluations, today’s deep learning
techniques are in many cases not outperforming much simpler heuristic methods. Overall, this indicates that
there still is a huge potential for more effective neural recommendation methods in the future in this area.
In a related analysis of deep learning techniques for recommender systems [11, 12], the authors found that
different factors contribute to what they call phantom progress. One first problem is related to the reproducibility
of the reported results. They found that in less than a third of the investigated papers, the code was made available
to other researchers. The problem also exists to some extent for session-based recommendation approaches. To
further increase the level of reproducibility, we share our evaluation framework publicly, so that other researchers
can easily benchmark their own methods with a comprehensive set of neural and non-neural approaches on
different datasets.
Through sharing our evaluation framework, we hope to also address other methodological and procedural
issues mentioned in [12] that can make the comparison of algorithms unreliable or inconclusive. Regarding
methodological issues, we for example found works that determined the optimal number of training epochs on
the test set and furthermore determined the best Hit Rate and MRR values across different optimization epochs.
Regarding procedural issues, we found that while researchers seemingly rely on the same datasets as previous
works, they sometimes apply different data pre-processing strategies. Furthermore, the choice of the baselines

22

• Ludewig et al.

can make the results inconclusive. Most investigated works do not consider the sknn method and its variants
as a baseline. Some works only compare variants of one method and include a non-neural, but not necessarily
strong other baseline. In many cases, little is also said about the optimization of the hyperparameters of the
baselines. The session-rec framework used in our evaluation should help to avoid these problems, as it contains
all the code for data pre-processing, evaluation, and hyperparameter optimization. Such frameworks are generally
important to ensure replicability and reproducibility of research results [8]. Furthermore, sharing the framework
allows other researchers to inspect the exact details of how the algorithms are implemented and evaluated, which
is important as no de-facto standards exists in the literature, which can sometimes lead to inconclusive and
inconsistent results [48].
Moreover, also from a methodological perspective, our analyses indicated that optimizing solely for accuracy
can be insufficient also for session-based recommendation scenarios. Depending on the application domain,
other quality factors such as coverage, diversity, or novelty should be considered besides efficiency, because
they can be crucial for the adoption and success of the recommendation service. Given the insights from our
controlled experiment, we furthermore argue that more user studies and field tests are necessary to understand
the characteristics of successful recommendations in a given application domain.
Looking at future directions, in particular methods that leverage side information about users and items seem
to represent a promising way forward, see [9, 10, 21, 22]. In [21], the authors for example use a parallel RNN
architecture to incorporate image and text information in the session modeling process. In [9] and [10], both item
information and user context information are combined in a neural architecture for news recommendation. The
authors of [22], finally, combine RNNs with Key-Value memory networks to build a hybrid system that integrates
information about item attributes in the sequential recommendation process.
A main challenge when trying to analyze and compare such methods under identical conditions, as was the
goal of our present work, is that these works rely on largely different and often specific datasets, e.g., containing
image information, or are optimized for a specific problem setting, e.g., cold-start situations in the news domain.
An important direction for future work therefore lies in analyzing to what extent the benefits of such hybrid
architectures generalize beyond individual application domains.

ACKNOWLEDGEMENT
We thank Liliana Ardissono for her valuable feedback on the paper.

REFERENCES
[1] Gediminas Adomavicius and YoungOk Kwon. Improving aggregate recommendation diversity using ranking-based techniques. IEEE
Transactions on Knowledge and Data Engineering, 24(5):896–911, May 2012.
[2] Timothy G. Armstrong, Alistair Moffat, William Webber, and Justin Zobel. Improvements that don’t add up: Ad-hoc retrieval results
since 1998. In Proceedings of the 18th ACM Conference on Information and Knowledge Management, CIKM ’09, pages 601–610, 2009.
[3] Geoffray Bonnin and Dietmar Jannach. Automated generation of music playlists: Survey and experiments. ACM Computing Surveys,
47(2):26:1–26:35, 2014.
[4] Diego Carraro and Derek Bridge. Debiased offline evaluation of recommender systems: A weighted-sampling approach (extended
abstract). In Proceedings of the ACM RecSys 2019 Workshop on Reinforcement and Robust Estimators for Recommendation (REVEAL ’19),
2019.
[5] Patrick Y.K. Chau, Shuk Ying Ho, Kevin K.W. Ho, and Yihong Yao. Examining the effects of malfunctioning personalized services on
online users’ distrust and behaviors. Decision Support Systems, 56:180 – 191, 2013.
[6] Shuo Chen, Josh L. Moore, Douglas Turnbull, and Thorsten Joachims. Playlist prediction via metric embedding. In Proceedings of the
18th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, KDD ’12, pages 714–722, 2012.
[7] KyungHyun Cho, Bart van Merrienboer, Dzmitry Bahdanau, and Yoshua Bengio. On the properties of neural machine translation:
Encoder-decoder approaches. CoRR, abs/1409.1259, 2014.
[8] Ludovik Çoba and Markus Zanker. Replication and reproduction in recommender systems research - evidence from a case-study with
the rrecsys library. In 30th International Conference on Industrial Engineering and Other Applications of Applied Intelligent Systems,

Empirical Analysis of Session-Based Recommendation Algorithms • 23

IEA/AIE ’17, pages = 305–314, year = 2017,.
[9] Gabriel de Souza Pereira Moreira, Felipe Ferreira, and Adilson Marques da Cunha. News session-based recommendations using deep
neural networks. In Proceedings of the 3rd Workshop on Deep Learning for Recommender Systems, DLRS ’18, pages 15–23, 2018.
[10] Gabriel de Souza Pereira Moreira, Dietmar Jannach, and Adilson Marques da Cunha. Contextual hybrid session-based news recommendation with recurrent neural networks. IEEE Access, Volume 7, 2019.
[11] Maurizio Ferrari Dacrema, Simone Boglio, Paolo Cremonesi, and Dietmar Jannach. A troubling analysis of reproducibility and progress
in recommender systems research. 2019.
[12] Maurizio Ferrari Dacrema, Paolo Cremonesi, and Dietmar Jannach. Are We Really Making Much Progress? A Worrying Analysis of
Recent Neural Recommendation Approaches. In Proceedings of the 13th ACM Conference on Recommender Systems, RecSys ’19, pages
101–109, 2019.
[13] Florent Garcin, Christos Dimitrakakis, and Boi Faltings. Personalized news recommendation with context trees. In Proceedings of the 7th
ACM Conference on Recommender Systems, RecSys ’13, pages 105–112, 2013.
[14] Florent Garcin, Kai Zhou, Boi Faltings, and Vincent Schickel. Personalized news recommendation based on collaborative filtering. In
Proceedings of the the 2012 IEEE/WIC/ACM International Joint Conferences on Web Intelligence and Intelligent Agent Technology, WI-IAT
’12, pages 437–441, 2012.
[15] Diksha Garg, Priyanka Gupta, Pankaj Malhotra, Lovekesh Vig, and Gautam Shroff. Sequence and time aware neighborhood for
session-based recommendations: Stan. In Proceedings of the 42nd International ACM SIGIR Conference on Research and Development in
Information Retrieval, SIGIR ’19, pages 1069–1072, 2019.
[16] Negar Hariri, Bamshad Mobasher, and Robin Burke. Context-aware music recommendation based on latent topic sequential patterns. In
Proceedings of the Sixth ACM Conference on Recommender Systems, RecSys ’12, pages 131–131, 2012.
[17] Negar Hariri, Bamshad Mobasher, and Robin Burke. Adapting to user preference changes in interactive recommendation. In Proceedings
of the 24th International Conference on Artificial Intelligence, IJCAI ’15, pages 4268–4274. AAAI, 2015.
[18] Ruining He and Julian McAuley. Fusing similarity models with markov chains for sparse sequential recommendation. CoRR,
abs/1609.09152, 2016.
[19] Balázs Hidasi and Alexandros Karatzoglou. Recurrent neural networks with top-k gains for session-based recommendations. In
Proceedings of the 27th ACM International Conference on Information and Knowledge Management, CIKM ’18, pages 843–852, 2018.
[20] Balázs Hidasi, Alexandros Karatzoglou, Linas Baltrunas, and Domonkos Tikk. Session-based recommendations with recurrent neural
networks. In Proceedings International Conference on Learning Representations, ICLR ’16, 2016.
[21] Balázs Hidasi, Massimo Quadrana, Alexandros Karatzoglou, and Domonkos Tikk. Parallel recurrent neural network architectures for
feature-rich session-based recommendations. In Proceedings of the 10th ACM Conference on Recommender Systems, RecSys ’16, pages
241–248, 2016.
[22] Jin Huang, Wayne Xin Zhao, Hongjian Dou, Ji-Rong Wen, and Edward Y. Chang. Improving sequential recommendation with knowledgeenhanced memory networks. In The 41st International ACM SIGIR Conference on Research & Development in Information Retrieval, SIGIR
’18, pages 505–514, 2018.
[23] Dietmar Jannach, Lukas Lerche, and Michael Jugovac. Adaptation and evaluation of recommendations for short-term shopping goals. In
Proceedings of the 9th ACM Conference on Recommender Systems, RecSys ’15, pages 211–218, 2015.
[24] Dietmar Jannach and Malte Ludewig. When recurrent neural networks meet the neighborhood for session-based recommendation. In
Proceedings of the 11th ACM Conference on Recommender Systems, RecSys ’17, pages 306–310, 2017.
[25] Dietmar Jannach, Malte Ludewig, and Lukas Lerche. Session-based item recommendation in e-commerce: On short-term intents,
reminders, trends, and discounts. User-Modeling and User-Adapted Interaction, 27(3–5):351–392, 2017.
[26] Dietmar Jannach and Markus Zanker. Collaborative filtering: Matrix completion and session-based recommendation tasks. In
Collaborative Recommendations: Algorithms, Practical Challenges and Applications, pages 1–38. 2019.
[27] Santosh Kabbur, Xia Ning, and George Karypis. FISM: Factored item similarity models for top-n recommender systems. In KDD ’13,
pages 659–667, 2013.
[28] Lukas Lerche, Dietmar Jannach, and Malte Ludewig. On the value of reminders within e-commerce recommendations. In UMAP ’16,
pages 27–35, 2016.
[29] Jing Li, Pengjie Ren, Zhumin Chen, Zhaochun Ren, Tao Lian, and Jun Ma. Neural attentive session-based recommendation. In Proceedings
of the 2017 ACM on Conference on Information and Knowledge Management, CIKM ’17, pages 1419–1428, 2017.
[30] Lihong Li, Wei Chu, John Langford, and Xuanhui Wang. Unbiased offline evaluation of contextual-bandit-based news article recommendation algorithms. In Proceedings of the Fourth ACM International Conference on Web Search and Data Mining, WSDM ’11, pages 297–306,
2011.
[31] Qiao Liu, Yifu Zeng, Refuoe Mokhosi, and Haibin Zhang. STAMP: short-term attention/memory priority model for session-based
recommendation. In Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery & Data Mining, KDD ’18,
pages 1831–1839, 2018.

24

• Ludewig et al.

[32] Malte Ludewig and Dietmar Jannach. Evaluation of session-based recommendation algorithms. User-Modeling and User-Adapted
Interaction, 28(4–5):331–390, 2018.
[33] Malte Ludewig and Dietmar Jannach. User-centric evaluation of session-based recommendations for an automated radio station. In
Proceedings of the 13th ACM Conference on Recommender Systems, RecSys ’19, pages 516–520, 2019.
[34] Malte Ludewig, Iman Kamehkhosh, Nick Landia, and Dietmar Jannach. Effective nearest-neighbor music recommendations. In
Proceedings of the ACM Recommender Systems Challenge 2018, RecSys Challenge ’18, pages 3:1–3:6, 2018.
[35] Malte Ludewig, Noemi Mauro, Sara Latifi, and Dietmar Jannach. Performance comparison of neural and non-neural approaches to
session-based recommendation. In Proceedings of the 13th ACM Conference on Recommender Systems, RecSys ’19, pages 462–466, 2019.
[36] Spyros Makridakis, Evangelos Spiliotis, and Vassilios Assimakopoulos. Statistical and machine learning forecasting methods: Concerns
and ways forward. PloS one, 13(3), 2018.
[37] Fei Mi and Boi Faltings. Context tree for adaptive session-based recommendation. CoRR, abs/1806.03733, 2018.
[38] Bamshad Mobasher, Honghua Dai, Tao Luo, and Miki Nakagawa. Using sequential and non-sequential patterns in predictive web usage
mining tasks. In Proceedings of IEEE International Conference on Data Mining, ICDM ’02, pages 669–672, 2002.
[39] J.R. Norris. Markov Chains. Cambridge University Press, Cambridge, 1997.
[40] Pearl Pu, Li Chen, and Rong Hu. A user-centric evaluation framework for recommender systems. In Proceedings of the 5th ACM
Conference on Recommender Systems, RecSys ’11, pages 157–164, 2011.
[41] Massimo Quadrana, Paolo Cremonesi, and Dietmar Jannach. Sequence-aware recommender systems. ACM Computing Surveys, 54:1–36,
2018.
[42] R. Ragno, C. J. C. Burges, and C. Herley. Inferring similarity between music objects with application to playlist generation. In Proceedings
of the 7th ACM SIGMM International Workshop on Multimedia Information Retrieval, MIR ’05, pages 73–80, 2005.
[43] Pengjie Ren, Zhumin Chen, Jing Li, Zhaochun Ren, Jun Ma, and Maarten de Rijke. Repeatnet: A repeat aware neural recommendation
machine for session-based recommendation. In The Thirty-Third AAAI Conference on Artificial Intelligence, AAAI ’19, pages 4806–4813,
2019.
[44] Steffen Rendle, Christoph Freudenthaler, Zeno Gantner, and Lars Schmidt-Thieme. Bpr: Bayesian personalized ranking from implicit
feedback. In UAI ’09, pages 452–461, 2009.
[45] Steffen Rendle, Christoph Freudenthaler, and Lars Schmidt-Thieme. Factorizing personalized markov chains for next-basket recommendation. In WWW ’10, pages 811–820, 2010.
[46] Paul Resnick, Neophytos Iacovou, Mitesh Suchak, Peter Bergstrom, and John Riedl. Grouplens: An open architecture for collaborative
filtering of netnews. In Proceedings of the 1994 ACM Conference on Computer Supported Cooperative Work, CSCW ’94, pages 175–186,
1994.
[47] Peter Romov and Evgeny Sokolov. Recsys challenge 2015: Ensemble learning with categorical features. In Proceedings of the 2015
International ACM Recommender Systems Challenge, RecSys ’15 Challenge, pages 1:1–1:4, 2015.
[48] Alan Said and Alejandro Bellogín. Comparative recommender system evaluation: Benchmarking recommendation frameworks. In
Proceedings of the 8th ACM Conference on Recommender Systems, RecSys ’14, page 129–136, 2014.
[49] Guy Shani and Asela Gunawardana. Evaluating recommendation systems. In Recommender Systems Handbook, pages 257–297. 2011.
[50] Guy Shani, David Heckerman, and Ronen I. Brafman. An MDP-based recommender system. The Journal of Machine Learning Research,
6:1265–1295, 2005.
[51] Harald Steck. Training and testing of recommender systems on data missing not at random. In Proceedings of the 16th ACM SIGKDD
International Conference on Knowledge Discovery and Data Mining, KDD ’10, pages 713–722, 2010.
[52] Yong Kiam Tan, Xinxing Xu, and Yong Liu. Improved recurrent neural networks for session-based recommendations. In Proceedings of
the 1st Workshop on Deep Learning for Recommender Systems, DLRS ’16, pages 17–22, 2016.
[53] Maryam Tavakol and Ulf Brefeld. Factored MDPs for detecting topics of user sessions. In Proceedings of the 8th ACM Conference on
Recommender Systems, RecSys ’14, pages 33–40, 2014.
[54] Meirui Wang, Pengjie Ren, Lei Mei, Zhumin Chen, Jun Ma, and Maarten de Rijke. A collaborative session-based recommendation
approach with parallel memory modules. In Proceedings of the 42nd International ACM SIGIR Conference on Research and Development in
Information Retrieval, SIGIR ’19, pages 345–354, 2019.
[55] Shoujin Wang, Longbing Cao, and Yan Wang. A survey on session-based recommender systems. CoRR, abs/1902.04864, 2019.
[56] Shu Wu, Yuyuan Tang, Yanqiao Zhu, Liang Wang, Xing Xie, and Tieniu Tan. Session-based recommendation with graph neural networks.
In Proceedings of the Thirty-Third AAAI Conference on Artificial Intelligence, AAAI, pages 346–353, 2019.
[57] Wei Yang, Kuang Lu, Peilin Yang, and Jimmy Lin. Critically examining the neural hype: Weak baselines and the additivity of effectiveness
gains from neural ranking models. In Proceedings of the 42nd International ACM SIGIR Conference on Research and Development in
Information Retrieval, SIGIR ’19, pages 1129–1132, 2019.
[58] Fajie Yuan, Alexandros Karatzoglou, Ioannis Arapakis, Joemon M. Jose, and Xiangnan He. A simple convolutional generative network
for next item recommendation. In Proceedings of the 12th ACM International Conference on Web Search and Data Mining, WSDM ’19,
pages 582–590, 2019.

