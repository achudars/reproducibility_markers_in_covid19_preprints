Exact and approximation algorithms for
the expanding search problem
Ben Hermans∗,a , Roel Leusa , and Jannik Matuschkeb

arXiv:1911.08959v1 [cs.DM] 20 Nov 2019

a

Research Center for Operations Research & Business Statistics, KU Leuven,
Belgium
b
Research Center for Operations Management, KU Leuven, Belgium

Abstract
Suppose a target is hidden in one of the vertices of an edge-weighted graph
according to a known probability distribution. The expanding search
problem asks for a search sequence of the vertices so as to minimize the
expected time for finding the target, where the time for reaching the
next vertex is determined by its distance to the region that was already
searched. This problem has numerous applications, such as searching for
hidden explosives, mining coal, and disaster relief. In this paper, we develop exact algorithms and heuristics, including a branch-and-cut procedure, a greedy algorithm with a constant-factor approximation guarantee,
and a novel local search procedure based on a spanning tree neighborhood.
Computational experiments show that our branch-and-cut procedure outperforms all existing methods for general instances and both heuristics
compute near-optimal solutions with little computational effort.

1

Introduction

The problem of searching a hidden target plays a major role in the daily operations of search and rescue teams, intelligence services, and law enforcement
agencies. Research and development departments in corporations also face a
search problem when they need to identify a viable product design. One way to
represent the search space is by a graph in which each vertex has a given probability to contain the target and each edge has a length that reflects the distance
(cost, time, or a composite measure) to move between the adjacent vertices.
We study the problem of a searcher who, starting from a predetermined root,
needs to determine how to search the graph in order to minimize the expected
distance traveled before finding the target.
The traditional paradigm of pathwise search assumes that the searcher can
only continue searching from their current location, which leads to a search
trajectory that forms a walk in the graph. In this paper, we adopt the alternative
paradigm of expanding search, as introduced by Alpern and Lidbetter (2013).
Here, the searcher can proceed from every previously visited vertex and the
resulting trajectory forms a tree in the graph. Such a search arises naturally
∗ The

author is funded by a PhD Fellowship of the Research Foundation – Flanders.

1

when the cost to traverse an edge for a second time is negligible compared to
the first traversal. When mining for coal, for example, moving within existing
tunnels can occur in time negligible compared to the time needed to dig into
a new site (Alpern and Lidbetter, 2013). Similarly, when securing an area for
a hidden explosive, moving within a secured area takes considerably less time
than securing a new location (Angelopoulos et al., 2019).
Another application for the expanding search paradigm follows from the
situation where we want to minimize the weighted average (re)connection time
of a graph’s vertices to its root (Averbakh and Pereira, 2012). In the context
of disaster relief, for example, the vertices could reflect villages, the root an
aid center, and the edges road segments that have been destroyed by a natural
disaster. Edge lengths represent the time necessary to clear the roads and once
a road segment has been cleared, the time to travel over it becomes negligible.
The problem then consists in deciding the order in which to clear the roads so
as to minimize the weighted reconnection time of all villages to the aid center,
where the weighting occurs according to the relative importance of different
villages. This is equivalent to the expanding search problem if we interpret
vertex weights as a measure of relative importance rather than as a probability
that the respective vertex contains the target.
Contribution and main findings. In this paper, we study exact and approximation algorithms for the expanding search problem. While a substantial
amount of work has been done for the pathwise search problem, research on
expanding search has only emerged relatively recently. In particular, to the
best of our knowledge, no approximation algorithm for the problem has been
developed so far. This paper fills this gap by showing how a greedy approach
yields a constant-factor approximation algorithm. As a second contribution,
we develop a branch-and-cut procedure that finds an optimal expanding search
sequence for instances that were not solved by previous methods. Finally, we
also describe a local search procedure.
Our branch-and-cut procedure relies on a novel mixed integer program for
the expanding search problem that exploits the knowledge of how to solve the
special case of trees. We build upon the single-machine scheduling literature
(Correa and Schulz, 2005) to obtain a linear program that identifies an optimal search sequence for a given tree, and we embed this formulation in a
mixed integer program to select an optimal tree within the graph. Inspired by
well-known results for the minimum spanning tree problem, we obtain valid inequalities that form the basis of our branch-and-cut procedure. Computational
experiments show that our branch-and-cut procedure outperforms the existing
methods for general instances and that the computational performance greatly
depends on the graph’s density.
The greedy approximation algorithm starts from the intuitive idea that one
prefers to probe groups of nearby vertices with a high probability to contain
the object. More specifically, we employ the concept of the search density of
a subtree, defined as the ratio of (i) the total probability mass of all vertices
in the subtree and (ii) the total length of all edges in the subtree. Using a
proof technique inspired by Feige et al. (2004), we show that a greedy approach
of approximating the subtree of maximum search density and then searching
that tree leads to an 8-approximation algorithm. Computational experiments

2

suggest that, empirically, the greedy approach produces solutions much closer
to optimality than the factor eight worst-case guarantee.
Our local search procedure, finally, iteratively improves the current solution
within an edge-swap neighborhood based on the spanning tree representation
of the search sequence, exploiting our ability to find the optimal search for a
given tree efficiently. We observe that it is crucial to consider all edge swaps
in the metric closure of the input graph. We further show that this procedure
finds the optimum when the underlying graph is a cycle. This contrasts with a
related insertion-based local search of Averbakh and Pereira (2012), for which
we observe that it can perform arbitrarily bad on a cycle. Moreover, our local
search found the optimum for around 80% of the instances in our computational
experiment and it exceeded the optimal value by at most 2.15% for the other
cases.
Related work. Since the seminal work of Koopman (1956a,b, 1957), search
theory has grown to a rich area of research; see the books of Alpern and Gal
(2003), Stone (2007), Alpern et al. (2013), and Stone et al. (2016) for general overviews. We focus on the work directly related to the expanding search
problem, and compare it to previous work on the pathwise search problem.
It has been established that the pathwise search problem is NP-hard (Trummel and Weisinger, 1986), even if the underlying graph forms a tree (Sitters,
2002). Archer et al. (2008) describe a 7.18-approximation algorithm for the
problem, and Li and Huang (2018) give an exact solution method that also allows for multiple searchers. Many of these results exploit the connection between
the pathwise search problem and the minimum latency problem, also known as
the traveling repairman problem, which asks for a tour that visits all vertices
and minimizes the sum of arrival times (Afrati et al., 1986). Indeed, the pathwise search problem can be seen as a node-weighted version of the minimum
latency problem (Koutsoupias et al., 1996; Ausiello et al., 2000).
Considerably less work has been done for the expanding search problem.
Averbakh and Pereira (2012) show that the problem is NP-hard in general and
develop exact solution methods. Averbakh (2012) develops polynomial-time algorithms for a more general model that allows for multiple searchers, but only
for the special case where the graph is a path. Alpern and Lidbetter (2013)
describe a polynomial algorithm for the expanding search problem when the
underlying graph is a tree, and Tan et al. (2019) study both exact and approximation algorithms when there are multiple searchers, again for the special case
of trees. Fokkink et al. (2019), finally, generalize the algorithm of Alpern and
Lidbetter (2013) to submodular cost and supermodular weight functions. This
generalization, however, does not work for general graphs since the length necessary to search a set of vertices is, in general, not a submodular function of
that set.
Several articles have also studied expanding search games, where an adversary, or hider, chooses the target’s location so as to maximize the expected search
time. This then leads to a zero-sum game between the searcher and hider. In
this setting, the probability distribution for the target’s location cannot be taken
as given, but results from an optimal (mixed) hider strategy. Alpern and Lidbetter (2013) solve the game for trees and 2-edge-connected graphs, and Alpern
and Lidbetter (2019) describe a method to approximate the game’s value for

3

arbitrary graphs. Angelopoulos et al. (2019) study a related problem where the
searcher wants to minimize the expanding search ratio, defined as the maximum
over all vertices of (i) the length that the search needs to reach a vertex and (ii)
the shortest path between the root and that vertex. The authors show that the
problem is NP-hard and find constant-factor approximation algorithms.
Overview. After formally defining the expanding search problem in Section 2,
we develop our branch-and-cut procedure in Section 3. Next, we describe our
greedy approximation algorithm and local search in Section 4, and report our
findings from the computational experiments in Section 5. Finally, we conclude
and discuss potential future work in Section 6.

2

Problem statement

Let G = (V, E) be a connected graph with root r ∈ V , a probability pv ∈ [0, 1]
associated to each vertex v ∈ V , and a length λe ∈ R>0 to each edge e ∈ E.
Denote the number of non-root vertices by n = |V \ {r}|. We consider one
searcher who has perfect information about the vertex probabilities and edge
lengths. Finally, we assume that the P
target is hidden at exactly one of the
non-root vertices such that pr = 0 and v∈V pv = 1.
We define an expanding search as a sequence of edges σ = (e1 , . . . , en ) such
that r ∈ e1 and each edge ek , with k = 1, . . . , n, connects an unvisited vertex to
one of the previously visited vertices. Hence, the edges {e1 , . . . , ek } form a tree
Pk
in G for every k = 1, . . . , n. Next, denote by λ(σ, v) = i=1 λei the distance
traveled until the search σ = (e1 , . . . , en ) reaches vertex v ∈ V , where ek is the
first edge in σ with v ∈ ek . The search cost c(σ) of an expanding search σ,
defined as the expected distance traveled before finding the target, then equals
X
c(σ) =
pv λ(v, σ),
(1)
v∈V

and the expanding search problem asks to find an expanding search that minimizes this search cost. As mentioned above, Averbakh and Pereira (2012,
Theorem 1) have shown that a problem equivalent to the expanding search
problem is strongly NP-hard. Hence, unless P = NP, no polynomial-time algorithm that solves the expanding search problem exists and we need to rely on
exponential-time (Section 3) or approximation (Section 4) algorithms.

3

Branch-and-cut procedure

The mixed integer program that forms the base of our branch-and-cut procedure
embeds a linear program to determine an optimal search sequence on a given tree
(Section 3.1) within a mixed integer program that selects a tree (Section 3.2).
We also introduce two classes of valid inequalities to strengthen the formulation
(Section 3.3) and show how to separate these valid inequalities (Section 3.4).

3.1

Linear program for trees

If G takes the form of a rooted tree, then the searcher can only probe a vertex
v ∈ V \ {r} if all vertices on the unique path from r to v in the tree have
4

already been searched. Let A denote the set of arcs obtained by directing
all edges in the tree so as to reflect these precedence constraints. That is,
the set A contains an arc (i, j) for each edge {i, j} ∈ E such that vertex i is
the immediate predecessor of vertex j in the tree’s unique path from r to j.
Several polynomial-time algorithms for the expanding search problem on a tree
then arise as a special case of existing methods for sequencing with precedence
constraints (Sidney, 1975; Monma and Sidney, 1979; Queyranne and Wang,
1991; Correa and Schulz, 2005).
Define a decision variable δij for each pair of vertices i, j ∈ V that indicates
whether or not the search visits vertex i before j, and a decision variable zi
for each vertex i ∈ V that records the probability that the target has not been
found before visiting vertex i. Now consider the following linear program.
X
[LP]
min
λ{i,j} zj
(2)
(i,j)∈A

s.t.

δij + δji = 1
δij + δjk + δki ≥ 1
δij = 1
pi +

X

pj δij = zi

∀ i, j ∈ V , i 6= j

(3)

∀ i, j, k ∈ V , i 6= j 6= k 6= i

(4)

∀ (i, j) ∈ A

(5)

∀i ∈ V

(6)

∀ i, j ∈ V

(7)

j∈V \{i}

δij ≥ 0

To see why this is a correct formulation for the expanding search problem on
a tree, suppose first that all variables δij are either zero or one. Constraints (3)
then make sure that vertex i is searched either before or after vertex j. Together
with Constraints (4) and (5), this also enforces transitivity and the precedence
constraints (Potts, 1980). Constraints (6), in turn, state that the target has not
been found before reaching a certain vertex i with a probability equal to the
total probability mass of all vertices unvisited prior to arriving at that vertex i.
The objective function (2), finally, combines the length of each arc with the
probability that the searcher travels through this arc. Correa and Schulz (2005)
have shown that a linear program equivalent to [LP], denoted [P-LP] in their
article, has an optimal solution with all variables δij either zero or one. Hence,
the linear program [LP] provides a correct formulation for the expanding search
problem on a tree.

3.2

Mixed integer program for general graphs

We keep the notation of the previous section except for A = {(i, j), (j, i) : {i, j} ∈
E}, which now includes an arc for both possible directions to move over each
edge. We say that the search uses arc (i, j) ∈ A if the searcher travels from
vertex i to vertex j through edge {i, j}. In addition to the decision variables
used in the linear program [LP], we introduce for each arc (i, j) ∈ A a binary
decision variable xij that indicates whether or not the search uses arc (i, j) and,
similarly, a continuous decision variable yij that records the probability that
the searcher did not find the target before using arc (i, j). The following mixed
integer program then constitutes a valid formulation for the expanding search

5

problem on general graphs.
[MIP]

X

min

λ{i,j} yij

(8)

(i,j)∈A

s.t.

(3), (4), (6), and (7)
X
xij = 1

∀ j ∈ V \ {r}

(9)

∀ j ∈ V \ {r}

(10)

0 ≤ yij ≤ xij ≤ δij

∀ (i, j) ∈ A

(11)

xij ∈{0, 1}

∀ (i, j) ∈ A

(12)

i: (i,j)∈A

X

yij = zj

i: (i,j)∈A

Similarly as before, the objective function (8) combines the length of each
edge with the probability that the searcher travels through that edge. Constraints (9) state that the search must reach every non-root vertex through
exactly one arc, and Constraints (3), (4) and (11) prevent cycles. Together with
Constraints (12), all feasible assignments to the variables (xij )(i,j)∈A thus constitute a spanning tree of G with root r. By Constraints (10), the probability that
the search reaches a vertex equals the total probability with which the search
travels through an arc leading to that vertex. Combined with Constraints (9)
and (11), this implies that for each vertex j ∈ V \ {r} we have yij = zj if (i, j)
is the unique arc reaching vertex j (and thus having xij = 1), and yij = 0
otherwise. Hence, the x-variables select a tree, the δ- and z-variables determine
an optimal search sequence on this tree, and the y-variables translate this to
the associated search cost.

3.3

Valid inequalities

The main source of weakness for the linear programming (LP) relaxation of
[MIP] is that, in the presence of fractional values for the x-variables, there can
be multiple arcs (i, j) leading to the same vertex j with a positive value for
yij . The valid inequalities to be discussed in this section attempt to better
coordinate the value of these y-variables.
The first set of valid inequalities is inspired by the so-called “directed cut
model” for spanning trees (see e.g. Magnanti and Wolsey, 1995):
X
yij ≥ zk
for all k ∈ V \ {r} and S ⊆ V \ {k} with r ∈ S. (13)
(i,j)∈C(S)

Here, the directed cut C(S) = {(i, j) ∈ A : i ∈ S, j ∈
/ S} collects all arcs starting
in S and ending in V \ S. The inequalities are valid because at least one arc
in each directed cut C(S) that separates a vertex k from the root should be
traveled through with at least the probability to reach this vertex k.
Our second set of valid inequalities is similar to Constraints (13), except
that now we directly use the probability parameters (pi )i∈V instead of decision
variables (zi )i∈V :
X
X
yij ≥
pi
for all S ⊆ V with r ∈ S.
(14)
(i,j)∈C(S)

i∈V \S

6

These inequalities are valid since at least one arc in the directed cut
should be traveled through with a probability equal to the probability
of all vertices outside set S. For the special case where S = V \ j for
j ∈ V \ {r}, these inequalities can be strengthened to
X
zj =
yij ≥ pj + yjk
∀ (j, k) ∈ A.

C(S)
mass
some

(15)

i: (i,j)∈A

Indeed, the searcher travels to vertex j with a probability at least the sum of
the probability that vertex j contains the object and that the searcher travels
through arc (j, k).
In the remainder of this paper, we refer to the two classes of Inequalities (13)
and (14)-(15) as cuts (C1) and (C2), respectively.

3.4

Separation

Constraints (13) and (14) contain exponentially many inequalities and it is
therefore undesirable to include them all. Instead, we embed these inequalities
in a cutting plane algorithm that iteratively solves the LP relaxation of [MIP],
checks whether a violated valid inequality exists and, if so, adds it. This gives
rise to a branch-and-cut procedure where we use the cutting plane algorithm to
solve the LP relaxations and branch on whether or not to use an arc.
For both Constraints (13) and (14), we can check whether there is a violated
?
inequality by solving O(n) minimum cut problems. Let (x?ij , yij
)(i,j)∈A , (zj? )j∈V
be a given solution to the LP relaxation and consider the directed graph (V, A) in
?
which arc (i, j) ∈ A has capacity yij
. A violated inequality for Constraints (13)
then exists if and only if there is a vertex k ∈ V \ {r} for which the minimum
directed cut separating r from k has a capacity strictly smaller than zk? . A similar
approach allows to separate Constraints (14), except that now we additionally
introduce a dummy sink node t in our directed
P graph and anPextra arc (i, t)
for each node i ∈ V with capacity pi . Since i∈V \S pi = 1 − i∈S pi for each
S ⊆ V , a violated inequality for Constraints (14) then exists if and only if the
minimum directed cut has a capacity strictly smaller than one.

4

Approximation algorithm

If the graph is a star with the root at its center, traveling to a non-root vertex v
takes the same distance λ{r,v} , independently of which vertices have been visited
before. A straightforward pairwise interchange argument then shows that it is
optimal to visit the vertices in non-increasing order of the ratio pv /λ{r,v} (Smith,
1956). The search density of a subgraph generalizes this idea to subgraphs by
taking the ratio of (i) the total probability mass of all vertices in the subgraph
and (ii) the total length of all edges in the subgraph.
Alpern and Lidbetter (2013) have shown that if G is a tree, then there exists
an optimal search that starts with searching the edges of a maximum density
subtree. Although this approach may be suboptimal in general graphs (Alpern
and Lidbetter, 2013), we will show that the resulting search cost is at most
four times the optimal one. The problem of finding a subtree of maximum
density in a general graph, however, is also strongly NP-hard. We develop a
1/2-approximation for this problem (Section 4.1) and show how this leads to an
7

8-approximation for the expanding search problem (Section 4.2). In Section 4.3,
finally, we discuss a local search procedure to further improve the sequence found
by the approximation algorithm.

4.1

The maximum density subtree problem

Given an arbitrary graph G0 , let V [G0 ] and E[G0 ] collect the vertices and edges
0
0
of G0 , respectively. For
P a set of vertices0 V ⊆
P V of edges E ⊆ E, we use
0
the notation p(V ) = v∈V 0 pv and λ(E ) = e∈E 0 λe . Let T (G) collect all
subtrees with root r of the graph G and, given a subtree T ∈ T (G), denote
p(T ) = p(V [T ]) and λ(T ) = λ(E[T ]). The search density, or simply density, of
a subtree T ∈ T (G) with λ(T ) > 0 is then defined as
ρ(T ) =

p(T )
,
λ(T )

and the maximum density subtree problem (MDSP) asks to find a tree T ? ∈
T (G) that maximizes this density:
ρ? = ρ(T ? ) = max ρ(T ).
T ∈T (G)

The MDSP can be solved efficiently by a dynamic program in case G is a tree
(Alpern and Lidbetter, 2013), but it is strongly NP-hard in general (Lau et al.,
2006, Theorem 8). Kao et al. (2013) describe both exact and approximation
algorithms for different variants of the MDSP, but, to the best of our knowledge,
we are the first to develop an approximation algorithm for the MDSP as defined
above.
As a subroutine to our approximation algorithm, we consider a sequence of
instances for the prize-collecting Steiner tree (PCST) problem. Given a connected graph G = (V, E) with root r, edge lengths (λe )e∈E , and vertex penalties (p)v∈V , the PCST problem asks to find a tree T ∈ T (G) that minimizes
λ(T )+p(V \V [T ]). Goemans and Williamson (1995) have developed an approximation algorithm (henceforth called the GW algorithm) for the PCST problem
with the following guarantee:
Theorem 1 (Goemans and Williamson, 1995). The GW algorithm yields a tree
T ∈ T (G) with




1
1
λ(T ) + 2 −
p(V \ V [T ]) ≤ 2 −
(λ(T 0 ) + p(V \ V [T 0 ]))
n
n
for each T 0 ∈ T (G).
Our approximation algorithm for the MDSP consists of a parametric search
where we iteratively guess a value for the maximum density ρ? and evaluate our
guess by employing the GW-algorithm. In particular, given a constant ε > 0,
our parametric search produces a subtree T s ∈ T (G) as follows:

1. Take arbitrary T s ∈ T (G), and initialize α ← 2 − n1 p(T s )/λ(T s ) and
β ← max{pv /λ{v,w} : {v, w} ∈ E}
2. While β > (1 + ε) α, do
8

(a) ρ ← (α + β)/2
(b) let T be the subtree obtained by applying the GW algorithm on
graph G with lengths (ρλe )e∈E and penalties (pv )v∈V


(c) if 2 − n1 p(T ) ≤ ρλ(T ), let β ← ρ; else, let α ← 2 − n1 ρ(T ) and
Ts ← T
3. Return T s .
Proposition 1. For each ε > 0, the maximum density ρ? is at most (1 + ε) 2 −
times the density ρ(T s ) of the tree T s obtained by the parametric search.
Proof. Denote by αi , βi , and Tis the values for α, β, and T s at the beginning of
iteration i in the while loop, and let T ? be a tree with maximum density ρ? . We
claim that for each iteration i ≥ 1 it holds that ρ? ≤ βi and αi = 2 − n1 ρ(Tis ).
Since β ≤ (1 + ε) α after the final iteration, this implies


1
ρ(T s ),
ρ? ≤ (1 + ε) α = (1 + ε) 2 −
n
which would then prove the result.

We prove the claim by induction. By definition, α1 = 2 − n1 ρ(T1s ). Since
for every two sequences a1 , . . . , ak and b1 , . . . , bk of respectively non-negative
and positive numbers it holds that
Pk
aj
j=1 aj
max
≥ Pk
,
j=1,...,k bj
j=1 bj
we also have that β1 ≥ ρ? .
?
Next, take
 ans arbitrary iteration i ≥ 1, and assume that βi ≥ ρ and
1
αi = 2 − n ρ(Ti ). Let T be the subtree obtained by the GW algorithm and
distinguish between two cases. Firstly, if


1
p(T ) ≤ ρλ(T ),
2−
n

then adding 2 − n1 p(V \ V [T ]) to both sides of this inequality yields that




1
1
2−
p(V ) ≤ ρλ(T ) + 2 −
p(V \ V [T ]).
n
n
Hence, by Theorem 1, we have for each T 0 ∈ T (G) that




1
1
2−
p(V ) ≤ 2 −
(ρλ(T 0 ) + p(V \ V [T 0 ]))
n
n
or, equivalently, that ρλ(T 0 ) ≥ p(T 0 ). Thus, our guess ρ for the density was
?
s
s
too high, and we obtain
 that βi+1 = ρ ≥ ρ , while αi+1 = αi and Ti+1 = Ti .
1
Alternatively, if 2 − n p(T ) > ρλ(T ), then




1
1
2−
p(V ) > ρλ(T ) + 2 −
p(V \ V [T ]),
n
n

which yields that 2 − n1 ρ(T ) > ρ.  Thus, our guess ρ for the density was
s
too low, and we have αi+1 = 2 − n1 ρ(Ti+1
) > ρ and βi+1 = βi . Together
with the induction
hypothesis,
we
obtain
in
both cases that ρ? ≤ βi+1 and

1
s
αi+1 = 2 − n ρ(Ti+1 ), which proves the claim.
9

1
n



As summarized by the next result, by choosing ε = 1/(2n − 1), we obtain a
1/2-approximation algorithm for the MDSP. The associated running time consists of the one for the GW algorithm multiplied with the number of iterations
in the while loop. In particular, Hegde et al. (2015, Theorem 28) discuss how
the GW algorithm can be implemented to run in time O(|E| log(n) log(M )) and,
for every ε > 0, the number of iterations in the while loop is O(log(M/ε)).
Corollary 1. For ε = 1/(2n − 1), the parametric search is a 1/2-approximation
algorithm for the maximum density subtree problem that runs in time
O(|E| log(n) log(M ) log(nM )), with M the largest input number required to describe the instance.

4.2

Greedy algorithm for the expanding search problem

To represent the graph structure that remains after having searched a set of
vertices, we use the concept of vertex contraction. Given a graph G = (V, E)
and a subset S ⊆ V with r ∈ S, denote the graph obtained by contracting the
vertices in S to the root by G/S. For each vertex w ∈ V \ S, let C(w, S) =
{{v, w} ∈ E : v ∈ S} collect all edges in E connecting vertex w to a vertex in S.
We then have that V [G/S] = (V \S)∪{r}, and that E[G/S] consists of all edges
{v, w} ∈ E with v, w ∈ V \ S and all edges {r, w} with w ∈ V \ S and non-empty
C(w, S). For each edge e ∈ E[G/S] in the contracted graph, we define a length
/ e, then we take
λSe as follows. If the edge is not adjacent to the root, i.e. if r ∈
the original edge length λSe = λe . If the edge is of the form e = {r, w} for some
w ∈ V \S, in turn, then we set λSe equal to the minimal length to reach vertex w
from the set S in the original graph, i.e. λSe = mine0 ∈C(w,S) λe0 .
Our greedy algorithm assumes that an approximation algorithm for the
MDSP is available and uses this to produce a search sequence σ g as follows:
1. Initialize i ← 1 and S ← {r}
2. While a vertex v ∈ V \ S with pv > 0 remains, do
(a) let Ti be the subtree obtained by applying the approximation algorithm for the MDSP on graph G/S with probabilities (pv )v∈V [G/S]
and lengths (λSe )e∈E[G/S]
(b) let σi be an arbitrary expanding search on tree Ti
(c) increment i and let S ← S ∪ V [Ti ]
3. Let σ g be the expanding search implied by (σ1 , σ2 , . . .), where every edge
adjacent to the root in the contracted graph is replaced with a corresponding length-minimizing edge in the original graph.
Suppose we have an algorithm for the MDSP that can find a subtree with
a density at most α ≥ 1 times smaller than the maximum density. Employing
this algorithm within our greedy procedure then leads to a search sequence with
a cost at most 4α times the optimal search cost. The proof follows a similar
structure as the one of Feige et al. (2004, Theorem 4).
Theorem 2. Given a 1/α-approximation algorithm for the maximum density
subtree problem, the greedy algorithm is a 4α-approximation algorithm for the
expanding search problem.
10

Proof. Let σ ? be an optimal expanding search sequence, σ g the sequence obtained by the greedy algorithm, and m the
number of iterations in this greedy
Sm
algorithm. For each iteration i, let Ri = j=i V [Tj ] \ {r} collect the unvisited
vertices prior to iteration i, denote by λ(i) = λV \Ri (Ti ) the total length of the
tree obtained in iteration i, and call ϕi = p(Ri )λ(i) /p(Ti ) the price of iteration i.
To show that c(σ g ) ≤ 4αc(σ ? ), we proceed in three steps. Firstly, Lemma 1
gives an upper bound on the greedy algorithm’s search cost in terms of the
weighted sum of prices. Next, Lemma 2 shows that if the searcher has already
visited a set S of vertices and if ρ̄ is an upper bound on the density in the
remaining graph G/S, then no tree in the original graph can search more than
τ ρ̄ probability mass of the unvisited vertices within length τ . Lemma 3, finally,
uses this result together with a geometric argument to show that the upper
bound for the greedy algorithm’s search cost is at most four times the optimal
search cost.
Pm
Lemma 1. c(σ g ) ≤ i=1 p(Ti )ϕi .
Proof. By Equation (1) and the construction of σ g ,
c(σ g ) =

X

pv λ(v, σ g ) =

m
X
X

pv λ(v, σ g ) ≤

i=1 v∈V [Ti ]

v∈V

m
X
X
i=1 v∈V [Ti ]

pv

i
X

λ(j) .

j=1

Rearranging terms then yields that
c(σ g ) ≤

m
X
i=1

λ(i)

m
X

p(Ti ) =

m
X

λ(i) p(Ri ),

i=1

j=i

and the result follows since the definition of ϕi implies that λ(i) p(Ri ) = p(Ti )ϕi .
Lemma 2. Given set of vertices S ⊂ V , let ρ̄ be such that ρ̄ ≥ p(T )/λS (T ) for
every T ∈ T (G/S). For each τ > 0 and T ∈ T (G) with λ(T ) ≤ τ then holds
that p(V [T ] \ S) ≤ τ ρ̄.
Proof. For arbitrary τ > 0 and T ∈ T (G) with λ(T ) ≤ τ , consider the graph
T /S obtained from T by contracting the vertices of S to the root. Since T /S ∈
T (G/S), the definition of ρ̄ together with the observation that λS (T /S) ≤
λ(T ) ≤ τ yields that
p(V [T ] \ S) = p(T /S) ≤ ρ̄λS (T /S) ≤ τ ρ̄.
Lemma 3.

Pm

i=1

p(Ti )ϕi ≤ 4αc(σ ? ).

Proof. The proof relies on a geometric argument and proceeds P
in two steps.
m
Firstly, we construct two diagrams whose surfaces equal c(σ ? ) and i=1 p(Ti )ϕi ,
respectively. Next, we show that if we shrink the latter diagram by factor 4α,
then it fits within the former. Figure 1 illustrates this idea.
The first diagram contains one column for each non-root vertex and these
n columns are ordered from left to right in the same order as the optimal
expanding search visits the corresponding vertices. In particular, if vertex v ∈ V
is the k th one to be searched by σ ? , then let pv be the width of column k and
11

Figure 1: Geometric argument to show that

Pm

i=1

p(Ti )ϕi ≤ 4αc(σ ? ).

ϕ

λ

ϕi

λ(v, σ ? )

q0

p

pv

p(Ti )

p

λ

ϕi
2α

q
p(Ri )/2

p

λ(v, σ ? ) its height. By Equation (1), the resulting diagram’s surface equals
c(σ ? ). The second diagram, in turn, contains m columns that correspond to the
trees selected in the greedy algorithm. Let p(Ti )Pbe the width of column i and
m
ϕi its height, then the diagram’s surface equals i=1 p(Ti )ϕi .
Now shrink the second diagram’s surface by dividing the width of each column by two and the height by 2α. The original diagram’s surface then equals
4α times the shrunk one. Next, take an arbitrary point q 0 within the second
diagram, align the shrunk diagram to the right of the first diagram, and call
q the point corresponding to q 0 within the shrunk diagram (see Figure 1). To
complete the proof, we show that q lies within the first diagram.
Call i the index of the column that contains q 0 in the second diagram, then
the height of point q in the shrunk diagram is at most ϕi /2α and its distance
from the right-hand side boundary is at most p(Ri )/2. Hence, it suffices to
show that after having traveled length ϕi /2α, at least a probability mass of
p(Ri )/2 still needs to be searched under the optimal sequence σ ? . To prove
this, we apply Lemma 2 with S = V \ Ri and ρ̄ = αp(Ti )/λ(i) , where ρ̄ upper
bounds the density in G/Si since we obtained Ti from our 1/α-approximation
algorithm for the MDSP. Lemma 2 then yields that in length τ = ϕi /2α, the
optimal sequence σ ? can search at most a probability mass
ϕi αp(Ti )
p(Ri )
=
2α λ(i)
2
within the set Ri . Hence, after length ϕi /2α, a probability mass of at least
p(Ri )/2 still needs to be searched, which implies that point q lies within the
first diagram.
In sum, Lemmas 1 and 3 yield
g

c(σ ) ≤

m
X

p(Ti )ϕi ≤ 4αc(σ ? ),

i=1

which completes the proof of Theorem 2.
12

Since the greedy algorithm needs at most n iterations to construct the sequence σ g , Corollary 1 and Theorem 2 yield the following result.
Corollary 2. The greedy algorithm and parametric search with ε = 1/(2n − 1)
yield an 8-approximation algorithm for the expanding search problem that runs in
time O(|E|n log(n) log(M ) log(nM )), with M the largest input number required
to describe the instance.

4.3

Local search

We now describe a local search algorithm that attempts to improve a given
search sequence, such as the one obtained by our greedy algorithm. In this
procedure, a solution is represented by a spanning tree in the metric closure of
the instance graph. The associated cost is the search cost of an optimal sequence
within this tree. A local move consists of adding one edge and removing another
edge such that we obtain a new spanning tree. If the optimal search cost of the
new tree is better than that of the previous tree, we proceed with it; otherwise,
we try the next local move. The algorithm ends when no move exists that
improves upon the current tree’s search cost.
To formalize this, denote by Ḡ = (V, Ē) the metric closure of graph G =
(V, E), i.e. the complete graph on V with the length of edge {v, w} ∈ Ē equal
to the shortest path between vertices v and w in G. Let T ∈ T (Ḡ) be a
given spanning tree of Ḡ, and define c? (T ) as the optimal search cost associated
with this tree. Note that c? (T ) can be efficiently computed using, for example,
the algorithm of Monma and Sidney (1979). Next, call CT,e the fundamental
cycle of T with respect to an edge e ∈ Ē \ E[T ], i.e. the unique cycle in the
graph obtained by adding edge e to tree T . Finally, let T + e − e0 denote
the tree obtained by adding an edge e ∈ Ē \ E[T ] to T and removing another
edge e0 ∈ CT,e . Our local search algorithm then produces a feasible expanding
search sequence σ ls for the original graph G as follows:
1. Given a spanning tree T ∈ T (Ḡ), initialize S ← Ē \ E[T ]
2. While S is non-empty, do
(a) take an arbitrary edge e ∈ S
(b) if c? (T + e − e0 ) < c? (T ) for an edge e0 ∈ CT,e , let T ← T + e − e0
and S ← Ē \ E[T ]
(c) else, let S ← S \ {e}
3. Let σ ls be the search sequence in G obtained from the optimal sequence
associated with T in Ḡ by replacing each transitive edge by the underlying
shortest path in G and, to avoid cycles, omitting those edges that connect
two previously visited vertices.
Our computational experiments suggest that, empirically, this local search
provides a high-quality solution as it attained the optimum in around 80% of
the cases. The next lemma shows that the procedure always finds a globally
optimal solution if the input graph is a cycle. To keep the proof simple, we
assume that pv > 0 for all v ∈ V \ {r}, which is without loss of generality.
Lemma 4. If G is a cycle, every locally optimal tree is also globally optimal.
13

Figure 2: Instance that illustrates the importance of taking the graph’s metric
closure in our local search.
1

r

m
m
m

2

1
k
1
k

..
.
k

1
1

n

1
1
k

m

Proof. Let T ∈ T (Ḡ) be a locally optimal tree in the metric closure of G. By
contradiction assume that T contains an edge e = {v, w} that is in Ḡ but not
in G. W.l.o.g. assume e is the last such edge in the optimal search sequence σ
for T and that v is visited before w. Because e is not in G, it corresponds to a
path in G containing at least one internal vertex. Let z be the internal vertex
of this path that is visited first in the sequence σ. If z is visited before w in σ,
then the tree T 0 = T + {z, w} − {v, w} has lower optimal search cost than T
(note that a feasible search sequence for T 0 is σ with {v, w} replaced by {z, w},
with λ{z,w} < λ{v,w} ). If z is visited after w in σ, then by choice of e and z,
either the edge {v, z} or the edge {z, w} must be in T . Note that replacing
{v, w} ∈ T by the respective missing edge is a feasible local move, creating a
new tree T 00 . A feasible search sequence for T 00 is σ with {v, w} replaced by the
tuple {v, z}, {z, w}. In this sequence, z is visited strictly earlier while no other
vertex is visited later than in the optimal order for T . Hence, in either case, T
was not locally optimal, yielding a contradiction.
We conclude that T only contains edges of G. Because G is a cycle, any tree
in G can be attained from T by a local move. Because there is a tree T ∗ in G
that corresponds to a globally optimal search sequence, also T must be globally
optimal.
Figure 2 illustrates the importance of taking the metric closure of the graph.
Given positive integers n, m, and k = n − 1, consider the search sequence σ1 =
({r, 1}, {r, 2}, . . . , {r, k}, {r, n}), and the search sequence σ ? = ({r, n}, {1, n},
{2, n}, . . . , {k, n}), which is a global optimum for m, k ≥ 3. The associated
Pk
m(k+1)
search costs are c(σ1 ) = i=1 im
and c(σ ? ) = m+ (k+1)
k =
2
2 , such that the
ratio c(σ1 )/c(σ ? ) can be made arbitrarily high by choosing k and m sufficiently
large. Without considering the metric closure of the graph, the tree defined by
the first sequence forms a local optimum because replacing an edge {r, i} by
another edge {i, n} only increases the distance to reach vertex i ∈ {1, . . . , k}. If
we do consider the metric closure, however, this tree is locally optimal only if
m ≤ 2 because, otherwise, replacing edge {r, 2} by the transitive edge {1, 2} of
length 2 would decrease the search cost. Since for m = 2 the ratio c(σ1 )/c(σ ? )
tends to 2 as k increases, we conclude that the worst-case ratio for the instance
of Figure 2 is arbitrarily high without considering the graph’s metric closure and
is bounded by 2 if we do consider the metric closure. This latter observation

14

Figure 3: Instance for which the local search of Averbakh and Pereira (2012)
has locality gap Ω(n).
1
n

i

i−1
2

i

2
n−1
1
n

1
n

1

n

1
n

r

1
n

n

also implies that the worst-case ratio of our local search is at least 2.
Averbakh and Pereira (2012) have described a different local search for expanding search. In their method a solution is represented by the sequence in
which the vertices are visited instead of by the underlying spanning tree. Given
a permutation π = (r, π1 , . . . , πn ) of the vertices in V with πk indicating the k th
vertex to be searched, define a spanning tree T π ∈ T (Ḡ) by including for each
k ∈ {1, . . . , n} a minimum-length edge in the metric closure Ḡ that connects
vertex πk to one of the vertices in {r, π1 , . . . , πk−1 }. Given a permutation π,
the local search of Averbakh and Pereira (2012) then checks whether there exist i and j, with i < j, such that the permutation π 0 obtained by inserting
vertex πj at position i in permutation π and shifting all vertices (πi , . . . , πj−1 )
0
one position backwards attains a lower search cost c? (T π ) < c? (T π ). If so, the
procedure repeats with permutation π 0 , otherwise π is a local optimum. Observe
that Averbakh and Pereira (2012) focus on complete graphs in their article, but
that this is equivalent to our setting when taking the metric closure.
Although the insertion-based local search of Averbakh and Pereira (2012) is
a natural approach, Figure 3 illustrates that it can perform arbitrarily bad on a
cycle. This contrasts with our local search procedure that, as argued above, finds
a global optimum on a cycle. Referring to Figure 3, the ‘clockwise’ sequence π =
(r, n, n − 1, . . . , 1) forms a local optimum for the procedure of Averbakh and
Pn Pn
Pereira (2012) with search cost c? (T π ) = i=1 j=i nj = (n+1)(2n+1)
(it is easy
6
to check that changing only a single element in the sequence does not result
in lower cost). The optimal expanding search σ ? = ({r, 1}, {1, 2}, . . . , {n −
1, n}), however, goes counterclockwise and attains a search cost of c(σ ? ) =
P
n
n+i−1
?
π
?
= 3n−1
i=1
n
2 . Hence, the ratio c (T )/c(σ ) grows proportionally with
n, establishing that the locality gap of this procedure is Ω(n).

5

Computational experiment

This section reports how our methods perform on existing and newly generated
test instances. After providing details regarding the implementation, we test
our branch-and-cut algorithm on the benchmark instances provided by Averbakh and Pereira (2012). The results indicate that our method outperforms
15

the current state of the art for weighted instances (i.e. with probabilities that
differ across vertices) and that sparse graphs are considerably easier to solve
than dense ones. We also provide numerical evidence that our valid inequalities
and heuristics lead to reasonably tight lower and upper bounds for the optimal
search cost.

5.1

Implementation details

All our algorithms were implemented using the C++ programming language,
compiled with Microsoft Visual C++ 14.0, and run using an Intel Core i7-4790
processor with 3.60 GHz CPU speed and 8 GB of RAM under a Windows 10
64-bit OS. To solve the mixed integer programs, we employed the commercial
solver IBM ILOG CPLEX 12.8 using only one thread. Apart from the warm
start provided by our greedy algorithm combined with the local search, all
CPLEX parameters were set to their default values.
Unless mentioned otherwise, we ran our branch-and-cut algorithm with both
classes of valid inequalities, i.e. with cuts (C1) and (C2). Violated valid inequalities were separated using the Ford-Fulkerson algorithm (Ford and Fulkerson,
1956). Relying on more efficient algorithms for the maximum flow problem, such
as the push-relabel algorithm of Goldberg and Tarjan (1988), should not affect
our results because separating the cuts requires only a relatively small fraction
of the computation time. For the GW subroutine in our greedy algorithm, finally, we used the implementation of Hegde et al. (2015) that is available on
GitHub (https://github.com/fraenkel-lab/pcst_fast). As part of our local search, we employed the polynomial-time algorithm of Monma and Sidney
(1979) to determine an optimal sequence for a given tree, and we took the tree
returned by the greedy algorithm as input for the local search procedure.

5.2

Performance on instances of Averbakh and Pereira
(2012)

Averbakh and Pereira (2012) consider both an unweighted and a weighted version of their problem, which corresponds to whether or not all vertices have
equal probabilities. They further distinguish between random and euclidean
network structures. In the first case, the distance between each pair of vertices
is randomly generated, after which the metric closure of the graph is taken by
computing shortest paths. In the second case, the distances are generated by
associating with each vertex a point in the euclidean plane and then taking the
euclidean distance between each pair of points and rounding to the nearest integer. For both types, the authors generated 10 benchmark instances with and
without vertex weights for each of the considered network sizes.
Tables 1-2 displays the average CPU time in seconds for the branch-andbound algorithm of Averbakh and Pereira (2012) and for our branch-and-cut
method, where the averaging occurs over the solved instances within each setting. Importantly, the CPU times for the algorithm of Averbakh and Pereira
(2012) have been taken directly from their article because we were unable to
obtain or to replicate their code. To partially compensate for the different processor speeds (2.33 GHz versus 3.60 GHz), we employ a time limit of 20 minutes
to solve the instances instead of the 30 minutes used in Averbakh and Pereira

16

Table 1: Average CPU time in seconds for the branch-and-bound method of
Averbakh and Pereira (2012) using an Intel Core 2 Duo 2.33 GHz processor and
a 30-min time limit. The number of solved instances appears in parentheses if
not all 10 could be solved.
unweighted

weighted

n

random

euclidean

random

euclidean

10
15
20
25
30
35
40
45
50
55
60
65
70

0.01
0.01
0.01
0.01
0.01
0.07
0.05
0.15
0.91
4.71
12.57
135.35
263.14

0.01
0.01
0.01
0.01
0.02
0.09
0.36
2.37
11.86
70.52
165.83 (9)
468.80 (8)
858.16 (5)

0.00
0.01
0.02
1.10
9.59
229.40
836.94 (4)

0.00
0.01
0.02
0.30
2.57
72.27
487.96 (7)
1,377.24 (3)

(2012). If not all 10 instances were solved within their respective time limit, the
number of solved instances appears in parentheses.
The results indicate that our branch-and-cut method outperforms the branchand-bound algorithm of Averbakh and Pereira (2012) for the weighted but not
for the unweighted instances. This behavior occurs because the method used
to compute lower bounds for the unweighted instances in Averbakh and Pereira
(2012) differs from the one used to compute lower bounds for the weighted instances. As a result, also the bounds’ quality differs for the two cases. Our
formulation, in contrast, remains unaffected by vertex weights.
Observe that our branch-and-cut algorithm solves random instances with
considerably less effort than it needs to solve the euclidean ones. One possible
explanation is that our formulation might implicitly ignore those edges whose
random length was replaced by a shorter path; indeed, these edges are dominated because they have a length equal to a path that also visits intermediate
vertices. Ignoring these dominated edges could improve the performance because it essentially reduces the number of spanning trees that our method needs
to enumerate. The next section examines this effect in further detail.
For the unsolved instances, we also recorded the relative gap between the
best upper and lower bound obtained after reaching the time limit. The average
optimality gap, not included in the tables, was at most 2.16% for our branchand-cut method, whereas Averbakh and Pereira (2012) reported an average
optimality gap of up to 20.77%.

5.3

Influence of network density

The density of a graph G = (V, E), not to be confused with Section 4’s search
density, is defined as the ratio between the actual number of edges |E| and the
17

Table 2: Average CPU time in seconds for our branch-and-cut algorithm using
an Intel Core i7-4790 3.60 GHz processor and a 20-min time limit. The number
of solved instances appears in parentheses if not all 10 could be solved.
unweighted
n

random

10
15
20
25
30
35
40
45
50
55
60
65
70

0.15
0.24
0.98
1.67
2.34
7.86
10.05
12.54
71.44
41.69
98.79
77.60
166.78 (9)

weighted

euclidean
0.15
0.32
1.09
3.31
7.76
27.83
60.82
157.80
192.16
436.99
577.51
601.35

(9)
(7)
(4)
(3)

random
0.15
0.22
0.67
2.60
2.76
6.91
13.54
18.44
48.60 (9)
70.98
112.21 (9)
195.91
162.57

euclidean
0.16
0.29
1.09
1.94
22.15
57.24
110.67
144.04
161.69
168.96
683.07
486.17

(8)
(6)
(3)
(4)

maximum possible number of edges |V |(|V |−1)/2. To examine how the network
density influences the computational performance, a new set of test instances
was generated in which we control for the network density. In particular, for all
considered graph sizes and densities, ten instances were randomly generated as
follows. An integer weight av between 0 and 1000 was drawn randomly
for each
P
vertex v ∈ V \ {r}, after which we set the probability pv = av / w∈V \{r} aw .
To generate edges, first a spanning tree was constructed by randomly selecting a sequence of edges and including the next edge whenever it connects two
previously unconnected vertices. Secondly, edges were randomly added until
the desired density was obtained. Edge lengths were generated by assigning an
arbitrary point in the natural cube between 0 and 100 to each vertex and then
taking the rectilinear (or Manhattan) distance between those vertices that are
connected by an edge.
Table 3 shows that the network density strongly affects the CPU times. For
graphs with n = 40 vertices and a density of 100%, for example, the average
CPU time exceeds the one for a density of 20% with almost factor ten. To a lesser
extent, the average optimality gap for unsolved instances also seems to increase
in the network density. As mentioned above, one possible reason why solving
dense graphs requires more effort is that our method needs to enumerate more
spanning trees for these graphs. Indeed, the binary x-variables in our mixed
integer program essentially select a spanning tree, and the more such trees the
graph contains, the more branching needs to be done by the branch-and-cut
algorithm.

18

Table 3: Influence of network density on average CPU time (in seconds), number
of solved instances (# out of 10), and average optimality gap (in %) using a
20-min time limit.

n
10
20
30
40
50
60
70
80
90
100
110
120

5.4

density = 20%

density = 60%

density = 100%

CPU

CPU

CPU

0.08
0.27
1.20
2.20
6.82
59.34
108.15
194.68
321.08
454.05
676.50
802.89

# gap
10
10
10
10
10
9
10
10
10
6
4
2

0.00
0.00
0.00
0.00
0.00
0.32
0.00
0.00
0.00
0.79
0.38
0.85

0.11
0.52
2.24
8.19
83.46
141.96
536.39
478.04
1,011.24

# gap
10
10
10
10
10
9
6
5
2

0.00
0.00
0.00
0.00
0.00
0.79
0.64
0.91
0.75

0.12
0.79
4.74
20.19
95.13
291.45
305.09
720.39

# gap
10
10
10
10
8
7
3
2

0.00
0.00
0.00
0.00
0.95
0.51
1.29
0.99

Quality of formulation, valid inequalities, and heuristics

Solving the linear programming (LP) relaxation obtained by relaxing the integrality constraints in our mixed integer program provides a lower bound on the
minimal search cost. The greedy algorithm, on the other hand, yields an upper
bound as it returns a feasible starting solution. The goal of adding the valid
inequalities (Section 3.3) and local search (Section 4.3), finally, is to tighten
these bounds. To assess the quality of our formulation, valid inequalities, and
heuristics, we examine how close these bounds are to the minimal search cost.
Figure 4 plots the average ratio (averaged over the 10 solved instances per
setting) between the bounds and optimum as a function of network size and
density.
With a lower bound always exceeding 97% of the minimal search cost, the LP
relaxation together with both cuts (C1) and (C2) provides a reasonable lower
bound. Although cuts (C2) do considerably increase the lower bound compared
to the formulation without valid inequalities, cuts (C1) clearly have the most
influence: the LP relaxation with only cuts (C1) achieves a lower bound only
marginally weaker than the one with all cuts included.
Figure 4 also indicates that our heuristics provide high-quality solutions,
especially when including the local search algorithm. On average, the greedy
solution exceeds the optimal search cost with at most 4%, which drops to only
0.27% after performing the local search. Moreover, out of all 379 instances
solved to optimality in our computational experiment, the local search could
find the optimum for 305 instances and exceeded the minimal search cost with
at most 2.15% for the other cases. With respect to computation times, the
greedy heuristic always required less than 0.3 seconds and the local search procedure needed at most 100 seconds. We conclude that, empirically, the greedy
algorithm produces solutions much closer to optimality than the factor eight

19

Figure 4: Average ratio between bounds and the optimum. The bounds provided
by the LP relaxation without cuts and with only cuts (C2) deteriorate as network
size and density increase, whereas the other bounds remain reasonably close to
the optimum.
(a) Ratio as a function of network size n for a given 60% network density.
bound relative to optimum
greedy

1.04

local search
all cuts

1
0.97

cuts (C1)

cuts (C2)

0.84
no cuts

0.78

n
10
30
50
(b) Ratio as a function of network density for a given network size n = 40.
bound relative to optimum
1.04

greedy
local search
all cuts

1
0.97

cuts (C1)

cuts (C2)

0.84
no cuts

0.74
20 %

60 %

20

100 % density

worst-case guarantee.
Finally, observe that the lower bound provided by the LP relaxation without
cuts and with only cuts (C2) weakens as network size and density increase. The
other bounds, in contrast, seem to be more stable. This inverse relation between
network density and the quality of the formulation without cuts constitutes
another reason why instances with a higher density require more effort: to
make up for the weaker lower bound, cuts need to be generated. Not only
does separating these cuts take time, but, more importantly, adding them also
increases the time needed to solve each LP relaxation because the model grows
in size.

6

Discussion

We have studied exact and approximation algorithms for the expanding search
problem, which has received increasing attention in the literature since its introduction by Alpern and Lidbetter (2013). Our novel branch-and-cut method
can solve instances that were unsolved by existing algorithms and the greedy
algorithm described in this paper is the first constant-factor approximation algorithm established for the problem.
The formulation at the base of our branch-and-cut procedure builds upon
results from the single-machine scheduling literature and uncouples the selection of a tree from the sequencing on that tree. We believe this could be a
fruitful approach for dealing with other scheduling problems as well. In particular, our formulation seems generalizable to the problem of scheduling with OR
precedence constraints (Gillies and Liu, 1995).
Our results also contribute to the literature on search games. More specifically, consider the expanding search game where the target acts as an adversary
that hides in one of the graph’s vertices in order to maximize the expected search
time. Together with the work of Hellerstein et al. (2019), our branch-and-cut
procedure yields a method to compute the game’s value exactly, whereas our
greedy approach allows to approximate this value within factor eight. Note that
these results are incomparable with the approximations of Alpern and Lidbetter
(2019) because, in that article, the target can hide at any point of an edge in
the network instead of being restricted to hide at vertices only.
The tree-based local search procedure introduced in Section 4.3 showed
promising results in computational experiments. We also established that it
finds a global optimum in case the underlying graph is a cycle, whereas other
natural approaches for local neighborhoods fail on these instances. Determining
the actual worst-case guarantee of the local search is an interesting problem for
future research.
Finally, in line with the work of Tan et al. (2019), it would be interesting to
generalize the expanding search model to multiple searchers. In fact, by taking
the search sequence returned by our greedy algorithm as a so-called ‘list schedule’, the techniques of Chekuri et al. (2001) and Tan et al. (2018, 2019) seem
to provide a promising starting point to obtain constant-factor approximation
algorithms for the setting with multiple searchers.

21

Acknowledgments
Ben Hermans is funded by a PhD Fellowship of the Research Foundation –
Flanders (Fonds Wetenschappelijk Onderzoek). We thank I. Averbakh and J.
Pereira for kindly sharing their instances.

References
Afrati, F., Cosmadakis, S., Papadimitriou, C. H., Papageorgiou, G. and Papakostantinou, N. (1986), ‘The complexity of the travelling repairman problem’, RAIRO-Theoretical Informatics and Applications 20(1), 79–87.
Alpern, S., Fokkink, R., Gasieniec, L., Lindelauf, R. and Subrahmanian, V.
(2013), Search Theory, Springer.
Alpern, S. and Gal, S. (2003), The Theory of Search Games and Rendezvous,
Kluwer International Series in Operations Research and Management Sciences
(Kluwer, Boston).
Alpern, S. and Lidbetter, T. (2013), ‘Mining coal or finding terrorists: The
expanding search paradigm’, Operations Research 61(2), 265–279.
Alpern, S. and Lidbetter, T. (2019), ‘Approximate solutions for expanding search games on general networks’, Annals of Operations Research
275(2), 259–279.
Angelopoulos, S., Dürr, C. and Lidbetter, T. (2019), ‘The expanding search
ratio of a graph’, Discrete Applied Mathematics 260, 51–65.
Archer, A., Levin, A. and Williamson, D. P. (2008), ‘A faster, better approximation algorithm for the minimum latency problem’, SIAM Journal on Computing 37(5), 1472–1498.
Ausiello, G., Leonardi, S. and Marchetti-Spaccamela, A. (2000), On salesmen,
repairmen, spiders, and other traveling agents, in ‘Italian Conference on Algorithms and Complexity’, Springer, pp. 1–16.
Averbakh, I. (2012), ‘Emergency path restoration problems’, Discrete Optimization 9(1), 58 – 64.
Averbakh, I. and Pereira, J. (2012), ‘The flowtime network construction problem’, IIE Transactions 44(8), 681–694.
Chekuri, C., Motwani, R., Natarajan, B. and Stein, C. (2001), ‘Approximation techniques for average completion time scheduling’, SIAM Journal on
Computing 31(1), 146–166.
Correa, J. R. and Schulz, A. S. (2005), ‘Single-machine scheduling with precedence constraints’, Mathematics of Operations Research 30(4), 1005–1021.
Feige, U., Lovász, L. and Tetali, P. (2004), ‘Approximating min sum set cover’,
Algorithmica 40(4), 219–234.

22

Fokkink, R., Lidbetter, T. and Végh, L. A. (2019), ‘On submodular search and
machine scheduling’, Mathematics of Operations Research pp. 1–19. ePub
ahead of print August 1, https://doi.org/10.1287/moor.2018.0978.
Ford, L. R. and Fulkerson, D. R. (1956), ‘Maximal flow through a network’,
Canadian Journal of Mathematics 8, 399–404.
Gillies, D. W. and Liu, J. W.-S. (1995), ‘Scheduling tasks with AND/OR precedence constraints’, SIAM Journal on Computing 24(4), 797–810.
Goemans, M. X. and Williamson, D. P. (1995), ‘A general approximation
technique for constrained forest problems’, SIAM Journal on Computing
24(2), 296–317.
Goldberg, A. V. and Tarjan, R. E. (1988), ‘A new approach to the maximumflow problem’, Journal of the ACM 35(4), 921–940.
Hegde, C., Indyk, P. and Schmidt, L. (2015), A nearly-linear time framework for
graph-structured sparsity, in ‘International Conference on Machine Learning’,
pp. 928–937.
Hellerstein, L., Lidbetter, T. and Pirutinsky, D. (2019), ‘Solving zero-sum games
using best-response oracles with applications to search games’, Operations
Research 67(3), 731–743.
Kao, M.-J., Katz, B., Krug, M., Lee, D., Rutter, I. and Wagner, D. (2013),
‘The density maximization problem in graphs’, Journal of Combinatorial Optimization 26(4), 723–754.
Koopman, B. O. (1956a), ‘The theory of search I: Kinematic bases’, Operations
research 4(3), 324–346.
Koopman, B. O. (1956b), ‘The theory of search II: Target detection’, Operations
research 4(5), 503–531.
Koopman, B. O. (1957), ‘The theory of search III: The optimum distribution of
searching effort’, Operations Research 5(5), 613–626.
Koutsoupias, E., Papadimitriou, C. and Yannakakis, M. (1996), Searching a
fixed graph, in F. Meyer and B. Monien, eds, ‘Automata, Languages and
Programming’, Springer Berlin Heidelberg, Berlin, Heidelberg, pp. 280–289.
Lau, H. C., Ngo, T. H. and Nguyen, B. N. (2006), ‘Finding a length-constrained
maximum-sum or maximum-density subtree and its application to logistics’,
Discrete Optimization 3(4), 385–391.
Li, S. and Huang, S. (2018), ‘Multiple searchers searching for a randomly distributed immobile target on a unit network’, Networks 71(1), 60–80.
Magnanti, T. L. and Wolsey, L. A. (1995), Optimal trees, in M. O. Ball,
T. L. Magnanti, C. L. Monma and G. L. Nemhauser, eds, ‘Network Models’, Vol. 7 of Handbooks in Operations Research and Management Science,
Elsevier, pp. 503–615.

23

Monma, C. L. and Sidney, J. B. (1979), ‘Sequencing with series-parallel precedence constraints’, Mathematics of Operations Research 4(3), 215–224.
Potts, C. N. (1980), ‘An algorithm for the single machine sequencing problem
with precedence constraints’, Mathematical Programming Studies 13, 78–87.
Queyranne, M. and Wang, Y. (1991), ‘Single-machine scheduling polyhedra with
precedence constraints’, Mathematics of Operations Research 16(1), 1–20.
Sidney, J. B. (1975), ‘Decomposition algorithms for single-machine sequencing
with precedence relations and deferral costs’, Operations Research 23(2), 283–
298.
Sitters, R. (2002), The minimum latency problem is NP-hard for weighted trees,
in ‘International Conference on Integer Programming and Combinatorial Optimization’, Springer, pp. 230–239.
Smith, W. E. (1956), ‘Various optimizers for single-stage production’, Naval
Research Logistics Quarterly 3(1-2), 59–66.
Stone, L. D. (2007), Theory of Optimal Search, 2nd edition, INFORMS.
Stone, L. D., Royset, J. O. and Washburn, A. R. (2016), Optimal Search for
Moving Targets, Springer.
Tan, Y., Qiu, F., Das, A. K., Kirschen, D. S., Arabshahi, P. and Wang, J.
(2018), ‘Scheduling post-disaster repairs in electricity distribution networks’,
ArXiv e-prints arXiv:1702.08382 pp. 1–23. https://arxiv.org/pdf/1702.
08382.pdf.
Tan, Y., Qiu, F., Das, A. K., Kirschen, D. S., Arabshahi, P. and Wang, J.
(2019), ‘Scheduling post-disaster repairs in electricity distribution networks’,
IEEE Transactions on Power Systems 34(4), 2611–2621.
Trummel, K. and Weisinger, J. (1986), ‘The complexity of the optimal searcher
path problem’, Operations Research 34(2), 324–327.

24

