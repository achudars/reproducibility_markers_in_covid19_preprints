Nearly Optimal Static Las Vegas Succinct Dictionary

arXiv:1911.01348v2 [cs.DS] 31 Aug 2020

Huacheng Yu∗

Abstract
Given a set S of n (distinct) keys from key space [U ], each associated with a value from Σ, the
static dictionary problem asks to preprocess these (key, value) pairs into a data structure, supporting
value-retrieval queries: for any given x ∈ [U ], valRet(x) must return the value associated with x if
x ∈ S, or return ⊥ if x ∈
/ S. The special case where |Σ| = 1 is called the membership problem.
The “textbook” solution is to use a hash table, which occupies linear space and answers each query in
constant time. On the other hand, the minimum possible space to encode all (key, value) pairs is only
OPT := ⌈lg2 Un + n lg2 |Σ|⌉ bits, which could be much less.
In this paper, we design a randomized dictionary data structure using
OPT + poly lg n + O(lg lg lg lg lg U )
bits of space, and it has expected constant query time, assuming the query algorithm can access an
external lookup table of size n0.001 . The lookup table depends only on U , n and |Σ|, and not the input.
Previously, even for membership queries and U ≤ nO(1) , the best known data structure with constant
query time requires OPT + n/poly lg n bits of space (Pagh [Pag01a] and Pǎtraşcu [Pǎt08]); the best
known using OPT + n0.999 space has query time O(lg n); the only known non-trivial data structure with
OPT + n0.001 space has O(lg n) query time and requires a lookup table of size ≥ n2.99 (!). Our new data
structure answers open questions by Pǎtraşcu and Thorup [Pǎt08, Tho13].
We also present a scheme that compresses a sequence X ∈ Σn to its zeroth order (empirical) entropy
up to |Σ| · poly lg n extra bits, supporting decoding each Xi in O(lg |Σ|) expected time.

∗

Department of Computer Science, Princeton University. yuhch123@gmail.com

Contents
1 Introduction
1.1 Our contributions . . . . . . . . . . .
1.2 Related work . . . . . . . . . . . . .
1.3 Technical contributions . . . . . . . .
1.3.1 Strings with fractional lengths
1.3.2 Data interpretation . . . . . .
1.4 Overview of Pǎtraşcu’s data structure

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

2 Overview
2.1 Random inputs . . . . . . . . .
2.2 Using data interpretation . . . .
2.3 Constructing data interpretation
2.4 Worst-case input . . . . . . . .
2.5 Organization . . . . . . . . . . .

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

7
. 8
. 9
. 10
. 11
. 12

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

1
2
3
4
4
6
6

3 Preliminaries and Notations
12
3.1 Random access machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
3.2 Notations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
4 Fractional-length Strings

13

5 Reductions to Perfect Hashing

16

6 Perfect Hashing for Medium-Sized Sets
17
6.1 No bad block pair . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
6.2 At least one bad block pair . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
6.3 Final data structure for medium size sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
7 Data Structure Pair for Block Pair
31
7.1 Data interpretation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
7.2 Small sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
8 Perfect Hashing for Sets of Any Size

55

9 Discussions and Open Problems

59

A Proofs for Fractional-length Strings

62

B Approximating Binomial Coefficients

72

C Dictionary with Linear Redundancy

73

1 Introduction
Given n (key, value) pairs {(ki , vi )}i=1,...,n with distinct keys ki ∈ {0, . . . , U − 1} and (possibly duplicated)
values vi ∈ {0, . . . , σ − 1}, the static dictionary problem asks to preprocess them into a data structure,
supporting value-retrieval queries
• valRet(x): return vi if x = ki , and return ⊥ if x 6= k1 , . . . , kn .
When σ = 1, it is called the membership problem, i.e., preprocessing a set S of n keys into a data structure,
supporting queries of form “is x ∈ S?”
Dictionaries are very fundamental data structures, which have been extensively studied in theory [CW79,
TY79, Yao81, FKS84, FNSS92, FN93, BM99, Pag01a, Pag01b, FM95, Mil96, MNSW98, BMRV02]. They
are also one of the most basic data structures in practice, included in standard libraries for most of the popular
programming languages (e.g., std::unordered_map for C++, HashMap for Java, and language-level
built-in support for JavaScript, Python, Ruby, etc).
The “textbook” implementation of a dictionary is to store a hash table: use a hash function to map
all keys to O(n) buckets, and store each (key, value) pair in the corresponding bucket. Simple hash functions (e.g. (kx mod p) mod n) have low collision probabilities, and resolving collisions by chaining leads
to a dictionary data structure with expected constant query time. Using perfect hashing (e.g. [FKS84]),
one can further improve the query time to worst-case constant. However, such data structures use at least
n lg U + n lg σ bits of space, even just to write down all (key, value) pairs in the buckets, while the information theoretical space lower bound for this problem is only1
 
U
OPT := ⌈lg
+ n lg σ⌉
n

bits, which is much less than n lg U + n lg σ (note that lg Un = n lg(U/n) + O(n)).
It turns out that it is possible to not explicitly store all pairs, and beat n lg U + n lg σ bits. For membership queries (σ = 1), the previously best known data structure by Pagh [Pag01a] (and later improved by
Pǎtraşcu [Pǎt08]) uses OPT + O(n/poly lg n + lg lg U ) bits of space, and answers queries in constant time.
This data structure also gives a smooth tradeoff between time and space: for query time O(t), it uses space
OPT + n/r + O(lg lg U ),
where r = ( lgtn )Ω(t) . To achieve this query time, it is assumed that the query algorithm has access to an
external lookup table of size min{n3 , r 6 }, which depends only on U and n, and not the input. In particular,
when U = poly n, if the number of extra bits is n0.99 , the query time becomes O(lg n). If we want the
space to be very close to OPT, the query time is O(lg n), but the lookup table size becomes about n3 (it may
even be larger than the data structure itself). For σ > 1, only (OPT + O(n + lg lg U ))-bit data structures were
known [Pag01a]. While these data structures have deterministic query algorithms (and worst-case querytime guarantee), no better zero-error randomized data structure was known. To the best of our knowledge,
data structures with Las Vegas query algorithms have never been the state-of-the-art for this problem since
perfect hashing [FKS84].2 Therefore, it was unclear if randomization is even useful for static dictionaries.
1

Throughout the paper, lg is the binary logarithm.
Monte Carlo algorithms, where the query is allowed to err with a small probability, would have a different space benchmark.
Thus, they are not the focus of this paper.
2

1

1.1 Our contributions
In this paper, we show that if we allow randomization, near-optimal space and optimal time can be achieved
simultaneously. We design a dictionary data structure with poly lg n + O(lg lg U ) extra bits and expected
constant query time, making a step towards the optimal static dictionary. The query algorithm only needs to
access a small lookup table.
Theorem 1. There is a randomized algorithm that preprocesses n (key, value) pairs into a data structure
with
OPT + poly lg n + O(lg lg U )
bits, such that for any given query x, the query algorithm answers valRet(x) in expected constant time on
a random access machine with word-size w ≥ Ω(lg U + lg σ), assuming it can access an external lookup
table of size nǫ , for any constant ǫ > 0.
Same as the previous data structures, the lookup table depends only on U , n and σ, and not the input.
In fact, the lg lg U term can be improved to lg lg · · · lg U for logarithm iterated any constant number of
22

..

. 2n

with O(1) levels, this term can be removed. In this case, among
times. Hence, when U is at most
the OPT + poly lg n bits of the data structure, the first poly lg n are the (plain) random bits used by the
preprocessing algorithm, and the “actual” data structure only occupies the next (and last) OPT + 1 bits. The
expectation of the query time is taken over these random bits, which we assume the worst-case input data
and query do not see. Moreover, the query time is O(1) with probability 1 − o(1), and is poly lg n in
worst-case.
By storing the lookup table as part of the data structure, Theorem 1 implies a data structure with
OPT + nǫ + O(lg lg U ) bits and expected constant query time, which is still an improvement over the previous best known. In the cell-probe model, where we only count how many times the query algorithm accesses
the memory and the computation is free, the lookup table is not necessary, because it does not depend on
the input and can be computed without accessing the data structure.
In the theorem, we assume that each (key, value) pair fits in O(1) words, which is necessary to obtain
constant query time on random access machines. We will discuss larger keys or values in Section 9.
Perfect hashing. In general, a perfect hashing maps n input keys to distinct buckets, and it is called minimal if it maps them to exactly n distinct buckets, labeled from 0 to n − 1. En route to the new dictionary data
structure, the key component is a succinct membership data structure, equipped with a two-sided minimal
perfect hashing. Specifically, given a set S ⊆ [U ] of size n, we would like to construct a data structure D,
which not only supports membership queries, but also defines
• a bijection h between S and [n], and
• a bijection h between [U ] \ S and [U − n].
That is, we want to perfectly hash all keys, as well as all non-keys. The data structure must support hash(x)
queries, which returns a pair (b, v) such that
• if x ∈ S, b = 1 and v = h(x);
• if x ∈
/ S, b = 0 and v = h(x).
Theorem 2 (informal). There is a randomized algorithm that preprocesses a set S ∈ [U ] of size n into a
data structure with
 
U
lg
+ poly lg n + O(lg lg U )
n
2

bits, such that it defines a bijection h between S and [n] and a bijection between [U ] \ S and [U − n]. For
any x, the query algorithm outputs hash(x) in expected constant time on a random access machine with
word-size w ≥ Ω(lg U ), assuming it has access to an external lookup table of size nǫ , for any constant
ǫ > 0.
See Section 8 for the formal statement.
Locally decodable arithmetic codes. We also show that the above perfect hashing data structure can be
applied to obtain a version of locally decodable arithmetic codes with a better space [Pǎt08]. This problem
asks to compress a sequence X = (x1 , . . . , xn ) ∈ Σn for some (small) alphabet set Σ, such that each symbol
xi can be recovered efficiently from the compression. We should think of a sequence X that is sampled from
some low entropy source, and the encoding should take much less than n lg |Σ| bits. The arithmetic codes
match the zeroth order entropy of X, i.e., if each symbol in the sequence has entropy H (marginally), then
the encoding has length ∼ n · H. Pǎtraşcu [Pǎt08] gave a data structure whose size is


X
lg n t
n
+ O(|Σ| lg n) + n/
+ Õ(n3/4 ),
fσ lg
fσ
t
σ∈Σ

where fσ is the number of occurrences of σ. It supports single-element access in O(t) time on word RAM.
Note that
Pwhen each symbol xi is sample independent from a source of entropy H, then the empirical
entropy σ∈Σ fσ lg fnσ ≈ n · H with high probability.
Theorem 3. There is a randomized algorithm that preprocesses a sequence (x1 , . . . , xn ) ∈ Σn into a data
structure with


n!
lg
+ |Σ| · poly lg n
fσ1 !fσ2 ! · · ·

bits, where fσ is the number of occurrences of σ. For any index i, the query algorithm recovers xi in
O(lg |Σ|) time in expectation on a word RAM with word-size w ≥ Ω(lg n), assuming it has access to an
external lookup table of size nǫ , for any constant ǫ > 0.
Note that the first term P
in the space is the minimum possible space to store a sequence with frequencies
(fσ )σ∈Σ , which is at most σ fσ∈Σ lg fnσ .

1.2 Related work

The perfect hashing scheme by Fredman, Komlós and Szemerédi [FKS84] maps [U ] to [n] such that for any
given set S of size n, there is a hash function h that maps all elements in S to different buckets
√ (i.e., no hash
collision) such that h(x) can be evaluated in constant time. This hash function takes O(n lg n + lg lg U )
bits to store, and it is later improved to O(n + lg lg U ) bits by Schmidt and Siegel [SS90]. By storing the
(key, value) pair in the corresponding bucket, the perfect hashing scheme solves the dictionary problem with
O(n) words of space and constant query time. Fiat, Naor, Schmidt and Siegel [FNSS92] showed that only
O(lg n + lg lg U ) extra bits are needed to store both the hashing function and the table, obtaining space of
n⌈lg U ⌉ + n⌈lg σ⌉ + O(lg n + lg lg U ). Fiat and Naor [FN93] further removed the O(lg n) term, as well as
the O(lg lg U ) term when U is not too large.
The first dictionary data structure that achieves nearly optimal space is due to Brodnik and Munro [BM99].
Their data structure uses OPT + O(OPT/ lg lg lg U ) bits, and it has constant query time. Pagh [Pag01a] reduced the dictionary problem to the rank problem (see below, also Section 1.4 for definition of the rank
3

problem), and designed a data structure for membership queries using OPT + O(n lg2 lg n/ lg n + lg lg U )
bits for n < U/ lg lg U , and OPT + O(U lg lg U/ lg U ) for n ≥ U/ lg lg U . Pagh’s dictionary uses rank data
structures as subroutines. By improving the rank data structures, Pǎtraşcu [Pǎt08] improved the bound to
OPT + n/poly lg n + O(lg lg U ), as we mentioned earlier. Such data structures using OPT + o(OPT) bits are
called succinct data structures [Jac89], where the number of extra bits o(OPT) is called the redundancy.
It is worth mentioning that when n = U , i.e., when the input is a sequence of values v1 , . . . , vU ∈ [σ],
Dodis, Pǎtraşcu and Thorup [DPT10] designed a data structure using optimal space. Their data structure
uses a lookup table of poly lg n size. We get rid of this lookup table (see Lemma 16 in Section 7) as an
application of our new technique.
No non-trivial lower bounds are known without restrictions on the data structure or model. Fich and
Miltersen [FM95] and Miltersen [Mil96] proved Ω(lg n) and Ω(lg lg n) lower bounds in the RAM model
with restricted operations. Buhrman, Miltersen, Radhakrishnan and Venkatesh [BMRV02] proved that in
the bit-probe model (where the word-size w = 1), any data structure using O(OPT) space must have query
time at least O(lg Un ). Viola [Vio12] proved a higher lower bound for the case where U = 3n, that any
bit-probe data structure with query time q must use space OPT + n/2O(q) − log n.
Raman, Raman and Rao [RRR07] considered the indexable dictionary problem, which generalizes membership. Given a set S of n keys, it supports rank and select queries: rankS (x) returns ⊥ if x ∈
/ S, and
returns i if x is the i-th smallest in S; selectS (i) returns the i-th smallest element in S. They obtained
a data structure using OPT + o(n) + O(lg lg U ) bits and constant query time. Grossi, Orlandi, Raman and
Rao [GORR09] studied the fully indexable dictionary problem. It generalizes the indexable dictionary problem to let rankS (x) return the number of elements in S that are at most x (also for x ∈
/ S). They obtained
1+ǫ
δ
−1/ǫ
a data structure using space OPT + n
+U ·n
. In fact, this problem is much harder. It was observed
in [PV10] that rank queries can be reduced from colored predecessor search, which has a query time lower
bound of Ω(lg lg n) even when the space is O(n lg U ) [PT06, PT07] (not to say the succinct regime). When
U > n2 , the problem requires n1+ǫ space to get constant query time (when the word-size is lg n), even only
supporting rank queries.
The locally decodable source coding [MHMP15] studies (almost) the same problem as Theorem 3, in
a slightly different setting. They consider X that consists of i.i.d samples from a source of entropy H.
However, the main focus is non-adaptive bit-probe query algorithms. That is, the query algorithm has to
decide which t bits of the encoding to access based only on the queried index i. They studied the lossy case,
where the encoding is equipped with the error correcting ability.

1.3 Technical contributions
We make two technical contributions to succinct data structures: We summarize the “spillover representation”, introduced by Pǎtraşcu [Pǎt08], to define binary strings with fractional lengths and build a “toolkit” of
black-box operations; we study the “opposite” of data structures, called the data interpretation. We believe
they will have more applications to other problems in succinct data structures.
1.3.1

Strings with fractional lengths

A data structure is simply a bit string, and its length (or size) is the number of bits. Under standard notions,
an s-bit string is only well-defined for integer s. Here, we show how to define such strings when s is
fractional. We will see why this notion is useful later (or see [Pǎt08]).
4

Let (M, K) be a pair such that M ∈ {0, 1}m is a bit string, and K ∈ [R] is an integer. Such a pair
is viewed as a “binary string” of length m + lg2 R. When R is a power of two, this matches the standard
notion of length, as we could simply write K in its binary representation using lg R bits and append it to M .
As we increase R, such a pair could potentially represent more information. Only when R is increased by a
factor of two, does the pair correspond to a string with one more bit. That is, by restricting R ∈ [2κ , 2κ+1 )
for some fixed parameter κ, we essentially “insert” 2κ − 1 valid lengths between adjacent integers. It makes
the measure of space more fine-grained. Also note that a uniformly random pair of this size has binary
entropy exactly equal to m + lg2 R. In this paper, R is always set to 2O(w) (i.e. κ = O(w)), where w is the
word-size. Thus, K is an O(w)-bit integer, and the algorithms are able to do arithmetic operations on K in
constant time.
We summarize a few black-box operations on fractional-length strings. The two major ones are concatenation and fusion.
Concatenation. Given B (fractional-length) strings S1 , . . . , SB of lengths s1 , . . . , sB , we show that they
can be “concatenated” into one string of length s ≈ s1 +· · ·+sB (note that we do not get exactly s1 +· · ·+sB ,
because the set of valid lengths is not closed under addition). This is trivial for integral-length strings, as
we could simply connect all strings. Moreover for integral-lengths, suppose for a given i, s1 + · · · + si−1
can be computed efficiently, then we will be able to find where Si starts, and access it within the long string.
Likewise, we prove the same is true for fractional-length strings. That is, we show that if s1 + · · · + si−1
can be well-approximated, then Si can be decoded, i.e., it may be accessed within the long string, as if
it was stored independently. We emphasize that decoding an input string Si = (Mi , Ki ) does not mean
reconstructing the entire string. Instead, the decoding algorithm only recovers Ki , and finds where Mi is
located within the long string (where Mi is guaranteed to be a consecutive substring). Thus, the decoding
algorithm can be very efficient. Nevertheless, after decoding, Si can still be accessed as if it was stored
independently. In particular, by storing the prefix sums s1 + · · · + si in a lookup table, we will be able to
decode any Si in constant time.
Concatenation is useful when the data structure needs multiple subordinates. We could simply construct
each subordinate separately and then concatenate them. It also demonstrates, to some extent, why fractionallengths are useful and necessary. If we only use integral-length strings, then each Si will have length (at
least) ⌈si ⌉. The length of the concatenated string becomes ⌈s1 ⌉ + · · · + ⌈sB ⌉, which could be B − 1 bits
longer than ⌈s1 + · · · + sB ⌉.
Fusion. The other major operation is to fuse an integer into a string. Roughly speaking, it is to jointly
store a pair (i, Si ), where i ∈ [C] is an integer, and Si is a string of length si . More specifically, let us first
fix lengths s1 , . . . , sC . We are then given a pair (i, Si ) such that Si is guaranteed to have length si . We show
that such a pair can be encoded by a string S of (fixed) length s ≈ lg(2s1 + · · · + 2sC ). This length is the best
possible, because there are 2si different possible strings of length Si . Therefore, there are 2s1 + · · · + 2sC
different pairs (i, Si ) in total. To encode such a pair, lg(2s1 + · · · + 2sC ) bits are necessary. Furthermore,
suppose for every i, lg(2s1 + · · · + 2si ) can be well-approximated, then we will be able to recover the value
of i and decode Si .
The fusion operation is useful when we study different cases of the input, and construct a data structure
for each case separately. For example, suppose we wish to construct a data structure on a subset S ⊆ [n]
(of arbitrary size), using close to n bits (and supporting some queries). Now suppose when |S| = i, we
already know how to construct a data structure using ≈ lg ni bits, such that the queries can be answered
efficiently when the query algorithm is given the value of i for free. If this is the case for every i, then by
5

applying the fusion operation, we automatically obtain a data structure for subsets of arbitrary size using
≈ n bits, without giving |S| to the query algorithm for free. To see this, let case i be all S with exactly
i elements. Then we are able to construct a data structure Si just for all inputs in case i. The final data
structure is the pair (i, Si ) fused
 into one single data structure. The space bound guarantees that if each Si
n
has nearly
size ≈ lg i , then the final data structure also has nearly optimal size of ≈ n bits, since
 optimal
P
n
n . Given a query, we first retrieve the value of i and decode S , then run the query algorithm
=
2
i
i i
for inputs in case i, given the value of i. We may also view Si as the data structure “conditioned on” i.
Suppose all “conditional” data structures almost match their “conditional” optimal sizes, then they can be
combined into one single data structure matching the overall optimal space. See Section 1.4 for a more
concrete example.
By including a few other operations, we build a “toolkit” for operating on fractional-length strings. The
view of fractional-length strings makes the “spillover representation” of Pǎtraşcu [Pǎt08] more explicit. The
original paper needs huge lookup tables to store truth tables for O(w)-bit bizarre word operations. The new
view assigns semantic meanings to those operations, so that a major part can be efficiently computed without
lookup tables. This is the main reason why we can reduce the lookup table size.
1.3.2

Data interpretation

For a data structure problem, we preprocess a combinatorial object into a binary string. Then this string is
stored in memory, which is divided into w-bit words. In each time step, a query algorithm may access a
memory word (i.e. a w-bit substring), or do local computation. Finally, it computes some function of the
input object. The concept of data interpretation is to perform the above procedure in the opposite direction.
Given a binary string, we preprocess it into a combinatorial object. In each time step, a query algorithm
may query an oracle for some function of the object, or do local computation. Finally, it reconstructs a w-bit
substring of the input string.
Since this paper concerns data structures with space almost matching the information theoretical lower
bound, we will also make data interpretations space-efficient. We
 design a data interpretation algorithm
V
which preprocesses an input string of (fractional-)length ≈ lg m into a set S ⊆ [V ] of size m, such that
assuming there is a rank oracle for S (recall that rankS (x) returns the number of elements in S that are at
most x), any designated w consecutive bits of the input string can be reconstructed in poly lg V time (see
Section 7.1). It might not be obvious at this moment why it is beneficial to convert a string (data structure)
back to a set, but it turns out to be a key subroutine in our data structure. See Section 2 for more details.

1.4 Overview of Pǎtraşcu’s data structure
In this subsection, we summarize how Pǎtraşcu’s rank data structure [Pǎt08] works, which has important
ideas to be used in our data structure. We will “rephrase” this data structure using fractional-length strings,
which is a non-trivial simplification.

Given a set S ⊆ [U ] of size n, the rank data structure preprocesses it into ≈ lg Un bits, such that for
any given query x, the number of elements in S that are at most x can be computed in O(lg U ) time. The
idea is to recursively construct data structures for smaller universes, and then merge the subordinate using
concatenation and fusion. Suppose S has i elements in {0, . . . , U/2 − 1}, the first half of the universe, and
it has n − i elements in the second half. We first recursively
construct (fractional-length) data structures for
U/2
both halves, using space ≈ lg U/2
and
≈
lg
respectively.
Next, we concatenate two data structures,
i
n−i


U/2 U/2
and obtain one single data structure Si , which has length ≈ lg
i
n−i . Note that the data structure Si
6

encodes an input set S with exactly i elements in the first half (and n − i in the second half), and it does not
encode the value of i (likewise in the desired final data structure, the value of n is assumed to be known, and
is not encoded). Finally, we encode the value of i by fusing it into Si , i.e., we jointly store the pair (i, Si ).
The fusion operation guarantees that the pair can be stored using approximately
!

 
!
n 
n
X
X
U/2
U/2
U
|Si |
≈ lg
= lg
2
lg
i
n−i
n
i=0

i=0

bits.
This recursion terminates at sets of size n = 0 or n = U , in which case there is nothing to store (again we
assume n does not need encoding, so it is clear which case we are in). We guarantee that both concatenation
and fusion are implemented such that each operation only
causes an overhead of no more than O(1/U 2 )

bits. Therefore the overall space is no more than lg Un + O(1/U ). For the final (fractional-length) data
structure (M, K), we simply write K in its binary
 representation and append it to M . This gives us an
integral-length data structure using at most ⌈lg Un ⌉ + 1 bits.
It is then straightforward to answer a rank query on this data structure. Given a query x, we first recover
the value of i, and decode Si (again, decoding Si does not mean reconstructing it). Then we further decode
Si into the two data structures for the two halves. It can be done in constant time using a lookup table. Next,
if x < U/2, we recurse into the first half. If x ≥ U/2, we recurse into the second half (and add i to the final
answer). Since each time U decreases by a factor of two, the query time is O(lg U ).
In [Pǎt08], it is also shown that when U is small, we can do a B-way divide-and-conquer, as long as
B lg U ≤ O(w) (recall that w is the word-size). Therefore when U ≤ wO(1) , we can afford to set B = w1/2
and have only constant depth of recursion (rather than O(lg U )). This gives us a rank data structure with
constant query time for small U . In this paper, we show that it is possible to further improve it, and we
design a constant-query-time data structure when only n is bounded by wO(1) (and U could be still as large
as 2Θ(w) ). This will be the starting point of our new data structure.

2 Overview
In this section, we overview our new static dictionary. For simplicity, we will first focus on the membership
queries (i.e., σ = 1), and assume U = poly n. In this case, all previous solutions use hash functions in their
main construction, to map the keys into buckets. Our data structure is conceptually different: Instead of
random hash functions, we consider random inputs. While our data structure works for worst-case inputs,
let us first think of the input set being n uniformly random (distinct) keys. Then with high probability, the
input already has the properties we wanted from a random hash function, e.g., by dividing the key space
into buckets in some fixed way, we have the sizes of buckets roughly balanced, etc. We first construct a data
structure just for those “random-looking” inputs. On the other hand, with low probability, the input may look
“non-typical,” e.g., some bucket may have size much larger than average. However, “with low probability”
means that only a small fraction of all possible inputs have these non-typical features. Suppose the total
number of such inputs is, say n12 · 2OPT , then only OPT − 2 lg n bits are needed for the optimal encoding. This
suggests that we can afford to spend more extra bits on them. Suppose we use OPT − lg n bits (lg n extra
bits) to encoding these non-typical inputs, it is still negligible overall — among all O(2OPT ) possible data
structures (memory states), such an encoding only wastes 2OPT · ( n1 − n12 ). Another useful way to view it is
that if we use x extra bits for such rare cases, then those x bits “start” at the (OPT − 2 lg n)-th bit, rather than
the OPT-th bit. The more non-typical the input is, the more extra bits we can afford to spend. Finally, we will
7

use the fusion operation to fuse all cases together. Similar strategies for constructing succinct data structures,
where we consider random inputs and/or non-typical inputs, have been used in [BL13, Yu19, VWY19].
In the following, we show how to handle the “random-looking” case and the “non-typical” cases for
membership.

2.1 Random inputs
We partition the universe into n/ lg4 n buckets of size V . Then for a “random-looking” input set S, there
are lg4 n ± lg3 n keys in every block. As we mentioned in Section 1.4, for poly lg n = poly w keys, we
can construct a rank data structure with only O(1/U ) extra bits, such that given the number of keys, a query
algorithm answers rank queries in constant time. In particular, it supports membership queries (e.g., by
asking rankS (x) and rankS (x − 1)). The high-level idea is to construct a rank data structure for each
block, then concatenate them. In order to answer a query in block i, we need to
• recover the number of keys in block i (as the rank data structure assumes this number is known), and
• approximate the total length of data structures for first i − 1 blocks (to decode the i-th data structure).
That is, besides the n/ lg4 n rank data structures, we need to store their lengths such that any prefix sum can
be approximated. Unfortunately, any data structure supporting prefix sum queries cannot simultaneously
have “low” query time and “small” space, due to a lower bound of Pǎtraşcu and Viola [PV10]. The underlying issue in this approach is that the data structure for each block has a variable length (the length depends
on the number of keys in the block, which varies based on the input). In order to locate the i-th data structure from the concatenated string, computing a prefix sum on a sequence of variables seems inevitable. The
Pǎtraşcu-Viola lower bound even prevents us from supporting prefix sums implicitly. That is, not only separately storing a prefix sum data structure for the lengths requires “high” query time or “large” space, there is
also no “clever” way to jointly store the lengths together with the data structures for the blocks. Hence, this
“variable-length encoding” issue is the primary problem we need to tackle for “random-looking” inputs.
To this end, observe that although the number of keys in each block is not fixed, its deviation is actually
small compared to the number, i.e., the number of keys cannot be too different for different inputs. Then the
main idea is to construct two data structures for each block, consisting of
• a main data structure, which stores “most of the information” about the block, and importantly, has a
fixed length (independent of the number of keys), and
• an auxiliary data structure, which stores all “remaining information” about the block (and unavoidably has variable length).
Furthermore, we wish that with high probability, a given query can be answered by only accessing the main
data structure (in constant time) without knowing the number of keys. If it is possible, then to construct the
final data structure, we
• concatenate all main data structures,
• concatenate the auxiliary data structures, and store them together with a prefix sum structure,
• finally concatenate the two.
Now, since all main data structures have fixed lengths, each one can be decoded in constant time without a
prefix sum structure (the total length of the first i − 1 data structures is simply i − 1 times the length of a
single one). Then to answer a query in block i, we first decode the i-th main data structure, and query it in
constant time. With high probability, the answer to the query is already found, and we are done. Otherwise,
we decode the i-th auxiliary data structure by querying the prefix sum structure, and query the data structures
to find the answer. It may take a longer time, but if the probability that we have to decode the auxiliary data
structure is sufficiently low, then the expected query time is still constant.

8

Next, we describe an approach to construct such two data structures for a block, which uses more space
than what we aim for, but exhibits the main idea. For each block of size V , we pick lg4 n − lg3 n random
keys in the block to store in the main data structure. We also pick V − (lg4 n + lg3 n) random non-keys
(i.e. the elements in the key space but not in the input set), and store them in the main data structure. This
is always possible because there are at least lg4 n − lg3 n and at most lg4 n + lg3 n keys in each block for
“random-looking” inputs. Hence, only 2 lg3 n elements are “unknown” from the main data structure. Then
we show that such a separation of the block into lg4 n − lg3 n keys, V − (lg4 n + lg3 n) non-keys and
2 lg3 n unknowns can be jointly stored using the near-optimal ≈ lg lg4 n−lgV3 n,2 lg3 n bits (this is an easy
application of the rank data structures).3 Its size is independent of the actual input. Then in the auxiliary
data structure, we store the remaining information about the block, i.e., among the unknowns, which ones

3
n
are the keys. For a block with m keys, it takes ≈ lg m−(lg2 4lgn−lg
bits. Then for each query, the answer
3
n)
can be found in the main data structure with probability at least 1 − O(1/ lg n). Only when the main data
structure returns “unknown”, does the query algorithm need to access the auxiliary data structure.
The above construction has all the desired properties, except that it uses too much space. The inherent
reason is that it implicitly stores the randomness used in deciding which keys and non-keys to store in the
main data structure. If we sum up the sizes of the main and auxiliary data structures,




V
2 lg3 n
lg
+ lg
lg4 n − lg3 n, 2 lg3 n
m − (lg4 n − lg3 n)
 




V
m
V −m
= lg
+ lg
+ lg
.
m
lg4 n − lg3 n
V − (lg4 n + lg3 n)


V −m
m
Unsurprisingly, the number of extra bits lg lg4 n−lg
3
n + lg V −(lg4 n+lg3 n) is exactly how much is needed
to decide which keys and non-keys to store in the main data structure. These “random bits” are not part of
the input, and implicitly storing them causes a large amount of redundancy.
However, when the inputs are uniform, we do not really need any external randomness to decide the
two subsets, since the entire data structure is close to a random string. This suggests that for each block,
we should treat the data structure from other part of the inputs as the “randomness”. That is, we use the
opportunity of implicitly storing the random bits, to store other information that needs to be stored. This
is where we use data interpretation. We convert existing data structures back to subsets of certain sizes,
which correspond to the keys and non-keys in the main data structure. The details are presented in the next
subsection.

2.2 Using data interpretation
To implement this idea, we will have to slightly modify the construction. Now, the universe is partitioned into pairs of blocks. Each pair consists of a primary block and a secondary block, such that for
a “random-looking” input, the primary block contains lg2c n ± lgc+1 n keys, and the secondary block contains Θ(lgc+1 n) keys (which plays the role of the “randomness”), for some constant c. Fix a block pair, let
V be the size of the primary block, m be the number of keys in the primary block, Vsc be the size of the
secondary block, and msc
be the number
of keys in the secondary block. The goal is to construct two data
V
Vsc 
bits
in
total.
structures using ≈ lg m
+ lg m
sc
Vsc 
bits. We then divide
We first construct a rank data structure for the secondary block using ≈ lg m
sc

−m
m
this data structure into three substrings of lengths approximately lg lg2c n−lgc+1 n , lg V −(lg2cV n+lg
c+1
n)
3

n
k1 ,k2



= n!/(k1 !k2 !(n − k1 − k2 )!).

9



V −m
m
Vsc 
msc − lg lg2c n−lgc+1 n − lg V −(lg2c n+lgc+1 n) (we show divisions can also be done for fractionallength strings). Then msc = Θ(lgc+1 n) guarantees that there are enough bits and such division is possible.
m
Next, we apply a data interpretation algorithm to interpret the first string of length lg lg2c n−lg
c+1
n as a set
2c
c+1
and lg

of size lg n−lg
n over a universe of size m, indicating which of the m keys in the primary block should
be stored in the main data structure. We also interpret the second string as a subset indicating which of the
V − (lg2c n + lgc+1 n) non-keys should be stored in the main data structure. Moreover, we show that the
data interpretation algorithm guarantees that any consecutive w bits of the original string can be recovered
in lgO(1) n time, assuming there is a rank oracle of the set generated from the interpretation. Therefore,
there is no need to store the first two strings, as they can be implicitly accessed efficiently.
The main data structure is the same as what we stated in the previous subsection: storing lg2c n−lgc+1 n
keys, V − (lg2c n + lgc+1 n) non-keys and 2 lgc+1 n “unknowns”, supporting rank queries in constant time.
The auxiliary data structure now consists of two parts:
• among the 2 lgc+1 n unknowns, which m − (lg2c n − lgc+1 n) are keys, and
• the third substring from above.
One may verify that the sizes of the two data structures is what we claimed. This leads to our main technical
lemma.
Lemma 4 (main technical lemma, informal). For V ≤ poly n, given S ⊆ [V ] of size m and Ssc ⊆ [Vsc ] of
size msc , we can construct a main data structure Dmain of size


V
≈ lg
lg2c n − lgc+1 n, 2 lgc+1 n
and an auxiliary data structure Daux of size
 




V
V
Vsc
≈ lg
− lg
+ lg
,
m
msc
lg2c n − lgc+1 n, 2 lgc+1 n
such that
?
• any given query “x ∈ S” can be answered in constant time by accessing only Dmain with probability
1 − O(lg−c+1 n);
?

?

• any given query “x ∈ S” or “x ∈ Ssc ” can be answered in poly lg n time by accessing both Dmain
and Daux in worst-case.

See Section 7 for the formal statement. Then, the final data structure will be the concatenation of all main
and auxiliary data structures, in a similar way to what we stated in the previous subsection. The auxiliary
data structure needs to be decoded only when the main data structure returns “unknown” or the query lands
in a secondary block. By randomly shifting the universe, we bound the probability of needing the auxiliary
data structure by O(lg−c+1 n). By setting c to be a sufficiently large constant, the expected query time is
constant.

2.3 Constructing data interpretation
Next, we briefly describe how to design such a data interpretation algorithm, i.e., to convert a (fractionallength) string to a set. The high-level idea is similar to the rank data structure described in Section 1.4, with
all steps done in the opposite direction. The data structure uses concatenation and fusion of fractional-length
strings. We first show how to do the opposite of the two operations. More concretely, we show that
10

• given a string D, it can be divided into two substrings D1 , D2 of given lengths;
• given a string D, it can be viewed as a pair (i, Di ), where Di has a given length si , i.e., we extract an
integer i from D and let Di be the rest.
Both division and extraction are done with negligible
space overhead.

V
Then, given a string D of length ≈ lg m , to interpret it as a set of size m, we first extract an integer i
 V /2 
. Then we divide Di of length si into
from D such that i ∈ {0, . . . , m} and Di has length si ≈ lg V i/2 m−i


V /2
V /2
two substrings Da and Db of lengths ≈ lg i and ≈ lg m−i respectively. The integer i will represent
the number of keys in the first half of the universe, and m − i is the number of keys in the second half. We
recursively construct sets Sa , Sb ⊆ [V /2] from Da and Db of sizes i and m − i respectively. Then the final
set is Sa ∪ (Sb + V /2).
To access w consecutive bits of D given a rankS (·) oracle, we first ask the oracle rankS (V /2), i.e., the
number of keys in the first half. This determines the value of i, and hence the lengths of Da and Db , which
in turn determines whether the w consecutive bits are entirely in Da , or entirely in Db , or split across the two
substrings. If it is entirely contained in one substring, we simply recurse into the corresponding half of the
universe. On the other hand, it is possible to show that splitting across the two substrings does not happen
too many times, and when it happens, we recurse into both halves. The recursion has depth O(lg V ). More
details can be found in Section 7.1.

2.4 Worst-case input
Applying the above data structure to worst-case input has the following two issues:
1. for each primary block, the sets stored in the main data structure are no longer random, hence, the
expected query time may not be constant;
2. some primary block may not have lg2c n ± lgc+1 n keys, and some secondary block may not have
Θ(lgc+1 n) keys.
The first issue is easy to resolve. We simply sample a uniformly random string R, and “XOR” it to the
substrings before we do data interpretation. Thus, every string to be interpreted as a set will be a uniformly
random string. In particular, for each primary block, the subsets being stored in the main data structure are
uniformly random subsets marginally. This is sufficient to guarantee the constant query time. We use the
same R for all blocks. Storing R in the data structure introduces poly lg n extra bits of space.
For the second issue, we use the earlier argument. If the expected number of keys in a primary block is
2c
lg n, then the probability that a random set has some primary block with more than lg2c n + lgc+1 n is at
most exp(−Θ(lg2 n)). Then we can afford to use more extra bits to encode such inputs. Suppose S has a
block with, say ≈ 2 lg2c n keys. Then we could simply spend O(lg n) extra bits to encode which block it is,
the number of keys in it, as well as a pointer to a separate rank data structure for this block. The space usage
for such inputs is still OPT − Ω(lg2 n).
Similarly, we can show that the probability that S has N blocks with too many or too few keys is at
most exp(−Θ(N lg2 n)), suggesting that we can afford to use O(N lg2 n) extra bits (which we will use
to store a perfect hash table for these “bad” blocks); the probability that S has a block with m keys for
m > lg3c n is exp(−Θ(m lg m)), suggesting that we may at least use O(m) extra bits for such a block
(which is sufficient to store the previously known membership data structure). By computing the probability
that every particular case happens, we estimate how many extra bits we can afford. The more “non-typical”
the input is, the more extra bits we may use. We then construct a data structure within the allowed extra
bits. It turns out that overall, the total space usage for inputs with at least one “bad” block is at most
OPT − Θ(lg2 n). Finally, we apply the fusion operation to combine the “random-looking” inputs and these
11

“non-typical” inputs: if every block pair has number of keys close to the expectation, we set b := 1 and
construct the data structure as in the previous subsection using ≈ OPT bits; if at least one block pair has too
many or too few keys, we set b := 2 and construct a data structure using OPT − Θ(lg2 n) bits; then we fuse
b into the data structure. By the guarantee of the fusion operation, the final space is bounded by
≈ lg(2OPT + 2OPT−Θ(lg

2

n)

) = OPT + lg(1 + 2−Θ(lg

2

n)

) = OPT + o(1).

Generalizing the data structure to σ > 1 (associating each key with a value) can be done by generalizing
Lemma 4. Since the underlying data structure supports rank, it naturally maps m keys to {1, . . . , m}. Then
we use [DPT10], or simply concatenation, to store the list of m values. To retrieve the value of a key x,
we first find its rank xr . Then retrieve the xr -th value in the list. This generalizes the data structure to the
dictionary problem at essentially no extra cost.

2.5 Organization
In Section 3, we define notations and the model of computation. In Section 4, we formally define fractionallength strings, and state the black-box operations (the proofs are deferred to the appendix). In Section 5, we
show how to construct the succinct dictionary and locally decodable arithmetic codes using perfech hashing.
In Section 6, we design the data structure for the case where U = poly n using the main technical lemma.
Then we prove the main technical lemma in Section 7, and generalize to all n and U in Section 8.

3 Preliminaries and Notations
3.1 Random access machine
A random access machine (RAM) has a memory divided into w-bit words, where w is called the wordsize. Typically, we assume the number of words in the memory is at most 2w , and they are indexed by
{0, . . . , 2w − 1}. In each time step, an algorithm may load one memory word to one of its O(1) CPU
registers, write the content of a CPU register to one memory word, or compute (limited) word operations on
the CPU registers.
The standard word operations are the four basic arithmetic operations (addition, subtraction, multiplication and division) on w-bit integers, bit-wise operators (AND, OR, XOR), and comparison. In this paper,
we also assume that the machine supports floating-point numbers. A floating-point number is represented
by two registers in the form of a · 2b , and the arithmetic operations extend to these numbers as well (possibly with rounding errors). This is without loss of generality, as they can be simulated using the standard
operations. Finally, we assume it is possible to compute 2x up to 1 ± 2−w multiplicative error, and lg2 x up
to additive ±2−w error. We further assume that the error can be arbitrary but has to be deterministic, i.e., for
any given x, 2x and lg2 x always compute to the same result within the desired range. By expanding into
the Taylor series, the two can be computed in O(w) time using only arithmetic operations, which is already
sufficient for our application. On the other hand, using a lookup table of size 2ǫw (we already have lookup
tables of this size), the computational time can be reduced to constant.

3.2 Notations
In this paper, let X div Y denote ⌊X/Y ⌋, X mod Y denote X − Y · (X div Y ). Let [R] denote the set
{0, 1, . . . , R − 1}. Let frac(x) denote x − ⌊x⌋. Throughout the paper, lg x is the binary logarithm lg2 x,
Õ(f ) = f · poly lg f .
12

4 Fractional-length Strings
In this subsection, we formally define binary strings with fractional lengths using the spillover representation of [Pǎt08], and state block-box operations. Throughout the paper, let κ be the fineness parameter,
which characterizes the gaps between adjacent valid lengths, and determines the space loss when doing the
operations. It is an integer parameter that is specified by the algorithm designer and will be hardwired to the
preprocessing and query algorithms. In the following, we will see that each operation loses O(2−κ ) bits;
and on the other hand, the algorithms will have to perform arithmetic operations on κ-bit integers. In our
data structure construction, κ will be set to Θ(lg U ) = O(w), so that each operation loses negligible space,
and κ-bit arithmetic operations can still be performed in constant time.
Definition 5 (fractional-length strings). Let S = (M, K) be a pair such that M ∈ {0, 1}m and K ∈ [R],
where m is a nonnegative integer and R ∈ [2κ , 2κ+1 ) is an integer, or m = 0 and integer R ∈ [1, 2κ ). Then
S is a binary string of length m + lg R, and
(
M [i] i ∈ [m],
S[i] :=
K
i = m.
Let |S| denote the length of S. Let S[i, j] denote the sequence (substring) (S[i], . . . , S[j]). Let range(K) :=
R be the size of range of K.
Remark. Note the following facts about fractional-length strings:
• When s is an integer, by writing K in its binary representation, a binary string of length s from
Definition 5 is a standard binary string of s bits;
• A uniformly random string of length s has entropy exactly s;
• |S| uniquely determines |M | and range(K), i.e., if |S| < κ, |M | = 0 and range(K) = 2s , otherwise,
|M | = ⌊|S|⌋ − κ and range(K) = 2κ+frac(|S|) ;
• The length of a string may be an irrational number, but it can always be succinctly encoded, e.g., by
encoding |M | and range(K);
• One should not view range(K) as a function of K, it is indeed a parameter of the variable K.

Since the word-size is Ω(κ), any O(κ) consecutive bits of a string can be retrieved using O(1) memory accesses, which suggests how a fractional-length string is accessed. Formally, we define an access as
follows.
Definition 6 (access). Let S be a (fractional-length) string, an access to S is to retrieve S[i, j] for j − i ≤
O(κ).

When j < |M |, an access is to retrieve j − i + 1 bits of M . When j = |M |, it is to retrieve j − i bits
and the integer K.
In the following, we show how to operate on fractional-length strings. All the proofs are deferred to
Appendix A. Firstly, the strings can be concatenated.
Proposition 7 (concatenation). Let s1 , . . . , sB ≥ κ. Suppose for any given i, s1 + · · · + si can be approximated (deterministically) in O(t) time with an additive error of at most 2−κ . Then given B strings
S1 , . . . , SB , where Si = (Mi , Ki ) has length si , they can be concatenated into one string S = (M, K) of
length at most
s1 + · · · + sB + (B − 1) · 2−κ+4 ,
13

so that each Mi is a (consecutive) substring of M . Moreover, for any given i, Si can be decoded using O(t)
time and two accesses to S, i.e., a decoding algorithm recovers Ki , and finds the starting location of Mi
using O(t) time and two accesses to S.
In particular, by storing approximations of all B prefix sums in a lookup table of size O(B), each Si can
be decoded in O(1) time. Note that this lookup table does not depend on the B strings.
Proposition 8 (concatenation). Let s1 , . . . , sB ≥ 0. There is a lookup table of size O(B). Given B strings
S1 , . . . , SB , where Si = (Mi , Ki ) has length si , they can be concatenated into one string S = (M, K) of
length at most
s1 + · · · + sB + (B − 1)2−κ+4 ,
so that each Mi is a (consecutive) substring of M . Moreover, assuming we can make random accesses to
the lookup table, Si can be decoded using constant time and two accesses to S, i.e., a decoding algorithm
recovers Ki , and finds the starting location of Mi using constant time and two accesses to S.
Next, an integer i ∈ [C] can be fused into a string.
Proposition 9 (fusion). Let s1 , . . . , sC ≥ 0. Suppose for any given i, 2s1 + · · · + 2si can be approximated
(deterministically) in O(t) time with an additive error of at most (2s1 + · · · + 2sC ) · 2−κ−3 . Then given
i ∈ {1, . . . , C} and string Si = (Mi , Ki ) of length si , the pair (i, Si ) can be stored in S = (M, K) of
length at most
lg(2s1 + · · · + 2sC ) + C · 2−κ+4 ,
so that Mi is a (consecutive) substring of M . Moreover, we can recover the value of i and decode Si
using O(t lg C) time and two accesses to S, i.e., a decoding algorithm recovers i, Ki , and finds the starting
location of Mi using O(t lg C) time and two accesses to S.
Note that the error term is always proportional to 2s1 + · · · + 2sC , for every i. In particular, it is possible
that for some (small) i, the error term dominates the value, making the assumption easy to satisfy (for that
i). The decoding algorithm can take constant time if we use a lookup table of size O(C). Again, the lookup
table does not depend on the string.
Proposition 10 (fusion). Let s1 , . . . , sC ≥ 0. There is a lookup table of size O(C). Given i ∈ {1, . . . , C}
and string Si = (Mi , Ki ) of length si , the pair (i, Si ) can be stored in S = (M, K) of length
lg(2s1 + · · · + 2sC ) + C · 2−κ+2 ,
so that Mi is a (consecutive) substring of M . Moreover, assuming we can make random accesses to the
lookup table, the value of i can be recovered and Si can be decoded using constant time and two accesses
to S, i.e., a decoding algorithm recovers i, Ki , and finds the starting location of Mi using constant time and
two accesses to S.
Fractional-length strings have “one of its ends” encoded using an integer. For technical reasons, we also
need the following notion of double-ended binary strings.

14

Definition 11 (double-ended strings). Let S = (Kh , M, Kt ) be a triple such that M ∈ {0, 1}m , Kh ∈ [Rh ]
and Kt ∈ [Rt ], where m is a nonnegative integer and Rh , Rt ∈ [2κ , 2κ+1 ) are integers. Then S is a
double-ended binary string of length m + lg Rh + lg Rt , and

i = −1,

Kh
S[i] := M [i] i ∈ [m],


Kt
i = m.

Let |S| denote the length of S. Let S[i, j] denote the substring (S[i], . . . , S[j]). Let range(Kh ) :=
Rh , range(Kt ) := Rt be the sizes of ranges of Kh and Kt respectively.
Remark. Note the following facts:
• Unlike the (single-ended) fraction-length strings, the length of a double-ended string does not necessarily determine range(Kh ), range(Kt ), or even |M |;
• For s ≥ 2κ, any s-bit string (M, K) can be viewed as a double-ended string by taking the first κ bits
of M as Kh and letting Kt be K;
• For simplicity, in this paper, we do not define double-ended strings with length shorter than 2κ;
Double-ended strings are accessed in the same way.
Definition 12 (access). Let S be a double-ended string, an access to S is to retrieve S[i, j] for j − i ≤ O(κ).
Prefixes and suffixes of a double-ended string are defined in the natural way, as follows.
Definition 13 (prefix/suffix). Let S = (Kh , M, Kt ) be a double-ended string. Then S[−1, j] is a prefix of
S for any j ≤ |M |, S[i, |M |] is a suffix of S for any i ≥ −1.
Using double-ended strings, it is possible to divide a binary string into two substrings.

Proposition 14 (divide). Let s1 , s2 , s ≥ 3κ and s ≤ s1 + s2 − 2−κ+2 . Then given a double-ended string
S = (Kh , M, Kt ) of length s, a division algorithm outputs two double-ended strings S1 = (K1,h , M1 , K1,t )
and S2 = (K2,h , M2 , K2,t ) of lengths at most s1 and s2 respectively. Moreover, (K1,h , M1 ) is a prefix of
S, (M2 , K2,t ) is a suffix of S, and K1,t and K2,h together determine M [|M1 |, |M | − |M2 | − 1], i.e., the
remaining bits of M . range(Ki,h ), range(Ki,t ) and |Mi | can be computed in O(1) time given range(Kh ),
range(Kt ), |M | and s1 , s2 , for i = 1, 2.
Remark. Proposition 14 guarantees that each access to S can be implemented using at most two accesses to
S1 and S2 . Moreover, accessing a (short) prefix of S requires only accessing the prefix of S1 of the same
length. Likewise, accessing a suffix of S requires only accessing the suffix of S2 of the same length.
Finally, the “inverse” of fusion can also be done efficiently.

Proposition 15 (extraction). Let s1 , . . . , sC ≥ 0, Rh , Rt ∈ [2κ , 2κ+1 ) and m ≥ κ, let s = m+lg Rh +lg Rt ,
and s ≤ lg(2s1 + · · · + 2sC ) − C · 2−κ+2 , there is a lookup table of size O(C). Given a double-ended string
S = (Kh , M, Kt ) such that range(Kh ) = Rh , range(Kt ) = Rt and |M | = m, there is an extraction
algorithm that generates a pair (i, Si ) such that i ∈ {1, . . . , C}, and Si = (Ki,h , Mi , Ki,t ) has length at
most si . Moreover, (Mi , Ki,t ) is a suffix of S, and given i and Ki,h , the rest of S (i.e., S[−1, |M |−|Mi |−1])
can be recovered in constant time, assuming random access to the lookup table. range(Ki,h ), range(Ki,t )
and |Mi | does not depend on S, and can be stored in the lookup table.
Remark. We can safely omit any i with |M |−|Mi | > κ+1, since removing such si from the list (s1 , . . . , sC )
(and decrease C by one) could only increase the upper bound on s, lg(2s1 + · · · + 2sC ) − C · 2−κ+2 .
That is, the extraction algorithm may never generate a pair with this i. Therefore, we may assume that
S[−1, |M | − |Mi | − 1] has length at most O(κ), taking constant time to output.
15

5 Reductions to Perfect Hashing
Now, we show how to design succinct dictionary and compress low entropy sequence with local decodability
using the membership and perfect hashing data structure in Theorem 2.
Succinct dictionary.
rup [DPT10].

For dictionary, we shall use the following lemma by Dodis, Pǎtraşcu and Tho-

Lemma 16 ([DPT10]). There is an algorithm that preprocesses a given sequence (x1 , . . . , xn ) ∈ [σ]n for
σ ≤ 2κ into a data structure of length at most n lg σ + (n − 1)2−κ+5 , such that given any i, xi can be
retrieved in constant time.
The data structure in [DPT10] requires a lookup table of O(lg n) words. We show that by using the view
of fractional-length strings, we can completely remove the lookup table.
Proof. Let b = ⌈2κ/ lg σ⌉. We partition the sequence into n/b chunks of b symbols each, then combine
each chunk into one single character in [σ b ] (if n is not a multiple of b, then the last group will have more
than b symbols). Since σ b = 2O(κ) = 2O(w) , each xi can be decode in constant time given the character.
Then compute m = ⌊lg σ b ⌋ − κ and R = ⌈σ b · 2−m ⌉, and view each character in [σ b ] as a data structure of
size m + lg R. Note that m + lg R − b lg σ ≤ lg(σ b + 2m ) − b lg σ ≤ lg(1 + 2−κ ) ≤ 2−κ+1 . Then we apply
Proposition 7 to concatenate all n/b data structure. Since m and R can both be computed in constant time,
m + lg R can be approximated in constant time, hence Proposition 7 guarantees that there is a data structure
of size
(m + lg R) · (n/b) + (n/b − 1) · 2−κ+4 ≤ n lg σ + (n − 1) · 2−κ+5 ,
supporting symbol retrieval in constant time. This proves the lemma.
To store a set of n key-value pairs for keys in [U ] and values in [σ], we first apply Theorem 2 on the set
of keys. It produces a data structure of size lg Un + poly lg n + O(lg lg U ) bits, which defines a bijection
h between the keys and [n]. Next, we apply Lemma 16 to store the values. Specifically, we construct the
sequence (v1 , . . . , vn ) such that if (x, u) is an input key-value pair, then vh(x)+1 = u. This sequence can be
stored in space n lg σ + O(1) by Lemma 16. Hence, the total space of the data structure is
 
U
lg
+ n lg σ + poly lg n + O(lg lg U ) = OPT + poly lg n + O(lg lg U ),
n
as claimed in Theorem 1.
To answer a query valRet(x), we first query the membership data structure. If x is not a key, we return
⊥. Otherwise, we retrieve and return the (h(x) + 1)-th value in the sequence. The total query time is
constant in expectation and with high probability. This proves Theorem 1.
Compression to zeroth order entropy with local decodability. Given a sequence (x1 , . . . , xn ) ∈ Σn
such that each σ ∈ Σ appears fσ times, we construct a data structure recursively on Σ. We first arbitrarily
partition Σ into Σ1 ∪ Σ2 such that |Σ1 | = ⌊|Σ|/2⌋ and |Σ2 | = ⌈|Σ|/2⌉. For any set Γ ⊆ Σ, define
SΓ := {i ∈ [n] : xi ∈ Γ}. Then we apply Theorem 2 to construct a perfect hashing for SΣ1 , which uses
space




n
n!
+ poly lg n,
lg
+ poly lg n = lg
|SΣ1 |! · |SΣ2 |!
|SΣ1 |
16

and defines a bijection h that maps all coordinates in SΣ1 to [|SΣ1 |], and a bijection h that maps all SΣ2
to [|SΣ2 |]. We recursively construct a data structure for Σ1 over h(SΣ1 ), and a data structure for Σ2 over
h(|SΣ2 |).
In general, each node in the recursion tree corresponds to a subset Γ of the alphabet such that Γ1 and Γ2
are the subsets corresponding to the left and the right child respectively. In this node, we store
• the size of subset of its left child |Γ1 |,
• the perfect hashing data structure for SΓ1 ,
• two pointers to the data structures in its left and its right children.
For Γ of size one, we store nothing. Thus, we obtain a final data structure of size


n!
+ |Σ| · poly lg n.
lg
fσ1 !fσ2 ! · · ·
To answer a query i, we first retrieve the size of Σ1 and query if i ∈ SΣ1 . If i ∈ SΣ1 , we go to the left
child and recursively query h(i). If i ∈
/ SΣ1 , we go to the right child and recursively query h(i). Finally,
when the current subset |Γ| = 1, we return the only element in Γ. Since in each level of the recursion, the
perfect hashing data structure takes constant query time in expectation, and the size of Γ reduces by a factor
two, the total query time is O(lg |Σ|) in expectation. This proves Theorem 3.

6 Perfect Hashing for Medium-Sized Sets
In this section, we present the minimal perfect hashing and membership data structure when the number
of keys n is neither too large nor too small, focusing on the case where n ≥ U 1/12 and n ≤ U − U 1/12 .
Generalizing to all n involves less new ideas, and we defer the proof of the main theorem to Section 8.
Recall that we wish to preprocess a set of n keys S ⊆ [U ], such that the data structure defines a bijection
h between S and [n] and a bijection h between [U ] \ S and [U − n]. A query hash(x) returns a pair (b, v)
such that
• if x ∈ S, then b = 1 and v = h(x);
• if x ∈
/ S, then b = 0 and v = h(x).
We partition the universe [U ] into pairs of blocks. For each pair, we construct a main data structure and
an auxiliary data structure, such that the main data structure contains “most” of the information in the block
and has fixed length, and the auxiliary data structure stores the remaining information (which unavoidably
has variable length). Finally, we concatenate all data structures for all blocks.
Our main technical lemma is to construct such two (fractional-length) data structures for a pair of blocks
of sizes V and Vsc .
Lemma 17 (main technical lemma). Let κ be the fineness parameter for fractional-length strings, and c
be a constant positive integer. Let V ∈ [2κ2c−3 , 2κ/2 ] and Vsc ≥ 4κc+1 . For any constant ǫ > 0, there
is a preprocessing algorithm perfHashBlk, query algorithms qalgBlkmain , qalgBlk and lookup tables
tableBlkV,Vsc of size Õ(2ǫκ ). Given
• a set S ⊆ [V ] such that m := |S| ∈ [κ2c−3 + κc /3, κ2c−3 + 2κc /3],
• a set Ssc ⊆ {V, . . . , V + Vsc − 1} and msc := |Ssc | ∈ [κc+1 , 3κc+1 ],
• a random string R of κc+1 bits,
perfHashBlk preprocesses S and Ssc into a pair of two (fractional-length) data structures Dmain and Daux ,
such that

17

(i) Dmain has length at most
lg
(ii) Daux has length at most



V
κ2c−3 , κc



+ κ2c−3 · 2−κ/2+1 ;

 




V
Vsc
V
lg
+ lg
− lg 2c−3 c + κc+1 2−κ/2+2 ;
m
msc
κ
,κ
(iii) Dmain and Daux together define a bijection h between
S ∪ Ssc

and

[m + msc ],

and a bijection h between
[V + Vsc ] \ (S ∪ Ssc ) and

[(V + Vsc ) − (m + msc )],

such that h(S) ⊃ [κ2c−3 ] and h([V ] \ S) ⊃ [V − κ2c−3 − κc ];
(iv) given any x ∈ [V ], qalgBlkmain (V, x) outputs hash(x) when x ∈ S and h(x) ∈ [κ2c−3 ], or when
x ∈
/ S and h(x) ∈ [V − κ2c−3 − κc ], otherwise it outputs “unknown”; moreover, it only accesses
Dmain , R and the lookup table tableBlkV,Vsc , and it runs in constant time in the worst case;
(v) for any x ∈ [V ], the probability that qalgBlkmain (V, x) outputs “unknown” is at most O(κ−c+3 ) over
the randomness of R;
(vi) given any x ∈ [V + Vsc ], qalgBlk(V, m, Vsc , msc , x) computes hash(x); it accesses Dmain , Daux , R
and the lookup table tableBlkV,Vsc , and it runs in O(κ4 ) time.
Remark. Note that the size of Dmain does not depend on m or msc , and qalgBlkmain also does not need to
V
Vsc
, close
know m or msc to answer a query. The total size of Dmain and Daux is approximately lg m
+lg m
sc
to the optimal space given m and msc . The size of Dmain is also close to the optimum, as qalgBlkmain has
to identify a set of κ2c−3
V− κ2c−3 − κc non-keys by only accessing Dmain , which takes exactly
 keys and
V
V
lg κ2c−3 ,V −κ2c−3 −κc = lg κ2c−3 ,κc bits.
The proof of the lemma is deferred to Section 7. In this following, we present our data structure assuming
this lemma. For simplicity of the notations, let
 
V
OPTV,m := lg
m
be the information theoretical optimal space when storing a set of m keys over key space of size V .
Theorem 18. For any constant ǫ > 0 and constant integer c > 0, there is a preprocessing algorithm
perfHash, a query algorithm qAlg and lookup tables tableU,n of size nǫ , such that given
• a set S of n keys over the key space [U ], where n ≥ U 1/12 and n ≤ U − U 1/12 ,
• a uniformly random string R of length O(lgc+1 n),
perfHash preprocesses S into a data structure D of (worst-case) length
OPTU,n + U −1 ,
such that D defines a bijection h between S and [n] and a bijection h between [U ] \ S and [U − n]. Given
access to D, R and tableU,n , for any key x ∈ [U ], qAlg(U, n, x) outputs hash(x) on a RAM with word-size
w ≥ Ω(lg U ), in time
18

• O(1) with probability 1 − O(lg−c+4 U ) and
• O(lg7 U ) in worst-case,
where the probability is taken over the random R. In particular, the query time is constant in expectation
and with high probability by setting c = 11.
Remark. When n < U 1/12 , we could use a hash function to map the keys to n2 buckets with no collisions.
We could apply this theorem with the new key space being all buckets, and the keys being the non-empty
buckets. By further storing for each non-empty bucket, the key within it, it extends the membership query
to n < U 1/12 , using O(lg n + lg lg U ) extra bits. We will see a more generic approach in Section 8 (which
works for perfect hashing and improves the lg lg U term).
Without loss of generality, we may assume n ≤ U/2, since otherwise, we could simply take the complement of S. Let κ := ⌈4 lg U ⌉ be the fineness parameter, and c be a (large) constant positive integer to
be specified later. We partition the universe [U ] into pairs of blocks. Each block pair consists of a larger
primary block containing roughly κ2c−3 + κc /2 keys, and a smaller secondary block containing roughly
2κc+1 keys. Formally, let
(κ2c−3 + κc /2)U
⌋,
Vpr := ⌊
n
2κc+1 U
⌋
n
and Vbl = Vpr + Vsc . Each primary block has size Vpr and each secondary block has size Vsc . Every block
pair has size Vbl . For simplicity, let us first consider the case where U is a multiple of Vbl , and U = Vbl · Nbl .
We will show how to handle general U later.
Thus, we partition U into Nbl block pairs in the natural way, where the i-th primary block
Vsc := ⌊

i
Bpr
:= {x ∈ [U ] : (i − 1)Vbl ≤ x < Vpr + (i − 1)Vbl }

and the i-th secondary block
i
Bsc
:= {x ∈ [U ] : Vpr + (i − 1)Vbl ≤ x < iVbl } .

We call the i-th block pair good, if the numbers of keys in the primary and secondary blocks are close
to the average:
i
|S ∩ Bpr
| ∈ [κ2c−3 + κc /3, κ2c−3 + 2κc /3],
and
i
|S ∩ Bsc
| ∈ [κc+1 , 3κc+1 ].

The pair is bad if at least one of the two blocks has the number of keys outside the range.
In the following, we show that for inputs S with no bad blocks, we can construct a good data structure.
The goal is to design a data structure using space close to OPTNbl Vbl ,n .

6.1 No bad block pair
Lemma 19. If U is a multiple of Vbl , then there is a data structure with the guarantees in Theorem 18, for
all sets S with no bad block pair. Moreover, the size of the data structure is
OPTU,n + n · 2−κ/2+2 .
19

Before starting the preprocessing, we view the last O(lg U ) bits of the random bits R as a random
number ∆ ∈ [U ]. We shift the entire universe according to ∆, i.e., x 7→ (x + ∆) mod U . It is applied to
input S, and will be applied to the queries too (which guarantees that the query is in a primary block with
good probability).
The preprocessing algorithm is based on recursion. The following algorithm dict rec preprocesses S
j
i , B i , . . . , B j , B j , and outputs j−i+2 data structures D i
restricted to the i-th to j-th blocks Bpr
pr
sc
sc
main , . . . , Dmain
and Daux . We will inductively prove upper bounds on the sizes of the data structures: the length of each
i
Dmain
is at most


Vpr
+ κ2c−3 · 2−κ/2+1 ,
(1)
SIZEmain := lg
κ2c−3 , κc
and the length of Daux generated from i, . . . , j-th block pair is at most
OPT(j−i+1)Vbl ,m − (j − i + 1)SIZEmain + (m − 1)2−κ/2+2 ,

(2)

where m is the number of keys in blocks i to j. In the base case with only one block pair, we simply apply
Lemma 17.
preprocessing algorithm dict rec(i, j, m, S, R):
1. if i = j
2.
let Spr ⊆ S be the set of keys in the i-th primary block
3.
let Ssc ⊆ S be the set of keys in the i-th secondary block
4.
mpr := |Spr | and msc := |Ssc |
i
′
5.
(Dmain
, Daux
) := perfHashBlk(Vpr , mpr , Vsc , msc , Spr , Ssc , R) (from Lemma 17)
′
6.
apply Proposition 10 to fuse mpr into Daux
, and obtain Daux
i
7.
return (Dmain , Daux )
(to be cont’d)
i
Claim 20. If i = j, |Dmain
| ≤ SIZEmain and |Daux | ≤ OPTVbl ,m − SIZEmain + (m − 1) · 2−κ/2+2 .

To prove the claim, note that the premises of Lemma 17 are satisfied: since 2n ≤ U , Vpr ≥ 2κ2c−3
and Vpr ≤ U ≤ 2κ/2 ; Vsc ≥ 4κc+1 ; by assumption, every primary block has between κ2c−3 + κc /3 and
κ2c−3 +2κc /3 keys, and every secondary block has between κc+1 and 3κc+1 keys. Therefore, by Lemma 17,
i
′
is at most
the size of Dmain
is at most SIZEmain , and the size of Daux




Vpr
Vsc
lg
+ lg
− SIZEmain + κ2c−3 · 2−κ/2+2 .
mpr
m − mpr

By fusing the value of mpr into the data structure, the size of Daux is at most

OPTVbl ,m − SIZEmain + (m − 1) · 2−κ/2+2 ,

 Vsc 
P
Vbl
Vpr
i
due to the fact that m ≥ κ2c−3 + κc+1 and mpr m
m−mpr = lg m = OPTVbl ,m . Dmain and Daux
pr
both have sizes as claimed in (1) and (2). Also, note that we give the same random string R to all block
pairs. Thus, the total number of random bits needed is κc+1 by Lemma 17.
Next, when i < j, we recurse on the two halves of the block pairs, and merge them.
k := ⌊(i + j)/2⌋
let m1 be the number of keys in the i-th, . . . , k-th block pair
let m2 be the number of keys in the (k + 1)-th, . . . , j-th block pair
recurse on the two halves:
i
k
(Dmain
, . . . , Dmain
, Daux,1 ) := dict rec(i, k, m1 , S, R)
j
k+1
(Dmain , . . . , Dmain
, Daux,2 ) := dict rec(k + 1, j, m2 , S, R)
′
12. apply Proposition 7 to concatenate Daux,1 and Daux,2 , and obtain Daux
′
13. apply Proposition 9 to fuse the value of m1 into Daux for m1 ∈ {0, . . . , m}, and obtain Daux
j
i
14. return (Dmain
, . . . , Dmain
, Daux )

8.
9.
10.
11.

20

i
Claim 21. |Dmain
| ≤ SIZEmain for all i, and |Daux | ≤ OPT(j−i+1)Vbl ,m − SIZEmain + (j − i + 1)(m − 1) ·
−κ/2+2
2
.
i
We have already showed that each |Dmain
| ≤ SIZEmain above. To prove the bound on |Daux |, by inductive
hypothesis, we know that Daux,1 has size at most

OPT(k−i+1)Vbl ,m1 − (k − i + 1)SIZEmain + (m1 − 1)2−κ/2+2
and Daux,2 has size at most
OPT(j−k)Vbl ,m2 − (j − k)SIZEmain + (m2 − 1)2−κ/2+2 .
To apply Proposition 7 in line 12, it requires us to approximates the data structure sizes. The following claim
implies that the premises can be satisfied.
Claim 22. Both OPT(k−i+1)Vbl ,m1 − (k − i + 1)SIZEmain + (m1 − 1)2−κ/2+2 and OPT(j−k)Vbl ,m2 − (j −
k)SIZEmain + (m2 − 1)2−κ/2+2 can be approximated with an additive error of at most 2−κ in O(1) time.
′
of length
Assuming Claim 22, Proposition 7 concatenates Daux,1 and Daux,2 into a data structure Daux
at most

OPT(k−i+1)Vbl ,m1 + OPT(j−k)Vbl ,m−m1 − (j − i + 1)SIZEmain + (m − 2)2−κ/2+2 + 2−κ+4 .
The following claim implies that the premises of Proposition 9 from line 13 can be satisfied, because −(j −
i + 1)SIZEmain + (m − 2)2−κ/2+2 + 2−κ+4 does not depend on m1 , and can be computed efficiently.
P
Claim 23. For any V1 , V2 , m ≥ 0,
and 0 ≤ l ≤ m, li=0 2OPTV1 ,i +OPTV2 ,m−i can be approximated up to an
P
OPTV1 ,i +OPTV2 ,m−i
additive error of at most 2−κ−3 · m
in O(κ5 ) time.
i=0 2
The proofs of both claims are deferred to Appendix B. Assuming Claim 23, Proposition 9 fuses m1 into
and obtains Daux of length at most
!
m
X
OPT(k−i+1)Vbl ,l +OPT(j−k)Vbl ,m−l −(j−i+1)SIZEmain +(m−2)2−κ/2+2 +2−κ+4
lg
2
+ (m + 1) · 2−κ+4

′ ,
Daux

l=0

≤ lg

m
X

2OPT(k−i+1)Vbl ,l +OPT(j−k)Vbl ,m−l

l=0

!

− (j − i + 1)SIZEmain + (m − 1)2−κ/2+2

= OPT(j−i+1)Vbl ,m − (j − i + 1)SIZEmain + (m − 1)2−κ/2+2
This proves Claim 21.
Nbl
1
, . . . , Dmain
of length SIZEmain and Daux of length
Thus, by induction, dict rec outputs Dmain
OPTNbl Vbl ,n − Nbl · SIZEmain + (n − 1)2−κ/2+2 .
Finally, we apply Proposition 7 again to concatenate all Nbl + 1 data structures. By storing approximai
tions of sizes of Dmain
and Daux in the lookup table, we obtain a data structure of length at most
Nbl · SIZEmain + (OPTNbl Vbl ,n − Nbl · SIZEmain + (n − 1)2−κ/2+2 ) + Nbl · 2−κ+3

≤ OPTNbl Vbl ,n + n · 2−κ/2+2 .

This proves the space bound in Lemma 19.
21

i and B i . We define
Hash functions. Let hi and hi be the bijections obtained by Lemma 17 for blocks Bpr
sc
the bijections h and h as follows:
i ∪ B i ), if h (x) < κ2c−3 , let h(x) := (i − 1)κ2c−3 + h (x),
• for key x ∈ S ∩ (Bpr
i
i
sc
P
j
j
otherwise, let h(x) := (Nbl − i) · κ2c−3 + j<i |(Bpr
∪ Bsc
) ∩ S| + hi (x);
• for non-key x ∈
/ S, if hi (x) < Vpr − κ2c−3 − κc , let h(x) := (i − 1)(Vpr − κ2c−3 − κc ) + hi (x),
P
j
j
∪ Bsc
) \ S| + hi (x).
otherwise, let h(x) := (Nbl − i) · (Vpr − κ2c−3 − κc ) + j<i |(Bpr
2c−3
Essentially, the smallest hash values will be those with hi (x) < κ
or hi (x) < Vpr − κ2c−3 − κc , ordered
according to i and hi (x) or hi (x). Then the rest take larger values ordered according to i and hi (x) or hi (x).
By definition, they are both bijections.

Lookup tables.

We store the following information in the lookup table.

lookup table tbl:
1. tableBlkVpr ,Vsc from Lemma 17
2. the lookup table for line 6 from Proposition 10 for all valid values mpr and msc
3. approximated value of SIZEmain and the (final) size of Daux , up to O(κ) bits of precision

By Lemma 17, the lookup table size is 2ǫκ . Since κ = O(lg U ) and n ≥ U 1/12 , by readjusting the constant
ǫ, the lookup table size is at most nǫ .
Query algorithm. Now, we show how to answer hash queries. Given a query x ∈ [U ], we first shift it
according to ∆, as we did at preprocessing, x 7→ (x + ∆) mod U . If x is in a primary block, we query
the corresponding main data structure. If the main data structure does not return the answer, or x is not in a
primary block, we recursively decode the corresponding auxiliary data structure, and run qalgBlk.
query algorithm qalgG(U, n, x):
1. if x is in the i-th primary block
i
2.
apply Proposition 7 to decode Dmain
i
3.
if (b, v) := Dmain .qalgBlkmain (Vpr , x) 6= “unknown” (from Lemma 17)
4.
if b = 1, return (1, (i − 1)κ2c−3 + v)
5.
if b = 0, return (0, (i − 1)(Vpr − κ2c−3 − κc ) + v)
6. decode Daux and return Daux .qalg rec(1, Nbl , 0, n, x)

Since Vpr /Vsc = O(κc−4 ) and we randomly shifted the universe, x is in a primary block with probability 1−
O(κ−c+4 ). Also, by Lemma 17, qalgBlkmain runs in constant time. It returns “unknown” with probability
at most O(κ−c+3 ) for a uniformly random R, and returns hash(x) otherwise. Therefore, the probability that
qalgG terminates before reaching the last line is 1 − O(κ−c+4 ). Since κ = Θ(lg U ), it computes hash(x)
in constant time with probability 1 − O(lg−c+4 U ).
Next, we show how to implement qalg rec(i, j, s, m, x), which takes as parameters
• (i, j): a range of blocks,
• s: the total number of keys before block i,
• m, the total number of keys in blocks i to j, and
• x, the element being queried.
We will prove that its worst-case running time is O(lg7 U ).

22

query algorithm qalg rec(i, j, s, m, x):
1. if i = j
′
2.
apply Proposition 10 to decode mpr and Daux
i
′
3.
(b, v) := (Dmain
, Daux
).qalgBlk(Vpr , mpr , Vsc , m − mpr , x − (i − 1)(Vpr + Vsc ))
(from Lemma 17)
4.
if b = 1, return (1, (Nbl − i) · κ2c−3 + s + v)
5.
if b = 0, return (0, (Nbl − i) · (Vpr − κ2c−3 − κc ) + ((i − 1) · Vbl − s) + v)
(to be cont’d)
′
In the base case with only one block, we simply decode the value of mpr as well as the corresponding Daux
from the i-th block pair. By running qalgBlk from Lemma 17 to query within the block pair, we compute
hash(x) according to its definition in O(κ4 ) time.

6.
7.
8.
9.
10.
11.
12.

k := ⌊(i + j)/2⌋
′
apply Proposition 9 and Claim 23 to decode m1 and Daux
apply Proposition 7 and Claim 22 to decode Daux,1 and Daux,2
if x is in i-th, . . . , k-th block pair
return Daux,1 .qalgrec(i, k, s, m1 , x)
else
return Daux,2 .qalgrec(k + 1, j, s + m1 , m − m1 , x)

In general, we decode m1 , the number of elements in the first half of the blocks. Then we decode the
data structures for the two halves. Depending on where the query is, we recurse into one of the two data
structures. Proposition 7, Proposition 9, Claim 22 and Claim 23 guarantee that the decoding takes O(κ6 )
time. The recursion has at most O(lg n) ≤ κ levels. Thus, the total running time of qalgrec is at most
O(κ7 ). This proves the claim on the query time, and hence, it proves Lemma 19.

6.2 At least one bad block pair
Now, let us show how to handle sets with at least one bad block. We will show that the space usage for such
sets is OPTU,n − Ω(κ3 ).
Lemma 24. If U is a multiple of Vbl , then there is a data structure with guarantees in Theorem 18, for all
sets with at least one bad block pair. Moreover, the size of the data structure is at most
OPTU,n − Ω(κ3 ).
3

Note that this is possible, because by Chernoff bound, there are only at most 2−Ω(κ ) fraction such sets,
and we can even afford to spend at least O(κ3 ) = O(lg3 U ) extra bits. The first ⌈lg Nbl ⌉ bits are used to
encode the number of bad block pairs Nbad . It turns out that the fraction of input sets with Nbad bad pairs is
3
2−Ω(κ Nbad ) , as we mentioned in Section 2. By the argument there, we can afford to use O(κ3 Nbad ) extra
bits.
The idea is to construct a mapping which maps all good block pairs to the first Nbl −Nbad pairs, construct
a data structure using the above algorithm for good blocks, and finally handle the bad pairs separately.
To construct such a mapping, observe that the following two numbers are equal:
(a) the number of good pairs among the last Nbad pairs, and
(b) the number of bad pairs among the first Nbl − Nbad pairs.
Hence, in the mapping, we map all the good pairs among the last Nbad to all bad pairs among the first
Nbl − Nbad . The good pairs in the first Nbl − Nbad pairs will be mapped to themselves. To store such a
mapping, we spend O(Nbad · lg Nbl ) bits to store a hash table of all the bad pairs using the FKS hashing.
23

Then we spend O(Nbad · lg Nbl ) bits to store for each pair in the last Nbad pairs, whether it is a good pair
and if it is, which bad pair it will be mapped to. The mapping takes O(Nbad · lg Nbl ) bits to store in total
(which is much smaller than κ3 Nbad ). It takes constant time to evaluate.
This mapping maps all good pairs to the first Nbl − Nbad pairs. Then we apply dict rec for good pairs
from Lemma 19 to construct a data structure using


OPT(Nbl −Nbad )Vbl ,n−nbad + (n − nbad ) · 2−κ/2+2 ≤ OPT(Nbl −Nbad )Vbl ,n−nbad + 1

bits, where nbad is the number of keys in the bad block pairs.
Next, we construct data structures for the bad pairs. Consider a bad pair with mpr keys in the primary
block and msc keys in the secondary block. Thus, either mpr ∈
/ [κ2c−3 + κc /3, κ2c−3 + 2κc /3], or msc ∈
/
c+1
c+1
[κ , 3κ ]. We construct two separate data structures, one for the primary block and one for secondary
block (note that it might be the case that the number of keys in the primary block is within the above range,
but the block pair is bad due to the secondary block, or vice versa, we still construct two separate data
structures for both of them using the following argument). It turns out that if the number of keys in the block
is at most κO(1) , then there is a data structure using only O(1) extra bit, answering queries in constant time.
Lemma 25. Let c be any constant positive integer and ǫ be any positive constant. There is a preprocessing
algorithm perfHashS, query algorithm qalgS and lookup tables tableSV,m of sizes Õ(2ǫκ ), such that for
any V ≤ 2κ/2 and m ≤ κc , given a set S ⊂ [V ] of m keys, perfHashS preprocesses S into a data structure
of size at most
OPTV,m + (m − 1) · 2−κ/2+1 ,
such that it defines a bijection h between S and [m] and a bijection h between [V ] \ S and [V − m]. Given
any x ∈ [V ], qalgS answers hash(x) in constant time, by accessing the data structure and tableSV,m .
In particular, the size is at most OPTV,m + O(1). The lemma is an immediate corollary of Lemma 28 in
Section 7.2. Its proof is deferred to Section 7.2.
On the other hand, sets that have a block with more than κ3c keys are even more rare. By Chernoff
bound, we can estimate that the fraction of sets with at least one block with m > κ3c keys is at most
2−Ω(m lg m) . This suggests that for every (bad) block with m > κ3c keys, we can afford to spend O(m lg m)
extra bits. A simple modification to [Pag01a] gives such a data structure.
Lemma 26. Given a set S ⊂ [V ] of m keys, there is a data structure of size
OPTV,m + O(m + lg lg V ),
such that it defines a bijection h between S and [m] and a bijection h between [V ] \ S and [V − m]. It
supports hash queries in constant time.
Note that lg lg V ≤ lg κ, and m ≥ κ3c . The number of extra bits is simply O(m). We prove this lemma
in Appendix C.
For each bad block pair, we write down the two numbers mpr and msc using O(lg n) bits. Then if
mpr ≤ κ3c , we apply Lemma 25, and obtain a data structure with
OPTVpr ,mpr + O(1)
bits. If mpr > κ3c , we apply Lemma 26, and obtain a data structure with
OPTVpr ,mpr + O(mpr )
24

bits. Likewise for the secondary block, we obtain a data structure with
OPTVsc ,msc + O(1)
bits if msc ≤ κ3c , and

OPTVsc ,msc + O(msc )

bits if msc > κ3c .
Finally, we concatenate all data structures (which now all have integer lengths), and for each bad pair,
we further store a pointer pointing to its corresponding data structure, as well as the total number of keys in
all bad blocks prior to it (which helps us compute the hash values).
Space usage. Let us first bound the space usage for the data structures for a bad block pair. Consider the
i-th bad block pair, suppose it has mpr,i keys in the primary block and msc,i keys in the secondary block.
Then note that we have


Vpr
Vpr !
= lg
lg
mpr,i !(Vpr − mpr,i )!
mpr,i
which by Sterling’s formula, is at most
≤ lg



Vpr
e

Vpr

− lg

m

pr,i

e

mpr,i

− lg



Vpr − mpr,i
e

Vpr −mpr,i

+ O(lg Vpr )

= Vpr lg Vpr − mpr,i lg mpr,i − (Vpr − mpr,i ) lg (Vpr − mpr,i ) + O(lg Vpr ).

(3)

In the following, we are going to compare (3) with
Vpr lg Vpr − mpr,i lg mpr − (Vpr − mpr,i ) lg (Vpr − mpr ) + O(lg Vpr ),

(4)

where mpr = κ2c−3 + κc /2 is the average number of keys in a primary block. First observe that f (x) =
m lg x + (V − m) lg(V − x) achieves its maximum at x = m, thus, (3) ≤ (4). On the other hand, if
mpr,i ∈
/ [κ2c−3 + κc /3, κ2c−3 + 2κc /3], i.e., mpr,i is far from mpr , (3) is even smaller.
Claim 27. We have (4) ≥ (3). Moreover, if mpr,i ∈
/ [κ2c−3 + κc /3, κ2c−3 + 2κc /3],
(
Ω(κ3 )
mpr,i ≤ κ3c ,
(4) − (3) ≥
mpr,i lg κ mpr,i > κ3c .
Proof.
Vpr − mpr
mpr
− (Vpr − mpr,i ) lg
mpr,i
Vpr − mpr,i




mpr,i − mpr
mpr − mpr,i
− (Vpr − mpr,i ) lg 1 +
.
= −mpr,i lg 1 +
mpr,i
Vpr − mpr,i

(4) − (3) = −mpr,i lg

By the facts that ln(1 + x) ≤ x for x > −1, ln(1 + x) ≤ x − 41 x2 for |x| ≤ 1, and ln(1 + x) ≤ 3x/4 for
x > 1, when mpr,i ≤ mpr /2, we have




mpr,i − mpr
mpr − mpr,i
(4) − (3) = −mpr,i lg 1 +
− (Vpr − mpr,i ) lg 1 +
mpr,i
Vpr − mpr,i
25

≥ −mpr,i ·

mpr,i − mpr
3 mpr − mpr,i
·
lg e − (Vpr − mpr,i ) ·
lg e
4
mpr,i
Vpr − mpr,i

lg e
(mpr − mpr,i )
4
≥ Ω(κ2c−3 ).

=

When mpr,i ≥ mpr /2 and mpr,i ≤ κ3c , we have




mpr − mpr,i
mpr,i − mpr
− (Vpr − mpr,i ) lg 1 +
(4) − (3) = −mpr,i lg 1 +
mpr,i
Vpr − mpr,i
2 !

mpr − mpr,i 1 mpr − mpr,i
≥ −mpr,i
lg e
−
mpr,i
4
mpr,i
mpr,i − mpr
lg e
Vpr − mpr,i
lg e (mpr,i − mpr )2
=
·
4
mpr,i
− (Vpr − mpr,i ) ·

≥ Ω(κ3 ),
where the last inequality uses the fact that mpr,i ∈
/ [κ2c−3 + κc /3, κ2c−3 + 2κc /3].
3c
When mpr,i ≥ κ , we have




mpr − mpr,i
mpr,i − mpr
(4) − (3) = −mpr,i lg 1 +
− (Vpr − mpr,i ) lg 1 +
mpr,i
Vpr − mpr,i
mpr
− (mpr,i − mpr ) lg e
≥ −mpr,i lg
mpr,i
mpr,i
≥ mpr,i lg
e · mpr
≥ mpr,i lg κ.

Combining the three cases, we conclude that
(
Ω(κ3 )
mpr,i ≤ κ3c ,
(4) − (3) ≥
mpr,i lg κ mpr,i > κ3c ,
proving the claim.
On the other hand, since Vpr = U ·

mpr
n

± O(1), we have

(4) = Vpr lg U − mpr,i lg n − (Vpr − mpr,i ) lg(U − n) + O(lg Vpr ).
Thus, Claim 27 implies that if mpr,i ∈
/ [κ2c−3 + κc /3, κ2c−3 + 2κc /3], i.e., the primary block is bad, then
the data structure size for the primary block is at most
Vpr lg U − mpr,i lg n − (Vpr − mpr,i ) lg(U − n) − Ω(κ3 )
(since O(mpr,i ) ≪ mpr,i lg κ and O(1) ≪ κ3 ), and otherwise, it is at most
Vpr lg U − mpr,i lg n − (Vpr − mpr,i ) lg(U − n) + O(lg Vpr ).
26

By applying the same argument to the secondary blocks, we conclude that if msc,i ∈
/ [κc+1 , 3κc+1 ], i.e.,
the secondary block is bad, then the data structure size for the secondary block is at most
Vsc lg U − msc,i lg n + (Vsc − msc,i ) lg(U − n) − Ω(κ3 ),
and otherwise, it is at most
Vsc lg U − msc,i lg n + (Vsc − msc,i ) lg(U − n) + O(lg Vpr ).
Summing up the two bounds, and by the fact that at least one of the primary and secondary block is bad,
the data structure size for the i-th bad block pair is at most
Vbl lg U − (mpr,i + msc,i ) lg n − (Vbl − mpr,i − msc,i ) lg(U − n) − Ω(κ3 ),
since κ3 ≫ lg Vpr .
Now we sum up the size for all Nbad bad blocks, which in total contain nbad keys, the total size is at
most
Nbad · Vbl lg U − nbad lg n − (Nbad · Vbl − nbad ) lg(U − n) − Ω(Nbad · κ3 ).
Therefore, the total size of the data structure is at most
OPT(Nbl −Nbad )Vbl ,n−nbad + O(Nbad lg Nbl ) + Nbad · Vbl lg U

− nbad lg n − (Nbad · Vbl − nbad ) lg(U − n) − Ω(Nbad · κ3 )

= (Nbl − Nbad )Vbl lg((Nbl − Nbad )Vbl ) − (n − nbad ) lg(n − nbad )

− ((Nbl − Nbad )Vbl − (n − nbad )) lg((Nbl − Nbad )Vbl − (n − nbad ))

+ Nbad · Vbl lg U − nbad lg n − (Nbad · Vbl − nbad ) lg(U − n) − Ω(Nbad · κ3 ),

which by Claim 27 and the fact that Nbad ≥ 1, is at most
= (Nbl − Nbad )Vbl lg U − (n − nbad ) lg n − ((Nbl − Nbad )Vbl − (n − nbad )) lg(U − n)
+ Nbad · Vbl lg U − nbad lg n − (Nbad · Vbl − nbad ) lg(U − n) − Ω(κ3 ),

= U lg U − n lg n − (U − n) lg(U − n) − Ω(κ3 )
 
U
≤ lg
− Ω(κ3 )
n

= OPTU,n − Ω(κ3 ),
as we claimed.

Hash functions. For all x in the good blocks, we simply use their hash value according to Lemma 19,
for which, h takes values in [n − nbad ] and h takes values in [Vbl · (Nbl − Nbad ) − (n − nbad )]. For x
in the i-th bad pair with hash value v, let si be the total number of keys in first i − 1 bad pairs (which is
explicitly stored in the data structure), then if x ∈ S, we set h(x) := n − nbad + si + v; if x ∈
/ S, we set
h(x) := Vbl · (Nbl − Nbad + (i − 1)) − (n − nbad + si ) + v.
That is, all elements in good blocks take the smallest values, and elements in bad blocks take the rest
according to the order of the blocks. By definition, they are both bijections.
27

Lookup tables. We include the lookup table from the data structure for no bad blocks, as well as all tables
tableSV,m from Lemma 25 for V = Vpr or V = Vsc , and 1 ≤ m ≤ κ3c . The total lookup table size is
Õ(2ǫκ ). It is at most nǫ by readjusting the constant ǫ.
Query algorithm. Given a query x, suppose x is in the i-th block pair. We first query the hash table
to check if it is one of the bad pairs. If the block pair is bad, we follow the pointer and query the data
structure for the primary block or the secondary block depending on which block x is in. Its hash value can
be computed according to the definition. It takes constant time.
If the block pair is good, we spend constant time to find out where i-th block pair is mapped to, in the
first Nbl − Nbad pairs. Then we run qalgG for good blocks, which takes constant time in expectation. This
proves Lemma 24.

6.3 Final data structure for medium size sets
Consider the following preprocessing algorithm for general U and U 1/12 ≤ n ≤ U/2 (U not necessarily
a multiple of Vbl ). We first construct a data structure for the block pairs, and fuse the two cases (with or
without bad blocks) together.
preprocessing algorithm perfHash(U, n, S, R):
1. compute Vpr , Vsc and κ
2. compute Nbl := U div Vbl and V := U mod Vbl
3. divide the universe [U ] into Nbl block pairs and a last block of size V
4. if all Nbl block pairs are good
5.
set i := 0, apply Lemma 19 on the Nbl block pairs, and obtain a data structure D0
6. else
7.
set i := 1, apply Lemma 24 on the Nbl block pairs, and obtain a data structure D1
8. apply Proposition 10 to fuse i into Di , and obtain a data structure Dbl

(to be cont’d)

Suppose there are nbl keys in the first Nbl block pairs. By Lemma 19, D0 has length at most
OPTNbl Vbl ,nbl + nbl · 2−κ/2+2 .
By Lemma 24, D1 has length at most
OPTNbl Vbl ,nbl − Ω(κ3 ).
Thus, by Proposition 10, Dbl has length at most
−κ/2+2

OPTNbl Vbl ,nbl + lg(2nbl ·2

3

+ 2−Ω(κ ) ) + 2−κ+2
3

≤ OPTNbl Vbl ,nbl + lg(1 + nbl · 2−κ/2+2 + 2−Ω(κ ) ) + 2−κ+2

≤ OPTNbl Vbl ,nbl + nbl · 2−κ/2+3

= OPTU −V,nbl + nbl · 2−κ/2+3 .

Then we construct a separate data structure for the last block using Lemma 25 or Lemma 26 based on
the number of keys in it.

28

9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
20.

if n − nbl ≤ κ3c
construct Dlast for the last block using Lemma 25
apply Proposition 8 to concatenate Dbl and Dlast , and obtain D′
let n′bl = nbl
else
construct Dlast for the last block using Lemma 26
spend ⌈lg n⌉ bits to store nbl ,
round both Dbl and Dlast to integral lengths and concatenate them
spend ⌈lg n⌉ bits to store a point to Dlast , let the resulting data structure be D′
let n′bl = n − κ3c − 1
apply Proposition 10 to fuse the value of n′bl into D′ for n′bl ∈ [n − κ3c − 1, n], and obtain D
return D

We do not fuse the whole value of nbl into D ′ , as its range is large and Proposition 10 requires a large lookup
table to do this. However, we only fuse its value if nbl ≥ n − κ3c , and otherwise only indicate that it is
smaller than n − κ3c (by setting n′bl to n − κ3c − 1). This is fine because we spend extra lg n bits to explicitly
store its value in this case. We will show in the following that the total space is close the optimum.
There are n − nbl keys in the last block. If n − nbl ≤ κ3c , Dlast has size at most
OPTV,n−nbl + (n − nbl − 1) · 2−κ/2+1 .
In this case, the length of D ′ is at most
OPTU −V,nbl + OPTV,n−nbl + nbl · 2−κ/2+3 + (n − nbl − 1) · 2−κ/2+1 + 2−κ+2

≤ OPTU −V,nbl + OPTV,n−nbl + n · 2−κ/2+3



U −V
V
= lg
+ n · 2−κ/2+3 .
nbl
n − nbl

(5)

If n − nbl > κ3c , Dlast has size at most
OPTV,n−nbl + O(n − nbl + lg n).
The length of D ′ is at most


U −V
lg
nbl




V
+ O(n − nbl + lg n).
n − nbl

(6)

By Sterling’s formula, the first term is at most



U −V
V
(U − V )!V !
lg
= lg
nbl !(U − V − nbl )!(n − nbl )!(V − n + nbl )!
nbl
n − nbl

≤ (U − V ) lg(U − V ) − nbl lg nbl − (U − V − nbl ) lg(U − V − nbl )

+ V lg V − (n − nbl ) lg(n − nbl ) − (V − n + nbl ) lg(V − n + nbl ) + O(lg U )

which again by the fact that f (x) = m lg x + (V − m) lg(V − x) is maximized at x = m, is at most
(U − V )n
(U − V )n
− (U − V − nbl ) lg(U − V −
)
U
U
+ V lg V − (n − nbl ) lg(n − nbl ) − (V − n + nbl ) lg(V − n + nbl ) + O(lg U )

≤ (U − V ) lg(U − V ) − nbl lg

29

= (U − V ) lg U − nbl lg n − (U − V − nbl ) lg(U − n)


Vn
Vn
− (V − n + nbl ) V −
+ V lg V − (n − nbl ) lg
U
U
U (n − nbl )
V − n + nbl
− (n − nbl ) lg
+ O(lg U )
− (V − n + nbl ) lg
Vn
V − VUn

= U lg U − n lg n − (U − n) lg(U − n)

n − nbl − VUn
U (n − nbl )
+ (V − n + nbl ) lg 1 +
− (n − nbl ) lg
Vn
V − n + nbl

which by the fact that ln(1 + x) ≤ x, is at most
 
U
U (n − nbl )
≤ lg
− (n − nbl ) lg
+ (n − nbl ) lg e + O(lg U )
n
Vn
which by the fact that n − nbl ≥ κ3c , is at most
 
U
U κ3c
+ O(lg U )
≤ lg
− (n − nbl ) lg
n
eV n
which by the fact that U/(eV n) ≥ κ−2c and c ≥ 1, is at most
 
U
≤ lg
− (n − nbl ) lg κ + O(lg U ).
n
Therefore, when n − nbl > κ3c , the size of D ′ is at most
 
U
(6) ≤ lg
− Ω((n − nbl ) lg κ) + O(lg U + lg n)
n
≤ OPTU,n − Ω(κ3 ).

Finally together with Equation (5), by Proposition 10, the size of D is at most





n
X
U −V
V
3
−κ/2+3
 + n · 2−κ+2
lg 2OPTU,n −Ω(κ ) +
· 2n·2
n
n
−
n
bl
bl
nbl =n−κ3c




n 
X
U
−
V
3
V
−κ/2+3
 + n · 2−κ+2
≤ lg 2OPTU,n −Ω(κ ) +
· 2n·2
n
n
−
n
bl
bl
nbl =0

 

U
3
−κ/2+3
= lg 2OPTU,n −Ω(κ ) +
· 2n·2
+ n · 2−κ+2
n


3
−κ/2+3
+ n · 2−κ+2
= OPTU,n + lg 2−Ω(κ ) + 2n·2


3
≤ OPTU,n + lg 2−Ω(κ ) + 1 + n · 2−κ/2+3 + n · 2−κ+2
3

≤ OPTU,n + 2−Ω(κ ) + n · 2−κ/2+4 + n · 2−κ+2
≤ OPTU,n + U −1 .

30

!

+ O(lg U )

Hash functions. For all x in the first Nbl block pairs, we simply use their hash values defined by Dbl (from
Lemma 19 or Lemma 24), for which, h takes values from [nbl ] and h takes values from [Vbl · Nbl − nbl ].
For all x in the last block, let v be its hash value defined by Dlast . If x ∈ S, let h(x) := nbl + v; if x ∈
/ S,
let h(x) := Vbl · Nbl − nbl + v. By definition, h and h are both bijections.
Lookup table. We include the lookup tables in Section 6.1 and in Section 6.2, which both have size nǫ .
Then we include the lookup tables needed by Proposition 8 and Proposition 10 in line 8, 11 and 19. The
total size is nǫ .
Query algorithm.
of x.

Given a query x, we decode all the components, and query the part based on the value

query algorithm qAlg(x):
1. compute Vpr , Vsc , Nbl and V
2. apply Proposition 10 to recover n′bl and decode D′ from D
3. if n′bl > n − κ3c − 1
4.
let nbl := n′bl
5.
apply Proposition 8 to decode Dbl and Dlast
6. else
7.
recover nbl from D′
8.
decode Dbl and Dlast
9. if x ≥ U − V
10.
query x in Dlast , and obtain (b, v)
11.
if b = 1, then return (1, nbl + v)
12.
if b = 0, then return (0, Vbl · Nbl − nbl + v)
13. else
14.
apply Proposition 10 to recover i and decode Di from Dbl
15.
query x in Db using the corresponding query algorithm, and return the outcome

All subroutines run in constant time, the overall query time is constant. This proves Theorem 18.

7 Data Structure Pair for Block Pair
In this section, we prove our main technical lemma (Lemma 17), which constructs a pair of data structures
for a pair of blocks.
Lemma 17 (restated). Let κ be the fineness parameter for fractional-length strings, and c be a constant
positive integer. Let V ∈ [2κ2c−3 , 2κ/2 ] and Vsc ≥ 4κc+1 . For any constant ǫ > 0, there is a preprocessing
algorithm perfHashBlk, query algorithms qalgBlkmain , qalgBlk and lookup tables tableBlkV,Vsc of
size Õ(2ǫκ ). Given
• a set S ⊆ [V ] such that m := |S| ∈ [κ2c−3 + κc /3, κ2c−3 + 2κc /3],
• a set Ssc ⊆ {V, . . . , V + Vsc − 1} and msc := |Ssc | ∈ [κc+1 , 3κc+1 ],
• a random string R of κc+1 bits,
perfHashBlk preprocesses S and Ssc into a pair of two (fractional-length) data structures Dmain and Daux ,
such that
(i) Dmain has length at most


V
lg 2c−3 c + κ2c−3 · 2−κ/2+1 ;
κ
,κ

31

(ii) Daux has length at most

 




V
V
Vsc
lg
− lg 2c−3 c + κc+1 2−κ/2+2 ;
+ lg
m
msc
κ
,κ

(iii) Dmain and Daux together define a bijection h between
S ∪ Ssc

and

[m + msc ],

and a bijection h between
[V + Vsc ] \ (S ∪ Ssc ) and

[(V + Vsc ) − (m + msc )],

such that h(S) ⊃ [κ2c−3 ] and h([V ] \ S) ⊃ [V − κ2c−3 − κc ];
(iv) given any x ∈ [V ], qalgBlkmain (V, x) outputs hash(x) when x ∈ S and h(x) ∈ [κ2c−3 ], or when
x ∈
/ S and h(x) ∈ [V − κ2c−3 − κc ], otherwise it outputs “unknown”; moreover, it only accesses
Dmain , R and the lookup table tableBlkV,Vsc , and it runs in constant time in the worst case;
(v) for any x ∈ [V ], the probability that qalgBlkmain (V, x) outputs “unknown” is at most O(κ−c+3 ) over
the randomness of R;
(vi) given any x ∈ [V + Vsc ], qalgBlk(V, m, Vsc , msc , x) computes hash(x); it accesses Dmain , Daux , R
and the lookup table tableBlkV,Vsc , and it runs in O(κ4 ) time.
As mentioned in the overview, we first improve the rank data structure of Pǎtraşcu [Pǎt08]. We show
that if a block has κc keys, then there is a rank data structure with constant query time and negligible extra
space. The rank problem asks to preprocess a set S of m keys into a data structure, supporting
• rankS (x): return the number of keys that are at most x.
In particular, by computing both rankS (x) and rankS (x − 1), one can decide if x ∈ S.

Lemma 28. Let c be any constant positive integer and ǫ be any positive constant. There is a preprocessing
algorithm prepRank, query algorithm qAlgRank and lookup tables tableRankV,m of sizes Õ(2ǫκ ), such
that for any integers V ≤ 2κ/2 , m ≤ κc , given a set S ⊂ [V ] of size m, prepRank(V, m, S) outputs a data
structure D of length
 
V
lg
+ (m − 1) · 2−κ/2 .
m
Given x ∈ [V ], qAlgRank(V, m, x) computes rankS (x) in constant time, by accessing D and tableRankV,m .
In particular, by computing both rankS (x) and rankS (x − 1), one can decide if x ∈ S in constant time.
The algorithms run on a random access machine with word-size w = Θ(κ).
We prove this lemma in Section 7.2. Note that a rank data structure easily defines hash functions that
map the keys to [m], and the non-keys to [V − m]: For each key x, we set h(x) := rank(x) − 1; for each
non-key x, we set h(x) := x − rank(x) − 1. Lemma 17 designs a pair of two data structure, where the size
of the main data structure does not depend on m (it only assumes that m is in a small range). Most queries
can be answered by accessing only the main data structure, also without knowing the value of m.
To construct the two data structures, we first apply Lemma 28 to construct a rank data structure for the
secondary block Ssc ⊂ [Vsc ]. Denote this data structure by Dsc . Then we pick a set of κ2c−3 keys from S,
as well as V − κ2c−3 − κc non-keys from [V ] \ S, and construct the above rank data structure, which will
be the main data structure. The remaining κc elements in [V ] will correspond to the “unknowns.” We pick
the two setsbased on the bits in Dsc . That is, we apply
 Proposition 14 and divide Dsc into a string of length
m
−m
≈ lg κ2c−3
, a string of length ≈ lg V −κV2c−3
−κc and the remaining bits. Then we apply the following
lemma to interpret the first string as a subset of S and the second string as a subset of [V ] \ S. The final
auxiliary data structure consists of the remaining bits of Dsc , as well as a data structure for the “unknowns.”
32

Lemma 29. Let c ≥ 2 be a constant positive integer. There is a preprocessing algorithm prepIntoSet, a
query algorithm request and lookup tables tableIntV,m of sizes O(κc+2 ), such that for any integers V
and m where V ≤ 2κ/2 and m ≤ κc , given a (double-ended) string D = (Kh , M, Kt ) of length
 
V
s ≤ lg
− m(V − 1)2−κ+2 ,
m
prepIntoSet(V, m, D) outputs a set S ⊆ [V ] of size m. For any −1 ≤ a1 ≤ a2 ≤ |M | and a2 < a1 +
κ, request(0, V, m, range(Kh ), |M |, range(Kt ), a1 , a2 ) computes D[a1 , a2 ] in O(κ4 ) time using O(κ2 )
rank queries to S, assuming it can make random accesses to the lookup table tableIntV,m .
The lemma guarantees that even if the original string is not stored explicitly as part of the final data
structure, it can still be accessed implicitly assuming rank queries to the sets, which the above dictionary
data structures support naturally. We prove the above lemma in Section 7.1.
In the remainder of the section, we show how to construct the pair of data structures in detail.
Proof of Lemma 17. We begin by presenting the preprocessing algorithm.
Preprocessing algorithm. In the preprocessing algorithm, we first construct a rank data structure for the
secondary block, and divide it into three substrings.
Preprocessing algorithm perfHashBlk(V, m, Vsc , msc , S, Ssc , R):
1. run Dsc := prepRank(Vsc , msc , Ssc ) (from Lemma 28) to construct a rank data structure for Ssc using
!
Vsc
ssc ≤ lg
+ (msc − 1) · 2−κ/2
msc
bits
2. apply Proposition 14 twice to divideDsc into
• Dsc,1 : length ≤ lg m−κm2c−3 − κc (m − 1)2−κ+2

V −m
• Dsc,2 : length ≤ lg κ2c−3
− κc (V − m − 1)2−κ+2
+κc −m 

m
V −m
• Dsc,3 : length ≤ ssc − lg m−κ2c−3 − lg κ2c−3
+ κc V 2−κ+2
+κc −m

(to be cont’d)

Note that m − κ2c−3 ≥ κc /3 and κ2c−3 +
κc − m ≥ κc /3, therefore, both Dsc,1 and Dsc,2 have length at
Vsc 
least 4κ. For Dsc,3 , we have ssc ≥ lg msc ≥ κc+1 , and thus,
ssc − lg



m
m − κ2c−3



− lg




V −m
+ κc V 2−κ+2
κ2c−3 + κc − m

≥ κc+1 − (m − κ2c−3 ) lg V − (κ2c−3 + κc − m) lg V

≥ κc+1 − κc lg V

≥ 4κ.

The premises of Proposition 14 are satisfied. In order to store two random subsets in the main data structure,
we “XOR” Dsc,1 and Dsc,2 with the random string R.
3. compute Dsc,1 ⊕ R and Dsc,2 ⊕ R

(to be cont’d)

For double-ended string D = (Kh , M, Kt ), D ⊕ R is defined as follows: compute the bitwise XOR of M
and R[1, |M |], treat R[|M |+1, |M |+2κ] and R[|M |+2κ+1, |M |+4κ] as two 2κ-bit integers, and compute
(Kh + R[|M | + 1, |M | + 2κ]) mod range(Kh ) and (Kt + R[|M | + 2κ + 1, |M | + 4κ]) mod range(Kt );
33

D ⊕ R is the double-ended string (with the same length as D), formed by the outcomes. In particular, since
range(Kh ) and range(Kt ) are both smaller than 2κ+1 ≪ 22κ , when R is uniformly random, D ⊕ R is very
close to uniform. We have the following claim by standard information theory.
Claim 30. For any fixed D = (Kh , M, Kt ) and uniformly random R, we have
H(D ⊕ R) ≥ (lg(range(Kh )) + |M | + lg(range(Kt )))(1 − 2−κ+2 )
≥ (|D| − 2−κ+2 )(1 − 2−κ+2 ).

Also, Kh , Kt and any O(κ) consecutive bits of M can be computed in constant time, given random
access to D ⊕ R and R. Next, we interpret the Dsc,1 ⊕ R and Dsc,2 ⊕ R as two subsets using Lemma 29.
4. run S1 := prepIntoSet(m, m − κ2c−3 , Dsc,1 ⊕ R) (from Lemma 29) to interpret Dsc,1 ⊕ R as a set
S1 ⊆ [m] of size m − κ2c−3
run S2 := prepIntoSet(V − m, κ2c−3 + κc − m, Dsc,2 ⊕ R) to interpret Dsc,2 ⊕ R as a set
S2 ⊆ [V − m] of size κ2c−3 + κc − m
5. compute Sunk ⊆ S according to S1
(to be cont’d)
compute S unk ⊆ [V ] \ S according to S2

More specifically, for each i ∈ [m], Sunk contains the (i + 1)-th smallest element in S if and only if i ∈ S1 .
Similarly, S unk contains the (i + 1)-th smallest element in [V ] \ S if and only if i ∈ S2 . They are the keys
and non-keys that are not to be stored in the main data structure, i.e., the “unknowns.”
Then, we compute the main data structure Dmain .
6. apply Proposition 8 to concatenate the following two data structures: and obtain Dmain :
• Dmain,1 := prepRank(V, κ2c−3 , S \ Sunk ) (from Lemma 28), a rank data structure
• Dmain,2 := prepRank(V − κ2c−3 , κc ,“Sunk ∪ S unk ”) a rank data structure for Sunk ∪ S unk
over [V ] \ (S \ Sunk ) (see below)
(to be cont’d)

For Dmain,2 , before running prepRank, we first remove all κ2c−3 elements in S \ Sunk from both the
universe [V ] and Sunk ∪S unk , and keep the order of the remaining elements. Thus, the new universe becomes
[V − κ2c−3 ]. In the other words, Dmain,2 supports queries of form “return # of elements in Sunk ∪ S unk that
are no larger than i-th smallest element in [V ] \ (S \ Sunk )”.
Finally, we compute the auxiliary data structure Daux .
7. apply Proposition 8 to concatenate the following two data structures and obtain Daux :
• Daux,1 := prepRank(κc , m − κ2c−3 ,“Sunk ”), a rank data structure for Sunk over Sunk ∪ S unk
• Daux,2 := Dsc,3

Similarly, Daux,1 supports queries of form “return # of elements in Sunk that are no larger than the i-th
smallest element in Sunk ∪ S unk .”
Space analysis. Next, we analyze the length of Dmain and Daux . Dmain is the concatenation of Dmain,1
and Dmain,2 . For Dmain,1 , its length is at most


V
lg 2c−3 + (κ2c−3 − 1)2−κ/2
κ
by Lemma 28. For Dmain,2 , its length is at most


V − κ2c−3
+ (κc − 1)2−κ/2 .
lg
κc
34

By Proposition 8, the length of Dmain is at most




V
V − κ2c−3
2c−3
−κ/2
+ (κc − 1)2−κ/2 + 2−κ+4
lg 2c−3 + (κ
− 1)2
+ lg
κc
κ


V
≤ lg 2c−3 c + κ2c−3 2−κ/2+1 .
κ
,κ
Daux is the concatenation of Daux,1 and Daux,2 . For Daux,1 , its length is at most


κc
+ (m − κ2c−3 − 1)2−κ/2 .
lg
m − κ2c−3
For Daux,2 , which is Dsc,3 , its length is at most




m
V −m
ssc − lg
− lg 2c−3
+ κc V 2−κ+2
m − κ2c−3
κ
+ κc − m






V −m
m
Vsc
−
lg
− lg
≤ lg
+ 3κc+1 2−κ/2 ,
msc
m − κ2c−3
κ2c−3 + κc − m
since V ≤ 2κ/2 and msc ≤ 3κc+1 . Summing up the lengths and by Proposition 8, the length of Daux is at
most




Vsc
κc
2c−3
−κ/2
+ (m − κ
− 1)2
+ lg
lg
m − κ2c−3
msc




m
V −m
− lg
− lg 2c−3
+ 3κc+1 2−κ/2 + 2−κ+4
m − κ2c−3
κ
+ κc − m


Vsc
κc !κ2c−3 !(V − κ2c−3 − κc )!
+ lg
+ (m − κ2c−3 + 3κc+1 )2−κ/2
≤ lg
msc
m!(V − m)!
 




V
V
Vsc
≤ lg
− lg 2c−3 c + κc+1 2−κ/2+2 ,
+ lg
m
msc
κ
,κ
as we claimed. This proves item (i) and (ii) in the statement.
Hash functions. For x ∈ S ∪ Ssc , we define h(x) as follows.
• For x ∈ S \ Sunk , let h(x) := rankS\Sunk (x) − 1; they are mapped to [κ2c−3 ].
• For x ∈ Sunk , let h(x) := κ2c−3 + rankSunk (x) − 1; they are mapped to {κ2c−3 , . . . , m − 1}.
• For x ∈ Ssc , let h(x) := m + rankSsc (x) − 1; they are mapped to {m, . . . , m + msc − 1}.
Similarly, for x ∈
/ S ∪ Ssc , we define h as follows.
• For x ∈ ([V ] \ S) \ S unk , let h(x) := rank[V ]\S\S unk (x) − 1; they are mapped to [V − κ2c−3 − κc ].
• For x ∈ S unk , let h(x) := V − κ2c−3 − κc + rankS unk (x) − 1; they are mapped to {V − κ2c−3 −
κc , . . . , V − m − 1}.
• For x ∈ {V, . . . , V + Vsc − 1} \ Ssc , let h(x) := V − m + rank{V,...,V +Vsc −1}\Ssc (x) − 1; they are
mapped to {V − m, . . . , V + Vsc − m − msc − 1}.
Overall, h is a bijection between S ∪ Ssc and [m + msc ], and h is a bijection between [V + Vsc ] \ (S ∪ Ssc )
and [V + Vsc − m − msc ]. Moreover, h(S) ⊃ [κ2c−3 ] and h([V ] \ S) ⊃ [V − κ2c−3 − κc ]. This proves item
(iii) in the statement.
35

Lookup table.

We store the following information in the lookup table.

lookup table tableBlkV,Vsc :
1. lookup table for line 6 from Proposition 8
2. tableRankV,κ2c−3 , tableRankV −κ2c−3 ,κc from Lemma 28
3. for all m ∈ [κ2c−3 + κc /3, κ2c−3 + 2κc /3] and msc ∈ [κc+1 , 2κc+1 ]
• lookup tables for line 7 from Proposition 8
• tableRankκc ,m−κ2c−3 and tableRankVsc ,msc from Lemma 28
• tableIntm,m−κ2c−3 and tableIntV −m,κ2c−3 +κc −m from Lemma 29

Each tableRank has size Õ(2ǫκ ) and each tableInt has size O(κc+2 ). The total size of tableBlkV,Vsc
is Õ(2ǫκ ).
The main query algorithm. We show how to answer each query x in constant time with high probability,
by querying only the main data structure (and without knowing m). We begin by decoding the two data
structures Dmain,1 and Dmain,2 from Dmain , and query Dmain,1 .
query algorithm qalgBlkmain (V, x):
1. decode Dmain,1 and Dmain,2 from Dmain using Proposition 8
2. xr := Dmain,1 .qAlgRank(V, κ2c−3 , x) (from Lemma 28)
3. if xr > Dmain.1 .qAlgRank(V, κ2c−3 , x − 1)
4.
return (1, xr − 1)

(to be cont’d)

xr is the number of elements in S \ Sunk that are at most x. Line 3 checks if x ∈ S \ Sunk . If it is, then x is
the xr -th element in S \ Sunk , and we return its hash value according by the definition of h.
5. xunk := Dmain,2 .qAlgRank(V − κ2c−3 , κc , x − xr )
6. if xunk > Dmain,2 .qAlgRank(V − κ2c−3 , κc , x − xr − 1)
7.
return “unknown”
8. return (0, x − xr − xunk )

If x ∈
/ S \ Sunk , we query Dmain,2 to check if x ∈ Sunk ∪ S unk in line 6. Note that x is the (x − xr + 1)th element in [V ] \ (S \ Sunk ). If it is, we return “unknown”. Otherwise, we know that x ∈
/ S, and it
is the (x − xr − xunk + 1)-th element in [V ] \ (S ∪ S unk ), we return its h-value. Since qAlgRank has
constant query time, qalgBlk also runs in constant time. Clearly, qalgBlk outputs hash(x) when x ∈ S
and h(x) ∈ [κ2c−3 ], or x ∈
/ S and h(x) ∈ [V − κ2c−3 − κc ], and otherwise it outputs “unknown”. This
proves item (iv) in the statement.
Next, we show that the probability that it outputs “unknown” is small. To this end, let us fix the input
data S, Ssc and query x, and let R be uniformly random. We will show that Sunk is close to a uniformly
random subset of S of size m − κ2c−3 , and S unk is close to a uniformly random subset of [V ] \ S of size
κ2c−3 + κc − m. By Claim 30, we have H(Dsc,1 ⊕ R) ≥ (|Dsc,1 | − 2−κ+2 )(1 − 2−κ+2 ). Since the division
operation in Proposition 14 is an injection, we have
|Dsc,1 | ≥ ssc − |Dsc,2 | − |Dsc,3 |


m
− κc V 2−κ+3 .
≥ lg
m − κ2c−3

36


Therefore, H(Dsc,1 ⊕ R) ≥ lg m−κm2c−3 − κc 2−κ/2+4 . Furthermore, since prepIntoSet(m, m − κ2c−3 , ·)

is an injection, we have H(S1 ) ≥ lg m−κm2c−3 − κc 2−κ/2+4 , which in turn implies that


m
H(Sunk ) ≥ lg
m − κ2c−3



− κc 2−κ/2+4 ,

for any fixed S and Ssc . By Pinsker’s inequality, the ℓ1 distance between Sunk and a uniformly random
subset of S of size m − κ2c−3 is at most O(κc/2 2−κ/4 ). In particular, it implies that for any fixed x ∈ S, the
probability that x ∈ Sunk is at most
m − κ2c−3
+ O(κc/2 2−κ/4 ) ≤ O(κ−c+3 ).
m
By applying the same argument to Dsc,2 , S2 and S unk , we conclude that for any fixed x ∈
/ S, the
probability that x ∈ S unk is at most
κ2c−3 + κc − m
+ O(κc/2 2−κ/4 ) ≤ O(κ−c+3 ).
V −m
This proves item (v) in the statement.
The general query algorithm. Finally, we describe the query algorithm for all x ∈ [V + Vsc ]. We use
two different algorithms for x ∈ [V ] and x ∈ {V, . . . , V + Vsc − 1}. We begin by the x ∈ [V ] case (x is in
the primary block).
query algorithm qalgBlk(V, m, Vsc , msc , x):
1. (if x < V )
2. (b, v) := qalgBlkmain (V, x)
3. if (b, v) is not “unknown”
4.
return (b, v)
5. let xunk := rankSunk ∪S unk (x) (already computed in qalgBlkmain (V, x))

(to be cont’d)

When qalgBlkmain returns “unknown”, x is the xunk -th element in Sunk ∪ S unk . Next, we query Daux,1
to find out whether x ∈ Sunk or x ∈ S unk and its rank in the corresponding set. Then we return its h or h
value according to the definition.
6.
7.
8.
9.
10.
11.

apply Proposition 8 on Daux to decode Daux,1
xunk,r := Daux,1 .qAlgRank(κc , m − κ2c−3 , xunk − 1)
if xunk,r > Daux,1 .qAlgRank(κc , m − κ2c−3 , xunk − 2)
return κ2c−3 + xunk,r − 1
else
return V − κ2c−3 − κc + (xunk − xunk,r ) − 1

Similarly to qalgBlkmain , we check if the xunk -th element is in Sunk . if it is, then it is the xunk,r -th element
in Sunk . Otherwise, it is the (xunk − xunk,r )-th element in S unk . In this case (x ∈ [V ]), the query algorithm
runs in constant time.
Next, we show how to handle x ∈ {V, . . . , V + Vsc − 1}. To this end, let us first assume that we can
make random access to Dsc .

37

12.
13.
14.
15.
16.
17.
18.

(if x ≥ V )
apply Proposition 8 on Daux to decode Daux,2
xr := Dsc .qAlgRank(Vsc , msc , x − V ) (from Lemma 28)
if xr > Dsc .qAlgRank(Vsc , msc , x − V − 1)
return m + xr − 1
else
return V − m + (x − V − xr )

If we had access to Dsc , then the query algorithm would be similar to the previous cases, and it runs in
constant time. However, Dsc is not stored in the data structure explicitly. In the following, we show how
qalgBlk accesses Dsc from its implicit representation.
More specifically, qalgBlk only needs to access Dsc when it runs the query algorithm qAlgRank on Dsc .
By Lemma 28, qAlgRank runs on a RAM with word-size Θ(κ), i.e., it may request Θ(κ) consecutive bits of
the data structure Dsc during its runtime. To implement such access requests, we first apply Proposition 14
to reduce each access to O(1) accesses to Dsc,1 , Dsc,2 and Dsc,3 . Dsc,3 is stored as Daux,2 , which has been
decoded. Each access to it can be implemented in constant time. For Dsc,1 , Dsc,1 ⊕ R is interpreted as a
set S1 ⊆ [m] of size m − κ2c−3 . Lemma 29 guarantees that each access to Dsc,1 ⊕ R can be implemented
in O(κ4 ) time and O(κ2 ) rank queries to S1 , which by the previous argument, implies that each access to
Dsc,1 can also be implemented in the same time and number of rank queries.
On the other hand, the way the preprocessing algorithm “encodes” S1 guarantees that rankS1 (k) queries
can be implemented efficiently. To see this, recall that Sunk ⊂ S is determined according to S1 . rankS1 (k)
is exactly the number of elements in Sunk that are no larger than the (k + 1)-th smallest element in S. We
first do a binary search to find the (k + 1)-th smallest element in S.
implementing rank queries on S1 rank S1 (k):
1. decode Dmain,1 , Dmain,2 and Daux,1
2. binary search for (k + 1)-th element x∗ in S: given x ∈ [V ],
(i) xr := Dmain,1 .qAlgRank(V, κ2c−3 , x)
(ii) xunk := Dmain,2 .qAlgRank(V − κ2c−3 , κc , x − xr )
(iii) rankS (x) := xr + Daux,1 .qAlgRank(κc , m − κ2c−3 , xunk − 1)

xr is the number of elements in S \ Sunk that are at most x. xunk is the number of elements in Sunk ∪ S unk
that are at most x. Daux,1 .qAlgRank(κc , m − κ2c−3 , xunk − 1) computes the number of elements in Sunk
that are at most x. By summing up xr and Daux,1 .qAlgRank(κc , m − κ2c−3 , xunk ), we compute rankS (x),
the number of elements in S that are at most x, in constant time. Being able to compute rankS (x) for any
given x allows us to binary search for the (k + 1)-th smallest element x∗ in S in O(lg V ) = O(κ) time,
which then allows us to compute rankS1 (k).
3. x∗r := Dmain,1 .qAlgRank(V, κ2c−3 , x∗ )
4. return rankS1 (k) := k − x∗r + 1

This shows that rankS1 (k) can be computed in O(κ) time, and thus, each access to Dsc,1 can be implemented in O(κ4 + κ · κ2 ) = O(κ4 ) time.
Similarly, each access to Dsc,2 can be implemented in O(κ4 ) time: Lemma 29 reduces it to O(κ2 ) rank
queries to S2 and O(κ4 ) processing time; For rankS2 (k), we do binary search to find the (k + 1)-th element
in [V ] \ S; By querying Dmain,1 , Dmain,2 and Daux,1 , we compute rankS2 (k).
Overall, the above algorithms allow us to access Dsc,1 , Dsc,2 and Dsc,3 in O(κ4 ) time, which in turn,
allows us to access Dsc in O(κ4 ). Thus, qalgBlk runs in O(κ4 ) time. This proves item (vi) in the statement.

38

7.1 Data interpretation
In this subsection, we prove Lemma 29, showing how to represent a string as a set which allows us to locally
decode the string given access to a rank oracle of the resulting set.
Lemma 29 (restated). Let c ≥ 2 be a constant positive integer. There is a preprocessing algorithm
prepIntoSet, a query algorithm request and lookup tables tableIntV,m of sizes O(κc+2 ), such that
for any integers V and m where V ≤ 2κ/2 and m ≤ κc , given a (double-ended) string D = (Kh , M, Kt )
of length
 
V
s ≤ lg
− m(V − 1)2−κ+2 ,
m
prepIntoSet(V, m, D) outputs a set S ⊆ [V ] of size m. For any −1 ≤ a1 ≤ a2 ≤ |M | and a2 < a1 +
κ, request(0, V, m, range(Kh ), |M |, range(Kt ), a1 , a2 ) computes D[a1 , a2 ] in O(κ4 ) time using O(κ2 )
rank queries to S, assuming it can make random accesses to the lookup table tableIntV,m .
To construct set S from the input string D, the main idea is to apply Proposition 15 and 14, and then
recurse on the two halves of [V ]. We extract an integer m1 ∈ [m + 1] from D using Proposition 15, which
encodes the number of elements in the first half of [V ]. Then we divide D into two data structure D1 and
V /2 
.
and
the
length
of
D
is
approximately
lg
D2 such that the length of D1 is approximately lg Vm/2
2
m−m
1
1
Then the set S is recursively constructed in the two halves. When the m gets sufficiently small and the D
has length O(κ2 ), we continue the recursion without applying the two propositions about fraction-length
2
strings. Instead, we take the whole string as an integer smaller than 2O(κ ) , and use the integer to encode a
set (also decode the whole integer at the decoding time). See below for the formal argument.
Encoding and decoding an integer using a set. We first show that given an integer Z ≤
it into a set of size m in [V ], such that Z can be recovered using rank queries.

V
m ,

how to turn

encoding algorithm encSet(V, m, Z):
1. if m = 0, return ∅
2. if m = V , return [V ]
3. V1 := ⌊V /2⌋ and V2 := ⌈V /2⌉
 V2 
P
V1
4. compute the largest 0 ≤ j ≤ m such that Z ≥ j−1
i=0
i
m−i
Pj−1 V1  V2 
5. Y := Z − i=0 i m−i


V2
V2
6. Z1 := Y div m−j
and Z2 := Y mod m−j
7. return encSet(V1 , j, Z1 ) ∪ (encSet(V2 , m − j, Z2 ) + V1 )

To construct the set, the algorithm is a standard recursion. All possible sets are listed in the increasing order
of the number of elements in the [V1 ]. We compute this number, and then recurse into the two halves. Z
can be recovered by the following algorithm, assuming the set generated is in the universe [X, X + V ). For
technical reasons that we will encounter later, sometimes we may only have access to the complement of the
set. The bit b indicates whether we should take the complement.
decoding algorithm decSet(X, V, m, b):
1. if m = 0 or m = V , return 0
2. V1 := ⌊V /2⌋ and V2 := ⌈V /2⌉
3. j := rankS (X + V1 − 1) − rankS (X − 1)
4. if b, then j := V1 − j
5. Z1 := decSet(X,
V1 , j, b) and
+ V1 , V2 , m − j, b)
 Z2 := decSet(X

P
V1
V2
V2
6. return Z := j−1
+
Z
·
+
Z
1
2
i=0
i
m−i
m−j

39

Pj−1 V1  V2 
V2 
We will store the sum i=0
i
m−i and the binomial coefficient m−j in the lookup table. Since the
recursion terminates when m = 0 and the value of V decreases by a factor of two each time, the size of the
recursion tree is O(m lg V ). Thus, we have the following claim.
V
Claim 31. decSet uses O(m lg V ) arithmetic operations on O(lg m
)-bit integers, as well as O(m lg V )
rank queries.
Preprocessing into a set. Given a string D = (Kh , M, Kt ) of length at most lg
we preprocess it into a set S ⊆ [V ] of size m.
preprocessing algorithm prepIntoSet(V, m, D = (Kh , M, Kt )):
1. if 2m > V
2.
return [V ] \ prepIntoSet(V, V − m, D)
3. if m ≤ 24κ
4.
rewrite D as an nonnegative integer Z < range(Kh ) · range(Kt ) · 2|M |
5.
return encSet(V, m, Z)
6. if |D| ≤ 24κ
7.
return prepIntoSet(48κ, 24κ, D) ∪ {V − (m − 24κ), . . . , V − 1}

V
m

− m(V − 1)2−κ+2 ,

(to be cont’d)

If m is larger than V /2, we simply work on the complement. If m is O(κ), we view the entire string D as an
integer, and call encSet. If the string is too short while m (and V ) are still large, we manually decrease m
2
V
and V , and reduce it to the m = O(κ) case. Note that m
may be at most 2O(κ ) , Z occupies O(κ) words
(as κ = Θ(w)).
Otherwise, we extract an integer j from D.
8. V1 := ⌊V /2⌋ and V2 := ⌈V /2⌉ 
V2
9. compute sj := lg Vj1 + lg m−j
− m(V − 2)2−κ+2
10. apply Proposition 15 for j ∈ {⌊m/3⌋ + 1, . . . , 2⌊m/3⌋} and C = ⌊m/3⌋, encode D using a pair
(j, Dj ) such that Dj has length at most sj
11. let (S1 , S2 ) := prepIntoTwo(V1 , V2 , j, m − j, Dj )
12. return S1 ∪ (S2 + V1 )

prepIntoTwo preprocesses Dj into two sets of sizes j and m − j over the two halves of the universe (see
below). P
Then we return their union. Proposition 15 requires that the length of D is at least 3κ + 2 and at
most lg( j 2sj ) − (C − 1)2−κ+2 . This is true, because on one hand, the length of D is at least 24κ; on the
other hand,
2⌊m/3⌋

s1

2

sC

+ ··· + 2



 

V2
−κ+2
=
·
· 2−m(V −2)2
m−j
j=⌊m/3⌋+1



 
V1
V2
V
2m
−m(V −2)2−κ+2
·
≥2
−
3 ⌊m/3⌋ ⌈2m/3⌉
m


 



⌊m/2⌋
Y
V
2m
V
V
j(V
−
m
+
j)
−κ+2
1
2
2

·
= 2−m(V −2)2
−
·
m
3 ⌊m/2⌋ ⌈m/2⌉
(V1 − j + 1)(m − j + 1)
j=⌊m/3⌋+1


 
⌊m/2⌋
Y
V
−κ+2
j
2m

≥ 2−m(V −2)2
·
· 1 −
·
m
3
m−j+1
X

V1
j

j=⌊m/3⌋+1

40

−κ+2

≥ 2−m(V −2)2

−κ+2

≥ 2−m(V −2)2

  
V
· 1−
m
  
V
·
· 1−
m
·

⌊m/2⌋
m−2j+1
2m − Pj=⌊m/3⌋+1
m−j+1
·e
3

2m −m/24
·e
.
3



Therefore, by the fact that m ≥ 24κ, we have
s1

lg(2

 
V
+ · · · + 2 ) ≥ lg
− m(V − 2)2−κ+2 − m2−κ
m
sC

≥ s + m2−κ+2 − m2−κ

≥ s + (C − 1) · 2−κ+2 .

Thus, the premises of Proposition 15 are also satisfied. Next, we describe prepIntoTwo.
preprocessing algorithm
1 , V2 , m1 , m2 , D):
 prepIntoTwo(V

V1
V2
−κ+2
1. let s1 := lg m
−
m
and s2 := lg m
− m2 (V2 − 1)2−κ+2
1 (V1 − 1)2
1
2
2. apply Proposition 14, divide D into D1 and D2 of lengths at most s1 and s2 respectively
3. let S1 := prepIntoSet(V1 , m1 , D1 ) and S2 := prepIntoSet(V2 , m2 , D2 )
4. return (S1 , S2 )

Proposition 14 requires that the length of D is at most s1 +s2 −2−κ+2 (and at least 3κ), and s1 , s2 ≥ 3κ. It is
easy to verifier the former. For the latter, because m1 +m2 ≤ V /2, m2 /2 ≤ m1 ≤ 2m2 and m1 +m2 > 24κ,
and in particular, we have V1 ≥ 24κ and m1 ∈ [V1 /3, 2V1 /3]. Hence, we have
 
V1
≥ 38κ ,
m1
and it implies s1 ≥ 8κ. Similarly, we also have s2 ≥ 8κ.
Lookup table.

We store the following lookup table.

lookup table tableIntV,m :
1. if m
24κ 

P≤
j−1 V1
V2
2.
for j = 0, . . . , m
i=0
i
m−i

V2
3.
for all j = 0, . . . , m
j
4. else
5.
lookup table from Proposition 15 for line 10 of prepIntoSet
6. include all tables tableIntV ′ ,m′ for V ′ = ⌊V /2i ⌋ or V ′ = ⌈V /2i ⌉ for i ≥ 1, and 0 ≤ m′ ≤ m

The lookup table tableIntV,m itself has size at most O(κ) words for m > 24κ and O(κ2 ) words for
m ≤ 24κ. Including the smaller tables, its total size is at most O(κ2 m + κ4 ) ≤ O(κc+2 ) words for m ≤ κc
and c ≥ 2.
Access the string. Suppose S is the set generated from a string D using the above preprocessing algorithm. In the following, we show how to access D[a1 , a2 ] for a2 − a1 < κ, assuming rank queries can be
computed efficiently on S. Assuming the set S restricted to [X, X + V ) (with m elements in this range)
is generated from a string D = (Kh , M, Kt ), request(X, V, m, range(Kh ), |M |, range(Kt ), a1 , a2 , b)
recovers D[a1 , a2 ], where b indicates if we take the complement of S.
41

accessing algorithm request(X, V, m, range(Kh ), |M |, range(Kt ), a1 , a2 , b):
1. if 2m > V
2.
m := V − m and b := ¬b
3. if m ≤ 24κ
4.
Z := decSet(x, V, m, b)
5.
rewrite Z as a string D = (Kh , M, Kt )
6.
return D[a1 , a2 ]
7. if lg(range(Kh )) + |M | + lg(range(Kt )) ≤ 24κ
8.
return request(X, 48κ, 24κ, range(Kh ), |M |, range(Kt ), a1 , a2 , b)

(to be cont’d)

If S has small size, we recover the whole data structure using decSet. If D is too short, we reduce m and
V.
9.
10.
11.
12.

V1 := ⌊V /2⌋, V2 := ⌈V /2⌉
ask rank queries and compute j := rankS (X + V1 − 1) − rankS (X − 1)
if b, then j := V1 − j
find the size of Dj = (Kj,h , Mj , Kj,t ) in the lookup table

We compute j, the integer extracted from D, which encodes the number of elements in the first half. We
recover the size of Dj , and use the fact that (Mj , Kj,t ) is a suffix of D (by Proposition 15) to recurse.
13. if a1 ≥ |M | − |Mj |
14.
return reqFromTwo(X, V1 , V2 , j, m − j, range(Kj,h ), |Mj |, range(Kj,t ), a1 − (|M | − |Mj |), a2 −
(|M | − |Mj |), b)
15. else
16.
recover Dj [−1, a2 − (|M | − |Mj |)] :=
reqFromTwo(X, V1 , V2 , j, m − j, range(Kj,h ), |Mj |, range(Kj,t ), −1, a2 − (|M | − |Mj |), b)
17.
compute D[a1 , a2 ] using Proposition 15

reqFromTwo recovers the requested substring of D assuming rank queries to the set generated from prepIntoTwo.
Since (Mj , Kj,t ) is a suffix of D, if D[a1 , a2 ] is entirely contained in this range, we simply recursive on Dj .
Otherwise, Proposition 15 guarantees that the remaining bits can be recovered from j and Kj,h . Note that
in either case, the difference a2 − a1 does not increase.
Next, we describe reqFromTwo.
accessing algorithm reqFromTwo(X, V1 , V2 , m1 , m2 , range(Kj,h ), |Mj |, range(Kj,t ), a1 , a2 , b):
1. compute the sizes of D1 = (K1,h , M1 , K1,t ) and D2 = (K2,h , M2 , K2,t ), which D is divided into
(to be cont’d)

Suppose S restricted to [X, X + V1 ) and [X + V1 , X + V1 + V2 ) is generated from D using prepIntoTwo.
Then by Proposition 14, (K1,h , M1 ) is a prefix of D and (M2 , K2,t ) is a suffix.
2. if a1 ≥ |M | − |M2 |
3.
return request(X +V1 , V2 , m2 , range(K2,h ), |M2 |, range(K2,t ), a1 −(|M |−|M2 |), a2 −(|M |−
|M2 |), b)
4. if a2 < |M1 |
5.
return request(X, V1 , m1 , range(K1,h ), |M1 |, range(K1,t ), a1 , a2 , b)
(to be cont’d)

If the requested bits D[a1 , a2 ] are entirely contained in D1 or D2 , we simply recurse on the corresponding
substring. In this case, the difference a2 − a1 does not change either.
6. recover D1 [a1 , |M1 |] := request(X, V1 , m1 , range(K1,h ), |M1 |, range(K1,t ), a1 , |M1 |, b)
7. recover D2 [−1, a2 − (|M | − |M2 |)] :=
request(X + V1 , V2 , m2 , range(K2,h ), |M2 |, range(K2,t ), −1, a2 − (|M | − |M2 |), b)
8. reconstruct D[a1 , a2 ] using Proposition 14

Finally, if the requested bits D[a1 , a2 ] split across both substrings, then we make two recursive calls.
42

Query time. Next, we analyze the query time. First observe that request has at most O(lg m) levels of
recursion before we call decSet. This is because each time m is reduced at least by a factor of 1/3 by the
preprocessing algorithm. The only place that the whole recursion makes more than one recursive calls is
line 6 and line 7 in reqFromTwo. In all other cases, the algorithm makes at most one recursive call with the
same (or smaller) difference a2 − a1 . Moreover, we claim that those two lines can only be executed at most
once throughout the whole recursion.
Claim 32. Line 6 and line 7 in reqFromTwo can at most be executed once throughout the whole recursion.
Proof. When these two lines are executed, the two recursive calls will both request either a prefix or a suffix
of the substring. Also, as we observed above, the difference a2 −a1 never increases throughout the recursion.
The recursive call that requests a prefix will have a1 = −1 and a2 < κ − 1. Thereafter, any subsequence
recursive calls in this branch will have a1 = −1 and a2 < κ − 1. Since Proposition 14 always generates two
strings of length at least 3κ, line 4 in reqFromTwo is always true (as |M1 | ≥ κ − 1). Line 6 and line 7 will
hence not be executed in this branch. The recursive branch that requests a suffix is similar, in which line 2
in reqFromTwo is alway true. This proves the claim.
Claim 32 implies that the whole recursion tree has at most O(lg m) nodes, and at most two leaves. In
each node, the algorithm spends constant time, and makes two rank queries.
In each leaf, the algorithm

V
makes one call to decSet. As we argued earlier, the integer Z ≤ lg m
has at most O(κ2 ) bits (and O(κ)
words). Since m ≤ O(κ) when decSet is called, by Claim 31, each decSet takes O(κ4 ) time (O(κ)-word
numbers take O(κ2 ) time to multiply or divide), and makes O(κ2 ) rank queries. Combining the above
facts, we conclude that request runs in O(κ4 ) time, and it makes at most O(κ2 ) rank queries. This proves
Lemma 29.

7.2 Small sets
In this section, we prove Lemma 28, which constructs a succinct rank data structure for sets of size κO(1) ,
with constant query time. We first show that the fusion trees [FW93] can be implemented succinctly. This
gives us a data structure for small sets with a sublinear, although large, redundancy.
Lemma 33. Let c be any constant positive integer and ǫ be any positive constant. There is a preprocessing
algorithm prepRankL, a query algorithm qAlgRankL and lookup tables tableRankLV,m of sizes 2ǫκ such
that for any integers V, m such that V ≤ 2κ and m ≤ κc , given a set S ⊂ [V ] of size m, prepRankL
preprocesses it into a data structure using
 
V
1
lg
+ m lg κ
8
m
bits of space. Given any x ∈ [V ], qAlgRankL compute rankS (x) in constant time, by accessing the data
structure and tableRankLV,m . The algorithms run on a random access machine with word-size w ≥ Ω(κ).
Since the main ideas are similar, we may omit the proof of a few claims in the construction, and refer
the readers to the original fusion trees for details ([FW93]).
Proof. (sketch) Let S = {y1 , . . . , ym } and y1 < y2 < · · · < ym . Let us first show how to construct such a
data structure using
m⌈lg V ⌉ + m⌈lg κ⌉
43

bits when m ≤ κ1/4 . We view each yi as a ⌈lg V ⌉-bit binary string, and consider the first bit where yi and
yi+1 differ, for every i = 1, . . . , m − 1. Let W be this set of bits, i.e., j ∈ W if and only there exists
some i such that j-th bit is the first bit where yi and yi+1 differ. Then |W | ≤ m − 1. Similar to fusion
trees, let sketch(y) be y restricted to W . Observe that we must have sketch(y1 ) < sketch(y2 ) < · · · <
sketch(ym ).
The data structure first stores W using m⌈lg κ⌉ bits. Then it stores sketch(y1 ), . . . , sketch(ym ).
Finally, the data structure stores the remaining bits of each yi , for i = 1, . . . , m and from the top bits to the
low bits. It is clear that the data structure occupies m⌈lg V ⌉ + m⌈lg κ⌉ bits of space.
To answer a query x ∈ [V ], qAlgRankLV,m first breaks x into sketch(x) and the remaining bits. That
is, it generates two strings: x restricted to W (a |W |-bit string), and the remaining bits (a (⌈lg V ⌉ − |W |)-bit
string). It can be done in constant time using a lookup table of size 2O(ǫκ) , e.g., we divide the bits of x into
chunks of length ǫκ, and store in tableRankLV,m for each chunk, every possible set W and every possible
assignment to the bits of x in the chunk, their contribution to sketch(x) and the remaining bits (note that
there are only 2o(κ) different sets W ). Summing over all chunks gives us sketch(x) and the remaining bits.
The query algorithm then finds the unique i such that sketch(yi ) ≤ sketch(x) < sketch(yi+1 ). This can
1/2
be done by storing a lookup table of size at most 2(m+1)|W | ≤ 2κ , since (sketch(y1 ), . . . , sketch(ym ))
has only m|W | bits, and sketch(x) has |W | bits. However, we might not necessarily have yi ≤ x < yi+1 ,
but similar to the arguments in fusion trees, x has the longest common prefix (LCP) with either yi or yi+1
(among all y ∈ S). qAlgRankLV,m next computes the LCP between x and yi and the LCP between x and
yi+1 . Both can be done in constant time, since to compute the LCP between x and yi , it suffices to compute
the LCP between sketch(x) and sketch(yi ) and the LCP between their remaining bits. Suppose x and
yi∗ have a longer LCP (i∗ = i or i + 1). If x = yi∗ , then rankS (x) = i∗ . Otherwise, let their common
prefix be x′ . If x > yi∗ , then let j be the unique index such that sketch(yj ) ≤ sketch(x′ 111 · · · 11) <
sketch(yj+1 ). The argument from fusion trees shows that we must have yj < x < yj+1 , i.e., rankS (x) =
j. Likewise, if x < yi∗ , then let j be the unique index such that sketch(yj ) < sketch(x′ 000 · · · 00) ≤
sketch(yj+1 ). We must have yj < x < yj+1 . By computing the value of j using the lookup table again,
we find the number of elements in S that is at most x. Note that this data structure also allows us to retrieve
each yi in constant time.
Next, we show that the above data structure generalizes to any m ≤ κc , and uses space
 
V
m(lg V + (c + 3) lg κ) ≤ lg
+ (2c + 3)m lg κ.
m
When m > κ1/4 , let B = ⌊κ1/4 ⌋, we take B evenly spaced elements from S, i.e., y⌈im/B⌉ for i = 1, . . . , B.
′ }, where y ′ = y
Denote the set of these B elements by S ′ = {y1′ , . . . , yB
⌈im/B⌉ . We apply the above data
i
′
structure to S , using space
B⌈lg V ⌉ + B⌈lg κ⌉ < B(lg V + lg κ + 2).
Then, we recurse on all B subsets between elements in S ′ , where the i-th subset has ⌈im/B⌉ − ⌈(i −
1)m/B⌉ − 1 elements. Then the final data structure stores
• the data structure for S ′ ;
• B data structures for all subsets between elements in S ′ ;
• an array of B pointers, pointing to the starting locations of the above B data structures.
44

We assign (c + 3/2) lg κ bits to each pointer.
Suppose for each subset, we are able to (recursively) construct a data structure using
(⌈im/B⌉ − ⌈(i − 1)m/B⌉ − 1)(lg V + (c + 3) lg κ)
bits of space. The total space usage is
B(lg V + lg κ + 2) + (m − B)(lg V + (c + 3) lg κ) + B(c + 3/2) lg κ ≤ m(lg V + (c + 3) lg κ).
On the other hand, assigning (c + 3/2) lg κ bits to each pointer is sufficient, because
lg (m(lg V + (c + 3) lg κ)) ≤ lg (mκ + (c + 3)m lg κ) ≤ (c + 1) lg κ + 1.
′ . Then
To answer query x, we first query the data structure for S ′ , and find the i such that yi′ ≤ x < yi+1
we recurse into the i-th subset. The query time is constant, because the size of the set reduces by a factor of
B = Θ(κ1/4 ) each time. Note that for any given i, this data structure can also return yi in constant time.

Finally, we show that the redundancy (2c+ 3)m lg κ can be reduced to 81 m lg κ. To this end, let S ′ be the
m
⌋.
subset of S with gap 16(2c + 3), i.e., S ′ = {y1′ , y2′ , . . .} such that yi′ = y16(2c+3)·i . Then |S ′ | = ⌊ 16(2c+3)
′
We construct a data structure for S using space
|S ′ |(lg V + (c + 3) lg κ).
Naturally, S ′ partitions S into chunks of 16(2c + 3) − 1 elements. We simply write them down using
′
(16(2c + 3) − 1)⌈lg(yi+1
− yi′ − 1)⌉

bits for chunk i. The final data structure consists of
1. the data structure for S ′ ,
2. all other elements in S encoded as above,
3. |S ′ | + 1 pointers to each chunk.
We assign ⌈(c + 3/2) lg κ⌉ bits to each pointer. By the concavity of lg x, the total space usage is
X
′
|S ′ |(lg V + (c + 3) lg κ) +
− yi′ − 1)⌉ + (|S ′ | + 1)⌈(c + 3/2) lg κ⌉
(16(2c + 3) − 1)⌈lg(yi+1
i

X
V
V
≤ |S ′ | lg
+ |S ′ |(3c + 5) lg κ +
(16(2c + 3) − 1) lg ′
+m
m
|S | + 1
i
X
V
(3c + 5)m
V
≤ |S ′ | lg
+
lg κ +
(16(2c + 3) − 1) lg
+ O(m)
m 16(2c + 3)
m
i

V
(3c + 5)m
≤ m lg
+
lg κ + O(m)
m 16(2c + 3)
 
V
m
≤ lg
+ lg κ.
m
8

′ . Then we
To answer query x, we first query the data structure for S ′ , and find i such that yi′ ≤ x < yi+1
′
′
go over the 16(2c + 3) elements between yi and yi+1 , and compare each of them with x.

45

1

1

0

0

len=3
1

0
0
0

1
0

1
1

1 0

(a)

len=3

0

1
1

0 1

0

1
0

1
len=2

0

len=1

(b)

0

1

1 0

(c)

0

1

1
x

1

0 1

1

1
x

len=2

(d)

Figure 1: (b) is the topological structure of (a), by getting rid of the information that for each single child,
whether it is a left or a right child. The thick edges are shared. Query x branches off the tree from the dotted
edge.
Next, we show that if the sets are very small (m ≤ O(κ/ lg κ)), then there is a data structure with
constant query time and negligible extra bits.
Lemma 34. Let c ≥ 2, ǫ be two positive constants. There is a preprocessing algorithm prepRankS, a
query algorithm qAlgRankS and lookup tables tableRankSV,m of sizes O(2ǫκ ), such that for any integers
V ≤ 2κ and m ≤ c · κ/ lg
that given a set S ⊂ [V ] of size m, prepRankS preprocesses S into a
 κ, such
V
data structure using lg m
+ 2−κ/2 bits of space. Given any x ∈ [V ], qAlgRankS computes rankS (x) in
constant time by accessing the data structure and tableRankSV,m .
Proof. Consider the binary trie over {0, . . . , V }.4 Every element in {0, . . . , V } corresponds to a root-toleaf path. Consider all paths corresponding to an element in S ∪ {V } (V is included for technical reasons).
Their union forms a subtree T (S) of the binary trie with m + 1 leaves. In the following, we construct a
data structure assuming the topological structure of T (S) is known, then apply Proposition 10 to fuse the
topological structure into the data structure.
Roughly speaking, the topological structure of a subtree T is the tree T without specifying for each node
with only one child, whether it is a left or a right child (see Figure 1a). Formally, it is defined by partitioning
the set of such subtrees into equivalence classes, modulo the flip operation. Let v be a node in T with only
a left [resp. right] child, let flip(v, T ) be T relocating v’s entire left [resp. right] subtree to its right [resp.
left] child. We say two trees T ∼ T ′ if there is a (finite) sequence of flip operations that modifies T to
T ′ . It is easy to verify that ∼ is an equivalence relation, hence it partitions the set of all T into equivalence
classes.
We call an edge in T (S) a shared edge if it has more than one leaf in its subtree. Equivalently, a shared
edge is shared between at least two root-to-leaf paths. Note that if an edge is shared, then all edges on
the path from root to it are shared. It turns out that the number of shared edges in T (S) is an important
parameter, which is also invariant under flip. Thus, for each equivalence class T , all T ∈ T have the same
number of shared edges (see Figure 1b).
Intuitively, for a typical set S, the corresponding T ∋ T (S) should have most of its degree-two nodes
close to the root, i.e, it should have very few shared edges. Indeed, if we sample a uniformly random S, the
4

We write every integer in the set as a ⌈lg(V + 1)⌉-bit string, then construct a trie over these V + 1 binary strings. Note that S
is a subset of {0, . . . , V − 1}, while the trie has V + 1 leaves.

46

number of shared edges is at most O(κ) with probability at least 1 − 2−Ω(κ) . As we will see below, on the
inputs with few shared edges, it is relatively easy to construct data structures and answer queries. However,
for the rare inputs with more than Ω(κ) shared edges, we can afford to use a different construction with a
larger redundancy. Since they are sufficiently rare, the overall redundancy turns out to be small.
Few shared edges. Let us fix an equivalence class T , assume T is known and consider all inputs S such
that T (S) ∈ T . Furthermore, assume the trees in T have at most (2c + 1)κ shared edges. For each such
T , we construct a lookup table tableRankSV,m,T , and preprocess S into a data structure using about lg |T |
bits such that if the query algorithm is given access to this particular lookup table (specific for T ), it answers
rank queries in constant time.
Since the tree T (S) uniquely determines S, to construct the data structure for S, it suffices to encode
for each edge in T (S) that connects a single child and its parent, whether the child is left or right. The
preprocessing algorithm constructs T (S), then goes through all such edges in a fixed order, and uses one bit
to indicate whether the corresponding edge in T (S) connects to a left child or a right child. To facilitate the
queries (which we will describe in the next paragraph), all shared edges are encoded first in the depth-firstsearch order, followed by all other edges encoded in the depth-first-search order. This ensures that
1. if a shared edge e1 is on the path from root to shared edge e2 , then e1 is encoded before e2 ;
2. for each yi , its non-shared edges (which is a suffix in the root-to-leaf path) are consecutive in the data
structure.
Note that this encoding is a one-to-one mapping: Every S such that T (S) ∈ T is encoded to a different
string; Every string has a corresponding S with T (S) ∈ T encoded to it. Thus, the algorithm constructs a
data structure using exactly
lg |{S : T (S) ∈ T }|
bits of space.
Let S = {y1 , . . . , ym } such that y1 < y2 < · · · < ym , and let y0 = −1 and ym = V . Given a query
x ∈ {0, . . . , V − 1}, the goal is to compute i such that yi ≤ x < yi+1 . Let us consider the process of
walking down the tree T (S) following the bits in x. That is, we write x also as a ⌈lg(V + 1)⌉-bit string, and
walk down the tree from the root: if the current bit in x is 0, we follow the left child, otherwise we follow
the right child. The process stops when either the current node in T (S) does not have a left (or right) child
to follow, or we have reached a leaf. The location where it stops determines the answer to the query, in the
same way for all T ∈ T . See Figure 1c and 1d for a concrete example. Note that in the example, x branches
off the tree from left, which may not be possible at the same location for all T ∈ T , as some T may have
a left child there. But given that x branches off the tree at this location from left, all T (S) ∈ T must have
the same answer to rankS (x). Thus, we store in tableRankSV,m,T , for all nodes v in the tree, ansv,0 and
ansv,1 , the answer to the query when the process branches off the tree from v due to the lack of its left child
(i.e., from left), and the answer when it branches off from v due to the lack of its right child (i.e., from right)
respectively. It takes O(κ2 ) words, since m ≤ κ.
Now the task is reduced to efficiently simulating this walk. To this end, the query algorithm needs to
compare the bits in x with the corresponding bits of T (S), which are stored in the data structure. It turns out
that the difficult part is to compare x with the shared edges, which are stored in the first (at most) (2c + 1)κ
bits. The first step is to simulate the walk, and check if x branches off T (S) at a shared edge. We create
lookup tables of size 2ǫκ to compare ǫκ bits at once. For now, let us focus on the first ǫκ bits x≤ǫκ . These
bits determine for all the degree-two nodes in the first ǫκ levels, which child x follows (note we have fixed
T ). Thus, it determines for all other bits, which bits in the data structure they should compare with. In the
lookup table, we store for each of the 2ǫκ possible values,
47

• a (2c + 1)κ-bit string, which permutes x≤ǫκ to the same location as the bits they are comparing with;
• a (2c + 1)κ-bit string, indicating for each shared edge in the data structure, whether they are being
compared.
With these two strings, the query algorithm is able to compare x≤ǫκ with the first ǫκ levels of T (S). If
they do not match, we could find the first edge where they differ (since edges are encoded in the DFS order),
which is the location where x branches off T (S). If they all equal, we proceed and compare the next ǫκ bits.
Note that we may start the next chunk of the walk from different nodes depending on the value of x≤ǫκ , and
we will need a different lookup for each starting location. However, T can have at most m nodes in each
level, thus, only m tables are needed for each chunk. We repeat the above process until we find a different
bit, or we find out that x matches all shared edges from the root. In the former case, as we argued above, the
answer to the query can be found in the lookup table. In the latter case, by the definition of shared edges,
we identified one yi which is the only element in S that matches the prefix of x. Thus, it suffices to retrieve
the remaining bits of yi , which are stored consecutively in the data structure and take constant retrieval time,
and compare yi with x. If yi ≤ x, then the query algorithm returns i, otherwise, it returns i − 1. The query
time is constant.
So far for every T with at most (2c + 1)κ shared edges, we have designed a data structure that works
for all inputs S such that S ∈ T using space lg |{S : T (S) ∈ T }| bits, constant query time and lookup
table of size 2ǫκ . Next, we fuse T into the data structure and merge all lookup tables, obtaining a single data
structure that works for all S such that T (S) has at most (2c + 1)κ shared edge, which uses lookup table
tableRankSV,m,few . To this end, we fix an arbitrary ordering of all such equivalence classes T : T1 , . . . , TC ,
where C is the number of equivalence
Let si = lg |{S : T (S) ∈ Ti }| be the size of the data structure
 classes.
m lg(κ/m)+O(m) . This is because there are at most 22m rooted binary
≤
2
for Ti . Then, C ≤ 22m · (2c+1)κ+1
m−1
trees with m + 1 nodes (corresponding to the degree-two nodes). Each such tree can be extended to a class
T by specifying the distance from each child to its parent (adding the degree-one nodes). However, there
are only (2c + 1)κ shared edges, thus, the sum of distances ofall internal edges
is at most (2c + 1)κ, and
(2c+1)κ+1
≤(2c+1)κ
5
choices. Once the distances
≤
there are m − 1 internal edges. Hence, it is at most
m−1
m−2
on all internal edges are determined, the distance on each edge connecting to a leaf is also fixed, because all
leaves are at depth ⌈lg(V + 1)⌉.
Given an input set S such that T (S) has at most (2c + 1)κ shared edges, the preprocessing algorithm
computes T (S) and finds the index i such that Ti ∋ T (S). Then it runs the preprocessing algorithm for
class Ti on S, and computes a data structure Di of at most si bits. Next, we use Proposition 10 to store the
pair (i, Di ), using space at most
!
C
C
X
X
|{S : T (S) ∈ Ti }| + 2m lg(κ/m)+O(m)−κ+2
2si + C · 2−κ+2 ≤ lg
lg
i=1

i=1

 
V
< lg
+ 2m lg(κ/m)+O(m)−κ+2
m
 
3
V
< lg
+ 2− 4 κ .
m

The lookup table tableRankSV,m,few is simply the concatenation of all tables tableRankSV,m,Ti for
i = 1, . . . , C, as well as the O(C)-sized table from Proposition 10. Thus, the total size is at most 2ǫκ · C +
O(C) = 2(ǫ+o(1))κ .
5

An edge is internal if it does not connect to a leaf.

48

To answer a query x, Proposition 10 allows us to decode i and Di in constant time by storing a lookup
table of size O(C). Then, we find the corresponding lookup table tableRankSV,m,Ti and run the query
algorithm for Ti on query x and data structure Di . The query time is constant.
Many shared edges. Next, we construct a data structure that works for all S such that T (S) has more than
(2c + 1)κ shared edges, using
 
V
lg
−κ
m

V
bits of space. Note that this is possible, because there are very few such sets S (a tiny fraction of all m
sets). We find the largest k such that T (S≤k ) has at most (2c+1)κ shared edges, where S≤k = {y1 , . . . , yk }.
Note that every element can introduce no more than κ shared edges, thus, T (S≤k ) has at least 2cκ shared
edges. The data structure stores the (index of) equivalence class T ∋ T (S≤k ), then we run the preprocessing
algorithm on S≤k . This encodes the first k elements of S. For the next m − k elements, we simply apply
Lemma 33.
More specifically, for k elements, there are at most 2k lg(κ/k)+O(k) equivalence classes, as we showed
earlier. We construct the data structure as follows:
1. write down the index k using ⌈lg m⌉ bits;
2. write down the index i such that Ti ∋ T (S≤k ) using ⌈k lg(κ/k) + O(k)⌉ bits;
3. run the preprocessing algorithm on S≤k and obtain a data structure of size
lg |{S≤k : T (S≤k ) ∈ Ti }|;
4. run prepRankL on {yk+1 , . . . , ym } and obtain a data structure of size


V
1
lg
+ (m − k) lg κ.
8
m−k
Observe that Step 3 uses at most
k⌈lg V ⌉ − 2cκ
bits, because for any such Ti ,
• by construction, each bit of the data structure stores an input bit, i.e., one of the bits representing
{y1 , . . . , yk };
• each of the ≥ 2cκ shared edges corresponds to at least two input bits (since given T , these two input
bits are always the same);
• each input bit is stored only once.
Therefore, the preprocessing algorithm outputs a data structure using
 


V
1
lg m + k lg(κ/k) + O(k) + (k lg V − 2cκ) + lg
+ (m − k) lg κ + k + 2
m−k
8
1
≤ lg m + k lg(κ/k) + (k lg V − 2cκ) + (m − k) lg V + m lg κ + O(k)
8
1
≤ m lg V − 2cκ + lg m + k lg(κ/k) + m lg κ + O(k)
8
49

 
V
1
+ m lg m − 2cκ + lg m + m lg(κ/m) + m lg κ + O(m)
8
m
 
V
9
≤ lg
− 2cκ + m lg κ + O(m).
m
8

≤ lg

By the fact that m ≤ cκ/ lg κ and c ≥ 2, it is at most
 
V
lg
− κ.
m
The lookup table includes tableRankSV,k,few for all k ≤ m, and has 2(ǫ+o(1))κ size.
To answer query x, the query algorithm reads k and i. Then it runs the query algorithm for Ti for query
x on the data structure for S≤k , as well as qAlgRankL for x on the data structure for {yk+1 , . . . , ym }. Both
algorithms run in constant time. The answer to the query is simply the sum of the two answers.
Combining the two cases. Finally, we combine the two cases using Proposition 10, and construct a data
structure that works for all sets S. Given set S, prepRankS computes T (S) and the number of shared edges.
If it has no more than (2c + 1)κ shared edges, it sets b := 1, runs the preprocessing algorithm for “many
shared edges” and obtains a data structure D1 . Otherwise, it sets b := 2, runs the preprocessing algorithm
for “few shared edges” and obtains a data structure D2 . At last, it applies Proposition 10 to store the pair
(b, Db ). The space usage is
 

 
−3κ
V
V
· 2−κ + 2−κ+2
lg
· 22 4 +
m
m
 
−3κ
3
V
≤ lg
+ 2− 4 κ + lg(1 + 2−κ−2 4 ) + 2−κ+2
m
 
1
V
≤ lg
+ 2− 2 κ .
m
To answer query x, we simply decode b and Db using Proposition 10, and use the corresponding query
algorithm based on b.
The lookup table tableRankSV,m also includes all tableRankSV,k for k ≤ m, which has size 2O(ǫκ) .
This proves the lemma.
Finally, we prove Lemma 28, which constructs a rank data structure for m ≤ κc .
Lemma 28 (restated). Let c be any constant positive integer and ǫ be any positive constant. There is a
preprocessing algorithm prepRank, query algorithm qAlgRank and lookup tables tableRankV,m of sizes
Õ(2ǫκ ), such that for any integers V ≤ 2κ/2 , m ≤ κc , given a set S ⊂ [V ] of size m, prepRank(V, m, S)
outputs a data structure D of length
 
V
lg
+ (m − 1) · 2−κ/2 .
m
Given x ∈ [V ], qAlgRank(V, m, x) computes rankS (x) in constant time, by accessing D and tableRankV,m .
In particular, by computing both rankS (x) and rankS (x − 1), one can decide if x ∈ S in constant time.
The algorithms run on a random access machine with word-size w = Θ(κ).
50

Proof. The data structure construction is based on recursion. As the base case, if m ≤ 16κ/ lg κ, we simply
use the data structure from Lemma 34, and the statement holds. Otherwise for m > 16κ/ lg κ, we divide
V into B blocks of equal size, for B = ⌈κ1/2 ⌉. For a typical set S, we would expect each block to contain
roughly m/B elements. If it indeed happens, the size of S would be reduced by a factor of B. Hence,
we will reach the base case in constant rounds. On the other hand, input sets S which have at least one
block with significantly more than m/B elements are very rare. If such blocks occur, we are going to apply
Lemma 33 on them. Although Lemma 33 introduces a large redundancy, such cases occur sufficiently rarely,
so that the overall redundancy is still small.
We partition the input set S into B subsets S1 , . . . , SB such that Si contains all elements of S between
⌈(i − 1)V /B⌉ and ⌈iV /B⌉ − 1. Let Vi := ⌈iV /B⌉ − ⌈(i − 1)V /B⌉ be the size of the i-th block. By
definition, |S1 | + · · · + |SB | = m and V1 + · · · + VB = V . We construct a data structure for each Si ,
over a universe of size Vi . Then we apply Proposition 8 to concatenate the B data structures given the sizes
of S1 , . . . , SB . Finally, we apply Proposition 10 to union all combinations of sizes. We present the details
below.
Preprocessing algorithm. Given a set S of size m, if 2m ≥ V , we take the complement. Note that the
space bound stated in the lemma becomes smaller after taking the complement. It is also easy to derive the
answer from the data structure for the complement. Then if m = 1, we simply write down the element; if
m ≤ 16κ/ lg κ, we apply Lemma 34.
preprocessing algorithm prepRank(V, m, S):
1. if V ≤ 2m
2.
m := V − m and S := [V ] \ S
3. if m = 1
4.
return the only element in S
5. if m ≤ 16κ/ lg κ
6.
return D := prepRankS(V, m, S) using Lemma 34

(to be cont’d)

If m > 16κ/ lg κ, we divide [V ] into κ1/4 chunks, and construct a data structure for each chunk.
7.
8.
9.
10.
11.
12.
13.
14.

B := ⌊κ1/4 ⌋
compute Si := S ∩ [(i − 1)V /B, iV /B) and mi := |Si |
let Vi := ⌈iV /B⌉ − ⌈(i − 1)V /B⌉
for i = 1, . . . , B
if mi > max{m · κ−1/4 , 16κ/ lg κ}
compute Di := prepRankL(Vi , mi , Si ) using Lemma 33
else
compute Di := prepRank(Vi , mi , Si ) recursively

If the chunk has too many elements, we apply Lemma 33 to construct a data structure with larger redundancy.
Otherwise, the size of the set at least decreases by a factor of κ1/4 , and we recurse.
Next, we concatenate the data structures for all chunks, and fuse the tuple (m1 , . . . , mB ) into the data
structure.
15. apply Proposition 8 to concatenate D1 , . . . , DB , and obtain Dcat
16. let C := m+B−1
be the number of different tuples (m1 , . . . , mB ) such that mi ≥ 0 and m1 + · · · +
B−1
mB = m
17. let 1 ≤ j ≤ C be the index such that the current (m1 , . . . , mB ) is the j-th in the lexicographic order
18. apply Proposition 10 to fuse j into Dcat , and obtain D
19. return D

51

Space analysis. In the following, we analyze the size of the data structure. We will prove by induction
that prepRank(V, m, S) outputs a data structure of size at most
 
V
lg
+ (m − 1)2−κ/2 .
m
The base case
when m ≤ 16κ/ lg κ is a direct implication of Lemma 34 (or if m = 1, the space usage if
V
lg V = lg 1 ). Now, let us consider larger m.
To prove the inductive step, let us fix a B-tuple (m1 , . . . , mB ), and consider the size of Dcat from line 15.
By Proposition 8, when all mi ≤ max{m · κ−1/4 , 16κ/ lg κ}, its size is at most
s(m1 , . . . , mB ) := lg


B 
Y
Vi
mi

i=1

+ (m − B) · 2−κ/2 + (B − 1)2−κ+4 ;

otherwise, its size is at most

B 
Y
Vi

s(m1 , . . . , mB ) := lg

i=1

mi

X

+

i:mi >max{m·κ−1/4 ,16κ/ lg κ}

1
mi lg κ + B.
8

V
m .

It turns out that in the latter case, (7) is significantly smaller than lg

Claim 35. If there is at least one mi > max{m · κ−1/4 , 16κ/ lg κ}, then (7) is at most lg

V
m

(7)



− κ.

We defer its proof to the end. Assuming the claim, by Proposition 10, the size of D from line 18 is at
most



lg 


X

m1 ,...,mB :
P
i mi =m


−κ+2
.
2s(m1 ,...,mB ) 
+C ·2

(8)

To bound the sum in the logarithm, we first take the sum only over all tuples such that mi ≤ max{m ·
κ−1/4 , 16κ/ lg κ}, the sum is at most
X

s(m1 ,...,mB )

2

≤


B 
XY
Vi

−κ/2 +(B−1)2−κ+4

· 2(m−B)·2

mi
i=1
 
V
−κ/2 +(B−1)2−κ+4
≤
,
· 2(m−B)·2
m

where the second inequality uses the fact that

P

m1 ,...,mB :

P

mi =m

QB

Vi
i=1 mi



≤

this sum over a subset of all such B-tuples. By Claim 35, s(m1 , . . . , mB ) ≤ lg
Thus, the sum in the logarithm is at most
 
 
V
V
(m−B)·2−κ/2 +(B−1)2−κ+2
+
·2
· C · 2−κ .
m
m

PB

i=1

m

V
m

Vi



, and we are taking

− κ for all other tuples.

Finally, since C ≤ mB and m ≤ κc , (8) is at most
 
 

V
V
(m−B)·2−κ/2 +(B−1)2−κ+4
B
−κ
(8) ≤ lg
·2
+
·m ·2
+ mB · 2−κ+2
m
m
52

 
V
+ (m − B)2−κ/2 + (B − 1)2−κ+4 + lg(1 + 2−κ+B lg m ) + 2−κ+B lg m+2
m
 
V
1/4
≤ lg
+ (m − B)2−κ/2 + (B − 1)2−κ+4 + 2−κ+cκ lg κ+3
m
 
V
≤ lg
+ (m − 1)2−κ/2 .
m
≤ lg

By induction, it proves the data structure uses space as claimed.
Lookup table.

We store the following information in the lookup table.

lookup table tableRankV,m :
1. if m ≤ 16κ/ lg κ, include tableRankSV,m from Lemma 34
2. the value of C = m+B−1
B−1
3. for all 1 ≤ j ≤ C
4.
the j-th B-tuple (m1 , . . . , mB ) in the lexicographic order
5.
for i = 1, . . . , B
6.
m1 + · · · + mi
7. lookup table for Proposition 8 in line 15, for all possible B-tuples (m1 , . . . , mB )
8. lookup table for Proposition 10 in line 18
9. include all tables tableRankV ′ ,m′ and tableRankL V ′ ,m′ for V ′ = ⌊V /B i ⌋ or ⌈V /B i ⌉ for i ≥ 1,
and m′ ≤ m


Since C = m+B−1
≤ 2o(κ) , line 2 to 8 all have size 2o(κ) . Finally, we are only including κO(1) other
B−1
tables in line 1 and 6, each taking at most Õ(2ǫκ ) bits by Lemma 33 and 34. The total size of tableRankV,m
is Õ(2ǫκ ).
Query algorithm. Given a query x, if V ≤ 2m, we retreat the data structures as storing the complement
of S, and use the fact that rankS (x) = x + 1 − rank[V ]\S (x). Then if m = 1, we simply compare it with
x. If m ≤ 16κ/ lg κ, we invoke the query algorithm from Lemma 34.
query algorithm qAlgRank(V, m, x):
1. if V ≤ 2m
2.
m := V − m
3.
in the following, when about to return answer r, return x + 1 − r
4. if m = 1
5.
retrieve the element, compare it with x, and return 0 or 1
6. if m ≤ 16κ/ lg κ,
7.
return qAlgRankS(V, m, x) (from Lemma 34)

(to be cont’d)

If m > 16κ/ lg κ, we decode j, which encodes the tuple (m1 , . . . , mB ) and Dcat . Then if x is in the
i-th chunk, we decode mi and the corresponding Di .
8.
9.
10.
11.

apply Proposition 10 to decode j and Dcat
let i be the chunk that contains x
apply Proposition 8 to decode Di
retrieve m1 + · · · + mi−1 and mi for j-th tuple from the lookup table

(to be cont’d)

Then depending on the value of mi , we invoke the query algorithm from Lemma 33 or recurse.

53

12. if mi > max{m · κ−1/4 , 16κ/ lg κ}
13.
return (m1 + · · · + mi−1 ) + Di .qAlgRankL(Vi , mi , x − ⌈(i − 1)V /B⌉) (from Lemma 33)
14. else
15.
return (m1 + · · · + mi−1 ) + Di .qAlgRank(Vi , mi , x − ⌈(i − 1)V /B⌉)

The query algorithm recurses only when mi ≤ m · κ−1/4 . In all other cases, the query is answered in
constant time. On the other hand, m ≤ κc . The level of recursion must be bounded by a constant. Thus, the
data structure has constant query time, proving the lemma.
Next, we prove the remaining claim.
Proof of Claim 35. To prove the claim, let us first compare the first term with lg
 

B 
Y
V
Vi
lg
− lg
m
mi

V
m .

We have

i=1

V ! · m1 ! · · · mB ! · (V1 − m1 )! · · · (VB − mB )!
= lg
,
V1 ! · · · VB ! · m!(V − m)!
which, by Stirling’s formula, is at least
≥

B 
X
i=1

m
V −m
V
− mi lg
− (Vi − mi ) lg
Vi lg
Vi
mi
Vi − mi



− O(B) − lg V,

Vi −mi
i
which by the fact that f (ε) = ε log 1/ε is concave and hence V · f ( VVi ) ≥ m · f ( m
m ) + (V − m) · f ( V −m ),
is at least


X
m
V −m
V
− mi lg
− (Vi − mi ) lg
− O(B) − lg V. (9)
≥
Vi lg
Vi
mi
Vi − mi
−1/4
i:mi >max{m·κ

,16κ/ lg κ}

For each term in this sum, we have


V
Vi − V /B
Vi lg
= Vi lg B − Vi lg 1 +
≥ Vi lg B − O(1),
Vi
V /B
since |Vi − V /B| ≤ 1; and



mi − m/B + (V /B − Vi )
V −m
= (Vi − mi ) lg B + lg 1 +
(Vi − mi ) lg
Vi − mi
Vi − mi
mi − m/B + 1
· lg e
≤ (Vi − mi ) lg B + (Vi − mi ) ·
Vi − m i
≤ (Vi − mi ) lg B + 2mi .
Plugging into (9), we have

 
B 
Y
Vi
V
lg
− lg
mi
m
i=1

54



m
− (Vi − mi ) lg B − 2mi
m
i
i:mi >max{m·κ−1/4 ,16κ/ lg κ}


X
Bmi
=
mi lg
− 2 − O(B) − lg V
m
−1/4
i:mi >max{m·κ
,16κ/ lg κ}


X
1
lg κ − 2 − O(B) − lg V.
≥
mi
4
−1/4
≥

X

i:mi >max{m·κ

Vi lg B − mi lg



− O(B) − lg V

,16κ/ lg κ}

Therefore, we have
 
V
(7) ≤ lg
−
m
+

X

mi

i:mi >max{m·κ−1/4 ,16κ/ lg κ}

X

i:mi >max{m·κ−1/4 ,16κ/ lg κ}




1
lg κ − 2 + O(B) + lg V
4

1
mi lg κ
8

 


X
V
1
≤ lg
−
mi
lg κ − 2 + O(B) + lg V
m
8
−1/4
i:mi >max{m·κ
,16κ/ lg κ}
 
V
≤ lg
− κ.
m
The last inequality is due to the fact that there is at least one mi that is larger than max{m·κ−1/4 , 16κ/ lg κ}
(in particular, mi > 16κ/ lg κ), B = Θ(κ1/2 ) and lg V ≤ κ/2.
rank queries can be viewed as mapping that maps S → [m], and [V ] \ S → [V − m]. Thus, Lemma 25
is an immediate corollary.
Lemma 25 (restated). Let c be any constant positive integer and ǫ be any positive constant. There is a
preprocessing algorithm perfHashS, query algorithm qalgS and lookup tables tableSV,m of sizes Õ(2ǫκ ),
such that for any V ≤ 2κ/2 and m ≤ κc , given a set S ⊂ [V ] of m keys, perfHashS preprocesses S into a
data structure of size at most
OPTV,m + (m − 1) · 2−κ/2+1 ,
such that it defines a bijection h between S and [m] and a bijection h between [V ] \ S and [V − m]. Given
any x ∈ [V ], qalgS answers hash(x) in constant time, by accessing the data structure and tableSV,m .

8 Perfect Hashing for Sets of Any Size
In this section, we generalize the data structure from Section 6 to sets of all sizes, proving our main theorem.
Theorem 36 (main theorem). For any constant ǫ > 0, there is a preprocessing algorithm perfHash, a
query algorithm qAlg and lookup tables tableU,n of size nǫ , such that given
• a set S of n keys over the key space [U ],
• a uniformly random string R of length O(lg12 n),
perfHash preprocesses S into a data structure D of (worst-case) length
OPTU,n + O(lg lg U ),
55

such that D defines a bijection h between S and [n] and a bijection h between [U ] \ S and [U − n]. Given
access to D, R and tableU,n , for any key x ∈ [U ], qAlg(U, n, x) outputs hash(x) on a RAM with word-size
w ≥ Ω(lg U ), in time
• O(1) with probability 1 − O(lg−7 U ) and
• O(lg7 U ) in worst-case,
where the probability is taken over the random R. In particular, the query time is constant in expectation
and with high probability.
Proof. Similar to the proof of Theorem 18, we first assume 2n ≤ U (otherwise, we take the complement of
S). Then if n ≥ U 1/12 , Theorem 18 already gives the desired result. From now on, we assume n < U 1/12 .
We partition [U ] into n12 blocks. A typical set S has all the keys in different blocks. In this case, we
may view the universe size being only n12 , and apply Theorem 18. On the other hand, only roughly 1/n11 fraction of the inputs have at least one pair of keys in the same block, which suggests that we may use at
least 10 lg n extra bits.
No collision in blocks and last block empty. More specifically, given S such that n = |S| < U 1/12 , let
V := ⌈U · n−12 ⌉ be the block size. We partition U into blocks: (U div V ) blocks of size V and one last
block of size (U mod V ). Let us first only consider inputs that have at most one key in every block and
no key in the last block. We apply Theorem 18 on the universe of all blocks. That is, let the universe size
Unew = U div V , number of keys nnew = n. We construct the new set Snew such that i ∈ Snew if and only if
block i contains a key x ∈ S. By Theorem 18, we construct a data structure of size




U div V
Unew
+ 1/Unew = lg
lg
+ 1/(U div V ),
nnew
n
which defines hash functions hnew and hnew . Besides this data structure, we also apply Lemma 16 to store
for each i ∈ Snew , the key x within block i, according to hnew (i). That is, we store x−(i−1)V in coordinate
hnew (i). Hence, this part takes
n lg V + (n − 1)2−κ+5
bits. Then we apply Proposition 8 to concatenate the two data structures. The total space is at most


U div V
lg
+ 1/(U div V ) + n lg V + n · 2−κ+5
n
Qn−1
V n i=0
(U div V − i)
+ O(1/n)
≤ lg
n!
Qn−1
(U − i)
+ O(1/n)
≤ lg i=0
  n!
U
= lg
+ O(1/n).
n
To define the hash functions in this case, for each x ∈ S, which is in block i, we simply let h(x) :=
hnew (i), the hash value of the block. For x ∈
/ S in block i,
∗
• if i ∈ Snew , let x be the key in block i,
– if x < x∗ , we let h(x) := (V − 1) · hnew (i) + (x − (i − 1)V ),
– if x > x∗ , we let h(x) := (V − 1) · hnew (i) + (x − (i − 1)V − 1),
• if i ∈
/ Snew , we let h(x) := (V − 1)n + V · hnew (i) + (x − (i − 1)V ).
56

• if x is in the last block, we let h(x) := (U div V ) · V − n + (x − (U div V ) · V )
That is, we order all non-keys in block i for i ∈ Snew first, in the increase order of (hnew (i), x); then we
order all non-keys not in the last block, in the increasing order of (hnew (i), x); finally we order all non-keys
in the last block.
To answer a query x in block i, we first query if i ∈ Snew . If i ∈
/ Snew , then we know x is not a key,
calculate h(x) by its definition, and return. Otherwise, we query the (hnew (i)+1)-th value in the second data
structure, using Lemma 16, to retrieve the key in block i. If x happens to be this key, we return (1, hnew (i)).
Otherwise, x ∈
/ S, and h(x) can be calculated by its definition. Finally, for queries x in the last block, x is
not a key, and we calculate h(x) according to its definition.
Exist collision in blocks or keys in last block. Next, we consider the case where at least one block
contains more than one key, or the last block contains at least one key. We spend the first 3⌈lg n⌉ bits to
store
• N , the number of blocks with at least two keys (blocks with collisions, or simply collision blocks),
• ncl , the total number of keys in all collision blocks,
• nlast , the number of keys in the last block.
Next, we apply Lemma 26, and construct a membership data structure for N collision blocks using


U div V
lg
+ O(N )
N
bits, which defines a bijection hcl between all collision blocks and [N ], and a bijection hcl between all other
blocks (except for the last block) and [(U div V ) − N ].
The final data structure has three more components:
1. store all keys in N collision blocks using Lemma 26, where each element x in block i is stored as
V · hcl (i) + (x − (i − 1)V ), which uses at most


NV
lg
+ O(ncl + lg lg V )
ncl
bits;
2. store all other (U div V ) − N blocks using the data structure for no collisions, where each element x
in block i is stored as V · hcl (i) + (x − (i − 1)V ), which uses at most


(U div V )V − N V
lg
+1
n − ncl − nlast
bits;
3. store the last block using Lemma 26, which uses


U mod V
lg
+ O(nlast + lg lg V )
nlast
bits.

57

Summing up the sizes of these three data structures, we get




NV
(U div V )V − N V
U mod V
lg
+ O(ncl + nlast + lg lg V ).
ncl
n − ncl − nlast
nlast

By the fact that nk ≤ (en/k)k and ncl ≥ 2N , the first term is at most

NV
(U div V )V − N V
U mod V
+ (n − ncl − nlast ) lg
+ nlast lg
+ n lg e
ncl
n − ncl − nlast
nlast
U
V
+ nlast lg V + n lg e
≤ ncl lg + (n − ncl − nlast ) lg
2
n − ncl − nlast
nV
n
nV
eU
+ ncl lg
+ (n − ncl − nlast ) lg
+ nlast lg
≤ n lg
n
2U
n − ncl − nlast
U
ncl lg

which by the fact that V ≤ 2U · n−12 , is at most


ncl + nlast
eU
−11
+ ncl lg n
+ (n − ncl − nlast) lg 1 +
+ nlast lg(2n−11 )
≤ n lg
n
n − ncl − nlast
eU
≤ n lg
+ ncl lg n−11 + (ncl + nlast ) lg e + nlast lg(2n−11 )
n
eU
− (ncl + nlast)(11 lg n − O(1)).
≤ n lg
n
On the other hand, by Stirling’s formula,
 
U
U!
lg
= lg
n
n!(U − n)!
√
UUU
− O(1)
≥ lg √ n √
nn · U − n(U − n)U −n
U
U
1
≥ n lg + (U − n) lg
− lg n − O(1)
n
U −n 2
which by the fact that ln(1 + x) ≥ x − x2 /2 for x ≥ 0, is at most


U
n
n2
1
≥ n lg + (U − n)
−
lg e − lg n − O(1)
2
n
U − n 2(U − n)
2
2
n lg e
1
eU
−
− lg n − O(1)
= n lg
n
2(U − n) 2
eU
1
≥ n lg
− lg n − O(1).
n
2
Thus, the total size of the data structure when N ≥ 1 is at most


 
U div V
U
1
+ O(N + lg lg U )
lg
+ lg n − (ncl + nlast)(11 lg n − O(1)) + 3 lg n + lg
N
2
n
 
U
1
≤ lg
+ lg n − (ncl + nlast)(11 lg n − O(1)) + 3 lg n + 12N lg n + O(N + lg lg U )
n
2
58

which by the fact that ncl ≥ 2N , is at most
 
U
1
≤ lg
+ lg n − (ncl + nlast)(5 lg n − O(1)) + 3 lg n + O(lg lg U )
2
n
= OPTU,n − lg n + O(lg lg U ).
In this case, the hash functions are defined as follows. For both h and h, we first order all elements in the N collision blocks according to their hash values from component 1, which are mapped to
[ncl ] and [N · V − ncl ] respectively. Then we order all elements in the (U div V ) − N non-collision
blocks according to their hash values from component 2, which are mapped to {ncl , . . . , n − nlast − 1}
and {N · V − ncl , . . . , (U div V ) · V − (n − nlast ) − 1} respectively. Finally, we order all elements in the
last block according to their hash values from component 3, which are mapped to {n − nlast , n − 1} and
{(U div V ) · V − (n − nlast ), U − n − 1} respectively.
To answer a query x in block i, we retrieve N , ncl and nlast , and query if i is a collision block and h(i)
(or h(i)). If i is a collision block, we query component 1; if i is not a collision block, we query component
2; if i is the last block, we query component 3. In any case, the hash value of x can be computed according
to its definition in constant time.
Finally, we apply Proposition 10 to combine the two cases, by fusing a bit indicating whether there is
any collision block. The final data structure has space bounded by


lg 2OPTU,n +O(1/n) + 2OPTU,n −lg n+O(lg lg U ) + 2−κ+2
= OPTU,n + lg(2O(1/n) + (lgO(1) U )/n) + 2−κ+2
≤ OPTU,n + O(lg lg U ).
The query algorithm is straightforward. To answer a query x, we apply Proposition 10 to decode the
data structure, and the bit indicating whether there is any collision block or any element in the last block.
Then we apply the corresponding query algorithm as described above. This proves the theorem.
Remark. When the O(lg lg U ) term is at most 0.5 lg n, the above data structure uses OPT + o(1) bits. To
improve the O(lg lg U ) term when U is large, we partition the universe into lg10 U blocks, and check if
any block has at least two keys. In this case, the fraction of inputs with some block with at least two keys
is only 1/ lg10 U fraction. Therefore, we can afford to “waste” about 10 lg lg U bits, which dominates the
O(lg lg U ) term. This strategy reduces the problem to storing n non-empty blocks among a total of lgO(1) U
blocks, i.e., the universe size is reduced from U to lgO(1) U . Thus, repeatedly applying it improves the
O(lg lg U ) term to O(lg lg · · · lg U ) for logarithm iterated for any constant number of times.

9 Discussions and Open Problems
In this paper, we assumed that the word-size w is at least Ω(lg U + lg σ), i.e., each (key, value) pair fits in
O(1) words. When either the key or the value is larger than Θ(w) bits, it would take super-constant time to
just read the query or write the output on a RAM. The best query time one can hope for is O((lg U +lg σ)/w).
When lg σ ≫ w, the only place being affected is Lemma 16, where we need to retrieve values longer
than one word. Our data structure naturally supports such long answers in optimal time. When lg U ≫ w,
a similar strategy to Section 8 applies. We view the first O(w) bits of an element in [U ] as its “hash value”.
59

If it turns out that all keys have different “hash values”, it suffices to add the remaining bits of the key into
its value. Otherwise, if multiple keys share the same prefix, then we will be able to save O(w) bits for every
extra key with the same prefix.
Our dictionary data structure supports each query in constant expected time. A major open question is
to design deterministic succinct dictionary with similar bounds, or to prove this is impossible. Our approach
crucially relies on sampling a small set of keys to be the “hard queries”. There is always a small portion of the
data stored using the rank data structure of Pǎtraşcu, which takes O(lg n) time to decode. “Derandomizing”
this data structure seems to require a completely different strategy. On the other hand, proving lower bounds
may also be challenging, as the common strategy of “designing a hard distribution and proving average-case
lower bound” is doomed to fail. For any fixed input distribution, we could always fix and hardwire the
random bits in the data structure, thus, our data structure uses only OPT + 1 bits of space.
Our data structure only supports value-retrieval queries on a fixed set of (key, value) pairs, i.e., it solves
the static dictionary problem. The dynamic dictionary problem further requires the data structure to support
(key, value) insertions and deletions. It seems non-trivial to extend our data structure to such updates to
the data, even with good amortized expected time, although our data structure has Õ(n) preprocessing time,
thus using a hash table to store a “buffer” of size n1−ǫ and using the technique of global-rebuilding [Ove83],
one can get Õ(n1−ǫ ) redundancy, nǫ update time and expected constant query time. On the other hand, it is
also possible to update a (key, value) to a new value in our data structure, in O(1) expected time.
Finally, the dependence on U in the extra bits is intriguing. In the RAM model, the dependence is very
slow-growing, but still super constant. We believe it is not necessary, but it is unclear how to remove this
extra small term. On the other hand, note that in the cell-probe model, it can actually be entirely removed
(even for very large U ). This is because when U is large enough so that lg lg U becomes unignorable, we
could simply apply Lemma 25. This strategy does not work on RAM, since it requires a large lookup table,
which can only be hardwired in a cell-probe data structure.

Acknowledgment
The author would like to thank anonymous reviewers for helpful comments.

References
[BL13]

Karl Bringmann and Kasper Green Larsen. Succinct sampling from discrete distributions. In
Symposium on Theory of Computing Conference, STOC’13, Palo Alto, CA, USA, June 1-4,
2013, pages 775–782, 2013.

[BM99]

Andrej Brodnik and J. Ian Munro. Membership in constant time and almost-minimum space.
SIAM J. Comput., 28(5):1627–1640, 1999.

[BMRV02] Harry Buhrman, Peter Bro Miltersen, Jaikumar Radhakrishnan, and Srinivasan Venkatesh. Are
bitvectors optimal? SIAM J. Comput., 31(6):1723–1744, 2002.
[CW79]

Larry Carter and Mark N. Wegman. Universal classes of hash functions. J. Comput. Syst. Sci.,
18(2):143–154, 1979.

[DPT10]

Yevgeniy Dodis, Mihai Pǎtraşcu, and Mikkel Thorup. Changing base without losing space. In
Proc. 42nd ACM Symposium on Theory of Computing (STOC), pages 593–602, 2010.
60

[FKS84]

Michael L. Fredman, János Komlós, and Endre Szemerédi. Storing a sparse table with O(1)
worst case access time. J. ACM, 31(3):538–544, 1984.

[FM95]

Faith E. Fich and Peter Bro Miltersen. Tables should be sorted (on random access machines).
In Algorithms and Data Structures, 4th International Workshop, WADS ’95, Kingston, Ontario,
Canada, August 16-18, 1995, Proceedings, pages 482–493, 1995.

[FN93]

Amos Fiat and Moni Naor. Implicit O(1) probe search. SIAM J. Comput., 22(1):1–10, 1993.

[FNSS92]

Amos Fiat, Moni Naor, Jeanette P. Schmidt, and Alan Siegel. Nonoblivious hashing. J. ACM,
39(4):764–782, 1992.

[FW93]

Michael L. Fredman and Dan E. Willard. Surpassing the information theoretic bound with
fusion trees. J. Comput. Syst. Sci., 47(3):424–436, 1993.

[GORR09] Roberto Grossi, Alessio Orlandi, Rajeev Raman, and S. Srinivasa Rao. More haste, less waste:
Lowering the redundancy in fully indexable dictionaries. In 26th International Symposium
on Theoretical Aspects of Computer Science, STACS 2009, February 26-28, 2009, Freiburg,
Germany, Proceedings, pages 517–528, 2009.
[Jac89]

Guy Jacobson. Space-efficient static trees and graphs. In 30th Annual Symposium on Foundations of Computer Science, Research Triangle Park, North Carolina, USA, 30 October - 1
November 1989, pages 549–554, 1989.

[MHMP15] A. Makhdoumi, S. Huang, M. Médard, and Y. Polyanskiy. On locally decodable source coding.
In 2015 IEEE International Conference on Communications (ICC), pages 4394–4399, 2015.
[Mil96]

Peter Bro Miltersen. Lower bounds for static dictionaries on rams with bit operations but no
multiplication. In Automata, Languages and Programming, 23rd International Colloquium,
ICALP96, Paderborn, Germany, 8-12 July 1996, Proceedings, pages 442–453, 1996.

[MNSW98] Peter Bro Miltersen, Noam Nisan, Shmuel Safra, and Avi Wigderson. On data structures and
asymmetric communication complexity. J. Comput. Syst. Sci., 57(1):37–49, 1998.
[Ove83]

Mark H. Overmars. The Design of Dynamic Data Structures. Lecture Notes in Economic and
Mathematical Systems. Springer-Verlag, 1983.

[Pag01a]

Rasmus Pagh. Low redundancy in static dictionaries with constant query time. SIAM J. Comput., 31(2):353–363, 2001.

[Pag01b]

Rasmus Pagh. On the cell probe complexity of membership and perfect hashing. In Proceedings on 33rd Annual ACM Symposium on Theory of Computing, July 6-8, 2001, Heraklion,
Crete, Greece, pages 425–432, 2001.

[Pǎt08]

Mihai Pǎtraşcu. Succincter. In Proc. 49th IEEE Symposium on Foundations of Computer
Science (FOCS), pages 305–313, 2008.

[PT06]

Mihai Pǎtraşcu and Mikkel Thorup. Time-space trade-offs for predecessor search. In Proceedings of the 38th Annual ACM Symposium on Theory of Computing, Seattle, WA, USA, May
21-23, 2006, pages 232–240, 2006.

61

[PT07]

Mihai Pǎtraşcu and Mikkel Thorup. Randomization does not help searching predecessors. In
Proceedings of the Eighteenth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA
2007, New Orleans, Louisiana, USA, January 7-9, 2007, pages 555–564, 2007.

[PV10]

Mihai Pǎtraşcu and Emanuele Viola. Cell-probe lower bounds for succinct partial sums. In
Proceedings of the Twenty-First Annual ACM-SIAM Symposium on Discrete Algorithms, SODA
2010, Austin, Texas, USA, January 17-19, 2010, pages 117–122, 2010.

[RRR07]

Rajeev Raman, Venkatesh Raman, and Srinivasa Rao Satti. Succinct indexable dictionaries
with applications to encoding k-ary trees, prefix sums and multisets. ACM Trans. Algorithms,
3(4):43, 2007.

[SS90]

Jeanette P. Schmidt and Alan Siegel. The spatial complexity of oblivious k-probe hash functions. SIAM J. Comput., 19(5):775–786, 1990.

[Tho13]

Mikkel Thorup. Mihai Pǎtraşcu: Obituary and open problems. Bulletin of the EATCS, 109:7–
13, 2013.

[TY79]

Robert Endre Tarjan and Andrew Chi-Chih Yao. Storing a sparse table. Commun. ACM,
22(11):606–611, 1979.

[Vio12]

Emanuele Viola. Bit-probe lower bounds for succinct data structures. SIAM J. Comput.,
41(6):1593–1604, 2012.

[VWY19]

Emanuele Viola, Omri Weinstein, and Huacheng Yu. How to store a random walk. CoRR,
abs/1907.10874, 2019.

[Yao81]

Andrew Chi-Chih Yao. Should tables be sorted? J. ACM, 28(3):615–628, 1981.

[Yu19]

Huacheng Yu. Optimal succinct rank data structure via approximate nonnegative tensor decomposition. In Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing,
STOC 2019, Phoenix, AZ, USA, June 23-26, 2019., pages 955–966, 2019.

A

Proofs for Fractional-length Strings

In the section, we prove the propositions from Section 4. We first show that two strings can be concatenated.
Proposition 37. Let s1 , s2 ≥ 0. Given two binary strings S1 = (M1 , K1 ) and S2 = (M2 , K2 ) of s1 and s2
bits respectively, they can be concatenated into one string S = (M, K) of length at most s1 + s2 + 2−κ+2 ,
and both M1 and M2 are (consecutive) substrings of M . Moreover, given the values of s1 and s2 , both S1
and S2 can be decoded using constant time and one access to S, i.e., a decoding algorithm recovers K1 and
K2 , and finds the starting locations of M1 and M2 within M using constant time and one access to S.
After decoding S1 and S2 , any further access to the two strings can be performed as if they were stored
explicitly.
Proof. To concatenate two strings, let us first combine K1 and K2 into a single integer K ′ ∈ [range(K1 ) · range(K2 )]:
K ′ := K1 · range(K2 ) + K2 .
62

If s1 + s2 < κ + 1, we simply let K = K ′ , and let M be the empty string. Then lg(range(K)) = s1 + s2 <
κ + 1, (M, K) is the concatenation.
Next, we assume s1 + s2 ≥ κ + 1. In this case, in the final string S = (M, K), M will be the
concatenation of M1 , M2 and the lowest bits of K ′ . More specifically, let |M | be ⌊s1 + s2 + 2−κ+2 ⌋ − κ,
−κ+2 ) 6
and let range(K) be ⌊2κ+frac(s1 +s2 +2
⌋. It is easy to verify that |M |+lg(range(K)) ≤ s1 +s2 +2−κ+2
κ
κ+1
and range(K) ∈ [2 , 2 ).
We set
M := M1 ◦ M2 ◦ (K ′ mod 2|M |−|M1 |−|M2| )2 ,
where (x)2 is the binary representation of x, and
K := K ′ div 2|M |−|M1|−|M2 | .
To see why K is at most range(K) − 1, we have
K ≤ (range(K1 ) · range(K2 ) − 1) div 2|M |−|M1|−|M2|


= 2s1 −|M1 |+s2−|M2 | − 1 div 2|M |−|M1 |−|M2|
≤ 2s1 +s2 −|M |

−κ+2

≤ (range(K) + 1) · 2−2
≤ range(K) − 1,

−κ+2

where the last inequality uses the fact that 2−2

≤ 1 − 2−κ+1 and range(K) ≥ 2κ .

To decode S1 and S2 , observe that S[|M1 | + |M2 |, |M |] encodes exactly K ′ . We access S to retrieve its
value, and compute K1 and K2 using K1 := K ′ div range(K2 ) and K2 := K ′ mod range(K2 ). By our
construction, M1 is M [0, |M1 | − 1] and M2 is M [|M1 |, |M1 | + |M2 | − 1]. Hence, we decode S1 and S2
in constant time and one access to S.
Using ideas similar to [DPT10], we show that multiple strings can be concatenated, allowing fast decoding of any given string.
Proposition 38. Let s1 , . . . , sB ≥ κ. Suppose there are numbers T̃0 , . . . , T̃B such that
• T̃0 = 0 and si + 1 ≥ T̃i − T̃i−1 ≥ si + 2−κ+2 ;
• each T̃i is of the form T̃i = m̃i + lg R̃i , where R̃i ∈ [2κ , 2κ+1 ) and m̃i ≥ 0 are integers;
• for any given i, T̃i can be computed in O(t) time.
Then given B strings S1 , . . . , SB , where Si = (Mi , Ki ) has length si , they can be concatenated into one
string S = (M, K) of length T̃B , and each Mi is a (consecutive) substring of M . Moreover, for any given i,
Si can be decoded using O(t) time and two accesses to S, i.e., a decoding algorithm recovers Ki , and finds
the starting location of Mi using O(t) time and two accesses to S.
Proof. Without loss of generality, we assume B is odd, since otherwise, we could first apply the following
argument to the first B − 1 strings, then apply Proposition 37 to concatenate the outcome with the last string
SB .
To concatenate all strings, we break S2 , . . . , SB into (B − 1)/2 pairs, where the j-th pair consists of
S2j and S2j+1 . We start with the first string S1 , and repeatedly “append” the pairs to it. More specifically,
6

Recall that frac(x) = x − ⌊x⌋.

63

let S (0) := S1 . Suppose we have concatenated S1 and the first j − 1 pairs into S (j−1) = (M (j−1) , K (j−1) ),
such that |M (j−1) | = m̃2j−1 and range(K (j−1) ) = R̃2j−1 . In particular, it has length T̃2j−1 . Now, we show
how to “append” S2j and S2j+1 to it.
To this end, we combine K2j and K2j+1 into a single integer Lj ,
Lj := K2j · range(K2j+1 ) + K2j+1 .
Thus, range(Lj ) = range(K2j ) · range(K2j+1 ), and we have range(Lj ) ∈ [22κ , 22κ+2 ). Then, we re-break
Lj into a pair (Xj , Yj ), such that the product of range(Xj ) and range(K (j−1) ) is close to a power of two:
we set
%
$
2⌊T̃2j+1 ⌋−⌊T̃2j−1 ⌋−|M2j |−|M2j+1 |
,
range(Xj ) :=
range(K (j−1) )
and




range(Lj )
range(Yj ) :=
.
range(Xj )

Note that
2κ ≤ ⌊T̃2j+1 ⌋ − ⌊T̃2j−1 ⌋ − |M2j | − |M2j+1 | ≤ 2κ + 4.
To break Lj into such a pair, we let Yj := Lj div range(Xj ) and Xj := Lj mod range(Xj ). Next,
we combine K (j−1) and Xj into an integer Zj smaller than 2⌊T̃2j+1 ⌋−⌊T̃2j−1 ⌋−|M2j |−|M2j+1 | : let Zj :=
K (j−1) · range(Xj ) + Xj .
Finally, we let S (j) := (M (j) , K (j) ), where
M (j) := M (j−1) ◦ (Zj )2 ◦ M2j ◦ M2j+1 ,
and
K (j) := Yj .
The length of M (j)
|M (j) | = |M (j−1) | + (⌊T̃2j+1 ⌋ − ⌊T̃2j−1 ⌋ − |M2j | − |M2j+1 |) + |M2j | + |M2j+1 |
= ⌊T̃2j+1 ⌋ − κ

= m̃2j+1 .
The range of K (j) has size
range(K (j) ) <
≤
≤

range(Lj )
+1
range(Xj )
range(K2j ) · range(K2j+1 )
2⌊T̃2j+1 ⌋−⌊T̃2j−1 ⌋−|M2j |−|M2j+1 |
range(K (j−1) )

+1

−1

range(K2j ) · range(K2j+1 ) · range(K (j−1) )

2⌊T̃2j+1 ⌋−⌊T̃2j−1 ⌋−|M2j |−|M2j+1 |
(j)
= 2s2j +s2j+1 +T̃2j−1 −|M | · (1 − 2−κ+1 )−1 + 1
κ+3

≤ 2κ+frac(T̃2j+1 )−2
≤ 2κ+frac(T̃2j+1 )

· (1 − 2−κ+1 )−1 + 1

64

· (1 − 2−κ+1 )−1 + 1

= R̃2j+1 .
Thus, S (j) has length T̃2j+1 , and hence, the final string S := S ((B−1)/2) has length T̃B .
Next, we show that each Si can be decoded in O(t) time and two accesses to S. If i = 1, we compute
T̃3 in O(t) time, and then compute range(Z1 ), range(X1 ) and |M1 |. Thus, M1 = M [0, |M1 | − 1] and Z1
is stored in M immediately after M1 . By making one access to S, we recover the value of Z1 , and hence,
K1 can be computed using K1 = Z1 div range(X1 ). This decodes S1 in O(t) time and one access to S.
If i > 1, let j = ⌊i/2⌋, i.e., Si is in the j-th pair. We first compute T̃2j−1 and T̃2j+1 in O(t) time.
They determine range(Zj ), range(Xj ) and |M (j−1) |, as well as the starting location of Mi . Thus, Zj can
be recovered with one access to S. Xj can be computed using Xj = Zj mod range(Xj ). Similarly,
we then recover Zj+1 , and Yj can be computed using Yj = K (j) = Zj+1 div range(Xj+1 ) (if Si is in
the last pair, Yj is simply K in the final string). This recovers both Xj and Yj . Next, we recover Lj
using Lj = Yj · range(Xj ) + Xj , and compute K2j and K2j+1 using K2j = Lj div range(K2j+1 ) and
K2j+1 = Lj mod range(K2j+1 ). In particular, it recovers the value of Ki , and hence, it decodes Si .
Proposition 7 (restated). Let s1 , . . . , sB ≥ κ. Suppose for any given i, s1 + · · · + si can be approximated
(deterministically) in O(t) time with an additive error of at most 2−κ . Then given B strings S1 , . . . , SB ,
where Si = (Mi , Ki ) has length si , they can be concatenated into one string S = (M, K) of length at most
s1 + · · · + sB + (B − 1) · 2−κ+4 ,
so that each Mi is a (consecutive) substring of M . Moreover, for any given i, Si can be decoded using O(t)
time and two accesses to S, i.e., a decoding algorithm recovers Ki , and finds the starting location of Mi
using O(t) time and two accesses to S.
Proof. Suppose we can compute S̃i = s1 + · · · + si ± 2−κ . We set m̃i = ⌊S̃i + (i − 1) · 2−κ+3 ⌋ − κ,
−κ+3 −m̃
i ⌋ and T̃ = m̃ + lg R̃ . Then T̃ ≤ S̃ + (i − 1) · 2−κ+3 and T̃ > S̃ + (i − 1) ·
R̃i = ⌊2S̃i +(i−1)·2
i
i
i
i
i
i
i
−κ+3
−κ+1
2
−2
. Therefore,
T̃i − T̃i−1 ≥ S̃i − S̃i−1 + 2−κ+3 − 2−κ+1
≥ si + 2−κ+2 .

Also, T̃i − T̃i−1 ≤ si + 2−κ+4 . Finally, by Proposition 38, the size of the data structure is at most T̃B ≤
SB + (B − 1) · 2−κ+3 ≤ s1 + · · · + sB + (B − 1) · 2−κ+4 .
In particular, by storing approximations of all B prefix sums in a lookup table of size O(B), the length
of S is at most s1 + · · · + sB + (B − 1)2−κ+4 and each Si can be decoded in O(1) time.
Proposition 8 (restated). Let s1 , . . . , sB ≥ 0. There is a lookup table of size O(B). Given B strings
S1 , . . . , SB , where Si = (Mi , Ki ) has length si , they can be concatenated into one string S = (M, K) of
length at most
s1 + · · · + sB + (B − 1)2−κ+4 ,
so that each Mi is a (consecutive) substring of M . Moreover, assuming we can make random accesses to
the lookup table, Si can be decoded using constant time and two accesses to S, i.e., a decoding algorithm
recovers Ki , and finds the starting location of Mi using constant time and two accesses to S.
65

Proof. If all si ≥ κ, the proposition is an immediate corollary of Proposition 7, as we could simply store
the approximations of all B prefix sums. For general si ≥ 0, we group the strings so that each group has
length at least κ.
We greedily divide all strings into groups: Pick the first i1 such that s1 + · · · + si1 ≥ κ, then pick the
first i2 such that si1 +1 + · · · + si2 ≥ κ, etc. Then each group has total length at least κ, possibly except for
the last group. We store in the lookup table, which group each string belongs to, and the values of i1 , i2 , . . .
Then consider a group consisting of Sa , . . . , Sb , we must
Q have sa + · · · + sκb−1 < κ, which means that they
can be combined into one single integer smaller than b−1
i=a range(Ki ) < 2 , e.g.,
K :=

b−1
X
i=a

Ki ·

i−1
Y

range(Kj ).

j=a

Q
If we store i−1
j=a range(Kj ) and range(Ki ) in the lookup table for each i in the group, then Ki can be
recovered from K using
i−1
Y
range(Kj )) mod range(Ki ).
Ki = (K div
j=a

This concatenates all strings in the group except the last one. We then apply Proposition 37 to concatenate the last string in the group to it. Then we apply Proposition 7 to concatenate the strings obtained from
each group (except for the last group), using the lookup table. Finally, we concatenate the string obtained
from the last group to it.
Concatenating strings in each group loses at most 2−κ+2 due to Proposition 37. The length of the final
string is at most s1 + · · · + sB + (B − 1)2−κ+4 . The lookup table has size O(B).
Next, we show that an integer i ∈ [C] can be fused into a string.
Proposition 39. Let s1 , . . . , sC ≥ 0. Suppose there are numbers T̃1 , . . . , T̃C such that
• 2T̃i − 2T̃i−1 ≥ 2si ;
• each T̃i is of the form T̃i = m̃ + lg R̃i , where m̃, R̃i are integers;
• T̃C is a valid length, i.e., m̃ = 0 and R̃C ∈ [1, 2κ ), or m̃ ≥ 0 and R̃C ∈ [2κ , 2κ+1 );
• for any given K, the largest i ≤ C such that R̃i ≤ K can be computed in O(t) time.
Then given i ∈ {1, . . . , C} and string Si = (Mi , Ki ) of length si , the pair (i, Si ) can be stored in S =
(M, K) of length T̃C , and Mi is a (consecutive) substring of M . Moreover, we can recover the value of i
and decode Si using O(t) time and two accesses to S, i.e., a decoding algorithm recovers i, Ki , and finds
the starting location of Mi using O(t) time and two accesses to S.
Proof. Clearly, we have si ≤ T̃C for all i, and hence, |Mi | ≤ m̃. We first increase the length of |Mi | to m̃
by appending the least significant bits of Ki to it. That is, let
M := Mi ◦ (Ki mod 2m̃−|Mi | )2 .
Next, we encode the remaining information of (i, Si ) in K, i.e., encode i and the top bits of Ki :
K := R̃i−1 + (Ki div 2m̃−|Mi | ),
where R̃0 is assumed to be 0. Note that we have
R̃i−1 + (range(Ki ) − 1) div 2m̃−|Mi | < R̃i−1 + range(Ki ) · 2|Mi |−m̃
66

= R̃i−1 + 2si −m̃
= 2−m̃ (2T̃i−1 + 2si )
≤ 2T̃i −m̃

= R̃i .

That is, the value of K determines both i and Ki div 2m̃−|Mi | , and range(K) is at most R̃C . Thus, S is a
string of length T̃C .
To decode i and Si , we first access S to retrieve K. Then we compute the largest i ≤ C such that
R̃i ≤ K in O(t) time. By the argument above, it recovers the value of i and determines
(Ki div 2m̃−|Mi | ) = K − R̃i .
To decode Si , observe that Mi = M [0, |Mi |−1], and M [|Mi |, m̃−1] stores the value of Ki mod 2m̃−|Mi | .
If m̃ − |Mi | ≤ κ + 1, we retrieve its value using one access, and together with Ki div 2m̃−|Mi | , it determines
Ki . Otherwise, since Ki < 2κ+1 , its value is entirely stored in M (in its binary representation). We simply
make one access to retrieve it. In both cases, we recover the value of i and decode Si in O(t) time and two
accesses to S.
Proposition 9 (restated). Let s1 , . . . , sC ≥ 0. Suppose for any given i, 2s1 + · · · + 2si can be approximated
(deterministically) in O(t) time with an additive error of at most (2s1 + · · · + 2sC ) · 2−κ−3 . Then given
i ∈ {1, . . . , C} and string Si = (Mi , Ki ) of length si , the pair (i, Si ) can be stored in S = (M, K) of
length at most
lg(2s1 + · · · + 2sC ) + C · 2−κ+4 ,
so that Mi is a (consecutive) substring of M . Moreover, we can recover the value of i and decode Si
using O(t lg C) time and two accesses to S, i.e., a decoding algorithm recovers i, Ki , and finds the starting
location of Mi using O(t lg C) time and two accesses to S.
Proof. We compute S̃i = (2s1 + · · · + 2si ) ± (2s1 + · · · + 2sC ) · 2−κ−3 . If 2s1 + · · · + 2sC < κ, then the error
term (2s1 + · · · + 2sC ) · 2−κ−3 < 1/8. However, each 2s1 + · · · + 2si must be an integer by definition. S̃i
rounded to the nearest integer is the accurate value of 2s1 +· · ·+2si . To apply Proposition 39, we simply set
m̃ := 0, R̃i := ⌊S̃i + 1/2⌋ for i = 1, . . . , C and T̃i = m̃ + lg R̃i . It is easy to verify that R̃i − R̃i−1 ≥ 2si ;
T̃C is a valid length. For any given K, by doing a binary search, the largest i such that R̃i ≤ K can be found
in O(t lg C) time. Thus, by Proposition 39, the pair (i, Si ) can be stored using space
T̃C = lg(2s1 + · · · + 2sC ),
and allowing O(t lg C) time for decoding.
Next, we consider the case where 2s1 + · · · + 2sC ≥ κ. To apply Proposition 39, we let T̃C be the largest
valid length smaller than lg S̃C + C · 2−κ+3 . That is, we set
m̃ := ⌊lg S̃C + C · 2−κ+3 ⌋ − κ.
Then

−κ+3

R̃C := ⌊S̃C · 2C·2
67

· 2−m̃ ⌋,

and T̃C = m̃ + lg R̃C . Then for i < C, we let
R̃i := ⌊S̃i · 2−m̃ ⌋ + 2(i − 1),
and T̃i = m̃ + lg R̃i .
To apply Proposition 39, we verify that 2T̃i − 2T̃i−1 ≥ 2si . To see this, for i < C, we have


2T̃i − 2T̃i−1 = 2m̃ · R̃i − R̃i−1
≥ 2m̃ · (S̃i · 2−m̃ − S̃i−1 · 2−m̃ + 1)

≥ 2si + 2m̃ − (2s1 + · · · + 2sC ) · 2−κ−2 .

On the other hand, S̃C = (2s1 + · · · + 2sC ) · (1 ± 2−κ−3 ), i.e., 2s1 + · · · + 2sC = S̃C · (1 ± 2−κ−3 )−1 .
2m̃ − (2s1 + · · · + 2sC ) · 2−κ−2 ≥ 2m̃ − S̃C · 2−κ−1 ≥ 0.
Thus, 2T̃i − 2T̃i−1 ≥ 2si for i < C. For i = C, it suffices to show ⌊S̃C · 2−m̃ ⌋ + 2(C − 1) ≤ R̃C . Indeed,
we have
−κ+3

R̃C − (⌊S̃C · 2−m̃ ⌋ + 2(C − 1)) ≥ S̃C · 2C·2

· 2−m̃ − 1 − S̃C · 2−m̃ − 2(C − 1)
−κ+3

≥ S̃C · 2−m̃ · (2C·2
−m̃

≥ S̃C · 2

−κ+2

·C ·2

− 1) − 2C
− 2C.

Since m̃ + κ ≤ lg S̃C + 1, it is at least 0.
Since each R̃i can be computed in O(t) time, by doing a binary search, for any given K, we can find the
largest i such that R̃i ≤ K in O(t lg C) time. By Proposition 39, we obtain a data structure of size
T̃C ≤ lg S̃C + C · 2−κ+3 ≤ lg(2s1 + · · · + 2sC ) + C · 2−κ+4 .
This proves the proposition.
Similar to the concatenation, the decoding algorithm takes constant time if we use a lookup table of size
O(C).
Proposition 10 (restated). Let s1 , . . . , sC ≥ 0. There is a lookup table of size O(C). Given i ∈ {1, . . . , C}
and string Si = (Mi , Ki ) of length si , the pair (i, Si ) can be stored in S = (M, K) of length
lg(2s1 + · · · + 2sC ) + C · 2−κ+2 ,
so that Mi is a (consecutive) substring of M . Moreover, assuming we can make random accesses to the
lookup table, the value of i can be recovered and Si can be decoded using constant time and two accesses
to S, i.e., a decoding algorithm recovers i, Ki , and finds the starting location of Mi using constant time and
two accesses to S.
Proof. Without loss of generality, assume s1 ≤ · · · ≤ sC , since otherwise, we simply sort s1 , . . . , sC and
store the permutation in the lookup table.
To apply Proposition 39, if 2s1 + · · · + 2sC ≤ 2κ , we set
m̃ := 0,
68

R̃i = 2s1 + · · · + 2si

and T̃i = m̃ + lg R̃i . Otherwise, if 2s1 + · · · + 2sC > 2κ , we set


m̃ := lg(2s1 + · · · + 2sC ) + C · 2−κ+2 − κ,

for i < C, let

R̃i := ⌈2s1 −m̃ ⌉ + · · · + ⌈2si −m̃ ⌉,
and

R̃C := max ⌈2s1 −m̃ ⌉ + · · · + ⌈2sC −m̃ ⌉, 2κ .

Finally, let T̃i = m̃ + lg R̃i . Clearly, in both cases, we have 2T̃i − 2T̃i−1 ≥ 2m̃ · 2si −m̃ ≥ 2si . Also, we have
T̃C ≤ lg(2s1 + · · · + 2sC ) + C · 2−κ+2 . This is because
R̃C < max{(2s1 + · · · + 2sC ) · 2−m̃ + C, 2κ }

s1 +···+2sC )+C2−κ+2 )−C2−κ+2

= max{2κ+frac(lg(2

s1 +···+2sC )+C2−κ+2 )

≤ max{2κ+frac(lg(2

s1 +···+2sC )+C2−κ+2 )

≤ 2κ+frac(lg(2

+ C, 2κ }

· (1 − C · 2−κ+1 ) + C, 2κ }

.

Thus, T̃C = m̃ + lg R̃C ≤ lg(2s1 + · · · + 2sC ) + C · 2−κ+2 .
To apply Proposition 9, we need to show that for any given K, the largest i such that R̃i ≤ K can be
found in constant time. To this end, we store a predecessor search data structure for the set {R̃1 , . . . , R̃C }.
Note that the set of integers {R̃1 , . . . , R̃C } has monotone gaps. That is, the difference between adjacent
numbers is non-decreasing. Pǎtraşcu [Pǎt08] showed that for such sets, there is a predecessor search data
structure using linear space and constant query time, i.e., there is an O(C)-sized data structure such that
given an integer K, the query algorithm can answer in constant time the largest value in the set that is at
most K. This data structure is stored in the lookup table (it only depends on s1 , . . . , sC , but not the input
string). To compute the index i rather than R̃i , we simply store another hash table using perfect hashing in
the lookup table. Hence, the lookup table has size O(C).
The premises of Proposition 9 are all satisfied. The size of S is T̃C ≤ lg(2s1 + · · · + 2sC ) + C2−κ+2 ,
and i and Si can be decoded in constant time. This proves the proposition.
Next, we show that it is possible to divide a binary string into two substrings.
Proposition 14 (restated). Let s1 , s2 , s ≥ 3κ and s ≤ s1 + s2 − 2−κ+2 . Then given a double-ended string
S = (Kh , M, Kt ) of length s, a division algorithm outputs two double-ended strings S1 = (K1,h , M1 , K1,t )
and S2 = (K2,h , M2 , K2,t ) of lengths at most s1 and s2 respectively. Moreover, (K1,h , M1 ) is a prefix of
S, (M2 , K2,t ) is a suffix of S, and K1,t and K2,h together determine M [|M1 |, |M | − |M2 | − 1], i.e., the
remaining bits of M . range(Ki,h ), range(Ki,t ) and |Mi | can be computed in O(1) time given range(Kh ),
range(Kt ), |M | and s1 , s2 , for i = 1, 2.
Proof. We first calculate the length of M1 and M2 , let |M1 | := ⌊s1 − lg(range(Kh ))⌋ − κ and M2 :=
⌊s2 − lg(range(Kt ))⌋ − κ. Then let
(Kh,1 , M1 ) := S[−1, |M1 | − 1]
69

be a prefix, and
(M2 , Kt,2 ) := S[|M | − |M2 |, |M |]

be a suffix. The remaining task is to divide the middle |M | − |M1 | − |M2 | bits of M into Kt,1 and Kh,2 .
To this end, we represent the middle bits as an integer L in the range [2|M |−|M1 |−|M2| ]. The sizes of
ranges of Kt,1 and Kh,2 can be calculated using
range(Kt,1 ) = ⌊2s1 −lg(range(Kh ))−|M1 | ⌋
and
range(Kh,2 ) = ⌊2s2 −lg(range(Kt ))−|M2 | ⌋.

Then let Kt,1 := L mod range(Kt,1 ) and Kh,2 := L div range(Kt,1 ). Clearly, Kt,1 ∈ [range(Kt,1 )].
It suffices to show that Kh,2 is in its range:
Kh,2 <

2|M |−|M1 |−|M2|

2s1 −lg(range(Kh ))−|M1 | − 1
2|M |−|M2 |−s1 +lg(range(Kh ))
=
1 − 2−s1 +lg(range(Kh ))+|M1 |
2s−|M2 |−s1 −lg(range(Kt ))
=
1 − 2−κ
−κ+2
2s2 −|M2 |−lg(range(Kt ))−2
≤
1 − 2−κ
−κ+2
2−2
< (range(Kh,2 ) + 1) ·
1 − 2−κ
(1 + 2−κ )(1 − 2−κ+1 )
≤ range(Kh,2 ) ·
1 − 2−κ
< range(Kh,2 ).

Thus, S1 has at most s1 bits and S2 has at most s2 bits. This proves the proposition.
Finally, we show that the inverse of fusion can be done efficiently.
Proposition 15 (restated). Let s1 , . . . , sC ≥ 0, Rh , Rt ∈ [2κ , 2κ+1 ) and m ≥ κ, let s = m + lg Rh + lg Rt ,
and s ≤ lg(2s1 + · · · + 2sC ) − C · 2−κ+2 , there is a lookup table of size O(C). Given a double-ended string
S = (Kh , M, Kt ) such that range(Kh ) = Rh , range(Kt ) = Rt and |M | = m, there is an extraction
algorithm that generates a pair (i, Si ) such that i ∈ {1, . . . , C}, and Si = (Ki,h , Mi , Ki,t ) has length at
most si . Moreover, (Mi , Ki,t ) is a suffix of S, and given i and Ki,h , the rest of S (i.e., S[−1, |M |−|Mi |−1])
can be recovered in constant time, assuming random access to the lookup table. range(Ki,h ), range(Ki,t )
and |Mi | does not depend on S, and can be stored in the lookup table.
Proof. By setting Ki,t := Kt , the task becomes to encode (Kh , M ) using (i, (Ki,h , Mi )). Next, we show
how to determine i. To this end, we divide the range of Kh into C disjoint intervals {[li , ri )}i=1,...,C , such
that the i-th interval has size at most
⌊2si −|M |−lg(range(Kt )) ⌋.
Such division is possible, because
C
C
X
X
si −|M |−lg(range(Kt ))
2si −|M |−lg(range(Kt )) − C
⌊2
⌋>
i=1

i=1

70

−κ+2

≥ 2−|M |−lg(range(Kt )) · 2s+(C−1)·2

(C−1)·2−κ+2

≥ 2s−|M |−lg(range(Kt )) · (2

−C

− C · 2−κ )

≥ range(Kh ) · (1 + (C − 1)2−κ+1 − C · 2−κ )

≥ range(Kh ).
Fix one such division, e.g., the i-th interval is from

li := min{⌊2s1 −|M |−lg(range(Kt )) ⌋ + · · · + ⌊2si−1 −|M |−lg(range(Kt )) ⌋, range(Kh ) − 1}
to
ri := min{⌊2s1 −|M |−lg(range(Kt )) ⌋ + · · · + ⌊2si −|M |−lg(range(Kt )) ⌋, range(Kh ) − 1}
excluding the right endpoint. We store all endpoints li , ri in the lookup table, taking O(C) space.
Now, find i such that Kh ∈ [li , ri ). Then compute |Mi | = ⌊si − lg(range(Kt ))⌋ − κ, and let
Mi := M [|M | − |Mi |, |M | − 1].
Finally, we view the first |M | − |Mi | bits of M as a nonnegative integer Z ∈ [2|M |−|Mi | ] and let
Ki,h := 2|M |−|Mi | · (Kh − li ) + Z.
Observe that Ki,h < ⌊2κ+frac(si −lg(range(Kt ))) ⌋, because
Ki,h < 2|M |−|Mi | · (ri − li )

≤ 2|M |−(⌊si −lg(range(Kt ))⌋−κ) · 2si −|M |−lg(range(Kt ))
≤ 2κ+frac(si −lg(range(Kt ))) .

Thus, the length of Si = (Ki,h , Mi , Ki,t ) is at most
lg(range(Ki,h )) + |Mi | + lg(range(Ki,t )) ≤ si .
We also store the sizes of Si for every i in the lookup table.
It is clear that (Mi , Ki,t ) is a suffix of S. Given i and Ki,h , we retrieve li and Mi from the lookup table.
Then S[−1] = Kh can be recovered using
Kh = li + Ki,h div 2|M |−|Mi | .
Also, Z can be recovered using
Z = Ki,h mod 2|M |−|Mi | ,
which determines S[0, |M | − |Mi | − 1]. This proves the proposition.

71

B Approximating Binomial Coefficients
In this section, we prove Claim 22 and Claim 23 from Section 6.1.
Claim 22 (restated). Both OPT(k−i+1)Vbl ,m1 −(k−i+1)SIZEmain +(m1 −1)2−κ/2+2 and OPT(j−k)Vbl ,m2 −
(j − k)SIZEmain + (m2 − 1)2−κ/2+2 can be approximated with an additive error of at most 2−κ in O(1)
time.
Proof. (sketch) For Claim 22, the goal is essentially to efficiently approximate
s1 = OPT(k−i+1)Vbl ,m1 − (k − i + 1)SIZEmain + (m1 − 1)2−κ/2+2
and
s2 = OPT(j−k)Vbl ,m2 − (j − k)SIZEmain + (m2 − 1)2−κ/2+2 .

To approximate s1 and s2 , we can store an approximation of SIZEmain up to O(κ) bits of precision in
the lookup table. The task reduces to approximate the two OPTs. Recall that
 
V
OPTV,m = lg
.
m


bl
bl
. In the following, we show
and lg (j−k)V
The problem further reduces to approximate lg (k−i+1)V
m
m1
2
V
κ
that for any given V, m ≤ 2 , it is possible to approximate lg m in O(1) time.
V
can be expanded to lg V ! − lg m! − lg(V − m)!. We approximate each term separately. By
lg m
Stirling’s formula,
 
d
X
(−1)i Bi
k
1
+ O(k−d ),
+ ln 2πn +
ln k! = k ln
e
2
i(i − 1)ki−1
i=2

where Bi is the i-th Bernoulli number, and d ≥ 2. For any constant ǫ > 0, by setting d ≥ Ω(1/ǫ), the above
approximation gives an error of 2−Ω(κ) for any k ≥ 2ǫκ . We store the Bernoulli numbers in the lookup table,
and the formula can be evaluated in constant time. On the other hand, for all k < 2ǫκ , we simply store an
approximation of lg k! in a global lookup table, taking 2ǫκ size. Finally, by approximating
 lg V !, lg m! and
V
−2κ−2
lg(V − m)! independently with additive error 2
, we obtain an estimation of lg m with additive error
smaller than 2−2κ . Note that each of the three values may be 2ω(κ) , which takes super-constant words to
store. However, since the final value is guaranteed to be at most 2κ , we could safely apply mod 2κ over the
computation.
P
Claim 23 (restated). For any V1 , V2 , m ≥P
0, and 0 ≤ l ≤ m, li=0 2OPTV1 ,i +OPTV2 ,m−i can be approximated
OPTV1 ,i +OPTV2 ,m−i
up to an additive error of at most 2−κ−3 · m
in O(κ5 ) time.
i=0 2
Proof. (sketch) The goal is to approximate


l  
X
V1
V2
i
m−i
i=0

up to additive error of 2−κ−3 ·

V1 +V2
m


, because

OPTV1 ,i +OPTV2 ,m−i

2

=



V1
i




V2
.
m−i

To this end, we shall use the following lemma from [Yu19] to approximate binomial coefficients.
72

Lemma 40 ([Yu19]). For any large integers V , d and 0 < a ≤ V /2, such that d ≤ c·a, there is a polynomial
P of degree d, such that




   
√
V
V
V
V −a x
· PV,d (x) ≤
· (1 + 2− d+8 ),
≤
·
a+x
a
a+x
a
√
for all integers x ∈ [0, c · a], a (small) universal constant c > 0. Moreover, given V and d, the coefficients
of PV,d can be computed in O(d1.5 ) time.
 V2 
P
√
This lemma allows us to approximate bl=a Vl1 m−l
where b − a ≤ c · a, up to a multiplicative
P
error of 1 ± 2−2κ in O(κ4 ) time: it reduces approximating the sum to computing l αl · P1 (l)P2 (l) for two
degree-O(κ2 ) polynomials P1 , P2 .
√
√
1
· m. For l < m − 2 m · κ, we return 0 as the approximation; For m − 2 m · κ ≤
Let m = V1V+V
2
√
√
lP≤ m + 2 m · κ, we divide the range into chunks of size O( m), apply Lemma
40 to approximate
√
V1
V2
4 ) time, and return the sum; For l > m + 2 m · κ, we return (an apfor
each
chunk
in
O(κ
l l
m−l
+V2 
proximation of) V1m
as the estimation. It is not hard to verify that in all cases we return an approximation
with desired error. The details are omitted.

C

Dictionary with Linear Redundancy

In this section, we show a proof sketch of Lemma 26, and
 present a dictionary data structure that uses a
V
linear number of extra bits. Recall that OPTV,m := lg m
. For membership queries only, Pagh [Pag01a]
already obtained a better data structure. The data structure in this section is a generalization of Pagh’s static
dictionary.
Lemma 26 (restated). Given a set S ⊂ [V ] of m keys, there is a data structure of size
OPTV,m + O(m + lg lg V ),
such that it defines a bijection h between S and [m] and a bijection h between [V ] \ S and [V − m]. It
supports hash queries in constant time.
We are going to use Pagh’s static dictionary as a subroutine. For this reason, let us first give an overview
of this data structure. The data structure uses a minimal perfect hashing of Schmidt and Siegel [SS90]. The
hashing has three levels. In the first level, each key x is mapped to hk,p (x) = (kx mod p) mod m2 with no
collisions, for a prime p = Θ(m2 lg V ) and k ∈ [p]. A random pair (k, p) works with constant probability,
and it takes O(lg m + lg lg V ) bits to encode the function. This level effectively reduces the universe size
from V to m2 . Each key x ∈ S is then represented by a pair (x(1) , x(2) ) where x(1) ∈ [m2 ] is the hash
value, and x(2) = (x div p) · ⌈p/m2 ⌉ + (kx mod p) div m2 (called the quotient function in [Pag01a]). Then
x(2) ≤ O(V /m2 ) and (x(1) , x(2) ) uniquely determines x.
In the second level, we apply another hash function from the same family on x(1) , hk′ ,p′ (x(1) ) =
′
(k x(1) mod p′ ) mod m to map x(1) to m buckets. This time, we have p′ = Θ(m2 ) and k′ ∈ [p′ ]. Let
Ai be the number of keys mapped to bucket i. The hashing guarantees that for a random pair (k′ , p′ ), the
expectation of each A2i is bounded by O(1). Similarly, we can represent x(1) further as a pair such that the
first component is the hash value in [m], and the second component is the quotient function value, which is
at most O(m).

73

The third level hashing then hashes all keys in the same bucket to different integers. It is applied on x(1) :
gki ,pi (x(1) ) = (ki x(1) mod pi ) mod A2i , for pi = Θ(m2 ) and ki ∈ [pi ] such that all keys in the bucket are
mapped to different integers. It turns out that a random pair (ki , pi ) works with constant probability.
The data structure stores the following for the hash functions:
1. the top-level hash functions (k, p) and (k′ , p′ ),
2. a list of O(lg m) (random) choices for the third-level hash functions (k1 , p1 ), (k2 , p2 ), . . .,
3. for each bucket i, the index πi of the first hash function in the list that works.
It turns out that it is possible to use only O(m) bits to store the indices πi . This is because each second-level
hash function works with constant probability, the entropy of each πi is a constant. We can use the Huffman
coding for each πi to achieve constant bits per index (which turns out to be the unary representation of πi ).
These hash functions map all m input keys to O(m) buckets with no collisions. By storing a rank data
structure (e.g., [Pǎt08]) among the O(m) buckets using O(m) bits of space, we further map all the nonempty buckets to [m]. Finally, we store for each bucket, the quotient functions of the input key mapped to it.
Hence, it take lg(V /m2 ) + lg m + O(1) =
 lg(V /m) + O(1) bits to encode each key. Thus, the total space
V
is m lg(V /m) + O(m + lg lg V ) = lg m + O(m + lg lg V ) bits.

This data structure supports membership queries, and naturally defines a bijection h between S and
[m], namely h(x) simply being the bucket x is mapped to. To generalize the data structure and define an
efficiently computable bijection h between [V ]\S and [V −m], we apply an approach similar to Section 6.2.
To this end, we first store the number of keys m′ in [V − m]. This is also the number of non-keys in
{V − m, . . . , V − 1}. We are going to store a mapping that maps all m′ non-keys in {V − m, . . . , V − 1}
to all m′ keys in [V − m].
We then store the above data structure for all keys in [V − m], using
 
V
′
′
′
m lg((V − m)/m ) + O(m + lg lg V ) ≤ lg
+ O(m + lg lg V )
m

bits, which defines a bijection h′ between S ∩ [V − m] and [m′ ]. Note that this data structure also allows us
to “randomly access” all keys. That is, given an index i ∈ [m′ ], it returns a key xi , such that {x1 , . . . , xm′ }
is the set of all m′ keys in [V − m]. Then, we store a rank data structure for {V − m, . . . , V − 1}, such that
given an x ∈ {V − m, . . . , V − 1}, the query algorithm returns if x is a key, as well as its rank over the set
of keys (or non-keys). Hence, it maps all keys in {V − m, . . . , V − 1} to [m − m′ ] and all non-keys to [m′ ].
The total space is OPTV,m + O(m + lg lg V ).
For each x ∈ S, we define h(x) as follows.
• if x < V − m, let h(x) := h′ (x);
• if x ≥ V − m, let h(x) be m′ − 1 plus the rank of x in S ∩ {V − m, . . . , V − 1}.
For x ∈
/ S, we define h(x) as follows.
• if x < V − m, let h(x) := x;
• if x ≥ V − m, suppose the rank of x in {V − m, . . . , V − 1} \ S is i, then let h(x) := xi .
Having stored the above data structures, h(x) or h(x) can be computed in constant time.

74

