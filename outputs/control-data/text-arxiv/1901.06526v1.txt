LA-UR-19-20366

Floating-Point Calculations on a Quantum Annealer:
Division and Matrix Inversion

arXiv:1901.06526v1 [quant-ph] 19 Jan 2019

Michael L Rogers and Robert L Singleton Jr
Los Alamos National Laboratory
Los Alamos, New Mexico 87545, USA
(Dated: Jan 11 2019)

Abstract
Systems of linear equations are employed almost universally across a wide range of disciplines,
from physics and engineering to biology, chemistry and statistics. Traditional solution methods
such as Gaussian elimination become very time consuming for large matrices, and more efficient
computational methods are desired. In the twilight of Moore’s Law, quantum computing is perhaps
the most direct path out of the darkness. There are two complementary paradigms for quantum
computing, namely, gated systems and quantum annealers. In this paper, we express floating
point operations such as division and matrix inversion in terms of a quadratic unconstrained binary
optimization (QUBO) problem, a formulation that is ideal for a quantum annealer. We first address
floating point division, and then move on to matrix inversion. We provide a general algorithm for
any number of dimensions, but we provide results from the D-Wave quantum anneler for 2 × 2
and 3 × 3 general matrices. Our algorithm scales to very large numbers of linear equations. We
should also mention that our algorithm provides the full solution the the matrix problem, while
HHL provides only an expectation value.

1

Contents

I. Introduction

3

II. Floating Point Division on a Quantum Annealer
A. Division as a QUBO Problem
B. Embedding KR onto the D-Wave Chimera Architecture

7
7
9

III. Matrix Inversion as a QUBO Problem

16

IV. Calculations
A. Implementation
1. Note on Solution Normalization and Iteration
B. Results for Division
1. Basic Division Solver
2. Iterated Division Solver
C. Results for Matrix Equations
1. Simple Analytic Problem
2. QUBO Solution Results
D. Discussion

20
20
20
21
21
23
24
25
26
27

A. Matrix Test Problems

33

Acknowledgments

36

References

36

2

I.

INTRODUCTION

Systems of linear equations are employed almost universally across a wide range of disciplines, from physics and engineering to biology, chemistry and statistics. An interesting
physics application is computational fluid dynamics (CFD), which requires inverting very
large matrices to advance the state of the hydrodynamic system from one time step to the
next. An application of importance in biology and chemistry would include the protein
folding problem. For large matrices, Gaussian elimination and other standard techniques
becomes too time consuming, and therefore faster computational methods are desired. As
Moore’s Law draws to a close, quantum computing offers the most direct path forward, and
perhaps the most radical path. In a nutshell, quantum computers are physical systems that
exploit the laws of quantum mechanics to perform arithmetic and logical operations exponentially faster than a conventional computer. In the words of Harrow, Hassidim, and Lloyd
(HHL) [1], “quantum computers are devices that harness quantum mechanics to perform
computations in ways that classical computers cannot.’’ There are currently two complementary paradigms for quantum computing, namely, gated systems and quantum annealers.
Gated systems exploit the deeper properties of quantum mechanics such coherence, entanglement and non-locality, while quantum annealers take advantage of tunneling between
metastable states and the ground state. In Ref. [1], HHL introduces a gated method by
which the inverse of a matrix can be computed, and Refs. [2–4] provide implementations of
the algorithm to invert 2 × 2 matrices. Gated methods are limited by the relatively small
number of qubits that can be entangled into a fully coherent quantum state, currently of
order 32 or so. An alternative approach to quantum computing is the quantum anneler [5],
which takes advantage of quantum tunneling between metastable states and the ground
state. The D-Wave Quantum Annealers have reached capacities of 2000+ qubits, which
suggests that quantum annealers could be quite effective for linear algebra with hundreds
to thousands of degrees of freedom. In this paper, we express floating point operations such
as division and matrix inversion as quadratic unconstrained binary optimization (QUBO)
problems, which are ideal for a quantum annealer. We should mention that our algorithm
provides the full solution the the matrix problem, while HHL provides only an expectation
value. Furthermore, our algorithm places no contraints on the matrix that we are inverting,
such as a sparcity condition.
The first step in mapping a general problem to a QUBO problem begins with constructing
a Hamiltonian that encodes the logical problem in terms of a set of qubits. Next, it will
be necessary to “embed” the problem on the chip, first by mapping each logical qubit to a
collection or “chain” of physical qubits, and then by determining parameter settings for all
the physical qubits, including the chain couplings. We have implemented our algorithms on
3

the D-Wave 2000Q and 2X chips, illustrating that division and matrix inversion can indeed
be performed on an existing quantum annealer. The algorithms that we propose should scale
quite well for large numbers of equations, and should be applicable to matrix inversion of
relatively high order (although probably not exponentially higher order as in HHL).
Before examining the various algorithms, it is useful to review the basic formalism and
to establish some notation. The general problem starts with a graph G = (V, E), where V is
the vertex set and E is the edge set. The QUBO Hamiltonian on G is defined by
HG [Q] =

X

Ar Qr +

r∈V

X

Brs Qr Qs ,

(1.1)

rs∈E

with Qr ∈ {0, 1} for all r ∈ V. The coefficient Ar is called the weight at vertex r, while the
coefficient Brs is called the strength between vertices r and s. It might be better to call (1.1)
the objective function rather than the Hamiltonian, as HG is a real-valued function and not
an operator on a Hilbert-space. However, it is easy to map (1.1) in an equivalent Hilbert
space form,
ĤG =

X

Ar Q̂r +

r∈V

X

Brs Q̂r Q̂s ,

(1.2)

rs∈E

where Q̂r |Qi = Qr |Qi for all r ∈ V, and |Qi ∈ H for Hilbert space H. The hat denotes an
operator on the Hilbert space, and Qr is the corresponding Eigenvalue of Q̂r with Eigenstate
|Qi. Consequently, we can write
ĤG |Qi = HG [Q] |Qi ,

(1.3)

and we use the terms Hamiltonian and objective function interchangeably. By the QUBO
problem, we mean the problem of finding the lowest energy state |Qi of the Hamiltonian (1.2),
which corresponds to minimizing Eq. (1.1) with respect to the Qr . This is an NP-hard
problem uniquely suited to a quantum annealer. Rather than sampling all 2#V possible
states, quantum tunneling finds the most likely path to the ground state by minimizing the
Euclidian action. In the case of the D-Wave 2X chip, the number of distinct quantum states
is of order the insanely large number 21000 , and the ground state is selected from this jungle
of quantum states by tunneling to those states with a smaller Euclidean action.
The Ising model [6] is perhaps the quintessential physical example of a QUBO problem,
and indeed, is one of the most studied systems in statistical physics. The Ising model
consists of a square lattice of spin-1/2 particles with nearest neighbor spin-spin interactions
between sites r and s, and when the system is immersed in a nonuniform magnetic field,

4

FIG. 1: The left panel shows the fully connected graph K8 and the right panel shows the
corresponding graph K4 . To perform a calculation to 8-bit accuracy requires the connectivity of K8 . We take the vertex and edge sets for be K8 to V8 = {0, 1, 2, · · · , 7} and E8 =
{{0, 1}, {0, 2}, · · · , {0, 7}, {1, 2}, {1, 3}, · · · , { 6, 7} }. To perform a calculation to 4-bit accuracy requires K4 connectivity, and similarly, the vertex and edge sets for K4 are V4 = {0, 1, 2, 3} and
E4 = {{0, 1}, {0, 2}, {0, 3}, {1, 2}, {1, 3}, {2, 3}}.

this introduces coupling terms at individual sites r, thereby producing a Hamiltonian of the
form
HG [J] =

X

Br Jr +

r∈V

X

Jrs Jr Js ,

(1.4)

rs∈E

where Jr = ±1/2. The Ising problem is connected to the QUBO problem by Jr = Qr − 1/2.
For floating point division to R bits of resolution, the graph G is in fact just the fully
connected graph KR . In terms of vertex and edge sets, we write KR = (VR , ER ), and Fig. 1
illustrates K8 and K4 . The left panel shows the completely connected graph K8 , with vertex
and edge sets
V8 = {0, 1, 2, · · · , 7}

(1.5)

E8 = {{0, 1}, {0, 2}, · · · , {0, 7}, {1, 2}, · · · , {1, 7}, · · · , { 6, 7} } ,
(1.6)
while the right panel shows the K4 graph,
V4 = {0, 1, 2, 3}

(1.7)

E4 = {{0, 1}, {0, 2}, {0, 3}, {1, 2}, {1, 3}, {2, 3}} .

(1.8)

5

Just as 8-bits is called a word, 4-bits is called a nibble. As we will also see, the dynamic
range of the D-Wave is most directly suitable to K4 , and consequently the connectivity of
K4 gives a quantum nibble.
Let us remark about our summation conventions. Rather than summing over an edge set,
H[Q] =

X

Ar Qr +

r∈VR

=

R−1
X

X

Brs Qr Qs

(1.9)

rs∈ER

Ar Qr +

r=0

R−1 X
R−1
X

Brs Qr Qs ,

(1.10)

r=0 s>r

we find it convenient to sum over all values of r and s taking Brs to be symmetric. In this
case, the double sum differs by a factor of two relative to summing over the edge set of the
graph,
H[Q] =

R−1
X

R−1 X
R−1
X
1

Ar Qr +

r=0 s=0

r=0

2

Brs Qr Qs .

(1.11)

Furthermore, for r = s, there will be a linear contribution from the idempotency condition
Q2r = Qr , so that
H[Q] =

R−1 
X
r=0


R−1 X
R−1
X
1
1
Ar + Brr Qr +
Brs Qr Qs .
2
2
r=0 s6=r,s=0

(1.12)

We can write this as
H[Q] =

R−1
X

Ãr Qr +

R−1 X
R−1
X
r=0 s6=r,s=0

r=0

6

B̃rs Qr Qs .

(1.13)

II.

FLOATING POINT DIVISION ON A QUANTUM ANNEALER
A.

Division as a QUBO Problem

In this section we present an algorithm for performing floating point division on a quantum annealer. Given two input parameters m and y to R-bits of resolution, the algorithm
calculates the ratio y/m to R bits of resolution. The corresponding division problem can be
represented by the linear equation
m·x−y =0 ,

(2.1)

x = y/m .

(2.2)

which has the unique solution

Solving (2.1) on a quantum annealer amounts to finding an objective function H(x) whose
minimum corresponds to the solution that we are seeking, namely (2.2). Although the form
of H(x) is not unique, for this work we employ the simple real-valued quadratic function
2
H(x; m, y) = m x − y ,
(2.3)
where m and y are continuous parmeters. For an ideal annealer, we do not have to concern
ourselves with the numerical range and resolution of the parameters m and y; however, for a
real machine such as the D-Wave, this is an important consideration. For a well-conditioned
matrix, we require that the parameters m and y possess a numerical range that spans about
an order of magnitude, from approximately 0.1 to 1.0. This provides about 3 to 4 bits of
resolution: 1/20 = 1, 1/21 = 0.5, 1/22 = 0.25, and 1/23 = 0.125. The dynamic range and
the connectivity both impact the resolution of a calculation.
To proceed, let us formulate floating point division as a quadratic unconstrained binary
optimization (QUBO) problem. The algorithm starts by converting the real-valued number
x in (2.3) into an R-bit binary format, while the numbers m and y remain real valued
parameters of the objective function. For any number χ ∈ [0, 2), the binary representation
accurate to R bits of resolution can be expressed by [Q0 .Q1 Q2 · · · QR−1 ]2 , where Qr ∈ {0, 1}
is value of the r-th bit, and the square bracket indicates the binary representation. 1 It is
more algebraically useful to express this in terms of the power series in 2−r ,
χ =

R−1
X

2−r Qr .

(2.4)

r=0

1

P∞
Since the infinite geometric series r=0 2−r sums to 2, the finite series is less than 2. In binary form we
have [1.11 · · · ]2 = 2 and [1.11 · · · 1]2 < 2. Working to resolution R is like calculating the R-th partial sum
of an infinite series.

7

In order to represent negative number, we perform the binary offset
x = 2χ − 1 ,

(2.5)

where x ∈ [−1, 3). The objective function now takes the form
H(χ) = 4m2 χ2 − 4m(m + y)χ + (m + y)2 .

(2.6)

The constant term (m + y)2 can be dropped when finding the minimum of (2.6), but we
choose to keep it for completeness. Equation (2.4) provides a change of variables χ = χ[Q]
(where Q is the collection of the Qr ), and this allows us to express (2.3) in the form
H[Q] =

R−1
X

Ar Qr +

R−1 X
R−1
X

r=0

Brs Qr Qs .

(2.7)

r=0 s6=r,s=0

In the notation of graph theory, we would write
H[Q] =

X

Ar Qr +

r∈VR

X 1
Brs Qr Qs ,
2
rs∈E

(2.8)

R

where VR = {0, 1, 2, · · · , R − 1} is the vertex set, and ER is the edge set. We often employ
an abuse of notation and write rs ∈ ER to mean {r, s} ∈ ER . We should also use the
notation B{r,s} , but instead we write Brs . Since the order of the various elements of a set are
immaterial, we require Brs to be symmetric in r and s. Rather than summing over the edge
P
sets rs ∈ ER , we employ the double sum r6=s , which introduces a relative factor of two in
the convention for the strengths Brs . The goal of this section is to find Ar and Brs in terms
of m and y.
Note that we can generalize the simple binary offset (2.4) if we scale and shift χ ∈ [0, 2)
by
x = cχ − d ,

(2.9)

so that x ∈ [−d, 2c − d). When d > 0 and c > d/2, the domain of x always contains a
positive and negative region, and the precise values for d and c can be chosen based on the
specifics of the problem. For Eq. (2.9), the objective function takes the form
H(χ) = 4m2 c2 χ2 − 4mc (m + y)χ + (md + y)2 .

(2.10)

For simplicity of notation, this paper employs the simple binar offset (2.5), although our
Python interface to the D-Wave quantum annealer employs the generalized form (2.10).

8

Equation (2.4) allows us to express the quadratic term in χ as
χ2 =

R−1 X
R−1
X

2−r−s Qr Qs =

r=0 s=0

R−1 X
R−1
X

2−r−s Qr Qs +

R−1
X

r=0 s6=r,s=0

2−2r Qr ,

(2.11)

r=0

where we have used the idempotency condition Q2r = Qr along the diagonal in the last term
of (2.11). Substituting the forms (2.4) and (2.11) into (2.6) provides the Hamiltonian
H[Q] =

R−1
X

R
R−1
h
i
X
X
−r
4m 2 m 2 − (y + m) Qr +
4m2 2−r−s Qr Qs ,
−r

(2.12)

r=0 s6=r,s=0

r=0

and the Ising coefficients in (2.7) can be read off:
h
i
Ar = 4m 2−r m 2−r − (y + m)
Brs = 4m2 2−r−s

r 6= s .

(2.13)
(2.14)

Because of the double sum over r and s in the objective function in (2.12), the algorithm
requires a graph of connectivity KR . The special cases of K8 and K4 have been illustrated in
Fig. 1. To obtain higher accuracy than the KR graph allows, we can iterate this procedure
in the following manner. Suppose we start with y0 = y, and we are given a value yn−1 with
n > 1, then we advance the iteration to yn in the following manner,
solve mxn = yn−1 for xn to R bits
calculate the error yn = yn−1 − mxn .

(2.15)
(2.16)

Now that we have the value yn , we can repeat the process to find yn+1 , and we can stop the
iterative procedure when the desired level of accuracy has been achieved.

B.

Embedding KR onto the D-Wave Chimera Architecture

The D-Wave Chimera chip consists of coupled bilayers of micro rf-SQUIDs overlaid in
such a way that, while relatively easy to fabricate, results in a fairly limited set of physical
connections between the qubits. However, by chaining together well chosen qubits in a
positively correlated manner, this limitation can largely be overcome. The process of chaining
requires that we (i) embed the logical graph onto the physical graph of the chip (for example
K4 onto C8 ) and that we (ii) assign weights and strengths to the physical graph embedding
in such as a way as to preserve the ground state of the logical system. These steps are called
graph embedding and Hamiltonian embedding, respectively.
9

FIG. 2: The left panel illustrates the bipartate graph C8 in column format, while the right panel
illustrates the corresponding graph in cross format, often called a Chimera graph. The gray lines
represent direct connections between qubits. The cross format is useful since it minimizes the
number intersecting connections. The use of red and blue dots emphasize the bipartate nature
of C8 , as every red dot is connected to every blue dot, while none of the red and blue dots are
connected to one another. The vertex set of C8 is taken to be V8 = {1, 2, · · · , 8} and edge set is
B8 = {{1, 5}, {1, 6}, {1, 7}, {1, 8}, {2, 5}, {2, 6} · · · {7, 8}}.

FIG. 3: The the left panel shows the connectivity between four C8 bipartate Chimera zones, and
the right panel illustrates how multiple C8 graphs are stitched together along the vertical and
horizontal directions to provide thousands of possible qubits. A limitation of this connectivity
strategy is that red and blue zones cannot communicate directly with one another, as indicated by
the black crossed arrows. The purpose of chaining is to allow communication between the read and
blue qubits.

Let us explore the connectivity of the D-Wave Chimera chip in more detail. The D-Wave
architecture employs the C8 bipartate Chimera graph as its most basic unit of connectivity.
This unit cell is illustrated in Fig. 2, and consists of 8 qubits connected in a 4 × 4 bipartate
manner. The left panel of the figure uses a column format in laying out the qubits, and the

10

right panel illustrates the corresponding qubits in a cross format, where the gray lines represent the direct connections between the qubits. The cross format is useful since it minimizes
the number intersecting connections. The complete two dimensional chip is produced by
replicating C8 along the vertical and horizontal directions, as illustrated in Fig. 3, thereby
providing a chip with thousands of qubits. The connections between qubits are limited in
two ways: (i) by the connectivity of the basic unit cell C8 and (ii) by the connectivity between the unit cells across the chip. The bipartate graph C8 = (V8 , B8 ) is formally defined
by the vertex set V8 = {1, 2, · · · , 8}, and the edge set
B8 =



{1, 5}, {1, 6}, {1, 7}, {1, 8}, {2, 5}, {2, 6}, {2, 7}, {2, 8},
{3, 5}, {3, 6}, {3, 7}, {3, 8}, {4, 5}, {4, 6}, {4, 7}, {4, 8} .

(2.17)

The set B8 represents the connections between a given red qubit and the corresponding blue
qubits in the Figures. The red and blue dots illustrate the bipartate nature of C8 , as every
red dot is connected to every blue dot, while none of the blue and red dots are connected to
one another.
We will denote the physical qubits on the D-Wave chip by q` . For the D-Wave 2000Q
there is a maximum of 2048 qubits, while the D-Wave 2X has 1152 qubits. For the example
calculation in this text, we only use 10 to 50 qubits. The physical Hamiltonian or objective
function takes the form
H[q] =

X
`

a` q ` +

X

2b`m q` qm ,

(2.18)

`6=m

where we have introduced a factor of 2 in the strength to account for the symmetric summation over r and s. We will call the qubits Qr of the previous section the logical qubits.
To write a program for the D-Wave means finding an embedding of the logical problem onto
the physical collection of qubits q` . If the connectivity of the Chimera graphs were large
enough, then the logical qubits would coincide exactly with the physical qubits. However,
since the graph C8 possesses less connectivity than K4 , we must resort to chaining on the
D-Wave, even for 4-bit resolution. Figure 4 illustrates the K4 embedding used by our algorithm, where, as before, the left panel illustrates the bipartate graph in column format, and
the right panel illustrates the corresponding graph in cross format.
In Fig. 4 we have labeled the physical qubits by ` = 1, 2, 3 · · · 8, and we wish to map the
logical problem involving Qr Qs Qt onto the four physical qubits q5 q1 q6 q2 . The embedding
requires that we chain together the two qubits 1-6 and 3-8, respectively. We may omit
qubits 4 and 7 entirely. As illustrated in Fig. 5, the physical qubits q1 and q6 are chained
together to simulate a single logical qubit Qt , while qubits q5 and q2 are mapped directly
11

FIG. 4: The K4 embedding onto C8 used in our implementation of 4-bit of division on the D-Wave.
The blue lines represent normal connections between qubits, while the red double-lines represent
chained qubits, that is to say, qubits that are strictly correlated (and can thereby represent a single
logical qubit at a higher level of abstraction). The qubits 1-6 are chained together, as are the qubits
3-8.

FIG. 5: The left panel shows three logical qubits Qr , Qs , Qt with connectivity between r-t and t-s.
The box surrounding qubit t means that it will be modeled by a linear chain of physical qubits,
as illustrated in the right panel. The labeling is taken from Fig. 4 for qubits 5-1-6-2, where Qr is
mapped to q5 , Qs is mapped to q2 , and Qt is split between q1 nd q6 . Qubits q1 and q6 are chained
together to simulate the single logical qubit Qt , while qubits Qr and Qs map directly onto physical
qubits q5 and q2 .

to the logical qubits Qr and Qs , respectively. Qubit q5 is assigned the weight a5 = Ar and
the coupling between q5 and q1 is assigned the value b51 = Brt . Similarly for qubit q2 , the
vertex is assigned weight a2 = As , and strength between q2 and q6 is b26 = Bst . We must
now distribute the logical qubit Qt between q1 and q6 by assigning the values a1 , a6 and
b16 . We distribute the weight At uniformly between qubits q1 and q2 , giving a1 = At /2 and
a6 = At /2. We must now choose b16 . To preserve the energy spectrum, we must shift the
12

TABLE I: For two qubits the counter-term Hamiltonian is H CT (q1 , q6 ) = a q1 + a q6 + 2b q1 q6 . The
lowest energy state is preserved for b = −α and a = α where α > 0. We will split the weight
At uniformly across the N chained physical qubits, thereby giving a contribution to the physical
t = A /2 + α q + α q − 2α q q . The energy spectrum ensures that the two qubits
Hamiltonian H16
t
1
6
1 6
are strictly correlated.
q1

q6

H CT

0
0
1
1

0
1
0
1

0
α
α
0

values of the weights a1 and a6 . We can do this by adding a counter-term Hamiltonian
H CT = a q1 + a q6 + 2b16 q1 q6

(2.19)

to the physical Hamiltonian. The double lines in Figs. 4 and 5 indicate that two qubits are

FIG. 6: Generalization of Fig. 5 to a chain of N linear qubits. The right panel illustrates the chain
coupling parmeters used to create strict correlations of the physical qubits within the chain.

chained together. This means that the qubits are strictly correlated, i.e. when q1 is up then
q6 is up, and when q1 is down then q6 is down. This is accomplished by choosing the coupling
strength b16 to favor a strict correlation; however, to preserve the ground state energy, this
also requires shifting the weights for q1 and q6 . For q1 = q6 = 0 we have H CT = 0. We wish
to preserve this condition when q1 = q6 = 1, which means 2a + 2b = 0. Furthermore, the
state q1 = 1 and q6 = 0 must have positive energy, which means a > 0. Similarly for q1 = 0
and q6 = 1. We therefore choose a1 = a6 = α > 0 and b16 = −α, where α is an arbitrary
parameter. This is illustrated in Table. I. A more complicated case is the linear chain of N
qubits as shown in Fig. 6. The counter-term Hamiltonian is taken to be
H

CT

=

N
X
m=1

t
atm qm

+

N
−1
X
m=1

13

t t
btm,m+1 qm
qm+1 .

(2.20)

Note that H CT vanishes when qm = 0 for all m = 1 · · · N . And conversely, we must arrange
the counter-term to vanish when qm = 1. The simplest choice is to take all weights to be the
same and all couplings to be identical. Then, to preserve the ground state when the qr = 1,
we impose
atr =

At 2(N − 1)
+
α
N
N

(2.21)

btr,r+1 = −α

(2.22)

with α > 0 and r = 1 · · · N . The first term in atr distributes the weight At uniformly across
all N nodes in the chain. The second set of terms btr,r+1 ensures that the qubits of the chain
are strictly correlated. The counter-term energy is positive and is therefore selected against
when the linearly chained qubits are not correlated. Table II illustrates the spectrum of the
counter-term Hamiltonian for three qubits. We often need to choose large values of α, of
order 20 or more, to sufficiently separate the states. The uniform spectrum of 4 states with
H CT = a in Table II arises from a permutation symmetry in q1 , q2 , q3 .
TABLE II: For a three qubit chain the counter-term Hamiltonian is H CT (q1 , q2 , q3 ) = a q1 + a q2 +
a q3 +2b q1 q2 +2b q2 q3 , where a = 4α/3 and b = −α. The degeneracy in energy of value a arises from
a permutation symmetry in q1 → q2 → q3 that preserves the form of the counter-term Hamiltonian.
q1

q2

q3

H CT

0
0
0
0
1
1
1
1

0
0
1
1
0
0
1
1

0
1
0
1
0
1
0
0

0
4α/3
4α/3
2α/3
4α/3
8α/3
2α/3
0

0
a
a
a/2
a
2a
a
0

To review, note that a linear counter-term is represented in Fig. 6. We add a counter-term
to break the logical qubits into a chain of physical qubits that preserve the ground state.
Let us consider the conditions that we place on the Hamiltonian to ensure strict correlation
between the chained qubits. We adjust the values of Ar and Brs to ensure that spin alignment
is energetically favorable. By slaving several qubits together, we can overcome the limitations
of the Chimera connectivity. As a more complex example, consider the four logical qubits
of Fig. 7 connected in a circular chains by strengths B12 , B24 , B43 , and B31 . Suppose the
weights are A1 , A2 A3 and A4 . Figure 8 provides an example in which each logical qubit is
chained in a linear fashion to the physical qubits.
14

FIG. 7: Four logical qubits Q1 , Q2 , Q3 , Q4 in a circular loop with connection strengths B12 , B24
B43 and B31 .

FIG. 8: A possible mapping of the logical qubits in Fig. 7 onto the physical device. Each logical
qubit is modeled by a linear chain of strictly correlated qubits.

15

III.

MATRIX INVERSION AS A QUBO PROBLEM

In this section we present an algorithm for solving a system of linear equations on a
quantum annealer. To precisely define the mathematical problem, let M be a nonsingular
N × N real matrix, and let Y be a real N dimensional vector; we then wish to solve the
linear equation
M ·x=Y .

(3.1)

The linearity of the system means that there is a unique solution,
x = M −1 · Y ,

(3.2)

and the algorithm is realized by specifying an objective function whose ground state is
indeed (3.2). The objective function is not unique, although it must be commensurate with
the architecture of the hardware. If the inverse matrix itself is required, it can be constructed
by solving (3.1) for each of the N linearly independent basis vectors for Y. It is easy to
construct a quadratic objective H(x) whose whose minimum is (3.2), namely
2
T

H(x) = M x − Y = M x − Y · M x − Y .
(3.3)
In terms of matrix components, this can be written
H(x) = xT M T M x − xT M T Y − YT M x + YT Y
N
X

=

i j

Mki Mkj x x − 2

N
X

Yj Mji xi + kYk2 .

(3.4)

ij=1

ijk=1

Note that kYk2 is just a constant, which will not affect the minimization. In principle
all constants can be dropped from the objective function, although we choose to keep
them for completeness. One may obtain a floating point representation of each component
of x = (x1 , · · · , xN )T by expanding in powers of 2 multiplied by Boolean-valued variables
qri ∈ {0, 1},
R−1
X

2−r qri

(3.5)

x = 2χi − 1 .

(3.6)

i

χ =

r=0
i

As before, the domains are give by χi ∈ [0, 2) and xi ∈ [−1, 3), and upon expressing x as a
function the qri we can recast (3.4) in the form
H[q] =

N X
R−1
X
i=1 r=0

air qri +

N X
N X
R−1 X
R−1
X
i=1 i6=j=1 r=0 s=0

16

i j
bij
rs qr qs .

(3.7)

The coefficients air are called the weights and the coefficients bij
rs are the interaction strengths.
Note that the algorithm requires a connectivity of KNR .
Let us first calculate the product xi xj in (3.4). From (3.5) and (3.6) we find
!
!
R−1
R−1
X
X
0
xi xj = 2
2−r qri − 1
2
2−r qri 0 − 1
r0 =0

r=0

= 4

X

0

X

0

X

2−(r+r ) qri qrj0 − 4

rr0

= 4

2−r qri + 1

(3.8)

r

X

2−(r+r ) qri qrj0 + 4

r6=r0

2−2r qri − 4

X

2−r qri + 1 ,

(3.9)

r

r

where we have used the idempotency condition (qri )2 = qri in the second term of (3.9). While
the second form is one used by the code, it is more convenient algebraically to use the first
form. Substituting (3.8) into the first term in (3.4) gives
X
H1 ≡
Mki Mkj xi xj
(3.10)
ijk

(
=

X

Mki Mkj

)

4

X

2

qri qrj0 − 4

X

rr0

ijk

= 4

−(r+r0 )

XXX
ir

js

2−r qri + 1

(3.11)

r

2−r−s Mki Mkj qri qsj − 4

XX
ir

k

2−r Mki Mki qri +

X

Mki Mkj . (3.12)

ijk

k

The second term in (3.4) can be expressed as
!
H2 ≡ −2

X

Yj Mji xi = −2

ij

= −4

X

Yj Mji 2

X

2−r Mji Yj qri + 2

X

r

ij

Yj Mji .

(3.14)

ij

Adding H1 and H2 gives
XXX
XX
H = 4
2−r−s Mki Mkj qri qsj − 4
2−r Mki Mki qri
ir

−4

js

ij

ir

k

XX

(3.13)

r

ij

XX

2−r qri − 1

2−r Mji Yj qri + 2

r

X
ij

Yj Mji +

(3.15)

k

X

Mki Mkj .

(3.16)

ijk

The Ising terms are therefore
(
air = 4 · 2−r

X

Mki


)
X
2−r Mki − Yk +
Mkj
j

k
−(r+s)
bij
rs = 4 · 2

(3.17)

X

Mki Mkj .

k

17

(3.18)

The physical qubits in are accessed by a 1-dimensional linear index, while the logical qubits
in are defined in terms of the 2-dimensional indicies i and r, where i = 0, 1, · · · , N − 1 and
r = 0, 1, · · · , R − 1. To map the logical qubits onto the physical qubits, we re-parameterize
the logical qubits by a single index ` = 0, 1, · · · , N R − 1. Now we define a 1-1 mapping
between these indices and the linear index ` = 0, 1, · · · , N · R − 1. This is just an ordinary
linear indexing for 2-dimensional matrix elements, so we choose the usual row-major linear
index mapping,
`(i, r) = i · R + r

(3.19)

M` = Mir .

(3.20)

The inverse mapping gives the row and column indices as below,
i` = b`/Rc

(3.21)

r` = ` mod R ,

(3.22)

where bnc is the greatest integer less than or equal to n. The expression “` mod R” is `
modulo R. This is a 1-1, invertible mapping between each pair of values of i and r in the
matrix index space to every value of ` in the linear qubits index space. We can simply replace
sums over all index pairs i, r by a single sum over `, provided we also rewrite any isolated
indices in i and r as functions of ` via their inverse mapping.
We may summarize this observation in the following formal identity. Given some arbitrary
quantity, A, that depends functionally upon the tuple (i, r), and possibly upon the individual
indices i and r, it is trivial to verify that,
A[(i, r), i, r] =

NX
·R−1

A[`, i` , r` ] δi,i` δrr` ,

(3.23)

`=0

where `, i` , and r` are related as in equations (3.19)-(3.22). This identity is useful for formal
derivations. For example, we may use it to quickly derive the binary expansion of xi in terms
of logical qubits. Inserting (3.23) into (3.6) gives,
!
R−1
NX
·R−1
X
xi = 2
2−r
q` δi i` δr r` − 1
r=0

= 2

NX
·R−1

`=0

2−r` q` δi,i` − 1 .

(3.24)

`=0

Clearly, xi has non-zero contributions only for those indices corresponding to i = i` = b`/Rc,
that is, only from those qubits within a row in the qri array. Also, those contributions are
18

summed along that row, i.e., over r` = ` mod R. This equation will be used to reconstruct
the floating-point solution, x, from the components q` of the binary solution returned from
the D-Wave annealing runs. The weights and strengths now become
(
)
X
X
Mkj )
a` = 4 · 2−r`
Mk i` 2−r` Mk i` − (Yk +
k

b`m = 4 · 2−(r` +r`0 )

(3.25)

j

X

Mk i` Mk im .

(3.26)

k

For a 2 × 2 matrix to 4-bit accuracy, we need K8 (4 × 2 = 8), and to 8-bit accuracy we need
K16 (8 × 2 = 16). We have inverted matrices up to 3 × 3 to 4-bit accuracy, which requires
K12 (3 × 4 = 12). For an N × N matrix with R bits of resolutions, we must construct linear
embeddings of KRN . We could generalize this procedure for complex matrices.

19

IV.
A.

CALCULATIONS
Implementation

The methods above were implemented using D-Wave’s Python SAPI interface and tested
on a large number of floating-point calculations. Initially, we performed floating-point division on simple test problems with a small resolution. Early on, we discovered that larger
graph embeddings tended to produce noisier results. To better understand what was happening we started with a K8 graph embedding to represent two floating-point numbers with
only four bits of resolution. Since the D-Wave’s dynamic range is limited to about a factor of
10 in the scale of the QUBO parameters, we determined that we could expect no more than
3 to 4 bits of resolution from any one calculation in any event. However, our binary offset
representation (3.5) implies that we should expect no more than 3 bits of resolution in any
single run. Indeed, using the K8 embedding, we were able to get exact solutions from the
annealer for any division problems which had answers that were multiples of 0.25, between
-1.0, and 1.0. Problems in this range which had solutions that were not exact multiples
of 0.25 resulted in approximate solutions, effectively “rounded” to the nearest of ±0.25 or
±0.75. At this point we implemented an iterative scheme that uses the current error, or
residual, as a new input, keeping track of the accumulated floating-point solution.
The iteration method has been implemented and tested for floating-point division but we
have not yet implemented iteration for matrix inversion. That can be done by using the
previous residual (error) as the new inhomogeneous term in the matrix equation. We plan
to implement an iterative method in the matrix inversion code soon. However, we already
have good preliminary results on matrix inversion that encourages us that this should work
reasonably well, at least for well-conditioned matrices. Currently, we are able to solve 2 × 2
and 3 × 3 linear equations involving floating-point numbers up to a resolution of 4 bits, and
having well-conditioned matrices, exactly for input vectors with elements defined on [−1, 1]
and that are multiples of 0.25. Using an example matrix that is poorly-conditioned, we
find that it is generally not possible to get the right answer without first doing some sort of
pre-conditioning to the matrix. But more importantly, we were able to obtain some insight
about why ill-conditioned matrices can be difficult to solve as QUBO problems on a quantum
annealer, which gives some hints about how to ameliorate the problem. We will discuss these
results, and the effects of ill-conditioning on the QUBO matrix inverse problem below.

1.

Note on Solution Normalization and Iteration

Allowing both the division and linear equation QUBO solvers to work for arbitrary
floating-point numbers, and to allow for iterative techniques, requires normalizing the ratio
20

of the current dividend and the divisor, or the residual and matrix, to a value in a range
between −1 and 1. For the division problems, we wanted to avoid “dividing in order to
divide”, so we normalized each ratio using the difference between the binary exponents of
bdivisorc and bdividendc. These can be found just by using order comparisons, with no
explicit divisions. Adding 1 to this yields an “offset” - the largest binary exponent of the
ratio - to within a factor of 2 (±1 in the offset), which is sufficient for scaling our QUBO
parameters as needed. The fact that our QUBO solutions are always returned in binary
representation provides a simple way to bound the solution into a range solvable with the
annealer by simply shifting the binary representation of the current dividend by a few bits
(using the current offset), which is why we refer to the solution exponent as an “offset”. In
this way, the solution can easily be guaranteed to be in the correct range without having
to perform any divisions in Python. The “offset” is accumulated and used to construct the
current approximation to the floating-point solution on each iteration. The iteration process
continues until the error of the approximate solution is less than some tolerance specified by
the user.

B.

Results for Division

First, we present some examples for division without iteration. We used a K4 graph
embedding for expanding the unknown x up to a resolution of 4 bits. However using the
binary offset representation we can only get a true precisions of 3 bits. We solved the simple
division problem,
x =

1.

y
.
m

(4.1)

Basic Division Solver

Table III gives an extensive list of tested exact solutions returned by the floating-point
annealing algorithm on the D-Wave machine using the K4 graph embedding with an effective
binary resolution of 3, corresponding to the multiples of 0.25 in the range [−1, 1]. The
“Ground State” column lists the raw binary vector solutions, corresponding to the expansion
in Eq (2.5). It is easy to check from Eqs. (2.5) and (2.4) that these give the floating-point
solutions found in the corresponding “D-Wave Solution” column. In all of these cases, values
of α ≥ 0.5 yielded the solution exactly; however, α is set to 20.0 here because that gives a
better approximate solution for the inexact divisions, and faster convergence for the iterated
divisions. It does not change the solutions for the exact cases.
21

TABLE III: Exact Quantum Annealed Division Problems to 3-bit Resolution.
Division Problems with Exact D-Wave Solutions
y

m

x, Exact

x, D-Wave

Ground State

Energy

α

1.00

1.0

1.00

1.00

[1,0,0,0]

-2.0

20.0

0.50

0.5

1.00

1.00

[1,0,0,0]

-2.0

20.0

1.00

-1.0

-1.00

-1.00

[0,0,0,0]

0.0

20.0

-1.00

1.0

-1.00

-1.00

[0,0,0,0]

0.0

20.0

0.50

-0.5

-1.00

-1.00

[0,0,0,0]

0.0

20.0

-0.50

0.5

-1.00

-1.00

[0,0,0,0]

0.0

20.0

0.75

1.0

0.75

0.75

[0,1,1,1]

-1.53125

20.0

-0.75

1.0

-0.75

-0.75

[0,0,0,1]

-0.03125

20.0

0.75

-1.0

-0.75

-0.75

[0,0,0,1]

-0.03125

20.0

0.50

1.0

0.50

0.50

[0,1,1,0]

-1.125

20.0

-0.50

1.0

-0.50

-0.50

[0,0,1,0]

-0.125

20.0

0.50

-1.0

-0.50

-0.50

[0,0,1,0]

-0.125

20.0

0.25

1.0

0.25

0.25

[0,1,0,1]

-0.78125

20.0

-0.25

1.0

-0.25

-0.25

[0,0,1,1]

-0.28125

20.0

0.25

-1.0

-0.25

-0.25

[0,0,1,1]

-0.28125

20.0

0.25

0.5

0.50

0.50

[0,1,1,0]

-1.125

20.0

-0.25

0.5

-0.50

-0.50

[0,0,1,0]

-0.125

20.0

0.25

-0.5

-0.50

-0.50

[0,0,1,0]

-0.125

20.0

0.00

±1.00

0.00

0.00

[0,1,0,0]

-0.5

20.0

0.00

±0.75

0.00

0.00

[0,1,0,0]

-0.5

20.0

0.00

±0.50

0.00

0.00

[0,1,0,0]

-0.5

20.0

0.00

±0.25

0.00

0.00

[0,1,0,0]

-0.5

20.0

Table IV lists some illustrative division problems on [−1, 1] that do not have solutions
which are multiples of ±0.25, and therefore are not solved exactly by the quantum annealing
algorithm to 3 bits of resolution. Note that the energies are different for the ground states
because the Hamiltonians are somewhat different for these problems. The “rounding” here
occurs naturally in the quantum annealing algorithm as the annealer settles into the lowest
energy ground state that approximates the solution. The last four problems are “challenge”
problems for the iterated division solver.

22

TABLE IV: “Rounded” Quantum Annealed Division Solutions to 3-bit Resolution.
Division Problems with Approximate D-Wave Solutions
y

m

x, Exact

x, D-Wave

Ground State

Energy

α

0.90

1.0

0.90

1.00

[1,0,0,0]

-1.8

20.0

-0.90

1.0

-0.90

-1.00

[0,0,0,0]

0.0

20.0

0.80

1.0

0.80

0.75

[0,1,0,0]

-1.6875

20.0

-0.80

1.0

-0.80

-0.75

[0,0,0,1]

-0.01875

20.0

0.70

1.0

0.70

0.75

[0,1,0,0]

-1.44375

20.0

-0.70

1.0

-0.70

-0.75

[0,0,0,1]

-0.04374

20.0

0.60

1.0

0.60

0.50

[0,1,1,0]

-1.275

20.0

-0.60

1.0

-0.60

-0.50

[0,0,1,0]

-0.075

20.0

0.40

1.0

0.40

0.50

[0,1,1,0]

-0.975

20.0

-0.40

1.0

-0.40

-0.50

[0,0,1,0]

-0.175

20.0

0.30

1.0

0.30

0.25

[0,1,0,1]

-0.84375

20.0

-0.30

1.0

-0.30

-0.25

[0,0,1,1]

-0.24375

20.0

0.20

1.0

0.20

0.25

[0,1,0,1]

-0.71875

20.0

-0.20

1.0

-0.20

-0.25

[0,0,1,1]

-0.31875

20.0

0.10

1.0

0.10

0.00

[0,1,0,0]

-0.6

20.0

-0.10

1.0

-0.10

0.00

[0,0,1,1]

-0.4

20.0

0.30

0.9

0.3̄

0.25

[0,1,0,1]

-0.88542

20.0

-0.30

0.9

-0.3̄

-0.25

[0,0,1,1]

-0.21875

20.0

1.0

7.0

0.25

[0,1,0,1]

-0.64732

20.0

-1.0

7.0

¯
0.142875
¯
-0.142875

-0.25

[0,0,1,1]

-0.36161

20.0

2.

Iterated Division Solver

Table V lists a few example division problems returned from the iterated quantum annealing solver. These are problems selected from both Tables III and IV to illustrate the
nature of the solutions returned for both cases. These problems were iterated to an error
tolerance of 1.0 × 10−6 . The four “challenge” problems from Table IV can now be solved
with the iterative method. The ground state is no longer given since the solution is generally
the concatenation of multiple binary vectors for every iteration. Instead, the number of
iterations is listed in the last column. Note that some of the energies are the same for the
solutions of different problems. We have also left out an “Energy” column, since it only was
calculated for the partial solution from the last iteration.

23

TABLE V: Iterated Quantum Annealed Division Problems to Resolution 1.0 × 10−6 .
Iterated Division Problems on the D-Wave Annealer
y

m

x, Exact

x, D-Wave

α

Iterations

0.25

1.0

0.25

0.25

20.0

1

-0.25

1.0

-0.25

-0.25

20.0

1

0.50

1.0

0.50

0.50

20.0

1

-0.50

1.0

-0.50

-0.50

20.0

1

0.75

1.0

0.75

0.75

20.0

1

-0.75

1.0

-0.75

-0.75

20.0

1

0.80

1.0

0.80

0.799999

20.0

5

-0.80

1.0

-0.80

-0.799999

20.0

5

0.70

1.0

0.70

0.700000

20.0

5

-0.70

1.0

-0.70

-0.700000

20.0

5

0.10

1.0

0.10

0.999999

20.0

5

-0.10

1.0

-0.10

-0.999999

20.0

5

0.30

0.9

0.3̄

0.333333

20.0

10

-0.30

0.9

-0.3̄

-0.333333

20.0

10

1.0

7.0

0.1248751

20.0

7

-1.0

7.0

¯
0.142875
¯
-0.142875

-0.1248751

20.0

7

C.

Results for Matrix Equations

Note that we have occasionally been somewhat loose in calling this “matrix inversion”,
since we are technically solving the linear equations, rather than directly inverting the matrices. However, for the problems considered here, we may simply obtain the solutions to
the equations using trivial orthonormal eigenvectors such as (1, 0) and (0, 1), in which case
the inverse of the matrix will just be the matrix having those solutions as columns.
The linear equation algorithm was implemented and used to solve several 2 × 2 and 3 × 3
matrices on the D-Wave quantum annealer. Floating-point numbers are represented using
the same offset binary representation as was used for the division problems. Thus, there are 4
qubits per floating-point number. As in the previous section, this gives an effective resolution
of 3 bits for floating-point numbers defined on [−1, 1]. In this case, however, we employed
the normalization technique discussed in the the division iteration to allow solutions with
positive and negative floating-point numbers with larger magnitudes than 1. But, in these
problems we still use solution values with relatively small magnitudes, and within an order
of magnitude of each other for all solution vector elements. All of the cases shown here
are matrix equations with exact solutions, in which case the values of the solution vector
24

elements are multiples of 0.25. This suggests that we could have the iterative solver for the
matrix inversion working very soon.
In general, every qubit constituting a floating-point number may be coupled to every
other qubit for the same number. In turn, every logical qubit may be connected to every
other logical qubit, which implies that every qubit in the logical qubit representation of
the problem, may be coupled to every other logical qubit in the problem. Therefore, the
linear solution algorithm is implemented using a K8 graph embedding to solve 2 × 2 matrix
equations, having a 2 dimensional solution vector with 4 qubits per element, and using a K12
graph embedding to solve 3 × 3 matrix equations, having a 3 dimensional solution vector
with 4 qubits per element.
Most of these solutions involve well-conditioned matrices; however, one does not generally
find a feasible solution when using an ill-conditioned matrix. This is illustrated in two cases,
one with a of a 2 × 2 matrix another with a 3 × 3 matrix. We were able to obtain the correct
solutions by pre-conditioning these matrices before converting to QUBO form, however the
3 × 3 matrix, still had a nearly degenerate ground state and required a very large chaining
penalty α to get the correct solution. This is analyzed and discussed in detail below.

1.

Simple Analytic Problem

Recalling equation (3.1), we shall obtain solutions x of the following matrix equation,
M · x = Y,

(4.2)

using values of M and Y listed in the Appendix. Here we present the first two tests as an
example. Consider the following matrix,

M =

1
2

3
2

3
2

1
2


.

(4.3)

We can solve equation (3.1) for M , with the following two Y vectors,
 
 
1
0
Y1 =   , Y2 =   .
0
1

(4.4)

The exact solutions are,

x1 = 

− 14
3
4





 , x2 = 

25

3
4

− 14


.

(4.5)

We may obtain M −1 simply as,

M −1 = 

− 14
3
4

3
4

− 14


(4.6)



In the next section we summarize all of the solutions obtained by the DWave for all of our
test problems.

2.

QUBO Solution Results

The solutions for the 2 × 2 linear solves are presented in Table VI. Notice that all of
the test problems are presented with α = 20.0 except for the last two. This was done to
illustrate the affect of pre-conditioning for the ill-conditioned case. However, for this example,
the difference disappeared above α = 2.0, and both began to give incorrect answers below
α = 1.5. This is in contrast to the 3 × 3 matrix solution cases, which are evidently more
sensitive to condition number than the 2 × 2 tests.
TABLE VI: 2 × 2 Matrix Equation Solutions to 3-bit Resolution.
Division Problems with Approximate D-Wave Solutions
Test

Exact Solution D-Wave Solution Ground State

Energy

α

1(a)

(−0.25, 0.75)

(−0.25, 0.75)

[0,0,1,1,0,1,1,1]

−2.167

20.0

1(b)

( 0.75, −0.25)

( 0.75, −0.25)

[0,1,1,1,0,0,1,1]

−2.167

20.0

1(c)

( 1.00, 1.00)

( 1.00, 1.00)

[1,0,0,0,1,0,0,0]

−0.444

20.0

1(d)

(−1.00, 1.00)

(−1.00, 1.00)

[0,0,0,0,1,0,0,0]

−1.889

20.0

1(e)

( 1.00, −1.00)

( 1.00, −1.00)

[1,0,0,0,0,0,0,0]

−1.650

20.0

1(f )

( 1.00, 0.00)

( 1.00, 0.00)

[0,0,0,0,0,1,0,0]

−2.125

20.0

1(g)

( 0.25, −0.50)

( 0.25, −0.50)

[0,1,0,1,0,0,1,0]

−0.925

20.0

1(h)

( 0.25, 0.25)

( 0.25, 0.25)

[0,1,0,1,0,1,0,1]

−2.03125

20.0

1(i)

( 2.00, 1.00)

( 2.00, 1.00)

[1,1,0,0,1,0,0,0]

−2.450126

20.0

1(j)

( 2.00, 1.00)

( 2.00, 1.00)

[1,1,0,0,1,0,0,0]

−2.532545

20.0

1(i)

( 2.00, 1.00)

( 2.50, 0.75)

[1,1,1,0,0,1,1,1]

−2.887689

1.5

1(j)

( 2.00, 1.00)

( 2.00, 1.00)

[1,1,0,0,1,0,0,0]

−2.951557

1.75

The 3 × 3 matrix solutions are presented in Table VII. Note that We have not included
the 12 digit binary ground states here because they take up too much room in the table and
are not particularly illuminating. Problems 2(f ) and 2(g) are the ill-conditioned matrix test
and its pre-conditioned equivalent. For α = 20.0 both versions of the poorly-conditioned
26

problem gave only D-Wave solutions with broken chains. One only begins to get solutions
with unbroken chains at a value of α above 1000, but those solutions are generally wrong
and basically random until one gets to a very high α. We discuss this in greater detail in
the following section.
TABLE VII: 3 × 3 Matrix Equation Solutions to 3-bit Resolution.
Division Problems with Approximate D-Wave Solutions

D.

Test

Exact Solution

D-Wave Solution

Energy

α

2(a)

( 0.25, −0.5, 1.0)

( 0.25, −0.5, 1.0)

−15.5625

20.0

2(b)

( 0.25, −0.5, 0.0)

( 0.25, −0.5, 0.0)

−12.5625

20.0

2(c)

( 0.25, 0.0, −0.5)

( 0.25, 0.0, −0.5)

−13.5

20.0

2(d)

( 1.0, 0.25, −0.5)

( 1.0, 0.25, −0.5)

−15.6875

20.0

2(e)

( 0.0, 0.25, −0.5)

( 0.0, 0.25, −0.5)

−12.75

20.0

2(f )

( 0.0, 0.25, −0.75)

broken chains

N/A

20.0

2(g)

( 0.0, 0.25, −0.75)

broken chains

N/A

20.0

2(f )

( 0.0, 0.25, −0.75)

( 1.75, 1.25, 0.75)

−58.188

2200.0

2(g)

( 0.0, 0.25, −0.75)

( 0.0, 0.25, −0.75)

−557.437

2200.0

Discussion

The algorithms described here generally worked quite well for these small test cases with
the exception of the ill-conditioned 3×3 matrix. The ill-conditioned cases clearly demonstrate
not only the limitations of quantum annealing applied solving linear equations, but the
limitations of quantum annealing, in general. Consider the two ill-conditioned tests presented
here. When translated to a QUBO problem, the Hamiltonian spectra for these tests contain
many energy eigenvalues very close to the ground state energy. When these are embedded
within a larger graph of physical qubits they result in a very nearly degenerate ground
state, typically with thousands of states having energies within the energy uncertainty of the
ground state over the annealing time, τ , given by
~
.
(4.7)
τ
Consider a set of excited states with energy, En for n > 0, with n = 0, corresponding to
the ground state with energy denoted by E0 , and with En ordered by energy. The quantum
annealer near the ground state evolves adiabatically whenever
∆E =

E1 − E0 
27

~
τ

(4.8)

This is the adiabatic condition for quantum time evolution[8]. However, when this condition
is badly violated, which can occur dynamically since the instantaneous energies (eigenvalues
of H) are time dependent, the time evolution for the system near the ground state deviates
significantly from adiabatic behavior, resulting in a relatively slowly evolving superposition
of all the eigenstates states that are close in energy to the ground state. Now, the energy
spectra corresponding to poorly conditioned matrices have a large number of eigenstates
sufficiently near the ground state to strongly violate the adiabaticity condition. Furthermore,
these states, in general, will have no correlation to the solution encodings for any particular
problem (e.g., the offset binary floating-point representation). For example, they are not,
in general, related in any meaningful way to Hamming distance. Therefore, these problems
effectively cannot resolve the true ground state and tend to give nearly random lowest energy
”solutions” when the final state is measured on any individual annealing run. Since there
are so many of these states for ill-conditioned problems, a very large number of ”reads”
(individual runs) may be have to be specified to sufficient sample the solution space to find
the true ground state.
The behavior of the QUBO energies for the ill-conditioned matrices is illustrated in the
figures below. The final states are binary vectors corresponding to binary numbers up to
2N for N qubits. Since our test problems were reasonably small, we directly computed
the energies for all 256 final states for the 2 × 2 matrices, and all 4096 states for the 3 × 3
matrices. The array of binary solution states were plotted as what we call “Gray” projections.
By this we mean that the energy is plotted against the solution number ordered in a Gray
code sequence. Gray codes are cyclically ordered lists of binary numbers such that every
consecutive pair of numbers differ in only one bit, i.e., there us a Hamming distance of
1 between any two sequential numbers[7]. We employed the standard “reflected binary”
Gray code which is conveniently generated by a recursive algorithm. Table VIII shows an
example Gray code for the case of 4 bits. Gray code ordering was used for these plots
because, although it is impossible to represent all nearest-neighbor connections for K8 and
K12 graphs in a 1 dimensional line plot, we were able to at least ensure that all of the adjacent
values in the energy plots correspond to neighboring states, which gives some information
about the local energy landscape, such as whether neighboring states are close in energy,
indicating a relatively “flat” displacement along that direction, or if there is a large jump,
indicating a steep “cliff” or “valley” in the energy landscape. Note, also, that this Gray
code sequence has global permutation symmetry among its digits, and a cyclic symmetry
that repeats periodically for every 22 numbers in each digit place. Since this periodicity is
also reflected in some periodicity of states separated by a Hamming distance of 1, this makes
it possible to infer features of the local energy surface along other directions such as the
28

existence of very deep, but nearly flat, “canyon floors” in the global energy surface. One can
see this by noting periodic behavior with even periodicity in the 1 dimensional energy plots.
Figure 9 shows the energy surface for the 2 × 2 ill-conditioned matrix. Note the denseness
of the energy spectrum near the ground state energy. The alpha value is listed on this plot,
however, with our counter-term parameter setting strategy the energy of all the final states
(when there are no broken chains) is actually independent of α. To illustrate this point,
compare this to Figure 10, which is the same test problem but computed without using the
counter-terms weighted to subtract out the chaining penalty energy contribution. This plot
clearly shows why it is crucial to remove the error in the energy caused by not accounting
for varying different chain sizes when applying the chaining penalty. Note from the plot
that this error is inhomogeneous in state space. Therefore, the lowest energy state for the
embedded Hamiltonian will frequently not be the correct one corresponding to the logical
Hamiltonian. Note, also, that when the energy of all the chained logical qubits is restricted
to be 0, the plots for the embedded and logical QUBO energies overlay each other exactly.
Figure 11 shows the energy for the pre-conditioned version of this problem with the counterterm applied. Note that the pre-conditioning has moved many of the previous low-energy
eigenvalues significantly higher.
TABLE VIII: Example Gray code for 4 bits
4 Bit Reflected Binary Gray Code
N

Standard Binary Gray Code

0

0000

0000

1

0001

0001

2

0010

0011

3

0011

0010

4

0100

0110

5

0101

0111

6

0110

0101

7

0111

0100

8

1000

1100

9

1001

1101

10

1010

1111

11

1011

1110

12

1100

1010

13

1101

1011

14

1110

1001

15

1111

1000

29

FIG. 9: Gray Projection of Energy vs State for Test 1(i)

FIG. 10: Gray Projection of Energy vs State for Test 1(i) without Weighted Counter-terms

FIG. 11: Gray Projection of Energy vs State for Test 1(j)

The 3×3 ill-conditioned matrix was much more problematic. This is partly because of the

30

FIG. 12: Gray Projection of Energy vs State for Test 2(f)

FIG. 13: Gray Projection of Energy vs State for Test 2(g)

nature of this test matrix, which is very nearly singular with an approximate 2 dimensional
kernel space. The energy spectrum of the ill-condition problem is given in Figure 12, and
the energy spectrum of the pre-conditoned version is given in Figure 13. Although the
pre-conditioned version is significantly better, it still required a very large chaining penalty,
and even with that, it required thousands of “reads” (annealing runs) to reliably obtain the
correct answer. In this case, it required sampling the state space with as many as 2500 or
more “reads” with 20µs anneal times. Only several orders of magnitude longer anneal times
began to allow for a smaller number of reads. Here there were 212 = 4096 final states for
the logical Hamiltonian, so we were actually sampling with more than half as many distinct
runs as the number of possible states. However, the K12 embedding used for these runs
had 56 qubits. Therefore, the total state space for all qubits in the embedding was of size
256 ≈ 7 × 1016 , so perhaps this large sampling requirement is not as bad as it may at first
appear. Still, it is clear that there are still far too many excited states too close to the
31

ground state and that the system is far from perfectly adiabatic here. However, it should be
noted that the pre-conditioning still improved things somewhat, because we could not get
the correct answer with even 10000 “reads” for the original ill-conditioned problems.
The pre-conditioning method we used was very crude, rather ad-hoc, and ill-suited to
practical matrix inversion problems for classical algorithms, but the intent was simply to
test the effects of a simple pre-conditioning on the quantum annealing solutions. We have
been studying this issue and believe it may be possible to pre-condition the problems better
for solving these problems on a quantum annealing machine. In fact, we suspect that methods
related to this approach may allow other QUBO problems suffering from similar pathologies
to be “pre-conditioned” in way that better separates the ground state energy and allows
more practical solutions on the annealer. This, however, is still work in progress, and we
plan to further develop and test those ideas in the near future.

32

Appendix A: Matrix Test Problems

The problems we solved to test our quantum annealing algorithm to solve equation (3.1)
are listed below. Note that, although the QUBO Bij matrix is symmetric by construction,
the matrix M need not be symmetric.
1. Test Problems with 2 × 2 Matrices
Test 1(a):


0.5 1.5

M =

1.5 0.5







1.0

, Y = 



, x = 

0.0



−0.25



0.75

Test 1(b):


0.5 1.5

M =

1.5 0.5







0.0

, Y = 



0.75

, x = 

1.0



−0.25







Test 1(c):

M =

2.0 −1.0
−0.5 0.5





, Y = 

1.0
0.0



, x = 

1.0
1.0



Test 1(d):

M =

1.0 2.0
0.5 0.5





, Y = 

1.0
0.0





, x = 

−1.0
1.0




Test 1(e):

M =

3.0 2.0
2.0 1.0





, Y = 

1.0
1.0





, x = 

1.0
−1.0




Test 1(f ):

M =

1.0 0.5
1.0 −0.5





, Y = 

1.0
1.0





, x = 

1.0
0.0




Test 1(g):

M =

0.0 −2.0
−2.0 −1.5





, Y = 

33

1.0
0.25





, x = 

0.25
−0.5




Test 1(h):

M =

0.0 −2.0
−2.0 −1.5





, Y = 

−0.5
−0.875





, x = 

0.25
0.25




Test 1(i): Ill-conditioned problem with κ ≈ 25






1.0 2.0
4.0
2.0
, Y = 
, x = 

M =
2.0 3.999
7.999
1.0
Test 1(j): Pre-conditioned version of 1(i) with κ = 5.0






1.80026 1.6019
5.2007
2.0
, Y = 
, x = 

M =
1.6019 4.19974
7.40013
1.0
2. Matrix Problems with 3 × 3 Matrices
Test 2(a):
















































0.0 −2.0 0.0
1.0
0.25












M =  −2.0 1.5 0.0  , Y =  0.25  , x =  −0.5 






0.0 0.0 1.0
1.0
1.0
Test 2(b):
 0.25 
 1.0 
 0.0 −2.0 0.0 






M =  −2.0 1.5 0.0  , Y =  0.25  , x =  −0.5 






0.0
0.0
0.0 0.0 1.0
Test 2(c):
1.0 0.0 0.0
1.0
0.25












M =  0.0 0.0 −2.0  , Y =  0.0  , x =  0.0 






0.0 −2.0 −1.5
0.25
−0.5
Test 2(d):
1.0 0.0 0.0
1.0
1.0












M =  0.0 0.0 −2.0  , Y =  1.0  , x =  0.25 






0.0 −2.0 −1.5
0.25
−0.5
34

Test 2(e):












 1.0 0.0 0.0 
 0.0 
 0.0 






M =  0.0 0.0 −2.0  , Y =  1.0  , x =  0.25 






0.0 −2.0 −1.5
0.25
−0.5
Test 2(f ): Ill-conditioned problem with κ ≈ 78






−4.0 6.0
1.0
0.75
0.0












M =  8.0 −11.0 −2.0  , Y =  −1.25  , x =  0.25 






−3.0 4.0
1.0
0.25
−0.75
Test 2(g): Pre-conditioned version 2(g) with κ ≈ 1






0.0
1.4114
6.1795 11.8207 2.0583












M =  15.673 −7.56717 −3.8520  , Y =  0.9972  , x =  0.25 






−0.75
9.9643
−5.6457 7.96872 15.9418

35

Acknowledgments

We received funding for this work from the ASC Beyond Moores Law Project at LANL. We
would like to thank Andrew Sornborger, Patrick Coles, Rolando Somma, and Yiğit Subaşı
for a number of useful conversations.

[1] A. Harrow, A. Hassidim, and S. Lloyd, Phys. Rev. Lett. 103, 150502 (2009).
[2] Stefanie Barz, Ivan Kassal, Martin Ringbauer, Yannick Ole Lipp, Borivoje Dakic , Ala n
Aspuru-Guzik, Philip Walther, Solving systems of linear equations on a quantum computer,
arXiv:1302.1210v1 (2013).
[3] Stefanie Barz, Ivan Kassal, Martin Ringbauer, Yannick Ole Lipp, Borivoje Dakic , Ala n
Aspuru-Guzik, Philip Walther, Solving systems of linear equations on a quantum computer,
arXiv:1302.1946v1 (2013).
[4] X.-D. Cai, C. Weedbrook, Z.-E. Su, M.-C. Chen, Mile Gu, M.-J. Zhu, Li Li, Nai-Le Liu, ChaoYang Lu, Jian-Wei Pan, Experimental quantum computing to solve systems of linear equations,
arXiv:1302.4310v2 (2013).
[5] Edward Farhi, Jeffrey Goldstone, Sam Gutmann and Michael Sipser, Quantum Computation
by Adiabatic Evolution, arXive:000110 (2000).
[6] E. Ising, Z. Phys. 31 (1925) 253.
[7] Press, William H.; Teukolsky, Saul A.; Vetterling, William T.; Flannery, Brian P. ”Section 22.3.
Gray Codes”. Numerical Recipes: The Art of Scientific Computing (3rd ed.), New York, USA:
Cambridge University Press. ISBN 978-0-521-88068-8 (2007).
[8] Messiah, Albert “Chapter XVII.” Quantum Mechanics. Dover Publications. ISBN 0-486-409244. (1999)

36

