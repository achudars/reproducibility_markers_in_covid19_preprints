A class of robust numerical methods for solving dynamical systems
with multiple time scales
Thomas Y. Houa , Zhongjian Wangb , Zhiwen Zhangb,∗
a

Computing and Mathematical Sciences, California Institute of Technology, Pasadena, CA 91125, USA.
Department of Mathematics, The University of Hong Kong, Pokfulam Road, Hong Kong SAR, China.

arXiv:1909.04289v1 [math.NA] 10 Sep 2019

b

Abstract
In this paper, we develop a class of robust numerical methods for solving dynamical systems
with multiple time scales. We first represent the solution of a multiscale dynamical system as
a transformation of a slowly varying solution. Then, under the scale separation assumption,
we provide a systematic way to construct the transformation map and derive the dynamic
equation for the slowly varying solution. We also provide the convergence analysis of the
proposed method. Finally, we present several numerical examples, including ODE system
with three and four separated time scales to demonstrate the accuracy and efficiency of the
proposed method. Numerical results verify that our method is robust in solving ODE systems
with multiple time scale, where the time step does not depend on the multiscale parameters.
Keyword: Hamiltonian dynamical system; multiple time scales; stiff equations; convergence
analysis; uniform accuracy; composition maps.
AMS subject classifications. 34E13, 65L04, 65P10, 65L20.
1. Introduction
Dynamical systems with sub-processes evolving on many different time scales are ubiquitous
in applications: chemical reactions, electro-optical and neuro-biological systems, to name just
a few [19, 13]. The multiple time scales in the dynamical systems pose a major problem in
numerical simulations because one needs to choose small time steps for stable integration
of the fast motions in the systems, which leads to large numbers of time steps required for
the observation of the slow degrees of freedom and thus requires tremendous computational
resources. Interested readers are referred to [8, 15] and the references therein for a detailed
review.
The objective of this paper is to develop a new method to solve dynamical systems with
multiple time scales; see Section 2 for the precise definition of the problems. The main idea
of our method is to formally represent the solution of the multiscale dynamical system as
a transformation of a slowly varying solution; see Eq.(14). By dealing with the multiscale
Corresponding author
Email addresses: hou@cms.caltech.edu (Thomas Y. Hou), ariswang@connect.hku.hk (Zhongjian
Wang), zhangzw@hku.hk (Zhiwen Zhang)
∗

information in a dimension-by-dimension fashion, we propose a systematic way to construct
a set of cumulative composition maps that capture the complicated dynamics of the problem.
Based on the scale separation assumption, we successfully derive the dynamic equation for
the slowly varying solution (i.e., Eq.(30)) and prove that the dynamic equation for the slowly
varying solution is non-stiff; see Theorem 3.2. Thus, we can use conventional numerical
methods to compute it, where the time step is independent of the multiscale parameters in
the dynamical system. In addition, we analyze the error between the numerical solution
obtained from our method and the exact solution in Theorem 3.4. Finally, we carry out
several numerical experiments to demonstrate the accuracy and efficiency of the proposed
method.
As we will demonstrate in Section 4, the proposed method can offer accurate numerical
solutions to multiscale ODE systems with considerable computational savings over traditional
methods, especially when the multiscale parameters are small. Numerical results (see Fig.10)
show that the dynamic equation for the slowly varying solution based on the cumulative
composition maps indeed capture the averaged behaviors of the solution well. While a simple
averaging treatment of the original multiscale ODE systems leads to wrong results. As an
analogy to this interesting finding, in the homogenization for elliptic PDEs with multiscale
coefficients, a simple average of the coefficient gives a wrong result, where one needs to solve
a cell problem to obtain the correct homogenization coefficient [5].
Our method is inspired by the recent development in designing uniformly accurate numerical schemes for highly oscillatory evolution equations [3, 4], where two-scale problems
were solved. In [3, 4], the authors separate the two time scales into two independent variables
and embed the solution of the two-scale problem into a two-variable function. Then, they
derive formulations of the evolution equations for the two-variable function and prove that
under certain conditions the evolution equations are solvable and non-stiff.
The novelty of our paper is that we provide a systematical way to construct a set of
cumulative composition maps that allow us to correctly upscale the complicated dynamics
of the problem. Notice from Eq.(25) that each map Φk is a perturbation of the identity
operator. However, a cumulative composition of those simple maps (15) can provide an
accurate approximation of the complicated dynamics of the problem. In addition, we provide
a rigorous convergence analysis for the proposed method and verify the statement through
numerical experiments.
Before we end this section, we give a short review of several existing methods for solving two-scale problems. When slow variables can be identified, effective equations can be
obtained by averaging the instantaneous drift driving those slow variables. Two classes of
numerical methods have been developed based on this observation: the equation-free method
[14] and heterogeneous multiscale method (HMM) [1]. Later on, a new class of integrators
for stiff ODEs as well as SDEs were developed [18], which are based on the averaging of
the instantaneous flow of the hidden slow and fast variables simultaneously. Therefore, the
hidden slow variables do not need to be explicitly identified. In this paper, however, we will
consider problems parameterized by multiple time scales. In addition, we aim to design nu-

2

merical schemes that solve the multiscale dynamical problems for a wide range of multiscale
parameter values with uniform accuracy.
The rest of the paper is organized as follows. In Section 2, we will derive our numerical
method for solving multiscale dynamical systems and discuss its detailed implementation.
In Section 3, we provide the convergence analysis for the proposed method. In Section
4, we present numerical results to demonstrate the accuracy and efficiency of our method.
Concluding remarks are made in Section 5.
2. Numerical methods for solving multiscale dynamical systems
In this section, we will develop numerical methods to solve dynamical systems with multiple
time scales. Specifically, we consider the following first-order ordinary differential equation
(ODE) system to illustrate the main idea,
ẋ = f ǫ (t, x),

x(0) = x0 ,

t ∈ [0, T ],

(1)

where x(t) ∈ Rd is the solution vector, x0 is the initial value, and f ǫ (t, x) is a function vector
field. Here ǫ = (ǫ1 , ..., ǫn ) is a set of parameters, which are used to characterize different time
scales in the ODE system (1). When the parameters satisfy
0 < ǫn ≪ ǫn−1 ≪ · · · · · ≪ ǫ1 ≪ 1,

(2)

we say that the multiscale time scales are well-separated. Given the multiscale parameters,
we denote
t
t t
(3)
f ǫ (t, x) ≡ f ( , , · · · , , x),
ǫ1 ǫ2
ǫn
where f : Rn+d → Rd is a function vector field. We assume that the first-order derivatives of
f are bounded, which is sufficient to guarantee the existence and uniqueness of solutions of
the ODE system (1) [12, 16]. Let ti = ǫti , i = 1, ..., n. We denote f ǫ (t, x) = f (t1 , t2 , · · · , tn , x).
Moreover, we assume that f is periodic with respect to its first n coordinates, i.e., ti , i =
1, ..., n. Without lost of generalities, all the periods are assumed to be 1.
2.1. Decomposition of the multiscale function f
We iteratively define the averaged functions to resolve finer scale fluctuations on coarser scales
in a dimension-by-dimension fashion. We first start from the coordinate tn corresponding to
the smallest-scale and define the mean function
Z 1
n
f¯ (t1 , t2 , · · · , tn−1 , x) =
f (t1 , t2 , · · · , tn−1 , s, x)ds,
(4)
0

and the fluctuation function
f n (t1 , t2 , · · · , tn , x) = f (t1 , t2 , · · · , tn , x) − f¯n (t1 , t2 , · · · , tn−1 , x),

(5)

where the integration and subtraction are done in a component-wise fashion. Thus, f¯n and
f n are d-dimensional vector functions.
3

Then, based on the function f¯n (t1 , t2 , · · · , tn−1 , x), we define the mean function and fluctuation function corresponding to the second smallest-scale as follows
Z 1
n−1
¯
f (t1 , t2 , · · · , tn−2 , x) =
f¯n (t1 , t2 , · · · , tn−2 , s, x)ds,
(6)
0

f

n−1

(t1 , t2 , · · · , tn−1 , x) = f¯n (t1 , t2 , · · · , tn−1 , x) − f¯n−1 (t1 , t2 , · · · , tn−2 , x).

(7)

We continue this strategy and define mean functions and fluctuation functions corresponding
to different time scales recursively. For instance, given the mean function f¯n−k+1, we define
the mean function and fluctuation function corresponding to a coarser-scale as follows
Z 1
n−k
f¯ (t1 , t2 , · · · , tn−k−1 , x) =
f¯n−k+1(t1 , t2 , · · · , tn−k−1, s, x)ds,
(8)
0

f

n−k

(t1 , t2 , · · · , tn−k , x) = f¯n−k+1(t1 , t2 , · · · , tn−k , x) − f¯n−k (t1 , t2 , · · · , tn−k−1, x).

(9)

Finally, we define the mean function and fluctuation function corresponding to the largestscale as follows
Z 1
1
¯
f (x) =
f¯2 (s, x)ds,
(10)
0

f (t1 , x) = f¯2 (t1 , x) − f¯1 (x).
1

(11)

The above recursive formulations (4)-(11) naturally lead to a decomposition of the multiscale function f (t1 , t2 , · · · , tn , x) into
f=

n
X

f k + f¯1 .

(12)

k=1

According to the definition, for each k we have that
Z 1
f k (t1 , · · · , tk−1, s, x)ds = 0, ∀ ti ∈ [0, 1], i = 1, ..., k − 1, and x.

(13)

0

2.2. Derivation of the dynamic equation for the slowly varying solution
We will construct a family of maps Φk = Φkt1 ,t2 ,··· ,tk : Rd → Rd , k = 1, ..., n, that allow us to
represent the solution x(t) of the ODE system (1) as a transformation of a slowly varying
solution y(t), i.e.,
x(t) = Φn ◦ Φn−1 ◦ · · · ◦ Φ1 (y(t)).
(14)
We assume that each map Φk is periodic with respect to tk and becomes the identical map
Id when tk = 0. To simplify the notation, we define a family of cumulative composition maps
as follows
Φ̄k = Φk ◦ Φk−1 ◦ · · · ◦ Φ1 , k = 1, ..., n.
(15)
The rationale behind the representation (14) is that the complicated dynamics of the
ODE system (1) (e.g., highly oscillatory solutions) is captured by the map Φ̄n , and thus the
4

evolution of the solution y(t) is smooth. Therefore, we can compute the solution x(t) (through
solving y(t)) by using numerical methods with relatively large time steps (independent of the
multiscale parameters). To achieve this goal, we need to find a constructive way to obtain
the map Φ̄n and to identify the dynamical equation for the solution y(t).
Substituting the representation (14) into the original problem (1), we know that the
solution y(t) formally satisfies the following equation
∂t Φ̄n (y) + ∂x Φ̄n (y)ẏ = f ǫ ,

(16)

where ∂x Φ̄n (y) is the Jacobian matrix.
It will be complicated if we directly compute ∂x Φ̄n (y) using the chain rule. We shall
adopt some approximate method to address this difficulty. Notice that the scale separation
assumption on f ǫ (see Eq.(3)) indicates that the local fluctuation of f ǫ at O(ǫn ) scale can be
resolved by the same scale part of ∂t Φ̄n . More precisely, by the chain rule, we get
n−1

X1
1
∂t Φ̄ = ∂tn Φn (Φ̄n−1 ) +
∂ti Φn (Φ̄n−1 ) + ∂x Φn ∂t Φ̄n−1 ,
ǫn
ǫ
i
i=1
n

(17)

where the last two terms are independent of tn . Compared with the decomposition of the
multiscale function f in (12), we can set,
1
∂tn Φn (Φ̄n−1 ) = f n .
ǫn

(18)

Since Φn is an identical map when tn = 0, we can explicitly get,
Φnt1 ,t2 ,··· ,tn (x) = x + ǫn g n (t1 , t2 , · · · , tn , x),
where
n

g (t1 , t2 , · · · , tn , x) =

Z

∀x,

(19)

tn

f n (t1 , t2 , · · · , tn−1 , s, x)ds.

(20)

0

From (19), we can see that Φn = Id + O(ǫn ), which is an O(ǫn ) order perturbation of the
identity operator. When the time scales are well-separated, we can dismiss the second term
in Eq.(17) since
n−1
n−1
X
X
1
ǫn
ǫn
n
n−1
∂ti Φ (Φ̄ ) =
∂ti g n (Φ̄n−1 ) = O(
).
(21)
ǫ
ǫ
ǫn−1
i=1 i
i=1 i
Let us continue our derivation inductively with k = n − 1, · · · , 1. We consider the fluctuation
within period O(ǫk ), and have the following observation,
∂x (Φn ◦ Φn−1 ◦ · · · ◦ Φk+1 )(

1
∂t Φk ) = f k .
ǫk k

(22)

Due to the scale separation structure of Φn ◦ Φn−1 ◦ · · · ◦ Φk+1 , we obtain
∂x (Φn ◦ Φn−1 ◦ · · · ◦ Φk+1 ) = Id + O(ǫk+1 ),
5

(23)

which is an O(ǫk+1 ) order perturbation of the identity operator. Now we arrive at,
1
∂t Φk (Φ̄k−1 ) = f k .
ǫk k

(24)

Again, using the condition that Φk is an identical map when tk = 0, we get
Φkt1 ,t2 ,··· ,tk (x) = x + ǫk g k (t1 , · · · , tk−1, tk , x),
where
k

g (t1 , · · · , tk−1 , tk , x) =

Z

tk

f k (t1 , · · · , tk−1 , s, x)ds,

k = 1, ..., n.

(25)

(26)

0

Pk−1 1
ǫk
In the above derivation, we have used the condition that i=1
∂ Φk (Φ̄k−1 ) = O( ǫk−1
).
ǫi ti
k
After we obtain the explicit formulations for Φ , k = 1, ..., n and their derivatives, we are
in the position to derive the dynamic equation for the solution y(t). According to (16), we
obtain a nested equation



n−1
n−1
n−2
1
1
n
n
+ ∂x Φ
∂t Φ
+ · · · (∂t Φ + ∂x Φ ẏ(t)) · · ·
= f ǫ.
(27)
∂t Φ + ∂x Φ ∂t Φ
From the definition of Φk (see Eq.(25)), we compute the derivative of Φk with respect to time
t and get,
k
X
1
∂tr g k ,
∂t Φ = ǫk
ǫ
r
r=1
k

k = 1, ..., n.

(28)

The scale separation assumption on the multiscale parameters implies that ∂t Φk ≅ ∂tk g k =
1
∂ Φk , which allows us to simplify Eq.(27) into the following form
ǫk tk

1
1
n
n
∂tn Φ +∂x Φ
∂tn−1 Φn−1 + ∂x Φn−1 ·
ǫn
ǫn−1
 1

1
n−2
1
1˙
∂t Φ
+ · · · ( ∂t1 Φ + ∂x Φ ỹ(t)) · · ·
= f ǫ.
(29)
ǫn−2 n−2
ǫ1
Here ỹ(t) is an approximation of y(t) since Eq.(29) is an approximation of the original Eq.(27)
based on the scale separation assumption on the multiscale parameters. Finally, from Eq.(29)
we can get the dynamic equation for ỹ(t), i.e.,

1
−1
· · · (∂x Φn−1 )−1
ỹ˙ =(∂x Φ )



1
1
1
n
n−1
1
n −1
ǫ
− · · · − ∂t1 Φ =: F (t, x).
(30)
∂t Φ
(∂x Φ ) (f − ∂tn Φ ) −
ǫn
ǫn−1 n−1
ǫ1
From the above derivation, one can see that the existence of the matrices (∂x Φk )−1 , k =
1, ..., n in (30) is essential in establishing the consistency of our method. In Section 3, we will
prove that the invertibility is guaranteed in the case when ǫk are sufficient small; see (39).
6

In addition, we will prove that the ODE system (30) is non-stiff, which will be useful for the
design of uniformly accurate numerical schemes, i.e., the time step in the numerical schemes
does not depend on the multiscale parameters. When we obtain the solution ỹ(t) of the ODE
system (30), we can recover the solution of the ODE system (1) through the transform Φ̄n
defined in (14)(15). The error estimate of our method will be presented later.
Remark 2.1. From the explicit formulations for Φk , k = 1, ..., n, we know the solution of the
original ODE system can be rewritten as the following form



x(t) = Id + O(ǫn ) ◦ Id + O(ǫn−1 ) ◦ · · · ◦ Id + O(ǫ1 ) (y(t)).
(31)
Eq.(31) clearly reveals the structure of the transformation map in our method. One can
see that the transformation map is a composition of simple maps, where each of them is a
perturbation of identity. Interestingly, similar ideas appear in deep neural network research;
see e.g. [2, 17], where approximations of functions via compositions of near-identity functions
have been used intensively and are the key to the amazing expressibility power of a deep
neuron network.
Remark 2.2. Our method can be extended to solve an ODE system (1), where f ǫ is a quasiperiodic function. Assume that f ǫ (t, x) in (3) has the form
f ǫ (t, x) = f (

an (t)
a1 (t) a2 (t)
,
, ...,
, x),
ǫ1
ǫ2
ǫn

(32)

where ak (t), k = 1, ..., n are some invertible functions in C 2 such that 0 < c0 ≤ k dtd ak (t)k∞ ≤
c1 < ∞. Then the main results stated in this section for periodic functions still hold by using
the same definition of the mean function defined in (4) without any prior knowledge of ak (t),
k = 1, ..., n. The reason is that for any smooth function h(x, y) that is periodic in y with
period 1, one can easily show that (see [6] for an elementary proof)
Z b
Z b Z 1

ak−1 (t) ak (t) 
ǫk
ak−1 (t)
h
,
dt −
, y)dy dt ≤ C
,
(33)
h(
ǫk−1
ǫk
ǫk−1
ǫk−1
a
a
0
by using a change of variable from t to s = ak (t) and the fact that the Jacobian J(s) =
( dtd ak )−1 is a smooth function of s.
Remark 2.3. For a general ODE system ẋ = f (t, x), where f (t, x) does not have an explicit form of multiscale separation parametrization, we may reparameterize and approximate
f (t, x) by a formal multiscale velocity field f ǫ (t, x). For instance, we may reparameterize
f (t, x) into a formal two-scale structure through Fourier transform; see [11]. The limitation
is that we have to compute Fourier transform of f (t, x) with respect to t, for each fixed x,
which involves a certain amount of computation. To develop a fast solver to address this
issue will be our future work.
2.3. Construction of the numerical schemes
In this section, we construct efficient numerical schemes to solve Eq.(30) that are uniformly
accurate with respect to ǫ = (ǫ1 , ..., ǫn ). We first discuss how to accurately and efficiently
7

compute the maps Φk , k = 1, ..., n defined in Eqns.(19) and (25). We observe that the maps
Φk , k = 1, ..., n are explicitly defined. Therefore we can use an explicit numerical scheme to
approximate them. However, such an explicit implementation is not desirable because it may
destroy the structures (e.g., Hamiltonian structure) of the original problem (1).
Alternatively, we adopt an implicit midpoint scheme to approximate Φk , i.e.,
Φkt1 ,t2 ,··· ,tk (x) = x + ǫk g k (t1 , t2 , · · · , tk ,

x + Φkt1 ,t2 ,··· ,tk (x)
),
2

k = 1, ..., n.

(34)

The scheme (34) still provides an O(ǫk ) approximation of Eq.(25). In practice, Φk in (34)
can be computed by the fixed point iteration. In addition, the derivatives of Φk with respect
to tk or x involved in Eq.(30) can be computed by the fixed point iteration based on the
following identities,
x + Φk (x) 
x + Φk (x)  ǫk
+ ∂x g k
∂tk Φk (x),
(35)
2
2
2
−1

ǫk
x + Φk (x) 
∂x Φk (x) K = K − ∂x g k
K + (∂x Φk (x))−1 K ,
(36)
2
2
where K is a d-dimensional column vector. The formulae in (34)-(36) suggests an iterative
scheme to calculate all the quantities that are needed to compute (30) and Φ̄n . Finally, we
obtain an efficient numerical scheme to solve Eq.(30) at any time t and value x.
The detailed implementation of the proposed numerical scheme is listed in Algorithm
1, in which we introduce several variables to simply the notations. Specifically, we have
Pk = Φk ◦ Φk−1 ◦ · · · ◦ Φ1 (y), Tk = ǫ1k ∂tk Φk ◦ Φk−1 ◦ · · · ◦ Φ1 (y), k = 1, ..., n, and D1 = ẏ.
∂tk Φk (x) = ǫk f k

3. Convergence analysis
In this section, we present the convergence analysis of the proposed method. Since our goal
is to develop numerical methods to solve ODE systems with a large range of ǫ-values, the
following assumption appears as a natural prerequisite.
Assumption 3.1. Notice that our method developed in Section 2 is a first-order method
(w.r.t. ǫ). We require f ǫ and its fluctuation components f k , k = 1, ..., n are second-order
differentiable and are bounded on some closed set Tn × K, where K ⊂ Rd . In addition, we
assume that the path of the solution x(t) is in K.
Remark 3.1. In many cases, f ǫ and f k , k = 1, ..., n are globally defined, which requires
K = Rd .
First, we prove that the transformed equation (30) is non-stiff with respect to ǫ, and thus
it can be solved by using conventional numerical methods with relatively large time steps.
Theorem 3.2. Suppose that Assumption 3.1 is satisfied and 0 < ǫk < 1, k = 1, ..., n are
sufficiently small. Let F (t, x) denote the right hand side of the ODE system (30). Then, we
have the following estimate,
∂t F (t, x) ≤ C0 ,
(37)
where · is a vector norm and C0 does not depend on ǫk , k = 1, ..., n.
8

Algorithm 1 A fixed point iteration method to compute the ODE with n time-scales.
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:

[0]

[0]

[0]

Set i = 0, P1 = P2 = · · · = Pn = y
repeat
[i]
P0 = y
for k = 1 to
n do
[i]
[i]
Pk−1 +Pk
[i]
Rk =
2
[i+1]
[i]
[i]
Pk
= Pk−1 + ǫk g k (Rk )
end for
i→ i+1
[i]
until Pn converges.
[0]
[0]
[0]
[0]
[0]
[0]
Set j = 0,T1 = T2 = · · · = Tn = D1 = D2 = · · · = Dn = 0
repeat
[j]
[i]
Dn+1 = f ǫ (Pn )
for k = n to 1 do
[j+1]
[i]
[i]
[j]
Tk
= f k (Rk ) + ǫ2k ∂x g k (Rk )Tk
[j]
[j]
[j+1]
Bk = Dk+1 − Tk
[i]
[j]
[j]
[j+1]
[j]
Dk
= Bk − ǫ2k ∂x g k (Rk )(Bk + Dk )
end for
j →j+1
[j]
until D1 converges.

Proof. According to the definitions (25), we have the results,
∂x Φk = Id + ǫk ∂x g k ,

k = 1, ..., n.

(38)

When ǫk are sufficiently small, the inverse of ∂x Φk exists and can be computed through the
Neumann series expansion,
(∂x Φk )−1 = Id +

∞
X

(−ǫk ∂x g k )m .

(39)

m=1

Taking the derivative of Eq.(39) on both sides with respect to t, we obtain
∂t (∂x Φk )−1 =

∞
X

∂t (−ǫk ∂x g k )m .

(40)

m=1

Moreover, we have the estimates,
(∂x Φk )−1 − Id ≤ Cǫk ,
∞
X
∂t (∂x Φk )−1 =
∂t (−ǫk ∂x g k )m ≤ C,
m=1

9

(41)
(42)

where

·

is a matrix norm. At the same time, we have the condition
1
∂t Φk = ∂tk g k = f k .
ǫk k

(43)

Therefore, the right hand side of the ODE system (30) can be re-written as,
n
n Y
k
Y
X
1
k −1 ǫ
F (t, x) =
(∂x Φ ) f −
(∂x Φi )−1 ∂tk Φk ,
ǫk
i=1
k=1 i=1
n−1 Y
k
n
X
Y
k −1 ¯1
(∂x Φi )−1
(∂x Φ ) f +
=
k=1 i=1

i=1

≡ J0 +

n−1
X

n
Y


(∂x Φi )−1 − Id f k ,

i=k+1

Jk .

(44)

k=1

Taking derivative of F (t, x) with respect to t and using the product rule, we can easily verify
that the terms ∂t J0 and ∂t Jk , k = 1, ..., n − 1 are all O(1). Thus, the assertion in 37 is
proved.
Theorem 3.2 shows that the transformed ODE system (30) is non-stiff, which is then
amenable to a standard numerical treatment. As such, we divide the time interval [0, 1] by
the nodes tm = m∆t, m = 0, ..., M, where ∆t = 1/M is the time step and M is a positive
integer. For each m, m = 1, ..., M, we seek a numerical solution ŷ(tm ) to approximate ỹ(tm ),
which is the value of the exact solution of the ODE system (30) at time tm .
Here, we use the implicit integral midpoint scheme (Im2nd ) to solve the ODE system
(30). Between two consecutive computational times tm and tm+1 , we integrate the differential
equation (30) and obtain,
Z tm+1
F (s, ỹ(s))ds.
(45)
ỹ(tm+1 ) = ỹ(tm ) +
tm

Then, we approximate ỹ(s) by an average value and arrive at,
Z tm+1
ŷ(tm+1 ) + ŷ(tm )
F (s,
)ds.
ŷ(tm+1 ) = ŷ(tm ) +
2
tm

(46)

We remark that the numerical solution ŷ(tm+1 ) can be computed by some iteration methods,
such as the Newton-Raphson method or fixed point iteration method. In this paper, we choose
the scheme (46) since it preserves certain intrinsic structures in the solution of the original
problem; see Section 4 for more discussions.
The uniform boundedness of the first-order derivative of F (t, x) (proved in Theorem
3.2) guarantees that our implicit integral midpoint scheme (46) has second-order accuracy.
Furthermore, we do not need to decrease the time step ∆t when ǫk , k = 1, ..., n are small.
We summarize the property of the numerical solution ŷ(tm ) into the following lemma.
10

Lemma 3.3. Let ỹ(t) be the exact solution of the transformed ODE system (30). And let
ŷ(tm ), m = 1, ..., M be the numerical solutions obtained by the scheme (46). Then, we have
ŷ(tm ) − ỹ(tm ) = C1 (∆t)2 ,

m = 1, ..., M,

(47)

where C1 does not depend on ǫk , k = 1, ..., n.
Finally, we analyze the error between the approximated solution Φ̄n (ŷ) and the exact
solution x(t) of the original ODE system (1).
Theorem 3.4. Let T denote the final computational time. Suppose Assumption 3.1 is satisfied and 0 < ǫk < 1, k = 1, ..., n are sufficiently small. For all t ≤ T , we have the following
error estimate
ǫi 
+ C3 (∆t)2 ,
(48)
x(t) − Φ̄nt (ŷ(t)) ≤ C2 max
i=2,··· ,n ǫi−1
where C2 and C3 are generic constants that do not depend on ǫk , k = 1, ..., n and ∆t.
Proof. For any given computational time t, we have
x(t) − Φ̄nt (ŷ(t)) ≤ Φ̄nt (y(t)) − Φ̄nt (ỹ(t)) + Φ̄nt (ỹ(t)) − Φ̄nt (ŷ(t)) ,

(49)

where y(t) and ỹ(t) are the exact solutions of the ODE systems (27) and (30), respectively,
and ŷ(t) is the numerical approximation of ỹ(t). We shall estimate the two terms in (49)
separately. First we can see that,
ẏ − ỹ˙ =

k
n Y
k
n
X
Y
X

ǫk
i −1
k −1 ǫ
(∂x Φ ) f −
(∂x Φ )
∂tj g k
ǫ
j=1 j
i=1
k=1 i=1

−

n
Y

(∂x Φk )−1 f ǫ −

i=1

=−

n Y
k
X

(∂x Φi )−1 ∂tk g k Φk ,

k=1 i=1
k−1
X ǫk
∂tj g k .
(∂x Φi )−1
ǫ
i=1
j=1 j

n Y
k
X
k=1

(50)

Using the conditions that ∂tk g k are bounded functions (see Eq.(43)) and (∂x Φk )−1 − Id ≤
Cǫk (see Eq.(41)), we have
˙ ≤ C( max ǫi ).
|ẏ − ỹ|
(51)
i=2,··· ,n ǫi−1
Hence for any time t ≤ T , we have,
|y(t) − ỹ(t)| ≤ CT ( max

ǫi

i=2,··· ,n ǫi−1

),

(52)

where the constant CT = O(T ). Applying the chain rule for Φ̄n , we obtain
n

n

n−1

∂x Φ̄ = ∂x Φ ◦ Φ

1

◦···◦Φ

11



n
Y
=
(Id + ǫi ∂x g i ).
i=1

(53)

So at any time t, Φ̄n is Lipschitz in the variable x and the Lipschitz constant is uniformly
bounded when ǫi are small enough. Finally, combining the estimates (47), (52) and (53), we
prove the statement in Theorem 3.4.
When the multiscale parameters are well-separated; see (2), the first term in the error
estimate (48) is negligible, thus our scheme has a second-order accuracy with respect to
∆t. Although the above convergence analysis relies on the scale separation assumption, we
can relax this assumption in some special cases. For example, when two scales collapse, i.e.
ǫn = cǫn−1 , we can treat these two scales as a single scale and we can modify the mean function
m1
is a rational number, and h(y1 , y2) is
defined in (4) accordingly. More specifically, if c = m
2
t
t
t
a doubly periodic function in y1 and y2 with period [1, 1], then h( ǫn−1
, ǫtn ) = h( ǫn−1
, m1mǫ2n−1
)
is a periodic function of t with a period m1 ǫn−1 . Thus, the mean function defined in (4) can
be modified accordingly as follows
Z m1
1
m2
f (t1 , t2 , ..., tn−2 , s,
s, x)ds.
(54)
m1 0
m1
t
When c is an irrational number, it is easy to show that the time average of h( ǫn−1
, ǫtn ) will
converge to the area in (y1 , y2) ∈ T2 and we can modify the definition of the mean function
as follows
Z
f (t1 , t2 , ..., tn−2 , s1 , s2 , x)ds1 ds2 .
(55)
[0,1]2

With the above modification of the mean function, we can still prove the main results stated
in this section. Our numerical results to be presented later also confirm that our method
works equally well in the case when two scales collapse.
More general case can be considered as well if we have m number of collapsed scales, i.e.
ǫk = c1 ǫk+1 = c2 ǫk+2 = ... = cm−1 ǫk+m−1 . In this case, we should consider these m-scales
simultaneously and modify the definition of the mean function by using the time averaging
technique for multiple scales discussed in [10]. We will not present the more general case in
this paper and will leave it to our future work.
4. Numerical results
In this section, we present several numerical experiments to illustrate the efficiency of our
method and confirm the convergence analysis. The Im2nd solution, or direct Im2nd solution,
refers to the numerical solution obtained by solving the original problem (1) using the scheme
(46). Moreover, we use the UA solution to denote the numerical solution obtained by our
method. In our method, we use the scheme (46) to solve Eq.(30) and the Algorithm 1 to
compute necessary quantities in the Eq.(30).
4.1. An ODE system with three separated time scales
The Hénon-Heiles system [9] is undoubtedly one of the most paradigmatic model potentials
for time-independent Hamiltonian systems with two degrees of freedom, which is frequently
used to describe the motion of stars around a galactic center. We consider a generalization
12

of the original Hénon-Heiles system in three degrees of freedom. The relative equilibria and
bifurcations of this model were studied in [7].
Here, we assume the Hamiltonian of the three dimensional Hénon-Heiles system is parameterized by ǫ1 and ǫ2 and has the following form
p21
q2
p2
q2
p2 q 2
1
1
+ 1 + 2 + 2 + 3 + 3 + q12 q2 − q23 + q22 q3 − q33 .
(56)
2ǫ2 2ǫ2 2ǫ1 2ǫ1
2
2
3
3
where p = (p1 , p2 , p3 )T and q = (q1 , q2 , q3 )T . One can obtain the evolution equation for the
Hamiltonian in (56) as follows,
H(p, q) =

dp
∂H
=−
,
dt
∂q

dq
∂H
=
.
dt
∂p

(57)

When 0 < ǫ2 ≪ ǫ1 ≪ 1, the ODE system (57) becomes a three-scale problem and the
solutions (e.g., p1 and q1 ) are highly oscillatory. Let us carry out a change of variables,


w1





w2



w
3

w4





w5




w6

= cos( ǫt2 )q1 − sin( ǫt2 )p1 ,
= sin( ǫt2 )q1 + cos( ǫt2 )p1 ,
= cos( ǫt1 )q2 − sin( ǫt1 )p2 ,
= sin( ǫt1 )q2 + cos( ǫt1 )p2 ,

(58)

= q3 ,
= p3 .

Then, (w1 , ..., w6 )T satisfies the following ODE system

ẇ1 = 2 sin t2 (w1 cos t2 + w2 sin t2 )(w3 cos t1 + w4 sin t1 ),





ẇ2 = −2 cos t2 (w1 cos t2 + w2 sin t2 )(w3 cos t1 + w4 sin t1 ),



ẇ = sin t 2(w cos t + w sin t )w + (w cos t + w sin t )2 − (w cos t + w sin t )2 ,
3
1
4
1
5
1
2
2
2
3
1
4
1
3
1

2

ẇ4 = − cos t1 2(w3 cos t1 + w4 sin t1 )w5 + (w1 cos t2 + w2 sin t2 ) − (w3 cos t1 + w4 sin t1 )2 ,





ẇ5 = w6 ,



2
2
ẇ6 = w5 − w5 − (w3 cos t1 + w4 sin t1 ) ,

(59)
where t2 = and t1 =
Notice that the right-hand side of the ODE system (59) involves
trigonometric functions and simple polynomials. Thus, all the integrals in our numerical
schemes can be pre-computed analytically. We have implemented these computations with
the software Mathematica.
Verification of the convergence analysis. We compare the error between the numerical solution obtained by our method and the reference solution. The initial value is
(w1 (0), ..., w6 (0))T = (0.12, 0.12, 0.12, 0.12, 0.12, 0.12)T . The reference solution is obtained by
Matlab ode45 function applied to the ODE system (59), where the time step is ∆t = 0.0001.
To implement our method, we choose the second-order implicit integral midpoint scheme to
integrate the non-stiff problem (30). We find that the iteration loops needed in Algorithm 1
is about 3 − 10 times, where the convergence threshold is set to be 10−14 .
t
ǫ2

t
.
ǫ1

13

In Fig.1(a) and Fig.1(b), we show the error as a function of ∆t for different values of ǫ1
with ǫ2 = ǫ21 and ǫ2 = 0.8ǫ1 , respectively. The magnitude of the Hamiltonian (56) is about
0.0144
. We observe a second-order convergence rate with respect to ∆t in our method. Most
ǫ21
importantly, the error is independent of ǫ1 and ǫ2 as shown in Fig.1(a) and Fig.1(b), where
the curves for different values of ǫ1 and ǫ2 are nearly identical. This confirms that our scheme
is uniform accurate, which does not depend on ǫ1 and ǫ2 . Notice that the numerical solution
obtained by ∆t = 0.1 is accurate enough to maintain an error of the order 10−4 and error
of the Hamiltonian at the order of 10−3 , uniformly in ǫ1 and ǫ2 . For the Euler method, it is
impossible since the ODE system associated with the Hamiltonian (56) becomes severely stiff
when ǫ1 and ǫ2 become small. The numerical results for the Euler method were not shown
here.
100

100

10-4

10

-6

10-2

l2err

l2err

10-2

0.1
0.01
0.001
0.0001
1e-05
1e-06
1e-07
1e-08
slope 1
slope 2

10-6

10-8
10-10
10-4

10-4

10-3

10-2

10-8
10-4

10-1

0.1
0.01
0.001
0.0001
1e-05
1e-06
1e-07
1e-08
slope 1
slope 2

10-3

10-2

t

10-1

t

(a)

(b)

Figure 1: Error as a function of ∆t for ǫ1 = 10−k , k = 1, ..., 8. Left: ǫ2 = ǫ21 . Right: ǫ2 = 0.8ǫ1 .

In the derivation of the numerical method and the convergence analysis, we assume the
time-scales are well-separated, i.e., 0 < ǫn ≪ ǫn−1 ≪ · · · · · ≪ ǫ1 ≪ 1. In Fig.1(b), we show
the error as a function of ∆t for difference values of ǫ1 and ǫ2 = 0.8ǫ1 at T = 1. It is shown
that our scheme still has a uniform accuracy, which does not depend on separation between
ǫ1 and ǫ2 .
Let us now verify that our method preserves the Hamiltonian of the system. In Fig.2, we
plot the evolution of the error of the Hamiltonian (56) for different ǫ1 and ǫ2 , where ǫ2 = ǫ21 .
We find that when ǫ1 is relatively large, e.g., ǫ1 = 0.1, the implicit integral midpoint scheme
(46) with a large time step ∆t = 0.1 and our method give similar and accurate results in
computing the Hamiltonian; see Fig.2(a). However, when ǫ1 is small, e.g., ǫ1 = 0.001, the
ODE system associated with the Hamiltonian (56) becomes very stiff. Directly using the
scheme (46) will lose accuracy if the time step is not small enough. While our method with a
large time step still maintains the same accuracy; see Fig.2(b). This result again confirms that
our scheme has a uniform accuracy in computing an ODE system with multiple time-scales,
especially when the systems are stiff.
14

2

-2

1
0

-2.5

log10(err(H))

log10(err(H))

-1.5

-3
-3.5

-1
-2
-3

-4

UA
Im2nd

UA
Im2nd

-4

-4.5

-5
0

2

4

6

8

10

0

2

4

6

t

t

(a)

(b)

8

10

Figure 2: Evolution of the error of the Hamiltonian in the three-scale ODE system with ǫ2 = ǫ21 . Left:
ǫ1 = 0.1. Right: ǫ1 = 0.001. ∆t = 0.1.

Verification of the non-stiffness of the transformed equation (30). In Theorem
3.2, we proved that under certain assumptions the transformed ODE system (30) is nonstiff. Here, we shall verify this statement numerically by solving the three-scale ODE system
(59) with an initial value (w1 (0), ..., w6 (0))T = (0.12, 0.12, 0.12, 0.12, 0.12, 0.12)T . We compute the maps Φ1 and Φ2 in our method with different t1 and t2 for (y1 (0), ..., y6(0))T =
(0.20, 0.20, 0.20, 0.20, 0.20, 0.20)T . In addition, we record the quantities P2 = Φ2t2 (Φ1t1 (y)),
T1 = ǫ11 ∂t1 Φ1t1 (y), T2 = ǫ12 ∂t2 Φ2t2 (Φ1t1 (y)), and D1 = ẏ. Recall that these quantities were
defined in Section 2.3, especially in the Algorithm 1.
In Fig.3, we show the six components of the quantities f (y) − D1 as functions of t1 and
t2 (i.e., the six components of right hand side of the ODE system (59) minus their numerical
counterparts), where ǫ1 = 0.0001 and ǫ2 = ǫ21 . In this example, max |f (y)| is O(1). We also
compute the cases when ǫ1 = 0.01 and ǫ1 = 0.001 with ǫ2 = ǫ21 and find the patterns of the
six components of the quantities ẏ − D1 remain almost the same as the Fig.3. Thus, we do
not show them here.
In Fig.4, we show the magnitude of the quantity Φ2t2 (Φ1t1 (y)) − y as functions of t1 and t2
when ǫ1 = 0.01 and ǫ2 = ǫ21 . The results for Φ2t2 (Φ1t1 (y)) − y when ǫ1 = 0.01 and ǫ2 = ǫ21 are
shown in Fig.5. One can see that when there is no scale separation Φ2t2 (Φ1t1 (y)) are fluctuating
along t2 direction. This result provides numerical confirmation of our derivation. We can
write Φ2t2 (Φ1t1 (y)) explicitly out as,
Φ2t2 (Φ1t1 (y)) = Φ1t1 (y) + ǫ2 g 2 (t2 , t1 , Φ1t1 (y)) = y + ǫ1 g 1 (t1 , y) + ǫ2 g 2 (t2 , t1 , y + ǫ1 g 1 (t1 , y)).
(60)
Then given y, when ǫ1 and ǫ2 are close, ǫ2 g 2 (t2 , t1 , y + ǫ1 g 1 (t1 , y)) is comparable to ǫ1 g 1 (t1 , y).
In Fig.6 and Fig.7, we show the magnitude of the quantities T1 and T2 as functions of t1
and t2 , when ǫ1 = 0.0001 and ǫ2 = ǫ21 , respectively. We also compute the quantities T1 and T2
15

Component1

Component2

0

Component3

0

0

0.1

0.1

0.05

0.05
0

-0.05

-0.05

-0.05

-0.1

-0.1

2

-0.1

2

2

2

0

0

t2

0

t2

t2

0.05

2

0

t1

2

0

t1

Component4

t1

Component5

0

Component6

0

0

0

0.1

0.04

-0.5
0.02

-1

-2

0

t2

-1.5

t2

t2

0.05

0

-2.5
-0.02

-3

-0.05

-3.5

2

2
2

0

2

0

t1

-0.04

2

10 -6

2

0

t1

t1

Figure 3: Six components of f (t1 , t2 , y) − D1 . Here ǫ1 = 0.0001 and ǫ2 = ǫ21 .

10 -4

Component1

Component2

0

10 -4

Component3

0

0

8

0

6

-2

6

-4

2

-6

2

-8

0

2

2
2

0

t2

t2

t2

4
4

2

0

t1

0

2

10 -4

2

0

t1
10 -4

Component4

t1

Component5

0

Component6

0

0

1

0

5
4

-1

0.5

0

t2

t2

2

t2

3
-2

1
0

-3

-0.5

-1
-2

2
2

0

t1

-1

2
2

0

2

t1

Figure 4: Φ2t2 (Φ1t1 (y)) − y when ǫ1 = 0.01 and ǫ2 = ǫ21 .

16

2

0

t1

-4
10 -4

10 -4

Component1
0

Component2

10 -4

Component3

0

10

0

2

6

-2

4
2

-6

0

-8

-2

2

-4

2

0

-10

2

2

0

4

t2

0

t2

t2

6
8

2

0

t1

2

10 -4

2

0

t1
10 -4

Component4

t1

Component5

0

Component6

0

0

1

0

6
-1

0.5

0

t2

2

t2

t2

4
-2

0
-3

-0.5
-2

2

-1

2
2

0

t1

2

0

2
2

0

t1

Figure 5: Φ2t2 (Φ1t1 (y)) − y when ǫ1 = 0.01 and ǫ2 =

-4
10 -4

t1

ǫ1
2 .

when ǫ1 changes (e.g. ǫ1 = 0.01 and ǫ1 = 0.001) with ǫ2 = ǫ21 and find the time derivatives of
T1 and T2 remain almost the same magnitude as that shown in Fig.6 and Fig.7. This implies
the implicit iterative scheme Eq.(35) for Eq.(34) keeps the magnitude of the non-midpoint
P
setting, ∂t Φk = ki=1 ǫǫki ∂ti g k . Notice that component 5 and 6 do not depend on t2 . This is
due to the fact that f5 and f6 are independent of t2 . T1 is independent of t2 for difference
choice of ǫ1 and ǫ2 , this is due to the definition of T1 ; see Fig.6.
4.2. An ODE system with four separated time scales
To further study the performance of our method, we mimic the formulation of the three
dimensional Hénon-Heiles system and generate a Hamiltonian system with four time scales.
The Hamiltonian is given by,
H(q, p) =

p21
q2
p2
q2
p2
q2
p2 q 2
+ 1 + 2 + 2 + 3 + 3 + 4+ 4
2ǫ3 2ǫ3 2ǫ2 2ǫ2 2ǫ1 2ǫ1
2
2
1
1
1
+ q12 q2 + q22 q3 + q32 q4 − q23 − q33 − q43 ,
3
3
3

(61)

where p = (p1 , p2 , p3 , p4 )T and q = (q1 , q2 , q3 , q4 )T . The Hamiltonian in (61) is parameterized
by ǫ1 , ǫ2 , and ǫ3 . One can obtain the evolution equation for the Hamiltonian in (61) by
= − ∂H
and dq
= ∂H
. When 0 < ǫ3 ≪ ǫ2 ≪ ǫ1 ≪ 1, the associated
using the relation dp
dt
∂q
dt
∂p
evolution equation of the Hamiltonian in (61) becomes a four-scale ODE system. Since the
formulation of the change of variables and derivation of the transformed ODE system are
standard (similar as we did in Eqns.(58) and (59)), we do not show them here.
Verification of the convergence analysis. Let us now check that our method preserves
the Hamiltonian of the system. In Fig.8, we present the error of the Hamiltonian (61)
17

Component1

Component2

0

Component3

0

0.05

0

0.05

0.08
0.06
0.04

0

t2

t2

t2

0.02
0

0
-0.02
-0.04
-0.06

-0.05

-0.05

2

2

2

2

0

2

0

t1

t1

Component4

t1

Component5

0

2

0

Component6

0

0

1

0.06

0.03

0.04

0.5

0.02

0.02
0

t2

0.01

t2

t2

0

0

-0.02

-0.01

-0.04

-0.5

-0.02

-0.06

-0.03

-0.08

2

-1

2

2

0

2

0

t1

2
2

0

t1

t1

Figure 6: T1 when ǫ1 = 0.0001 and ǫ2 = ǫ21 .

Component1

Component2

Component3

0

0
0.06

0.03

0.04

0.04

0.02

0.02

0.02

0.01

0

0

t2

0.06

t2

t2

0

-0.02

-0.01

-0.04

-0.04

-0.02

-0.06

-0.06

2

-0.03

2

2

2

0

0

-0.02

2

0

t1
Component4

t1

Component5

0

2

0

t1

Component6

0

0

1

1

0.03
0.5

0.02

0.5

0

t2

0

t2

t2

0.01
0

-0.01
-0.5

-0.02

-0.5

-0.03

2

-1

2
2

0

t1

2

0

-1

2

t1

Figure 7: T2 when ǫ1 = 0.0001 and ǫ2 = ǫ21 .

18

2

0

t1

as a function of time for different ǫi , i = 1, 2, 3. In Fig.8(a), we set the multiscale timescale parameters to be (ǫ1 , ǫ2 , ǫ3 ) = (10−3 , 11 × 10−5 , 3 × 10−6) and the initial values are
wi (0) = 0.44 for i = 1, · · · , 8. In Fig.8(b), we set (ǫ1 , ǫ2 , ǫ3 ) = (0.5, 11 × 10−6 , 3 × 10−6 ) and
the initial values are the same. Notice that the smallest period of the ODE system is about
2π × ǫ3 ≈ 1.885 × 10−5. To resolve the oscillation in the solution, we choose the time step
for the fine-scale ODE solver to be ∆t = 5 × 10−6. To implement our method, we choose the
time step to be ∆t = 10−1 .
Numerical results in Fig.8 show that: (1) directly using the implicit integral midpoint
scheme (46) with a coarse time step ∆t = 10−1 gives wrong results; (2) our method with the
same coarse time step ∆t = 10−1 gives an accurate result that is comparable to that using
the scheme (46) with a very fine time step ∆t = 10−6 . This comparison again confirms that
our scheme has a uniform accuracy in computing ODE system with multiple time-scales. In
addition, from the results in Fig.8(b), where (ǫ1 , ǫ2 , ǫ3 ) = (0.5, 11 × 10−6 , 3 × 10−6 ), we can
see that when the time scales are not well separated ( i.e., ǫ3 is close to ǫ2 and ǫ1 is close to
1), our numerical method still gives an excellent performance.
In terms of the computational time, our method takes 0.163 and 0.367 seconds to compute
the result shown in Fig.8(a) and Fig.8(b), respectively. While the direct Im2nd method with
∆t = 5 × 10−6 takes about 10.48 seconds for both. Thus, our method achieves a 20 ∼ 60X
speedup over the conventional ODE solver in this example. Moreover, our method provides
uniform accurate results for different values of ǫi , i = 1, 2, 3. The conventional ODE solvers,
such as the direct Im2nd method, require to choose finer time steps when we decrease ǫi ,
i = 1, 2, 3. Therefore, it is expected that a higher speedup will be achieved when we need to
solve a multiscale ODE system with much smaller ǫi , i = 1, 2, 3.
4

5
4
3

Im2nd, t=5e-6
Im2nd, t=0.1
UA, t=0.1

log10(err(H))

log10(err(H))

2

0

-2

2

Im2nd, t=5e-6
Im2nd, t=0.1
UA, t=0.1

1
0
-1
-2

-4

-3
0

0.5

1

1.5

2

2.5

3

0

0.5

1

1.5

t

t

(a)

(b)

2

2.5

3

Figure 8: Evolution of the error of the Hamiltonian in the four-scale ODE system. Left: (ǫ1 , ǫ2 , ǫ3 ) =
(10−3 , 11 × 10−5 , 3 × 10−6 ). Right: (ǫ1 , ǫ2 , ǫ3 ) = (0.5, 11 × 10−6 , 3 × 10−6 ).

We also investigate the convergence rate of our method with respect to the time step. In
Fig.9, we show the error as a function of ∆t for two sets of values of ǫ1 , ǫ2 , and ǫ3 at time
19

T = 3, respectively. The intial values xi (0), i = 1, ..., 8 and values of (ǫ1 , ǫ2 , ǫ3 ) are the same
as before. The reference solution is obtained by Matlab ode45 function applied to the ODE
system, where the time step is ∆t = 5 × 10−7 . We observe a second-order convergence rate
with respect to ∆t in our method, which verifies the error estimate in Theorem 3.4. Most
importantly, the error is independent of ǫ1 , ǫ2 , and ǫ3 as shown in Fig.9.
100

l2err

10-2

=[1e-3,11e-6,3e-6]
=[0.5,11e-6,3e-6]
slope 1
slope 2

10-4

10-6

10-8
10-4

10-3

10-2

10-1

t
Figure 9: Error as a function of ∆t for two sets of multiscale parameters at time T = 3.

Difference between F and f¯1 . Simple calculations show that the right hand side of
Eq.(30), i.e. F (t, x) is approximately equal to f¯1 . One may expect that replacing the ODE
system (30) by ỹ˙ = f¯1 will generate a solution that is close to the original one. We aim to
investigate this issue in Fig.8(a). Here, we calculate f¯1 and directly solve ỹ˙ = f¯1 , which will
be referred as the averaged method. In Fig.10(a) and Fig.10(b), we plot the first and fifth
component of ỹ, i.e., w1 (t) and w5 (t) obtained by several different methods.
Fig.10(a) shows that w1 (t) is nearly a constant. Thus, the averaged method still performs
well. Fig.10(b) shows that w5 (t) has oscillations. In this case, the averaged method cannot
capture the right behavior of the solution, while our method can. We find that (1) the direct
Im2nd method with a coarse time step gives wrong results; (2) the solutions for component
w1 (t) obtained by the averaged method and our method agree with the reference solution; (3)
the solution for component w5 (t) obtained by the averaged method has large errors, while the
solution for component w5 (t) obtained by our method still approximates the reference solution
well. This experiment shows that F (t, x) in (30) indeed captures the correct dynamics of the
original multiscale problem, while the direct average term f¯1 cannot.
4.3. An ODE with a complicated right-hand side
In the previous numerical experiments, all the integrals in our numerical schemes can be
pre-computed analytically. Here, we consider a three-scale ODE, which is defined by
2πt
2πt
+ sin
))x.
(62)
ẋ = (1.5 − exp(sin
ǫ1
ǫ2
20

0.55

0.9
Im2nd, t=5e-6
Im2nd, t=0.1
UA, t=0.1
Averaged, t=0.1

Im2nd, t=5e-6
Im2nd, t=0.1
UA, t=0.1
Averaged, t=0.1

0.8
0.7

x5

x1

0.5

0.6
0.5

0.45

0.4
0.4

0.3
0

0.5

1

1.5

2

2.5

3

0

t

0.5

1

1.5

2

2.5

3

t

(a)

(b)

Figure 10: w1 and w5 obtained by using different methods.

In this example, the right-hand side of the ODE (62) does not have analytic expressions.
Thus, we use numerical quadrature rules to compute the integrals in our numerical schemes.
Since the integrands of f k , k = 1, 2 are smooth along x direction, we use 8 points in the
quadrature rules to compute the integration for f¯k , e.g. Eqns.(4), (6), (8), and (10). To
compute derivatives of g, we directly use a central difference scheme with ∆x = 10−3 . We
choose the initial value x0 = 0.48 and (ǫ1 , ǫ2 ) = [7 × 10−2 , 11 × 10−5 ] in the ODE (62).
In Fig.11(a), we show the numerical results obtained by different methods with different
time steps. We find that: (1) the direct Im2nd method with the coarse time step ∆t = 0.1
gives totally wrong results; (2) our method with very coarse time steps, ∆t = 0.1 and
∆t = 0.5, gives an accurate result that is comparable to that using the direct Im2nd method
with a very fine time step ∆t = 10−5 . This comparison again confirms that our method has
a uniform accuracy in computing ODE system with multiple time-scales. In this experiment,
our method with ∆t = 0.5 costs 1.39s, while the direct Im2nd method with ∆t = 10−5
costs 5.97s. More savings can be achieved if the ODE (62) is described by smaller multiscale
parameters ǫ1 and ǫ2 .
As a byproduct of our robust numerical method (namely we can solve the complicated
ODE with very large time step), we can use the representation in Eq.(14) to recover the
solution of the ODE (62) in a neighborhood of the numerical solution points. In Fig.11(b),
we show the recovered solution in the time domain [0.5, 0.501] based on the solution of our
method at t = 0.5. We can see that the recovered solution agrees with the reference solution
and the recovered solution captures the high oscillate structure in this neighborhood.
5. Conclusions
In this paper, we have successfully developed a class of robust numerical methods to solve
dynamical systems with multiple time scales. These problems are difficult to solve when the
21

1.041
UA, t=0.1
Im2nd, t=1e-5

1.1
1.08
1.0405

x(t)

x(t)

1.06
1.04
1.02

1.04
Im2nd, t=1e-5
Im2nd, t=0.1
UA, t=0.1
UA, t=0.5

1
0.98

1.0395

0.96
0

0.2

0.4

0.6

0.8

1

0.5

0.5002

0.5004

0.5006

0.5008

0.501

t

t

(a)

(b)

Figure 11: An ODE with a complicated right-hand side

multiscale parameters are small. The essential idea of our method is to represent the solution
of the dynamical systems as a transformation of a slowly varying solution. Based on the scale
separation assumption, we provide an efficient way to construct the transformation map and
derive the dynamic equation for the slowly varying solution. Under some mild assumptions,
we obtain the convergence of the proposed method. Finally, we present several numerical
examples, including ODE system with three and four separated time scales to demonstrate
the accuracy and efficiency of the proposed method. Numerical results show that: (1) our
method is robust and accurate in solving ODE systems with multiple time scale, where the
time step does not depend on the multiscale parameters; and (2) the construction of the
cumulative composition maps (which deals with the multiscale information in a dimensionby-dimension fashion) is necessary while a simple average treatment leads to wrong results.
There are two lines of work that deserve further explorations in the near future. Firstly,
we shall consider to extend our proposed method to solve dynamical systems without scale
separation. The idea mentioned in Remark 2.3 is a good starting point. However, we need
to design fast solvers. Secondly, we are interested in extending our proposed method to solve
elliptic PDEs with multiscale parameters.
Acknowledgements
The research of T. Hou is partially supported by the NSF Grants DMS-1613861, DMS1907977, and DMS-1912654. The research Z. Wang is partially supported by the Hong
Kong PhD Fellowship Scheme. The research of Z. Zhang is supported by Hong Kong RGC
grants (Projects 27300616, 17300817, and 17300318), National Natural Science Foundation
of China via grant 11601457, Seed Funding Programme for Basic Research (HKU), and Basic
Research Programme (JCYJ20180307151603959) of The Science, Technology and Innovation
Commission of Shenzhen Municipality. The computations were performed using the HKU
22

ITS research computing facilities that are supported in part by the Hong Kong UGC Special
Equipment Grant (SEG HKU09).

References
[1] A. Abdulle, E. Weinan, B. Engquist, and E. Vanden-Eijnden, The heterogeneous multiscale method, Acta Numerica, 21 (2012), pp. 1–87.
[2] S. Bartlett, P.and Evans and P. Long, Representing smooth functions as compositions of near-identity functions with implications for deep network optimization,
arXiv:1804.05012, (2018).
[3] P. Chartier, N. Crouseilles, M. Lemou, and F. Méhats, Uniformly accurate
numerical schemes for highly oscillatory Klein–Gordon and nonlinear Schrödinger equations, Numerische Mathematik, 129 (2015), pp. 211–250.
[4] P. Chartier, M. Lemou, F. Méhats, and G. Vilmart, A new class of uniformly
accurate numerical schemes for highly oscillatory evolution equations, Found. Comput.
Math., 19 (2019), pp. 1–33.
[5] Y. Efendiev and T. Y. Hou, Multiscale finite element methods. Theory and applications, Springer-Verlag, New York, 2009.
[6] B. Engquist and T. Hou, Particle method approximation of oscillatory solutions to
hyperbolic differential equations, SIAM journal on numerical analysis, 26 (1989), pp. 289–
319.
[7] S. Ferrer, M. Lara, J. Palacian, J. Juan, A. Viartola, and P. Yanguas, The
hénon and heiles problem in three dimensions. ii. relative equilibria and bifurcations in
the reduced system, International Journal of Bifurcation and Chaos, 8 (1998), pp. 1215–
1229.
[8] E. Hairer, C. Lubich, and G. Wanner, Geometric numerical integration: structurepreserving algorithms for ordinary differential equations, vol. 31, Springer Science &
Business Media, 2006.
[9] M. Hénon and C. Heiles, The applicability of the third integral of motion: some
numerical experiments, The Astronomical Journal, 69 (1964), p. 73.
[10] T. Hou, Homogenization for semilinear hyperbolic systems with oscillatory data, Communications on pure and applied mathematics, 41 (1988), pp. 471–495.
[11] T. Hou, D. Yang, and H. Ran, Multiscale analysis and computation for the threedimensional incompressible Navier–Stokes equations, Multiscale Model. Simul., 6 (2008),
pp. 1317–1346.
23

[12] A. Iserles, A first course in the numerical analysis of differential equations, no. 44,
Cambridge university press, 2009.
[13] C. Jones and A. Khibnik, Multiple-time-scale dynamical systems, vol. 122, Springer
Science & Business Media, 2012.
[14] I. Kevrekidis, C. Gear, J. Hyman, P. Kevrekidid, O. Runborg, and
C. Theodoropoulos, Equation-free, coarse-grained multiscale computation: Enabling
mocroscopic simulators to perform system-level analysis, Commum. Math Sci., 1 (2003),
pp. 715–762.
[15] C. Kuehn, Multiple time scale dynamics, vol. 191, Springer, 2015.
[16] L. Perko, Differential equations and dynamical systems, vol. 7, Springer Science &
Business Media, 2013.
[17] Z. Shen, H. Yang, and S. Zhang, Nonlinear approximation via compositions,
arXiv:1902.10170, (2019).
[18] M. Tao, H. Owhadi, and J. Marsden, Nonintrusive and structure preserving multiscale integration of stiff ODEs, SDEs, and Hamiltonian systems with hidden slow dynamics via flow averaging, Multiscale Model. Simul., 8 (2010), pp. 1269–1324.
[19] M. Tuckerman, B. Berne, and G. Martyna, Reversible multiple time scale molecular dynamics, J. Chem. Phys., 97 (1992), pp. 1990–2001.

24

