Query complexity of generalized Simon’s problem
Zekun Yea , Yunqi Huanga , Lvzhou Lia,b,∗, Yuyi Wangc

arXiv:1907.07367v4 [cs.CC] 3 May 2021

a School

of Data and Computer Science, Sun Yat-Sen University, Guangzhou 510006, China
of Education Key Laboratory of Machine Intelligence and Advanced Computing
(Sun Yat-sen University), Guangzhou 510006, China
c Disco Group, ETH Zurich, Switzerland

b Ministry

Abstract
Simon’s problem plays an important role in the history of quantum algorithms,
as it inspired Shor to discover the celebrated quantum algorithm solving integer
factorization in polynomial time. Besides, the quantum algorithm for Simon’s
problem has been recently applied to break symmetric cryptosystems. Generalized Simon’s problem, denoted by GSP(p, n, k), is a natural extension of Simon’s
problem: Given a function f : Znp → X where X is a finite set and the promise
that for any x, y ∈ Znp , f (x) = f (y) iff x − y ∈ S for a subgroup S ≤ Znp of rank
k < n, the goal is to find S. In this paper we consider the query complexity
of the problem, that is, the minimum number of queries to f required to find
S. First, it is not difficult to design a quantum algorithm solving the above
problem with query complexity of O(n − k). However, so far it is not clear what
is the classical query complexity of the problem, and revealing this complexity
is necessary for clarifying the computational power gap between quantum and
classical computing on the problem.
To tackle this problem, we prove that any classical (deterministic
or ran

p
domized) algorithm for GSP(p, n, k) has to query at least Ω max{k, pn−k }
values and any classicalnonadaptive deterministic
algorithm for GSP(p, n, k)

p
n−k
} values. Hence, we clearly show
has to query at least Ω max{k, k · p
the classical computing model is less powerful than the quantum counterpart,
in terms of query complexity for the generalizedSimon’s problem. Moreover,
p
we obtain an upper bound O max{k, k · pn−k } on the classical deterministic
query complexity of GSP(p, n, k), by devising a subtle classical algorithm based
on group theory and the divide-and-conquer approach. Therefore, we have an
almost full characterization of the classical deterministic query complexity of
∗ Corresponding author. Mobile: +8613802437672; Corresponding address: School of Data
and Computer Science, Sun Yat-sen University, Guangzhou 510006, China
E-mail address: yezekun@mail2.sysu.edu.cn (Z. Ye); lilvzh@mail.sysu.edu.cn (L. Li)

Preprint submitted to Elsevier

May 4, 2021

the generalized Simon’s problem.
Keywords: Simon’s problem, query complexity, quantum computing, group
theory

1. Introduction
Query complexity, also called decision tree complexity [22], is the computational complexity of a problem or algorithm expressed in terms of the decision
tree model. It has been very useful for understanding the power of different
computational models. In contrast to the Turing machine world where lower
bounds and separations between complexity classes often have to rely on unproven conjectures, using query complexity can often prove tight lower bounds
and have provable separations between different computational models. For
instance, quantum computing has been shown to have exponential advantages
over classical computing in terms of query complexity.
Simon’s problem is well known in the history of quantum algorithms. It
shows an exponential gap between classical and quantum computing. The definition of Simon’s problem is as follows.
Given: An (unknown) function f : {0, 1}n → {0, 1}m.
Promise: There exists a nonzero element s ∈ {0, 1}n such that
for all g, h ∈ {0, 1}n, f (g) = f (h) iff g = h or g = h ⊕ s.
Problem: Find s.
Simon [36] proposed a quantum algorithm to efficiently find s. Shortly afterward, inspired by this algorithm, Shor discovered the celebrated quantum
algorithm for the integer factorization problem [35]. Actually, Simon’s problem
and its variants have attracted a lot of attention from the academic community
[4, 10, 14, 26, 28, 32, 34, 38]. More details will be introduced in the section of
related work soon.
1.1. Problem statement and our results
Several extended versions of Simon’s problem with a minor difference have
been studied from the viewpoint of quantum computing [4, 10, 26, 32, 38]. An
extended version of Simon’s problem can be described as: Given an (unknown)
function f : Zn2 → X with a finite set X and a positive integer k < n, it
2

is promised that there exists a subgroup S ≤ Zn2 of rank k such that for any
x, y ∈ Zn2 , f (x) = f (y) iff x⊕ y ∈ S, and then the goal is to find S. This problem
is a natural extension since Simon’s problem is a special case of it with k = 1.
Example 1. We present an example of the above generalized Simon’s problem in Table 1. In this example, n = 4, k = 2, and we can find that S =
{0000, 0011, 0110, 0101}.
Table 1: An example of the generalization of Simon’s problem

x
0000
0001
1000
1001

0011
0010
1011
1010

0110
0111
1110
1111

0101
0100
1101
1100

f (x)
0000
0001
0010
0011

In this paper, we consider a more general extension of Simon’s problem,
called a generalized Simon’s problem as follows. In this case, we generalize the
domain of f from Zn2 to Znp , where p is a prime.
Given: An (unknown) function f : Znp → X, where X is a finite set,
and a positive integer k < n.
Promise: There exists a subgroup S ≤ Znp of rank k such that
for any x, y ∈ Znp , f (x) = f (y) iff x − y ∈ S.
Problem: Find S.
For convenience, we use GSP(p, n, k) to denote the above problem with parameter n, p, k throughout this paper. It is easy to see that Simon’s problem is
a special case of GSP(p, n, k) with p = 2 and k = 1.
To find the subgroup S, we need to design an algorithm that is allowed to
access the function f by querying an oracle that, given x, outputs f (x). According to randomness, algorithms can be divided into deterministic algorithms
and randomized algorithms. Deterministic algorithms solve the problem with
certainty, whereas randomized algorithms solve the problem with bounded error probability. Moreover, we also study a class of widely studied algorithms,
nonadaptive algorithms, where current queries are not allowed to depend on the
result of previous queries.

3

The deterministic query complexity of GSP(p, n, k) is the query complexity
of the optimal deterministic algorithm for that, and the query complexity of an
algorithm is the number of queries it makes in the worst case. the randomized
and nonadaptive deterministic query complexities of GSP(p, n, k) can be defined
in a similar way.
In this paper, we obtain some characterizations of the query complexity of
GSP(p, n, k) in the following theorems.
Theorem 1 (Lower bound). Any classical 
(deterministic or randomized) algop
rithm solving GSP(p, n, k) needs to make Ω max{k, pn−k } queries.
Theorem 2 (Lower bound).Any nonadaptive classical
deterministic algorithm

p
n−k
solving GSP(p, n, k) needs Ω max{k, k · p
} queries.

Theorem 3 (Upper bound).
exists a classical
deterministic algorithm to
 Therep

n−k
solve GSP(p, n, k) using O max{k, k · p
} queries.
√
Remark 1. When p = 2 and k = 1, the query complexity is Θ( 2n ) which is
the same as the result presented in [14, 16].
To prove the theorems above, we first use the double-counting method and
the adversary method to obtain the lower bounds. Furthermore, we design
a classical deterministic algorithm, obtaining the upper bound of the query
complexity. Our algorithm is based on group theory and the divide-and-conquer
technique.
Table 2: Known results about the query complexity of Simon’s problem and generalized
Simon’s problem. The randomized, deterministic and nonadaptive deterministic query complexities of GSP(p, n, k) are obtained in this paper.
Simon’s problem

quantum
Θ(n) [10, 14, 28, 32, 36]

GSP(p, n, k)

Θ(n − k)1

randomized/deterministic
√
Θ( 2n )[14, 16]




p
p
Ω max{k, pn−k } , O max{k, k · pn−k }

nonadaptive deterministic


p
Ω max{k, k · pn−k }

1.2. Motivation
Simon’s problem plays a key role in the history of quantum algorithms and
recently it has been found useful for applications in cryptography. First, the
1 The work in [23] implies that GSP(p, n, k) can be solved in O(n − k) queries by a quantum
algorithm with bounded error. Moreover, it can be solved by an exact quantum algorithm with
O(n − k) queries, if we slightly adjust the algorithms in [10] (see Appendix A). Additionally,
by generalizing the lower bound method of [28], it was found that any quantum algorithm for
GSP(p, n, k) has to query at least Ω(n − k) times with p = 2 [38]. It is trivial to obtain the
same result for general p.

4

quantum algorithm [36] for this problem inspired the discovery of Shor’s algorithm [35] solving integer factorization in polynomial time, and also inspired
Buhrman et al. [12] to propose the first exponential speed-up for quantum property testing. Furthermore, Simon’s algorithm can be used to show the insecurity
of commonly used cryptographic symmetric-key primitives. For example, Kaplan et al. [25] showed that several classical attacks based on finding collisions
can be exponentially speeded up using Simon’s algorithm. Moreover, it was
used to break the 3-round Feistel construction [30] and then to prove that the
Even-Mansour construction [31] is insecure with superposition queries. Also, it
can be used to quantum related-key attacks [33].
GSP(p, n, k) is a natural extended version of Simon’s problem and also a
special case of the hidden subgroup problem. The motivations for studying
GSP(p, n, k) are as follows.
• First, from the viewpoint of quantum computing, characterizing the classical query complexity of GSP(p, n, k) is necessary for clarifying the computational power gap between quantum and classical computing on this
problem. Note that we have a comprehensive understanding of the quantum query complexity for GSP(p, n, k) (see Table 2). However, as far as
we know, how well does a classical algorithm perform on this problem still
needs to be explored.
• Second, from the viewpoint of classical computing, it is an interesting
problem to reveal the query complexity of GSP(p, n, k), as it generalizes the
well-studied Simon’s problem and the ideas to solve the generalized problems are completely different from that for the original one. GSP(p, n, k)
is a more general problem in mathematics, and the hidden law behind it
is worth exploring. Based on our in-depth study, we find this problem
seems not so straightforward to solve, instead, it involves several techniques, such as the double-counting method, the adversary method, and
the divide-and-conquer method.
1.3. Related work
Query complexity is a very successful measurement to study the relative
power of quantum and classical computing. For quantum computing, query
models can be divided into bounded-error and exact versions in terms of their
outputs. A bounded-error model requires that the algorithm gives the correct
result with some sufficiently high probability, while an exact model means that
the algorithm gives the correct result with certainty. For the bounded-error case,
5

there is much work showing the advantage of quantum algorithms over classical
ones in terms of query complexity, e.g., [2, 3, 13]. However, the results for exact
query algorithms seem more limited. For total Boolean functions, Beals et al.
[9] showed that quantum query algorithms only achieve polynomial speed-up
over classical counterparts. In 2013, Ambainis [5] presented the first example
that exact quantum computing has a superlinear advantage over deterministic
algorithms. This result has been further improved by [6] with a quadratic gap
between its quantum and deterministic query complexity. On the other hand,
for computing partial functions, there exists a super-exponential separation as
shown by the famous Deutsch-Jozsa algorithm [17]: constant versus linear.
In 1994, Simon’s problem was shown to be solvable on quantum computers with O(n) queries in the bounded-error setting. The lower bound of query
complexity was proved to be Ω(n) in [28] by applying the polynomial method
[9]. For exact quantum query algorithms, Brassard and Høyer [10] solved the
problem with O(n) queries. Compared with their algorithm, Mihara and Sung
[32] proposed a simpler exact quantum algorithm. Apart from quantum algorithms, Cai and Qiu [14] designed a classical deterministic algorithm for solving
√
Simon’s problem with O( 2n ) queries and proved their algorithm is optimal in
terms of query complexity.
Moreover, Simon’s problem is a special case of a well-studied class of problems, the so-called hidden subgroup problem. That is, given a function f : G →
X, where G is a finitely generated group and X is a finite set, such that f
is bijective on G/S for a subgroup S ≤ G, the goal is to find S. Jozsa [24]
provided a uniform description of several important quantum algorithms such
as Deutsch-Jozsa [17], Simon [36], and Shor [35] algorithms in terms of the hidden subgroup problem. Indeed, this problem has received a lot of attention,
and many quantum algorithms were proposed for its different variants, e.g.,
[8, 15, 18, 19, 20, 21, 27, 29].
In Simon’s problem, it is assumed that G = Zn2 and |S| = 2. There are two
directions to generalize Simon’s problem. Alagic et al. [4] generalized Simon’s
problem by assuming G = K n , where K is a non-Abelian group of constant
size, and S is either trivial or |S| = 2. Additionally, they proposed an efficient
√
quantum algorithm with time complexity 2O( n log n) to solve this extended
version of Simon’s problem. Brassard and Høyer [10] proposed another extended
version of Simon’s problem by assuming G = Zn2 and S ≤ G, and solved this
problem with O(n) query complexity. Also, a similar result has been obtained
in [32]. Moreover, Brassard and Høyer [10] generalized their results to any finite
general additive group.

6

In this paper, we consider the generalized Simon’s problem similar to the
problem in [10]. It is assumed that G = Znp and rank(S) = k, and the problem
is denoted by GSP(p, n, k) as mentioned before. It is not difficult to see that
GSP(p, n, k) can be solved exactly by adjusting the algorithms of [10] slightly
(see Appendix A), and be solved with bounded error by a generalized Simon
algorithm [23]. All these algorithms need O(n − k) queries. Meanwhile, by
generalizing the method of [28], Wu et al. [38] found that the lower bound of
quantum complexity of GSP(p, n, k) is Ω(n − k) with p = 2. It is easy to obtain
the same result for general p.
To clarify the computational power gap between quantum and classical computing on this problem, there ought to be a characterization of the classical query
complexity of it. However, to our knowledge, almost no related result has been
obtained, except for the work [38]. Compared with this work, our results are
more general, since we consider the case G = Znp rather than G = Zn2 . Meanwhile, in terms of classical query complexity, completely different techniques are
used to obtain lower bounds, and we construct a smarter algorithm to obtain
a better upper bound. Furthermore, if their lower bound proof was correct,
then we could generalize their method to obtain the tight bound of the classical
query complexity of GSP(p, n, k). However, it is unfortunate that we could not
verify its correctness.
1.4. Organization
The remainder of the paper is organized as follows. In Section 2, we review some notations concerning group theory used in this paper. In Section
3, we present the lower bounds of deterministic, randomized and nonadaptive
deterministic query complexity of GSP(p, n, k). In Section 4, an upper bound is
obtained by giving a deterministic algorithm. Finally, a conclusion is made in
Section 5. For completeness, an exact quantum query algorithm for GSP(p, n, k)
is given in Appendix A.
2. Preliminaries
In this section, we present some notations used in this paper. Let Zp denote
the additive group of elements {0, 1, ..., p − 1} with addition modulo p, and Z∗p
denote the multiplication group of elements {1, 2, ..., p − 1} with multiplication
modulo p. In the following, all the groups we mention are Znp or its subgroup
without special instructions, where p is a prime. Let x, y ∈ Znp with x =

7

(x1 , x2 , ..., xn ) and y = (y1 , y2 , ..., yn ). For x, y ∈ Znp with x = (x1 , x2 , ..., xn )
and y = (y1 , y2 , ..., yn ), we define
x + y := ((x1 + y1 ) mod p, (x2 + y2 ) mod p, ..., (xn + yn ) mod p),
x − y := x + (−y).
For X, Y ⊆ Znp , w ∈ Znp , we define
X \ Y := {x | x ∈ X ∧ x ∈
/ Y },
X + Y := {x + y | x ∈ X, y ∈ Y },
X + w := {x + w | x ∈ X},
X − w := X + (−w).
We also use the abbreviated notation Xw for X + w and X ∪ w for X ∪ {w}.
Let αx denote x + x + · · · + x (the number of x is α). By hXi, we denote the
subgroup generated by X, i.e.,
)
( k
X
αi xi |xi ∈ X, αi ∈ Zp .
hXi :=
i=1

The set X is called a generating set of hXi. A set X is linearly independent if
hXi 6= hY i for any proper subset Y of X. In other words, a set X is linearly independent if X is the smallest generating set of hXi. Notice that the cardinality
|hXi| is p|X| if X is linearly independent.
For any group G, the basis of G is a maximal linearly independent subset
of G. The cardinality of the basis of G is called its rank, denoted by rank(G).
If H is a subgroup of G, then we write H ≤ G; if H is a proper subgroup, then
H < G.
Definition 1 (Complement Subgroup). For a group G and its subgroup H, a
group H G is called a complement subgroup of H in G if H + H G = G and H ∩
H G = {0n }.
In this paper, we abbreviate H G as H when G = Znp .
To obtain our results, we need the following facts to characterize the query
complexity of GSP.
Fact 1. Let V, W be two subgroups of Znp such that V ∩ W = {0n }, X be a basis
of V and Y be a basis of W . Then rank(V + W ) = rank(V ) + rank(W ) and
X ∪ Y is a basis of V + W .
8

Fact 2. Let {xi } ⊆ Znp . If
linearly independent.

P

i

αi xi = 0 implies αi = 0 for any i, then {xi } is

Fact 3. Suppose V, H is two subgroups of Znp such that V ∩ H = {0n }. For
w∈
/ V , we have hV ∪ wi ∩ H = {0n } ⇔ Vw ∩ H = ∅.
Proof. Suppose hV ∪wi∩H = {0n }. Since Vw ⊆ hV ∪wi, we have Vw ∩H ⊆ {0n }.
Because 0n ∈
/ Vw , we have Vw ∩ H = ∅. Now suppose hV ∪ wi ∩ H 6= {0n }.
Then there exists a non-zero element h ∈ hV ∪ wi ∩ H. Since V ∩ H = {0n },
we assume that h = αw + v, where α ∈ Zp∗ and v ∈ V . Since h ∈ H, we have
α−1 s ∈ H. Because α−1 s = w + α−1 v ∈ Vw , we have α−1 h ∈ Vw ∩ H. Thus,
hV ∪ wi ∩ H 6= {0n } implies Vw ∩ H 6= ∅.
3. Lower bound
In this section, we first present a lower bound by proving Theorem 1.
Theorem 1. Any classical (deterministic orrandomized) algorithm solving
p
GSP(p, n, k) needs to make Ω max{k, pn−k } queries.

Without loss of generality, we only need to prove the randomized query
complexity, which consists of Lemma 1 and 2. Before proving Lemma 1, we first
give the results below (Claim 1 and 2). Claim 1 is a folklore conclusion that can
be found in the textbooks such as [37], and we give the proof for completeness.
Claim 1. Let T1 denote the number of distinct subgroups of rank k in Znp . Then
T1 =

(pn −1)(pn −p1 )···(pn −pk−1 )
.
(pk −1)(pk −p1 )···(pk −pk−1 )

Proof. We can specify a subgroup of rank k by giving k linearly independent
elements in it. Now we select k linearly independent elements from Znp sequentially. Once we have selected d elements, we can not select the elements from the
subgroup generated by these d elements in the next step. Thus, we have pn − pd
possible ways to pick (d + 1)-th elements. So the total number of possible ways
to select k linearly independent elements is (pn − p1 )(pn − p2 ) · · · (pn − pk−1 ).
However, it is a double-counting process above. For a certain subgroup,
there are (pk − p1 )(pk − p2 ) · · · (pk − pk−1 ) ways to pick the elements generating
it. Thus, the total number of subgroups is
(pn − 1)(pn − p1 ) · · · (pn − pk−1 )
.
(pk − 1)(pk − p1 ) · · · (pk − pk−1 )

9

Claim 2. Every non-zero element in Znp belongs to T2 =
distinct subgroups of rank k.

(pn −p1 )(pn −p2 )···(pn −pk−1 )
(pk −p1 )(pk −p2 )···(pk −pk−1 )

Proof. Now we count the number of subgroups of rank k containing a certain
non-zero element e. Similar to the proof of Claim 1, we specify a subgroup of
rank k by giving k linearly independent elements in it. We also select k linearly
independent elements from Znp sequentially. Differently, we fix the first element
as e. So the total number of possible ways to select the following k − 1 elements
is (pn − p1 )(pn − p2 ) · · · (pn − pk−1 ).
It is also a double-counting process above. For a certain subgroup containing
element e, there are (pk − p1 )(pk − p2 ) · · · (pk − pk−1 ) ways to pick the remaining
k − 1 elements to generate it. Thus, the total number of subgroups containing
element e is
(pn − p1 )(pn − p2 ) · · · (pn − pk−1 )
.
(pk − p1 )(pk − p2 ) · · · (pk − pk−1 )
In the following proof, let Q be the set of queried elements in an algorithm to
solve GSP(p, n, k), and TQ = {q1 − q2 | q1 , q2 ∈ Q}. It is easy to see |TQ | ≤ |Q|2
and 0n ∈ TQ .

p
Lemma 1. Any classical randomized algorithm solving GSP(p, n, k) needs Ω
pn−k
queries.
Proof. In terms of the target subgroup S of GSP(p, n, k), we define a characteristic function fS : Znp → {0, 1} satisfying that fS (x) = 1 if and only if
x ∈ S. Thus, for any x, y ∈ Znp , if f (x) = f (y), then fS (x − y) = 1; otherwise,
fS (x − y) = 0. In this way, we can obtain one function value of fS by a pair
of queries to f . By the truth table of fS , we can view fS as a pn -bit Boolean
string equivalently. As a result, querying a function value of fS is equivalent
to querying a bit of the corresponding Boolean string of fS . Furthermore, we
pn
define a promise function P : F → S , where F ⊂ {0, 1} represents the set
of all characteristic functions above, S is the set of all possible target subgroups
in GSP(p, n, k), and P(fS ) = S. Thus, GSP(p, n, k) can be reduced to the problem of computing P(fS ) by querying the bits of fS . Denote the randomized
query complexity of P by Q(P).
Next, we apply the relational adversary method [1, 7] to obtain a lower bound
of Q(P). Let R : F × F → R≥0 be a real-valued function such R(fS1 , fS2 ) =
R(fS1 , fS2 ) for all fS1 , fS2 ∈ F and R(fS1 , fS2 ) = 0 whenever S1 = S2 . Then

10

for fS1 ∈ F and x ∈ Znp , let
θ(fS1 , x) = P

P

fS2 ∈F

R(fS1 , fS2 )

fS2 ∈F :fS1 (x)6=fS2 (x) R(fS1 , fS2 )

,

where θ(fS1 , x) is undefined if the denominator is 0. Denote
vmin =

min

fS1 ,fS2 ∈F ,x∈Zn
p :R(fS1 ,fS2 )>0,fS1 (x)6=fS2 (x)

max{θ(fS1 , x), θ(fS2 , x)}.

Then vmin is a lower bound of Q(P).
Now we assign for R. For any distinct characteristic functions fS1 , fS2 ∈ S ,
let R(fS1 , fS2 ) = 1. Let T1 , T2 be the number in Claim 1 and 2, respectively.
P
Then for any fS1 , fS ∈F R(fS1 , fS2 ) = T1 − 1. If fS1 (x) = 0,
2

X

fS1 ∈F :fS1 (x)6=fS2 (x)

R(fS1 , fS2 ) = T2 − 1,

and
θ(fS1 , x) =
If fS1 (x) = 1,
X

fS1 ∈F :fS1 (x)6=fS2 (x)

T1 − 1
.
T2 − 1

R(fS1 , fS2 ) = T1 − T2 − 1,

and
θ(fS1 , x) =

T1 − 1
.
T1 − T2 − 1

Next, we compute vmin . Because fS1 (x) 6= fS2 (x), we have fS1 (x) = 0, fS2 (x) =
−1
1 −1
> T1T−T
, max{θ(fS1 , x), θ(fS2 , x)} =
1 or fS2 (x) = 0, fS1 (x) = 1. Since TT21 −1
2 −1
T1 −1
n−k
n−k
− 1. So vmin > p
− 1.
T2 −1 > p
Suppose the number of queries to f is Q(f ). Since a pair of queries to f
is equivalent to one query to fS , we have Q(f )2 ≥ Q(P), which means that
p
p
√
Q(f ) = Ω( Q(P)) = Ω( vmin ) = Ω( pn−k ).
Lemma 2. Any classical randomized algorithm solving GSP(p, n, k) needs Ω (k)
queries.
Proof. Suppose an algorithm makes no more than k/2 queries. Let S1 =
hTQ i, S2 = hTQ ∩ Si, x = rank(S2 ), y = rank(S1 ). It is easy to see y ≤ k/2.
Similar Q contains no more than k/2 queries, TQ contains at most y linear independent elements. Thus, x ≤ y ≤ k/2. Now we count the number of possible
11

target subgroups until now. We have found a subgroup of rank x of S. Thus,
we only need to find other k − x linear independent elements in S in turn. In
the first step, we try to find first element e. There are at least pn − py candidate elements, i.e., those elements not in S1 . In the next step, there are at
least pn − py+1 candidate elements, i.e., those elements not in hS1 ∪ ei. In the
end, we have (pn − py )(pn − py+1 ) · · · (pn − py+(k−x+1) ) ways to select these
k − x elements. However, it is a double-counting process above. For a certain
subgroup of rank k, if we have known a subgroup of rank x of it, there are
(pk − px )(pk − px+1 ) · · · (pk − pk−1 ) ways to pick other k − x linear independent
elements. Thus, the total number of subgroups is no less than
(pn − py )(pn − py+1 ) · · · (pn − py+(k−x+1) )
pn − py+k−x−1 k−x
)
> p(n−k)k/2 ,
>
(
(pk − px )(pk − px+1 ) · · · (pk − pk−1 )
pk − pk−1
1
which means the success probability of the algorithm is less than p(n−k)k/2
. Thus,
k/2 queries is not enough to find the target subgroup with a high probabilitiy.

In the following, we give Claim 3 first. Then we present a lower bound for
the nonadaptive deterministic query complexity by proving Theorem 2.
n

−1)
(1 ≤ d ≤
Claim 3. For any set D ⊆ Znp such that {0n } ∈
/ D and |D| < d(p
(pk −1)
k ≤ n), there exists a subgroup S1 of rank k of Znp such that |S1 ∩ D| < d.

Proof. We prove the result by contradiction. Suppose for any group S1 of rank
k, there exist at least d elements in S1 ∩ D. Since Znp has T1 distinct subgroups
of rank k by Claim 1, the total number of elements is T1 · d. However, some
elements may be counted repeatedly. Since every non-zero element in Znp belongs
to T2 distinct subgroups of rank k by Claim 2, we have T2 · |D| ≥ T1 · d, which
d(pn −1)
1
means |D| ≥ dT
T2 = (pk −1) . It makes a contradiction. Thus, there exists a
subgroup S1 of rank k such that |S1 ∩ D| < d.
Theorem
 classical deterministic algorithm solving GSP(p, n, k)
 2. Anypnonadaptive
n−k
} queries.
needs Ω max{k, k · p
Proof. It is easy to see any nonadaptive classical deterministic algorithm solving GSP(p, n, k) needs Ω(k) queries by Lemma 2. Now we prove the other
part.
less than
q nSuppose there exists an nonadaptive algorithm A whichqmakes
k(p −1)
k(pn −1)
(pk+1 −1) queries to solve GSP(p, n, k) correctly. Then |Q| <
(pk+1 −1) , so we

have |TQ | <

k(pn −1)
.
(pk+1 −1)

By Claim 3, there exists a subgroup Ŝ of rank k + 1 such

12

that |Ŝ ∩ TQ | < k. Let Ŝ ′ = hS1 ∩ TQ i. Then rank(Ŝ) < k. Let S1 , S2 be two
different subgroups of k of Znp such that Ŝ ′ < S1 , S2 < Ŝ.
Now we pick a function f1 satisfying that f1 (x) = f1 (y) iff x − y ∈ S1 as
the input of Algorithm A. Since Algorithm A solves the problem correctly, its
output is S1 . Next we construct a function f2 as the input of Algorithm A, where
f2 satisfies that (i) ∀x ∈ Q, f2 (x) = f1 (x), which means ∀x, y ∈ Q, f2 (x) = f2 (y)
iff x−y ∈ Ŝ ′ ∩TQ ; (ii) f2 (x) = f2 (y) iff x−y ∈ S2 . Since Ŝ ∩TQ ⊆ S2 , conditions
(i) and (ii) are simultaneously satisfiable. Condition (i) implies the output of
Algorithm A is still S1 , which is a wrong answer. Thus, Algorithm A does
not solve the problem correctly for any input, which makes a contradiction.
Therefore,
GSP(p,
q nany classical deterministic algorithm solving
 n, k) needs at
p
k(p −1)
n−k
queries.
least (pk+1 −1) queries, i.e., we need to make Ω
k·p
4. Algorithm and upper bound
In this section, we propose an algorithm to solve GSP(p, n, k) and analyze
its query complexity, which establishes the upper bound in Theorem 3.
Theorem
exists a classical
deterministic algorithm to solve GSP(p, n, k)
 3. There

p
n−k
using O max{k, k · p
} queries.
For our problem, we say x and y collide iff f (x) = f (y), which means
x − y ∈ S. Thus, x and y collide if x and y belong to the same coset of
1
. Once
S. So the probability of the collision in each pair of elements is pn−k
we find k linearly independent elements in S, we will determine what S is.
Thus, there exists a randomized algorithm in intuition as follows. By making
p
O( k · pn−k ) queries randomly and uniformly, the expected number of colli1
sions is O(kpn−k pn−k
) = O(k), from which it is likely to find a generating set
of S with a high probability.
This randomized algorithm gives an intuitive guess on the upper bound of
query complexity. However, it seems hard to derandomize it directly. Therefore,
we give an ingenious construction of the query set to ensure that a generating
set of S can be found in Algorithm 1, which is based on group theory and a
divide-and-conquer subroutine (i.e., Algorithm 2). The main idea of Algorithm
1 is as follows. First, we try to obtain two subgroups A, B such that the elements
between A and B do not collide. We may find some collisions in this process.
Second, we try to find some other collisions between B and cosets of A. By the
above collisions, we make sure that a generating set of S will be found.

13

Algorithm 1 Find S
Input: d ∈ {0, ..., n − k};
Output: subgroup S;
1: (A, S1 ) ← f indGroup({0n }, {0n }, d);
2: (B, S2 ) ← f indGroup(A, S1 , n − k − d);
3: V ← A + B, W ← V + S2 , find a basis {wi } of W ;
4: for i = 1 to rank(W ) do
5:
Query all the elements in Awi , and then we can find a pair of (ai , bi ) s.t.
ai ∈ Awi , bi ∈ B and f (ai ) = f (bi );
6:
swi ← ai − bi ;
7: end for
8: return hS2 ∪ {swi }i;
4.1. Correctness analysis
Whatever the value of d is, Algorithm 1 will find S, but there exists an
optimal value such that the number of queries used is minimum. The details
will be discussed later. Now suppose Algorithm 2 is correct (which will be
proved later), and we show the correctness of Algorithm 1. Let rank(Si ) = ki
for i = 1, 2. In Step 1, we find a subgroup A such that A ∩ S = {0n } and
rank(A) = d by calling Algorithm 2. At the same time, we find a subgroup
S1 ≤ S. In Step 2, we find a subgroup B such that A ∩ B = {0n }, (A + B) ∩ S =
{0n }, and rank(B) = n − k − d by calling Algorithm 2 again. Simultaneously,
we find a subgroup S2 such that S1 ≤ S2 ≤ S. In Step 3, we obtain W , a
complement of V + S2 in Znp . Let {wi } be a basis of W . In Step 4-7, we query
all the elements in Awi to obtain swi for any i. Next we elaborate why we can
obtain the desired {swi }. Suppose f (a) 6= f (b) for any a ∈ Awi , b ∈ B in Step
5. Then we have a − b ∈
/ S for any a ∈ A, b ∈ Bwi . Since
Vwi = V +wi = A+B +wi = A−B +wi = A+wi −B = {a−b | a ∈ Awi , b ∈ B},
we have Vwi ∩ S = ∅. However, Lemma 3 implies that Vwi ∩ S 6= ∅, which makes
a contradiction. Thus, there exists ai ∈ Awi , bi ∈ B such that f (ai ) = f (bi ).
Then swi = ai − bi is a non-zero element in Vwi ∩ S. Finally, Lemma 4 implies
S2 ∪ {swi } is a generating set of S. Thus, we find S.
Lemma 3. Suppose V is a subgroup of Znp such that V ∩ S = {0n } and
rank(V ) = n − k. For w ∈
/ V , we have Vw ∩ S 6= ∅.
Proof. For w ∈
/ V , hV ∪ wi is a group of rank n − k + 1. First we prove
hV ∪ wi ∩ S 6= {0n } by contradiction. Suppose hV ∪ wi ∩ S = {0n }. Then we
14

have rank(hV ∪ w ∪ Si) = n − k + 1 + k = n + 1. Since hV ∪ w ∪ Si is a subgroup
of Znp , we have rank(hV ∪ w ∪ Si) ≤ n, which makes a contradiction. Now by
combining hV ∪ wi ∩ S 6= {0n }, hV ∪ wi = V ∪ Vw and V ∩ S = {0n }, we have
Vw ∩ S 6= ∅.
Lemma 4. In Algorithm 1, S2 ∪ {swi } is a generating set of S.
Proof. Let {vi } be a basis of V , {si } be a basis of S2 . Since V ∩ S2 = {0n },
we have rank(V + S2 ) = rank(V ) + rank(S2 ) = n − k + k2 . Since W is a
complement subgroup of V + S2 , we have rank(W ) = n − (n − k + k2 ) = k − k2
and {ui } = {vi }∪{si }∪{wi } constructs a basis of Znp by Fact 1. Since swi ∈ Vwi ,
we have
n−k
X
αij vj + wi .
swi =
j=1

Suppose we have
k2
X

βi s i +

i=1

That is,
k2
X

βi s i +

i=1

k−k
X2 n−k
X

k−k
X2

γi swi = 0.

i=1

γi αij vj +

i=1 j=1

k−k
X2

γi wi = 0,

i=1

which implies βi = 0 for any 1 ≤ i ≤ k2 , and γi = 0 for any 1 ≤ i ≤ k−k2 . Thus,
{swi }∪{si } is linearly independent by Fact 2. Since rank(S) = k, the cardinality
of a linearly independent subset of G is at most k. Thus, |{swi } ∪ {si }| = k
implies {swi } ∪ {si } consists of a basis of S. Since {si } ⊆ S2 , S2 ∪ {swi }
constructs a generating set of S.
4.2. Complexity analysis
Now we analyze the query complexity of Algorithm 1. Lemma 5 implies that
the number of queries in Step 1 is pd − 1 + k1, and the number of queries in Step
2 is at most pn−k−d − 1 + (k2 − k1 ) · pd − 1. In addition, the number of queries
in Step 4-7 is (k − k2 ) · pd . Let T Q denote the total number of queries. Then
T Q ≤ pd − 1 + k1 + pn−k−d − 1 + (k2 − k1 ) · (pd − pd−1 ) + (k − k2 ) · pd
≤ pn−k−d + (k + 1) · pd .

If n ≥ k + logp k, let d = (n − k − logp k)/2. Then we get
TQ ≤

p
p
k + 1 p n−k
k · pn−k + √
p
= O( k · pn−k ).
k
15

Otherwise, let d = 0, we have
T Q ≤ pn−k + k + 1 < 2k + 1 = O(k).
That is, the number of queries of our algorithm is
(
p
O( k · pn−k ) n ≥ k + logp k
TQ =
O(k)
n < k + logp k

.

It is equivalent to
T Q = O(max{k,

p
k · pn−k }),

which meets the upper bound in Theorem 3.
4.3. Critical subroutine

Next, we only need to show the correctness of Algorithm 2 and analyze its
query complexity. In Algorithm 2, given a subgroup S1 ≤ S, a subgroup A such
that A∩S = {0n } and an integer d, we wish to find a subgroup B of rank d such
that A ∩ B = {0n } and (A + B) ∩ S = {0n }. Also, we query all the elements in
B. Meanwhile, we find a subgroup S2 such that S1 ≤ S2 ≤ S, which is an extra
bonus. We use the idea of recursion. First, we find a subgroup B ′ of rank d − 1
such that A ∩ B = {0n }, (A + B ′ ) ∩ S = {0n } and a subgroup S ′ ≤ S. We also
query all the elements in B ′ . Next, we query an element u ∈ Znp \ (S ′ + A + B ′ ).
If there exists an element b ∈ B ′ such that f (b) = f (u), then we have b − u ∈ S.
Thus, we expand S ′ , and query an element u ∈ Znp \ (S ′ + A + B ′ ) again. We
repeat this procedure until for any b ∈ B ′ we have f (b) 6= f (u). Then we query
all the elements in hB ′ ∪ ui \ (B ′ ∪ u), i.e., the elements not queried in hB ′ ∪ ui.
Similarly, if there exists a ∈ A, b ∈ hB ′ ∪ ui \ {0n } such that f (a) = f (b), then
we have b − u ∈ S. So we expand S ′ and go back to Step 6. Only if for any
a ∈ A, b ∈ hB ′ ∪ ui \ {0n } we have f (a) 6= f (b), we exit the outer loop. Then
we obtain B = hB ′ ∪ ui and return (B, S ′ ). At this point, all the elements in B
have been queried.
We show that the algorithm obtains the desired output below. Since u ∈
/
′
′
′
n
n
(A+B ), we have A∩Bu = ∅, which implies A∩hB ∪ui = {0 }, i.e., A∩B = {0 }
by Fact 3. Since f (a) 6= f (b) implies a − b ∈
/ S for any a ∈ A, b ∈ B \ {0n },
we have ((A + B) \ {0n }) ∩ S = ∅. In addition, because 0n ∈ S, we have
(A + B) ∩ S = ∅. Moreover, while we expand S ′ , S ′ is always a subgroup of S.
Thus, we obtain desired B and S ′ .
Now, we analyze the query complexity of Algorithm 2 by proving Lemma 5.

16

Algorithm 2 findGroup
Input: A, S1 , d s.t. 0 ≤ d ≤ n − k, S1 ≤ S, A ∩ S = {0n };
Output: B, S2 s.t. rand(B) = d, A ∩ B = {0n }, (A + B) ∩ S = {0n };
1: if d = 0 then
2:
return ({0n }, S1 );
3: end if
4: (B ′ , S ′ ) ← f indGroup(A, S1 , d − 1);
5: repeat
6:
repeat
7:
Query a non-zero element u s.t. u ∈ Znp and u ∈
/ (S ′ + A + B ′ );
8:
if ∃b ∈ B ′ s.t. f (b) = f (u) then
9:
S ′ ← hS ′ ∪ (b − u)i;
10:
end if
11:
until ∀b ∈ B ′ s.t. f (b) 6= f (u)
12:
Query all the elements in hB ′ ∪ ui \ (B ′ ∪ u);
13:
if ∃a ∈ A, b ∈ hB ′ ∪ ui \ {0n } s.t. f (a) = f (b) then
14:
S ′ ← hS ′ ∪ (a − b)i;
15:
end if
16: until ∀a ∈ A, b ∈ hB ′ ∪ ui \ {0n } s.t. f (a) 6= f (b)
17: B ← hB ′ ∪ ui;
18: return (B, S ′ );

17

Lemma 5. In Algorithm 2, suppose rank(Si ) = ki for i = 1, 2. If A = {0n },
the number of queries is pd − 1 + (k2 − k1 ) · (pd − pd−1 ). If A 6= {0n }, the number
of queries is at most pd − 1 + (k2 − k1 ).
Proof. We consider the following two cases: A 6= {0n } and A = {0n }.
Case 1: A 6= {0n }. In Step 7 and 12, we make pd − pd−1 queries to query all
the element in hB ′ ∪ ui \ B ′ . Suppose we never execute Step 9 and 14. When
we recursively call the algorithm itself, the number of queries is (pd − pd−1 ) +
(pd−1 − pd−2 ) + · · · + (p1 − p0 ) = pd − 1 in total. However, once we execute
Step 9, we will go back to the inner loop and make one extra query. Once we
execute Step 14, we will go back to the outer loop and make at most pd − pd−1
extra queries. Moreover, every time we execute Step 9 or 14, the rank of S ′
adds one. Since we input S1 and obtain S2 , the total number we execute Step
9 and 14 is k2 − k1 . Thus, we need at most extra (k2 − k1 ) · (pd − pd−1 ) queries
in order to expand S1 to S2 . Finally, the total number of queries is at most
pd − 1 + (k2 − k1 ) · (pd − pd−1 ).
Case 2: A = {0n }. Different from Case 1, we never execute Step 14 in this
case. Suppose we go into Step 13. At this time, we have f (b) 6= f (u) for any
b ∈ B ′ . Since f (b) 6= f (u) implies b + u ∈
/ S, we have Bu′ ∩ S = ∅, which
implies hB ′ ∪ ui ∩ S = {0n }. Hence, we have f (a) 6= f (b) for any a ∈ {0n }, b ∈
hB ′ ∪ ui \ {0n }. Therefore, the if-statement is always judged to be false, and
then we jump out of Step 14. On the other hand, similar to Case 1, if we never
execute Step 9, then the number of queries is pd − 1. Once we execute Step 9,
we will go back to the inner loop and make one extra query. Thus, we need
extra k2 − k1 queries in order to expand S1 to S2 . Finally, the total number of
queries is pd − 1 + (k2 − k1 ).

5. Conclusion
In this paper, we obtain an almost full characterization of the classical query
complexity for the generalized Simon’s problem GSP(p, n, k). We
any 
 prove that
p
n−k
}
classical (deterministic or randomized) algorithm has to make Ω max{k, p
queries. Also, we
that any classical
nonadaptive deterministic algorithm
 prove p

has to make Ω max{k, k · pn−k } queries. Moreover, we devise an determin

p
istic algorithm for this problem with query complexity of O max{k, k · pn−k } .
These results clarify the computational power gap between quantum and classical computing on this problem. Furthermore, two open problems remain:

18

• It still has a gap between the lower bound and the upper bound for classical
query complexity of the generalized Simon’s problem.
• If we generalize the domain of f from Znp to an arbitrary finite Abelian
group Zm1 ⊕ Zm2 ⊕ · · ·⊕ Zmn , where Zmi denotes the additive cyclic group
of order mi , what is the optimal classical query complexity in this case?
References
[1] Scott Aaronson. Lower bounds for local search by quantum arguments.
SIAM Journal on Computing, 35(4):804–824, 2006.
[2] Scott Aaronson and Andris Ambainis. Forrelation:a problem that optimally
separates quantum from classical computing. SIAM Journal on Computing,
47(3):982–1038, 2018. doi:10.1137/15M1050902.
[3] Scott Aaronson, Shalev Ben-David, and Robin Kothari. Separations in
query complexity using cheat sheets. In Proceedings of the 48th Annual
ACM SIGACT Symposium on Theory of Computing (STOC 2016), pages
863–876, 2016. doi:10.1145/2897518.2897644.
[4] Gorjan Alagic, Cristopher Moore, and Alexander Russell.
Quantum algorithms for Simon’s problem over general groups.
In
Proceedings of the 18th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA 2007), pages 1217–1224, 2007.
URL:
http://dl.acm.org/citation.cfm?id=1283383.1283514.
[5] Andris Ambainis.
Superlinear advantage for exact quantum algorithms.
SIAM Journal on Computing, 45(2):617–631, 2016.
doi:10.1137/130939043.
[6] Andris Ambainis, Kaspars Balodis, Aleksandrs Belovs, Troy Lee, Miklos
Santha, and Juris Smotrovs. Separations in query complexity based on
pointer functions. Journal of the ACM (JACM), 64(5):32:1–32:24, 2017.
doi:10.1145/3106234.
[7] Andris Ambainis, Martins Kokainis, Krisjanis Prusis, and Jevgenijs
Vihrovs. All classical adversary methods are equivalent for total functions.
In Proceedings of the 35th Symposium on Theoretical Aspects of Computer
Science, pages 8:1–8:14, 2018.

19

[8] Dave Bacon, Andrew M. Childs, and Wim van Dam. From optimal measurement to efficient quantum algorithms for the hidden subgroup problem
over semidirect product groups. In Proceedings of the 46th Annual Symposium on Foundations of Computer Science (FOCS 2005), pages 469–478,
2005. doi:10.1109/SFCS.2005.38.
[9] Robert Beals, Harry Buhrman, Richard Cleve, Michele Mosca, and Ronald
de Wolf. Quantum lower bounds by polynomials. Journal of the ACM
(JACM), 48(4):778–797, 2001. doi:10.1145/502090.502097.
[10] Gilles Brassard and Peter Høyer. An exact quantum polynomial-time algorithm for Simon’s problem. In Proceedings of the 5th Israeli Symposium
on Theory of Computing and Systems (ISTCS 1997), pages 12–23, 1997.
doi:10.1109/ISTCS.1997.595153.
[11] Gilles Brassard, Peter Høyer, Michele Mosca, and Alain Tapp. Quantum amplitude amplification and estimation. Contemporary Mathematics,
305:53–74, 2002.
[12] Harry Buhrman, Lance Fortnow, Ilan Newman, and Hein Röhrig. Quantum
property testing. SIAM Journal on Computing, 37(5):1387–1400, 2008.
doi:10.1137/S0097539704442416.
[13] Mark Bun, Robin Kothari, and Justin Thaler. The polynomial method
strikes back: tight quantum query bounds via dual polynomials. In Proceedings of the 50th Annual ACM SIGACT Symposium on Theory of Computing (STOC 2018), pages 297–310, 2018. doi:10.1145/3188745.3188784.
[14] Guangya Cai and Daowen Qiu. Optimal separation in exact query complexities for Simon’s problem. Journal of Computer and System Sciences,
97:83–93, 2018. doi:10.1016/j.jcss.2018.05.001.
[15] Andrew M. Childs and Wim van Dam. Quantum algorithm for a generalized hidden shift problem. In Proceedings of the 18th Annual ACM-SIAM
Symposium on Discrete Algorithms (SODA 2007), pages 1225–1232, 2007.
doi:10.1137/S009753970139450X.
[16] Ronald de Wolf. Quantum Computing: Lecture Notes. arXiv preprint
arXiv:1907.09415, 2019.
[17] David Deutsch and Richard Jozsa. Rapid solution of problems by quantum computation. Proceedings of the Royal Society of London. Series A:
Mathematical and Physical Sciences, 439(1907):553–558, 1992.
20

[18] Mark Ettinger, Peter Høyer, and Emanuel Knill. The quantum query complexity of the hidden subgroup problem is polynomial. Information Processing Letters, 91(1):43–48, 2004. doi:10.1016/j.ipl.2004.01.024.
[19] Demerson Nunes Goncalves, Tharso D. Fernandes, Carlos Cosme, and Martins Magno. An efficient quantum algorithm for the hidden subgroup problem over some non-abelian groups. Trends in Applied and Computational
Mathematics, 18(2):215–223, 2017. doi:10.5540/03.2015.003.02.0045.
[20] Michelangelo Grigni, Leonard J. Schulman, Monica Vazirani, and
Umesh V. Vazirani.
Quantum mechanical algorithms for the nonabelian hidden subgroup problem. Combinatorica, 24(1):137–154, 2004.
doi:10.1007/s00493-004-0009-8.
[21] Sean Hallgren, Alexander Russell, and Amnon Tashma. The hidden subgroup problem and quantum computation using group representations.
SIAM Journal on Computing, 32(4):916–934, 2003.
[22] Buhrman Harry and Ronald de Wolf. Complexity measures and decision
tree complexity: a survey. Theoretical Computer Science, 288(1):21–43,
2002. doi:10.1016/S0304-3975(01)00144-X.
[23] Mika Hirvensalo. Quantum Computing. Springer-Verlag, 2001.
[24] Richard Jozsa. Quantum algorithms and the fourier transform. Proceedings of the Royal Society of London. Series A: Mathematical, Physical and
Engineering Sciences, 454(1969):323–337, 1998.
[25] Marc Kaplan, Gaëtan Leurent, Anthony Leverrier, and Marı́a
Naya-Plasencia.
Breaking symmetric cryptosystems using quantum period finding.
In Proceedings of the 36th Annual International Cryptology Conference (CRYPTO 2016), pages 207–237, 2016.
doi:10.1007/978-3-662-53008-5_8.
[26] Phillip Kaye, Raymond Laflamme, and Michele Mosca. An Introduction to
Quantum Computing. Oxford University Press, 2006.
[27] Julia Kempe and Aner Shalev. The hidden subgroup problem and permutation group theory. In Proceedings of the 16th Annual ACM-SIAM
Symposium on Discrete Algorithms (SODA 2005), pages 1118–1125, 2005.
URL: http://dl.acm.org/citation.cfm?id=1070432.1070592.

21

[28] Pascal Koiran, Vincent Nesme, and Natacha Portier. A quantum lower
bound for the query complexity of Simon’s problem. In Proceedings of the
32nd International Colloquium on Automata, Languages, and Programming
(ICALP 2005), pages 1287–1298, 2005. doi:10.1007/11523468_104.
[29] Greg Kuperberg. A subexponential-time quantum algorithm for the dihedral hidden subgroup problem. SIAM Journal on Computing, 35(1):170–
188, 2005. doi:10.1137/s0097539703436345.
[30] Hidenori Kuwakado and Masakatu Morii. Quantum distinguisher between
the 3-round feistel cipher and the random permutation. In Proceedings of
the IEEE International Symposium on Information Theory (ISIT 2010),
pages 2682–2685, 2010. doi:10.1109/ISIT.2010.5513654.
[31] Hidenori Kuwakado and Masakatu Morii. Security on the quantum-type
even-mansour cipher. In Proceedings of the International Symposium on Information Theory and its Applications (ISITA 2012), pages 312–316, 2012.
URL: http://ieeexplore.ieee.org/document/6400943/.
[32] Takashi Mihara and Shao Chin Sung. Deterministic polynomial-time quantum algorithms for Simon’s problem. Computational Complexity, 12(34):162–175, 2003. doi:10.1007/s00037-003-0181-z.
[33] Martin Roetteler and Rainer Steinwandt. A note on quantum relatedkey attacks.
Information Processing Letters, 115(1):40–44, 2015.
doi:10.1016/j.ipl.2014.08.009.
[34] Thomas Santoli and Christian Schaffner.
Using Simon’s algorithm to attack symmetric-key cryptographic primitives.
Quantum Information & Computation, 17(1&2):65–78, 2017.
URL:
http://www.rintonpress.com/xxqic17/qic-17-12/0065-0078.pdf.
[35] Peter W. Shor. Algorithms for quantum computation: Discrete logarithms
and factoring. In Proceedings of the 35th Annual Symposium on Foundations of Computer Science (FOCS 1994), pages 124–134, 1994.
[36] Daniel R. Simon. On the power of quantum computation. In Proceedings of
the 35th Annual Symposium on Foundations of Computer Science (FOCS
1994), pages 116–123, 1994. doi:10.1109/SFCS.1994.365701.
[37] Richard P. Stanley. Enumerative Combinatorics, Volume 1. Cambridge
University Press, 2000.

22

[38] Zhenggang Wu, Daowen Qiu, Guangya Cai, Yinuo Lin, and Yikang Zhu.
Quantum and classical query complexities for generalized Simon’s problem.
arXiv preprint arXiv:1905.08549, 2019.

23

Appendix A. An exact quantum algorithm for generalized Simon
problem
Brassard and Høyer [10] provided an algorithm to solve Simon problem with
O(n) queries exactly. In this section, we review the algorithm and make some
small adjustments to the algorithm to solve GSP(p, n, k). Particularly, we replace the method of improving the success probability in [10] with a more general method, amplitude amplification [11], such that the algorithm needs to only
make O(n − k) queries.
We first give some notation. Define quantum query oracle Of : Of |gi |yi =
|gi |f (g) + yi. The query complexity of a quantum algorithm is the number of
Of used in the algorithm. Let G = Znp and T0 be a transversal of S in G, i.e,
T0 consists of exactly one representative form each coset of S. For g, h ∈ G, let
n
X
g i hi )
g·h= (

mod p,

i=1

where g = (g1 , ..., gn ) and h = (h1 , ..., hn ). For H ≤ G, let
H ⊥ = {g ∈ G|g · h = 0 for all h ∈ H}
denote the orthogonal subgroup of H. Let
µ(g, h) = e

2πi
p gh

,

X
1
FG = p
µ(g, h) |gi hh| ,
|G| g,h∈G
X
φh =
µ(h, g) |gi hg| .
g∈G

For X ⊆ G and g ∈ G, let
|φg Xi =

1 X
µ(g, x) |xi .
|X|
x∈X

Next, we introduce the algorithm process. It is worth noting that the idea
⊥
of the quantum algorithm is to find a basis of S ⊥ . Then S = (S ⊥ ) . We give
Algorithm 3 first, which is a subroutine in Simon algorithm and generalized to
the case of Zp . The goal of Algorithm 3 is to obtain |Ψi. When we measure the
first register of |Ψi, we can get an element in S ⊥ with certain.

24

Algorithm 3 Simon subroutine
Input: Quantum state |0n i |0i;
Procedure:
1. Apply the inverse of transform FG to the first register producing an
equally-weighted superposition of all elements in the group G:
1 X
p
|gi |0i .
|G| g∈G

2. Apply Of , producing a superposition of all cosets of H0 :
1 X
1 X
|t + Si |f (t)i .
|gi |f (g)i = √
|G|
T0 t∈T
g∈G
0

3. Apply FG to the first register, producing a superposition over the orthogonal subgroup S ⊥ :
|Ψi =

1 X
|φt S ⊥ i |f (t)i .
|T0 |
t∈T0

Output: Quantum state |Ψi.
Suppose we have obtained some element y in S ⊥ , we do not wish to obtain
it again. Instead, we wish to find a basis of S ⊥ as soon as possible. Thus, Algorithm 4 is proposed to shrink the range of superposition and avoiding obtaining
the same elements. The input of Algorithm 4 can be obtained from Algorithm
3.

25

Algorithm 4 Shrinking a subgroup
Input: Quantum state |φg Hi |0i; H ≤ G be a nontrivial subgroup; y ∈ H/{0n};
j such that yj 6= 0 and K = {h ∈ H|hj = 0}.
Procedure:
1. Apply operation U1 : U1 |xi |zi = |xi |x + zi to the jth qubit in the first
register and the second register of |φg Hi |0i, producing the state:
1 X
p
µ(g, h) |hi |hj i
|H| h∈H

!
1 X
p
µ(g, k) |iy + ki |ii .
|K| k∈K

1 X
=√
µ(g, iy)
p
i∈Zp

2. Apply operator U2 : U2 |xi |ii = |x + iyi |ii to the above state. This
produces
!
1 X
1 X
µ(g, k) |ki |ii
µ(g, iy) p
√
p
|K| k∈K
i∈Zp


X
1
= |φg Ki  √
µ(g, iy) |ii .
p
i∈Zp

3. Apply FG to the second register, producing a superposition:
|φg Ki |g · yi .

Output: Quantum state |φg Ki |g · yi.
Suppose Y = {y1 , ..., ym } is a known linearly independent set in S ⊥ (0 ≤
m < n − k). Then there exists a subgroup Km ≤ S ⊥ such that S ⊥ = Km + hY i
and a quantum routine Am such that Am |φg S ⊥ i |0m i = |φg Km i |g · y1 , ..., g · ym i
by applying Algorithm 4 repeatedly. Moreover, we have a quantum routine A′m
P
such that A′m |0n i |0i |0m i = √ 1
t∈T0 |φt Km i |f (t)i |t · y1 , ..., t · ym i by ap|T0 |

plying Algorithm 3 and Am . Algorithm 3 makes one query, Am does not make
queries, thus A′m makes one query.
If we can measure the first register of the final state in A′m , we can obtain an
element y ∈ Km . Once y is nonzero, we can add y into Y to get a larger known
linearly independent set in S ⊥ . Thus, we say Algorithm A′m is successful if the
measurement result of the first register of the final state is a nonzero element in

26

Km . The success probability of A′m is 1 − 1/|Km | = 1 − 1/pn−k−m .
Furthermore, we wish to avoid obtaining zero element after measurement.
√
1
1
Since √
≤ 2, we use O( √
≤ √ 1
) = O(1) applin−k−m
n−k−m
1−1/p

1−1/p
−1

1−1/p

to get an algorithm A′′m that can obtain a nonzero
cations of A′m and A′m
element in Km with certain by the amplitude amplification technique of [11].
A′m −1 needs to use Of−1 and other operations not related to f . Since Of2 = I
by definition, Of−1 = Of . Thus, A′′m makes O(1) queries.
Finally, we gave Algorithm 5 to solve GSP(p, n, k) exactly. During the iteration of each time, an element is added into Y to consist of a larger linearly
independent set in S ⊥ . Finally, hY i = S ⊥ . Since A′′i makes O(1) queries for
Algorithm 5 An exact quantum algorithm for GSP(p, n, k)
1: Y = ∅;
2: for i = 0 to n − k − 1 do
3:
For a subgroup Ki ≤ S ⊥ satisfying that S ⊥ = Ki + hY i, perform Algorithm A′′i to obtain a nonzero element yi ∈ Ki ;
4:
Y = Y ∪ {yi };
5: end for
6: return hY i⊥ ;
1 ≤ i ≤ k, the total number of queries is O(n − k).

27

