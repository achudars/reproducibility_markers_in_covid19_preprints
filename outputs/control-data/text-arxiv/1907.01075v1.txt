Simulation smoothing for nowcasting with large
mixed-frequency VARs∗
arXiv:1907.01075v1 [econ.EM] 1 Jul 2019

Sebastian Ankargren and Paulina Jonéus
Department of Statistics, Uppsala University
July 3, 2019

Abstract
There is currently an increasing interest in large vector autoregressive (VAR) models. VARs are popular tools for macroeconomic forecasting and use of larger models
has been demonstrated to often improve the forecasting ability compared to more traditional small-scale models. Mixed-frequency VARs deal with data sampled at different
frequencies while remaining within the realms of VARs. Estimation of mixed-frequency
VARs makes use of simulation smoothing, but using the standard procedure these models quickly become prohibitive in nowcasting situations as the size of the model grows.
We propose two algorithms that alleviate the computational efficiency of the simulation
smoothing algorithm. Our preferred choice is an adaptive algorithm, which augments
the state vector as necessary to sample also monthly variables that are missing at the
end of the sample. For large VARs, we find considerable improvements in speed using
our adaptive algorithm. The algorithm therefore provides a crucial building block for
bringing the mixed-frequency VARs to the high-dimensional regime.

1

Introduction

Macroeconomic forecasting is a central activity for many organizations. Central banks, treasuries, and other government institutions as well as non-governmental organizations such as
banks and corporations rely on forecasts in order to assess the future development of the
local and global economy. Accurate forecasts is therefore a necessity for making informed
∗

Corresponding author, e-mail: sebastian.ankargren@statistics.uu.se

1

decisions that minimize adversarial effects and maximize the utility of the decisions that are
to be made. There is a vast array of forecasting methods that can be employed for macroeconomic data, but one of the more prominent and popular tools used in macroeconomic
forecasting is the vector autoregressive (VAR) model. It is a multivariate time series model
relating current values of a vector of variables to lags of all of the variables in the model.
In contrast to structural models relying heavily on economic theory, the VAR is a relatively
agnostic model that is easy to use.
Traditional vector autoregressive models make use of data that is sampled at the same
frequency. Most often, VAR models used for forecasting or structural analysis are estimated
on data with exclusively monthly or quarterly variables. In many cases, the inclusion of gross
domestic product (GDP) determines whether or not the model is estimated on a quarterly
basis. Mixed-frequency methods, in general, are attempts that aim to avoid having to
aggregate, say, monthly data to the quarterly frequency when at least one of the included
variables is sampled quarterly. One advantage is that the loss of information induced by the
aggregation can be avoided, and information can be incorporated into the forecasting model
in a more timely manner. Among the more prominent methods are dynamic factor models as
developed by Mariano and Murasawa (2003, 2010); Marcellino et al. (2016) and mixed-data
sampling (MIDAS) as introduced by Ghysels et al. (2006) and Ghysels et al. (2007). Related
literature has also considered vector autoregressive moving average (VARMA) models in
the mixed-frequency setting, see Zadrozny (2016), Anderson et al. (2016) and Deistler et al.
(2017). The relevance of the inclusion of an MA component has also been studied for MIDAS
regressions by Foroni et al. (2019).
The MIDAS regression approach is generalized to a VAR setting with a Bayesian approach
by Ghysels (2016), and McCracken et al. (2015) propose a high-dimensional variant of the
MIDAS-VAR. Götz et al. (2016) exploit the model by Ghysels (2016) for testing Granger
causality using mixed-frequency data. They consider both reduced rank regressions and
a Bayesian approach in situations with a large number of high-frequency observations per
low-frequency period.
The approach considered in this paper is the mixed-frequency VAR using a state-space
formulation. The primary empirical purpose of the model that motivates our work is the
use of a large monthly data set for forecasting GDP growth. We focus on the methodology
developed by Schorfheide and Song (2015), who use Gibbs sampling and simulation smoothing to estimate the model in the spirit of Carter and Kohn (1994). Other developments of
the mixed-frequency VAR include Eraker et al. (2015), who instead of simulation smoothing
employ a single-move sampler. Qian (2016) develop an alternative sampling strategy based
on linear transformations of the data. Cimadomo and D’Agostino (2016) employ a mixed2

frequency VAR with time-varying parameters and stochastic volatility to cope with a change
in frequency, and Götz and Hauzenberger (2018) extend the Schorfheide and Song (2015)
model to include stochastic volatility and time-varying intercepts.
The focus of this paper is on developing the simulation smoother proposed by Schorfheide
and Song (2015) in a way that enhances its performance in nowcasting situations. The
merits of the mixed-frequency VARs in nowcasting and forecasting have been demonstrated
by e.g. Schorfheide and Song (2015); Eraker et al. (2015); Ankargren et al. (2018); Götz
and Hauzenberger (2018). These papers frame the problem as a latent variable problem,
where the low-frequency series have an underlying, high-frequency series which we do not
observe. The model thus relates the observed outcome to the unobserved latent variable in
a measurement equation, while the VAR itself is specified at the high frequency.
One of the key advantages of the mixed-frequency VAR is that it is, in essence, a standard
VAR with an additional block in the Markov Chain Monte Carlo (MCMC) sampler. This
additional block samples the unobserved latent variable from the conditional posterior, given
the observed data and the parameters, by means of simulation smoothing. Next, given the
unobserved latent variable, the remaining steps needed to estimate the model are the usual
steps drawing from the posterior of the parameters. The important difference is that the
conditional posteriors of the parameters here condition upon the draw of the latent variable,
which makes the problem standard. Because our focus in this paper is on the simulation
smoother used for sampling the latent variables, we do not dwell any further on the other
blocks of the MCMC sampler.
Our contribution is that we develop a simulation smoother based on the proposal by
Schorfheide and Song (2015) that better deals with ragged edges in the (mixed-frequency)
data, i.e. when the end of the sample is unbalanced. The motivation is that in real-time
forecasting situations, the information set that the forecaster possesses can vary from day
to day: new data points for the different series are not obtained at the same time, but on
different days. In a stylized data set, the forecaster knows at the beginning of April the
outcomes of financial variables for March, but the numbers for other variables have not yet
been released. In addition, some variables are subject to larger publication delays. At the
beginning of April, the forecaster may therefore not know the February outcomes for slow
variables. We demonstrate that in such situations, use of our algorithm is a necessity when
the dimension of the model is large. On the other hand, if the data is not unbalanced, our
algorithm reduces to the Schorfheide and Song (2015) procedure. There is, in other words, no
loss associated with using our procedure. Moreover, our algorithm is purely a computational
improvement. The results from the different algorithms are therefore identical given the
same random number generator.
3

For small-scale models, the simulation smoothing algorithm that Schorfheide and Song
(2015) proposed works well. However, there is a growing literature on large VAR models and
their usefulness for forecasting, see for example Bańbura et al. (2010); Koop (2013); Carriero
et al. (2019). When the dimension of the model increases—either by the number of variables
or the lag length—the simulation smoother becomes prohibitive in estimating the models.
The method we propose for dealing with the ragged edge nature of data is intuitive: we
sample only those variables which we must sample. The issue with the Schorfheide and Song
(2015) sampler is that, for the ragged edge part of the data, it wastes a substantial amount
of computational resources on sampling what is already known, i.e. fully observed monthly
variables. We circumvent this problem by developing an adaptive simulation smoother, which
augments the state vector with the missing variables only. This allows us to improve the
computational efficiency for large-dimensional models. Our method applies to any mixedfrequency VAR estimated using data with ragged edges that employs simulation smoothing.
The rest of the paper is organized as follows. Section 2 describes the mixed-frequency
VAR and the approach suggested by Schorfheide and Song (2015) in more detail, Section 3
describes our two new algorithms amd Section 4 provides some computational experiments
illustrating the gains of our algorithms. Section 5 concludes.

2

Mixed-frequency VARs

To model data observed at mixed frequencies we follow Schorfheide and Song (2015); Ankargren et al. (2018); Götz and Hauzenberger (2018) and deal with the problem by postulating
a VAR model at the high frequency. That is, we start with the VAR(p) given by
xt = Πc + Π1 xt−1 + · · · + Πp xt−p + ut ,

ut ∼ N (0, Σt )

(1)

where xt , Πc and ut are n×1 and Πj are n×n. The vector xt can be decomposed into monthly
and quarterly variables as xt = (x0m,t , x0q,t )0 of dimensions nm × 1 and nq × 1, respectively,
where n = nm + nq . The model can be formulated in terms of the companion form as
zt =

Π1 Π2 · · ·
In(p−1)

!

Πp
0n(p−1)×n

zt−1 +

Πc
0n(p−1)×1

!
+

ut

!

0n(p−1)×1

(2)

where zt = (x0t , . . . , x0t−p+1 )0 . For future use, let also Π = (Πc , Π1 , . . . , Πp ).
The empirical problem motivating our work is that in reality we only observe
yt = St Λzt
4

(3)

where St is a deterministic nt × n selection matrix and Λ an n × pn aggregation matrix. For
ease of exposition, we assume that the aggregation employed includes at most p − 1 previous
values.
The posterior distribution of interest is p(Π, Σ, X|Y ). The key feature of Schorfheide and
Song (2015) is the use of the forward-filtering and backwards-smoothing algorithm (Carter
and Kohn, 1994; Frühwirth-Schnatter, 1994) in a Gibbs sampler. Such an approach utilizes
the fact that (Π, Σ) is conditionally independent of Y given X. Hence, the basic Gibbs
sampling strategy for the mixed-frequency VAR is to sample iteratively from:
p(Π, Σ|X)

(4)

p(X|Π, Σ, Y ).

(5)

Note that conditional on X, the first step is standard in the literature. Intuitively, the full
method can be understood from the perspective of missing values. The p(X|Π, Σ, Y ) step
produces a draw of the underlying monthly series of all variables observed quarterly. This
draw is produced under the restriction that when aggregated according to the linear aggregation defined by Λ, the aggregate is equal to the observed outcomes. However, conditional
on a particular draw of X, draws of Π and Σ can be produced as if this were the real data,
leading to standard procedures.
The main computational obstacle in an off-the-shelf implementation of a mixed-frequency
model employing the companion form formulation is to draw from the posterior of the underlying variable, p(X|Π, Σ, Y ). Two ways of circumventing the high dimensionality are to
use the computationally convenient reformulation of the model suggested by Schorfheide
and Song (2015) or the method proposed by Qian (2016). The companion form presented
in the beginning of the section should generally be avoided in computations because of the
extraneous computational burden it induces. We review next the procedure developed by
Schorfheide and Song (2015), which largely avoids the companion form in the computations.
Because of our frequent referral to their procedure, we will refer to it as SS15.
The companion form expresses the model in such a way that all of the endogenous
variables in the VAR enter the state equation of the state-space model. Furthermore, lagged
values of the variables are also included, which yields a state vector of dimension np × 1. In
empirical applications dealing with monthly and quarterly data, it is usually the case that
the set of monthly variables is fully observed up through a time point Tb .
The SS15 method exploits the balanced nature of the monthly part of the sample for t =
1, . . . , Tb . Intuitively, the primary purpose of employing a state-space model formulation and
its associated simulation smoother is that it provides a tractable way of imputing the missing

5

observations of the quarterly variables through a data augmentation approach common in
Bayesian statistics (see Tanner and Wong, 1987). The simulation smoothing sampling step
consists of sampling from p(X|Π, Σ, Y ), but since
Xm,1:Tb
Xq,1:Tb
Xm,Tb +1:T Xq,Tb +1:T

X=

!
(6)

it is evident that including the observed monthly variables in the state vector means that
we are also drawing from p(Xm,1:Tb |Π, Σ, Y ) — a degenerate distribution with all of its
mass on Ym,1:Tb . To alleviate the computational cost, SS15 therefore formulate the model
differently for t = 1, . . . , Tb , where the Xm,1:Tb is moved out of the state equation and treated
as exogenous and the dimension of the state vector is thereby reduced from np × 1 to
nq (p + 1) × 1. The new formulation of the model does not alter the underlying statistical
model, but is purely computational. Throughout, we will refer to the following as the compact
form:

ym,t
yq,t

!

xq,t
zq,t−1

!

!

=

0nm ×nq Πmq
Sq,t Λqs

!

=

Πqq 0nq ×nq
Ipnq 0pnq ×nq

xq,t
zq,t−1

!

zq,t−1
xq,t−p−1

!
!
!
(1,•)
ym,t−p:t−1
Wt
em,t
+
1
0nq ×n
eq,t
!
!
!
!
(2,•)
Πqm Πcq
ym,t−p:t−1
Wt
em,t
+
,
0pnq ×(pnm +1)
1
0pnq ×n
eq,t
(7)

Πmm Πcm
0nq ×(pnm +1)

+
!
+

!


0
where et = e0m,t e0q,t is independently and identically distributed as N (0, In ) and
(1,•)

Σt = Wt Wt0 ,

Wt =

Wt
(2,•)
Wt

!
(8)

and the partitioning in Wt consists of blocks of size nm × n and nq × n. Furthermore, the
matrices Πij for i, j ∈ {m, q} represent submatrices of Π consisting of parameters relating
the set of j variables to the i variable; i.e. Πmq contains the parameters pertaining to the
lagged effects of the quarterly variables in the equations for the monthly variables. In the
preceding description of the model we explicitly allow for a time-varying error covariance
matrix, but assume constant regression parameters. Relaxing the assumption of constant
regression parameters, as Cimadomo and D’Agostino (2016); Götz and Hauzenberger (2018)
have done for mixed-frequency VARs, can easily be done within the algorithms we develop.
To simplify the description of the filtering and smoothing algorithm, we write the model

6

in more general notation as
yt = Zt αt + ct + Gt et

(9)

αt = Tt αt−1 + dt + Ht et .

(10)

The full SS15 procedure for producing a draw from the conditional posterior uses the
Durbin and Koopman (2002) simulation smoothing technique, which consists of the steps:1
Generate a pseudo sample yt+ and αt+ based on the recursions in (1). For the difference
yt∗ = yt − yt+ :
1. Filter for t = 1, . . . , Tb using the compact form
2. Move to the companion form and filter for t = Tb + 1, . . . , T
3. Smooth for t = T, . . . , Tb + 1 using the companion form
4. Move back to the compact form and smooth for t = Tb , . . . , 1
∗
Compute the draw as xt = x̂∗t + x+
t where x̂t is the smoothed series from step 4.

Because nq (p + 1)  np in most applications, the compact procedure typically offers a
substantial improvement in speed.
The key parts of the simulation smoothing algorithm are the filtering and smoothing
steps. In the following when discussing the simulation smoothing step, we will for simplicity
discuss filtering and smoothing on their own, but note that they should be interpreted as the
main building blocks for the full simulation smoothing algorithm. The filtering recursions
are, for t = 1, . . . , Tb :
vt = yt − Zt at − ct ,
Kt = Tt Mt Ft−1 ,
at|t = at + Mt Ft−1 vt ,
at+1 = Tt at|t + dt ,

Mt = Pt Zt0 + Ht G0t ,
Lt+1 = Tt+1 − Kt Zt ,

Ft = Zt Mt + Gt (Gt + Zt Ht )0
Nt+1 = Pt L0t+1 − Ht G0t Kt0

Pt|t = Pt − Mt Ft−1 Mt0

(11)

Pt+1 = Tt Pt|t Tt0 + Ht Ht0 .

Having transitioned back to the compact form, the algorithm is completed by the following
smoothing recursions for t = Tb , . . . , 1:
at|T = at|t + Nt+1 rt
rt−1 = L0t+1 rt + Zt Ft−1 vt .
1

(12)

The constants in the model need to be excluded either in the simulation step, or in the filtering/smoothing
steps, see Jarociński (2015).

7

The details for the transitions between the compact and companion forms can be found
in A.

3

Handling mixed frequencies in large-dimensional VARs

Unsurprisingly, if nq is fixed and n grows an increasingly large share of the total computational time of the SS15 procedure can be attributed to the companion form, even if the
companion form is employed for only one or two time points. The main bottleneck is the
computation of the variance of the one-step ahead prediction. The variance is computed by
multiplying three square matrices of dimensions n(p + 1) × n(p + 1), an operation which is
prohibitive even if it needs to performed only once or twice if, say, n = 100 and p = 4.
In the next two subsections, we describe two ways to increase the computational efficiency of filtering and smoothing for the unbalanced part of the sample. The first is blocked
filtering, in which the structure of the system matrices in the state-space model is exploited
to reduce large matrix multiplications to a larger number of smaller block operations. The
second approach is adaptive filtering, which adaptively augments the state vector with the
missing monthly variables and by doing so avoids the use of a full-blown companion form
altogether. It should be emphasized that the two alternative procedures that we propose
produce draws which, given the same seed, are numerically identical to draws made by the
algorithm described in the previous section.
For use in the following, we formulate the state-space model for the companion form as:2
yt = Zt αt

(13)

αt = Tt αt−1 + Ht t ,

(14)

where
Zt = St
Tt =

!

0
0nm ×(np+nq )
0
0
, αt = xt · · · xt−p−1
0nm ×nm
Λq
!
!
1/2
Π1 · · · Πp 0n×n
Σt
0n×np
, Ht =
,
Inp
0n×n 0n×n
0np×n 0np×np
Inm

(15)
t =

et
0np×1

!
.

(16)

For simplicity, we abstract here from including the intercept in the following, but inclusion
thereof is straightforward.
2

When the companion form is used for the unbalanced part of the data following use of the compact form,
it is formulated with p + 1 lags to aid in the transition between the model formulations.

8

3.1

Blocked filtering

While the bottleneck of the Kalman filter lies in the multiplication of three potentially large
matrices, improvements can be made throughout the entire filtering algorithm by exploiting the fact that many of the system matrices in general are not dense, but have inherent
structures—including blocks of zeros and identity matrices. Strid and Walentin (2009) successfully used the same idea to reduce the computational burden associated with a large-scale
dynamic stochastic general equilibrium (DSGE) model. Inspired by their work for DSGE
models, it is clear from Equations (15)–(16) that there is a large degree of structure in the
recursions for the companion form. Hence, it is likely subject to a speed improvement if
the structure is efficiently utilized. In addition to what (15)–(16) display, the matrix Λq has
a sparse structure where at most nq p columns (out of np + nq ) contain non-zero elements,
the precise number depending on the specific aggregation scheme used. Let pq denote the
number of lags included in the aggregation scheme. If the intra-quarterly average is used
for aggregation, then pq = 3 and 3nq columns contain non-zero values with a maximum of
one non-zero value per column. Thus, when the system matrices become larger, substantial
gains in computational efficiency can be obtained by simply exploiting these structures.
Let Λqq be the nq × nq pq submatrix of Λq obtained by deleting zero-columns in Λq ,
i.e. columns corresponding to monthly variables in αt and additional lags not included in
the aggregation. Let also at (and at|t ) be partitioned into p + 1 blocks of n values, i.e.
0
0
0
at = (a1t , a2t , . . . , ap+1
)0 . We present next the filtering algorithm for the companion form
t
where the use of the structure is more explicit. In doing so, we let square brackets indicate
that the enclosed quantity is computed before it is used to facilitate multiple uses efficiently.
First, we can utilize the sparsity of Zt when computing Ft :
Ft =

Ptmm
[Ptmq Λ0qq ]
[Ptmq Λ0qq ]0 Λqq Ptqq Λ0qq

!
.

(17)

Here, Ptmm refers to the upper left nm × nm block of Pt containing the variances of the
one-step ahead predictions for the monthly variables. Similarly, Ptqq denotes the pq nq × pq nq
submatrix of Pt formed by extracting the elements corresponding to the first pq lags of all
quarterly variables, and Ptmq is the nm × pq nq submatrix of covariances between xm,t and
xq,t−i for i = 0, . . . , pq − 1.
Next, compute Pt1:p,m (Ft−1 )m,• , where Pt1:p,m is the np × nm submatrix retrieved from the
upper left part of Pt , and (Ft−1 )m,• is the first nm rows of Ft−1 . Analogously, we compute
also Pt1:p,q (Ft−1 )q,• where Pt1:p,q is the np × nq matrix obtained from taking the first np rows
of Pt and the nq columns corresponding to xq,t , and (Ft−1 )q,• is the bottom nq rows of Ft−1 .
9

We can then construct:
Kt =

!
Π[Pt1:p,m (Ft−1 )m,• ] Π[Pt1:p,q (Ft−1 )q,• ]
.
[Pt1:p,m (Ft−1 )m,• ]
[Pt1:p,q (Ft−1 )q,• ]

(18)

Let the left block of columns in Kt be denoted by Ktm and the right by Ktq and compute
Lt =

Π1 · · ·
Inp

Πp
0np×n

0n×n
0np×n

!
−



[Ktq Λq ]

Ktm



(19)

and
Mt =



1:(p+1),m
Pt

1:(p+1),q 0
Pt
Λqq



.

(20)

The state prediction is
at+1 =

Πa1:p
t|t
2:(p+1)

at|t

!
.

(21)

Finally, a sizable improvement can be obtained for the variance of the state prediction by
1:p,1:p
first computing ΠPt|t
and then constructing
Pt+1 =

1:p,1:p
1:p,1:p
[ΠPt|t
]Π0 + Σt [ΠPt|t
]
1:p,1:p 0
[ΠPt|t
]

1:p,1:p
Pt|t

!
.

(22)

There are two main points to make from the recursions for blocked filtering. First, there are
several instances where the same quantity appears in multiple places. It is therefore unnecessary to compute it over and over. Instead, efficiency can be gained by computing it once
and copying the object to the appropriate locations. Second, because of the large number
of zeros as well as the identity matrices in the system matrices, several computations can be
avoided altogether in favor of subsetting the appropriate matrices. The two approaches can
be used in conjunction in some cases. For example, to compute Kt Zt one would first select
the first nm columns of Kt . To compute the second part of Kt Zt , i.e. Ktq Λq , one can compute Ktq Λqq and subtract the column vectors of the obtained matrix from the corresponding
columns of Tt ; because Λq typically contains a large number of zero columns, so will Ktq Λq
and these need not be computed. The same type of computation can also be carried out
for vt , which involves Zt at for which copying of pre-computed data and multiplication for a
subset improves efficiency.
The smoothing step is cheap in comparison with the filtering part, but is nevertheless
10

Date

2018

Tb

Not observed

Observed

Figure 1: Observational pattern for U.S. data. The color of each cell indicates if the variable
is observed at the given time point. The right-most variable is a quarterly variable and the
remaining are monthly indicators.
subject to a modest improvement through:

[Ft−1 vt ]m,•


= L0t+1 rt + Λ0q [Ft−1 vt ]q,•  ,
0np×1


rt−1

(23)

where [Ft−1 vt ]m,• and [Ft−1 vt ]q,• are the monthly and quarterly, respectively, blocks of rows
of Ft−1 vt , which is computed during filtering.

3.2

Adaptive filtering

The advantage of blocked filtering is its ability to improve upon the existing SS15 compact
filtering procedure with relatively little effort. However, the downside is that it improves on
the problem without attempting to fix it.
Figure 1 offers an illustrative visual understanding of the compact filtering procedure:
for t ≤ Tb , the monthly block is fully observed, but for t > Tb some of the monthly variables
are missing. In this particular data set, based on the January vintage of the FRED database
(McCracken and Ng, 2016), at t = Tb + 1 only a single monthly indicator is missing. Nevertheless, in the compact procedure a move to the companion form is still triggered. Using the
companion form, the 18 monthly variables which are observed at t = Tb + 1 will have their
true values imputed with themselves. For t = Tb + 2, a larger number of monthly variables
are unobserved. Yet, use of the full companion form would still need to carry out addi11

tional computations for the sole purpose of imputing six variables with their already-known
outcomes.
Motivated by the large degree of unnecessary computations performed in the companion
form for larger models, we therefore develop an adaptive procedure. Intuitively, the adaptive
filtering procedure is simple and appealing: for every t = Tb + 1, . . . , T , augment the state
vector with the monthly variables missing at that time period. In relation to Figure 1,
the procedure consists of adding the single missing monthly variable to the state vector at
t = Tb + 1 and at t = Tb + 2 include all but the first six monthly variables in the state vector.
While the adaptive procedure is intuitive and simple in principle, it warrants some additional notation to be introduced. Let Ut denote the set of indexes of the monthly set of
variables which are unobserved at time t. Correspondingly, let Ot denote the set of indexes
of the observed set of monthly variables at time t. For t = 1, . . . , Tb , we have that ym,t = yOt ,t
is of dimension nm × 1. For t = Tb + 1, . . . , T , it still holds that ym,t = yOt ,t , but now the
dimension is |Ot | < nm . The notation yOt ,t−τ is taken to mean the observed values at time
t−τ of the monthly variables observed at time t. Similarly, xUt ,t−τ refers to the latent process
at time t − τ for the set of unobserved monthly variables that are unobserved at time t.
Equipped with this new set of notation, we can formulate the state-space model as


xUt ,t
xq,t
..
.







!


ym,t
yOt−1 ,t−p:t−1


= Zt 
+ Gt et
 + Ct


yq,t
1
x

 Ut ,t−p 
xq,t−p




xUt ,t
xUt−1 ,t−1




 xq,t 
 xq,t

!




y
 .. 


Ot−1 ,t−p:t−1
..
+ Ht et .
 .  = Tt 
 + Dt
.




1
x

x

 Ut ,t−p 
 Ut−1 ,t−p−1 
xq,t−p−1
xq,t−p
!

(24)

The preceding model formulation is valid for any t = 1, . . . , T , with no particular
distinction between the balanced and unbalanced part. However, because Ut = ∅ for
t = 1, . . . , Tb , the model is mostly constant and equal to the compact formulation. The
SS15 compact-companion procedure fits into the above formulation by specifying Ut = ∅
and Ot−1 = {1, . . . , nm } for t = 1, . . . , Tb , and Ut = {1, . . . , nm } and Ot−1 = ∅ for
t = Tb + 1, . . . , T . One particular feature is that if Ut 6= Ut−1 , Tt will not be a square
matrix. It is this time-varying size and shape that automatically lets the model augment
12

new variables with missing observations to the state vector.
Let Jt be a (|Ut | + nq ) × (|Ut−1 | + nq ) selection matrix with the property that
Jt0

xUt ,t
xq,t

!
=

!
xUt−1 ,t
.
xq,t

(25)

We can then construct the Tt matrix as:
U ,Ut−1

Tt =

Π1 t

ΠU1 t ,q · · · ΠUp t ,Ut−1 ΠUp t ,q 0|Ut |×|Ut−1 |
Ip ⊗ Jt
0nq ×|Ut−1 |

!
,

(26)

U ,U

where Πj t t−1 refers to the elements in the Ut−1 columns and Ut rows of Πj . In practice,
there is no need to compute the Kronecker product as the bottom-left block of Tt can more
efficiently be filled programmatically. Depending on the observational pattern of the data, it
may be worthwhile to use a block approach when dealing with multiplications involving Tt
because of the sparse structure of Ip ⊗ Jt . However, if nq is low—our interest lies primarily
in nq = 1—and if the unbalanced part contains many observations, there is likely little to
gain.
The selection matrix Jt is the |Ut | + nq identity matrix with columns corresponding to
T
Ut Ot−1 deleted, i.e. columns for variables which were observed at t − 1 but are unobserved at t. The matrix formed by collecting the deleted columns constitutes the orthogonal
complement of Jt , denoted by J⊥,t . The J⊥,t matrix is used in constructing Dt to ensure
that variables observed at t − 1 but unobserved at t get their lag identities—i.e. the bottom
equations of the state equation—correct:

U ,O
Π1 t t−1 · · · ΠUp t ,Ot−1


q,O
t−1
Dt =  Πq,O
· · · Π1 t−1  .
1
Ip ⊗ J⊥,t


(27)

For the observation equation, let I−m,|Ut !
|+nq be the |Ut | + nq identity matrix with the first
xUt ,t
|Ut | rows deleted, so that I−m,|Ut |+nq
= xq,t . Then we can construct the Zt system
xq,t
matrix as:
!
Ot ,q
t ,Ut
Ot ,Ut
Ot ,q
0nm ×(|Ut |+nq ) ΠO
Π
·
·
·
Π
Π
1
1
p
p
Zt =
(28)
Sq,t Λqq [Ip+1 ⊗ I−m,|Ut |+nq ]

13

O ,Ot−1

Ct =

Π1 t

···

t ,Ot−1
ΠO
p

Sq,t 0nq ×p|Ot−1 |

!
(29)

The only pieces missing for concluding the description of the adaptive procedure are the
Ht and Gt matrices, which consist of:
!
1/2
(Σt )Ot ,•
Gt =
Sq,t 0nq ×n


1/2
(Σt )Ut ,•


Ht =  (Σt1/2 )q,•  ,
0p(|Ut |+nq )×n

(30)

(31)

where the superscripts refer to all columns and the subsets of rows corresponding to: the
observed monthly variables (Ot ), the unobserved monthly variables (Ut ) or the quarterly
variables (q).
It should be noted that while the system matrices can be characterized using zero, identity
and selection matrices, it is usually inefficient to use these forms explicitly. Faster handling
of the matrices and the operations involved can be achieved by subsetting and copying
previously computed objects appropriately.
The procedure itself is simple and straightforward, but the description of the system
matrices is somewhat involved notationally. To illustrate how the model adapts to the
structure of observed data, let us demonstrate it using a simple example. Figure 2 displays
the observational pattern for our hypothetical data. The system matrices are not displayed
here for space considerations, but can be found in full in Appendix B.
As before, the compact form is used for the balanced part of the sample as Ut = ∅ and
Ot−1 = {1, 2, 3} for t = 1, . . . , Tb . We use the short form y1:j,t−1:t−3 to denote the vector
y1:j,t−1:t−3 = (y1,t−1 , . . . , yj,t−1 , y1,t−2 , . . . , yj,t−3 )0 . For the current example, the observation

14

Date

Tb

Not observed

Observed

Figure 2: Observational pattern for the example discussed in the text. The color of each
cell indicates if the variable is observed at the given time point. The right-most variable is
a quarterly variable and the remaining are monthly indicators.
and state equations for a model with three lags are:





y1,t
xq,t
 


y2,t 
xq,t−1 
  = Zt 
 + Ct y1:3,t−1:t−3 + Gt et
y 
x

3,t
q,t−2
 


yq,t
xq,t−3




xq,t
xq,t−1




xq,t−1 
xq,t−2 

 = Tt 
 + Dt y1:3,t−1:t−3 + Ht et .
x

x

 q,t−2 
 q,t−3 
xq,t−4
xq,t−3

(32)

At t = Tb + 1, the third monthly variable is missing so that UTb +1 = {3} and OTb =

15

{1, 2, 3}. The third monthly variable is thus added to the state equation:

x
q,Tb +1
!



y1,Tb +1
xq,Tb 
 + CT +1 y1:3,T :T −2 + GT +1 eT +1

= ZTb +1 
b
b b
b
b

x
y2,Tb +1
 q,Tb −1 
xq,Tb −2


x3,Tb +1


xq,Tb +1 





 x
x
 3,Tb 
q,Tb +1




 xq,Tb 
 xq,Tb 
 = TT +1 
 + DT +1 y1:3,T :T −2 + HT +1 eT +1 .

b
b
b b
b
b


x
x
 3,Tb −1 
 q,Tb −1 


xq,Tb −1 
xq,Tb −2



x
 3,Tb −2 
xq,Tb −2


(33)

At the end of the sample (t = Tb + 2 = T ), we obtain UTb +2 = {2, 3} and OTb +1 = {1, 2}.

16

The second monthly variable is now added to the state equation:


y1,Tb +2


x3,Tb +1


xq,Tb +1 


 x

 3,Tb 
!


 xq,Tb 
y
1,T
:T
−2
b
b
 + CT +2
+ GTb +2 eTb +2
= ZTb +2 
b
x

y2,Tb :Tb −2
 3,Tb −1 


xq,Tb −1 


x

 3,Tb −2 
xq,Tb −2




x2,Tb +1


x3,Tb +1 




x

x3,Tb +1
 q,Tb +1 




 x2,Tb 
xq,Tb +1 




 x
 x


 3,Tb 
 3,Tb 
!




 xq,Tb 
 xq,Tb 
y

 + DT +2 1,Tb :Tb −2 + HT +2 eT +2 .
 = TT +2 
b
b
b
b
x
x


y2,Tb :Tb −2
 2,Tb −1 
 3,Tb −1 




x3,Tb −1 
xq,Tb −1 




x
x


 q,Tb −1 
 3,Tb −2 


x2,Tb −2 
xq,Tb −2


x

 3,Tb −2 
xq,Tb −2

(34)

In principle, the procedure thus simply amounts to continuing to perform the compact
filtering procedure, but adjusting which variables are included as exogenous based on the
observational pattern. The filtering and smoothing recursions are therefore the same as for
the compact procedure in (11)–(12); what changes is instead the composition in the model
and the construction of the system matrices.
By studying the recursions in more detail, the benefit of the adaptive procedure becomes
clear. Take the main bottleneck—the computation of the variance of the one-step ahead
prediction—as an example. Using the companion form with blocked filtering for the obser1:p,1:p
vational pattern in Figure 1 with p = 3 requires multiplying Π (20 × 80), Pt|t
(80 × 80)
0
and the transpose Π together. The number of scalar multiplications required to compute
the full product is 203 × 803 = 4, 096, 000, 000.3 Using the adaptive procedure, it is (for
PTb +2 ) instead necessary to multiply TTb +2 (14 × 8), PTb +1|Tb +1 (8 × 8) and the transpose TT0 b +2
3

The calculated number of scalar multiplications does not exploit the symmetric nature of the resulting
matrix.

17

together. The number of scalar multiplications for this latter operation to be executed is
143 × 83 = 1, 404, 928—almost four orders of magnitude smaller. There is, in other words,
large possible gains to be achieved from adaptively adjusting the state vector to include only
the bare minimum. The relative gain depends on the number of observed variables in the
unbalanced part and the length of the unbalanced part.

4

Computational experiments

In this section, we demonstrate the computational benefits of our proposed algorithms. In
designing the setting for which we conduct the computational experiments, we aim to stay
close to a realistic scenario. Our primary empirical interest lies in using variables sampled
monthly in forecasting a single quarterly variable, the canonical example in mind being use
of a large set of monthly indicators for forecasting GDP growth. In order to see also the
effects of including more quarterly variables (cf. Schorfheide and Song, 2015; Götz and
Hauzenberger, 2018), we also consider nq = 3. For the total number of variables, we consider
a grid of n = 10, 20, . . . , 120 to capture the computational gains in both small and large
models. The sample size is T = 500 and we let the number of monthly variables with
missing values at t = 499, 500 be: one for n = 10, . . . , 40, two for n = 50, . . . , 80 and three
for n = 90, . . . , 120. The number of fully observed monthly series is set to 0.3n (rounded
up), with the remaining containing missingness at t = 500 only. The composition of the
ragged edge is roughly in line with the January 2019 vintage of the FRED-MD database
(McCracken and Ng, 2016). We first let p = 6 and vary n, and then consider the reverse
situation. We implement the simulation smoothing routines in C++ using the Armadillo
library for linear algebra (Sanderson and Curtin, 2016) via R and RcppArmadillo (R Core
Team, 2019; Eddelbuettel and Sanderson, 2014).
Figure 3 displays the computational cost per iteration. At the top in the figure, we
find the standard SS15 compact procedure followed by, in order, the blocked and adaptive
approaches. It is evident from the figure that for low-dimensional models, there is no need
to care about the computational efficiency as the cost per iteration is low to begin with.
Nevertheless, when the dimension of the model is large the choice of algorithm starts to
matter. There is also little relative difference between using one or three quarterly variables
in the model when the model size is large, which means that in large models there is no
need to restrict oneself from adding more quarterly variables to the model for computational
reasons. For a model using a data set similar in size to Bańbura et al. (2010) and Carriero
et al. (2019), use of the adaptive method yields 5,000 draws in approximately one hour,
whereas the SS15 procedure requires over 3 hours. While an hour is still needed, avoiding
18

2500

Milliseconds

2000

1500

Method
SS15
Blocked
Adaptive

Number of quarterly
nq = 1
nq = 3

1000

500

0
20

40

60

80

100

120

Number of variables (n)

Figure 3: Computational cost as a function of n, milliseconds per iteration. The example
uses T = 500 and Tb = 498. The number of monthly variables with missing observations at
both Tb + 1 and Tb + 2 is 0.025n and the number of fully observed monthly series is 0.3n
(both rounded up). The lag length is p = 6.
every bottleneck possible is highly desirable in a real-time forecasting situation where the
model may be subject to frequent re-estimation.
Because the three methods all make use of the compact filtering procedure for the balanced part, the difference in computational cost is due to the different treatments of the
unbalanced part. Thus, the figure clearly shows that using the companion form—even for
two time periods only—can be costly, as substantial reductions can be obtained by handling
it more carefully. In fact, using the adaptive procedure, dealing with the unbalanced part
constitutes only a small part of the overall computational cost. Consequently, for further
speed improvements one needs to focus on filtering and smoothing in the compact form. Further enhancements of the compact form may be possible depending on the remaining parts
of the model, if e.g. there are structures imposed on the parameters that can be exploited.
Figure 4 displays the cost per iteration as a function of the number of lags p. The number
of variables is n = 20 (upper panel) and n = 120 (bottom panel). Note that these two model
sizes correspond to the models used by Bańbura et al. (2010); Carriero et al. (2019). In both
of the aforementioned papers, the authors use p = 13. The figure shows that as the number
of lags increases, the added computational cost is lower using the adaptive procedure than
if the blocked approach is used. Going from 3 to 12 lags roughly means an increase from
0.8 to 1.1 seconds using the adaptive procedure. In contrast, the cost of the SS15 procedure
increases from 1.1 seconds to 14.1 seconds. Carriero et al. (2019) report that producing 5,000
19

128

Method

Milliseconds

SS15
Blocked
Adaptive
64

Number of quarterly
nq = 1
nq = 3
32

16
3

6

9

12

9

12

Number of lags (p)

(a) n = 20
Method
SS15
Blocked
Adaptive

Milliseconds

8192

4096

Number of quarterly
nq = 1
nq = 3

2048

1024
3

6

Number of lags (p)

(b) n = 120

Figure 4: Computational cost as a function of p, milliseconds per iteration. The example
uses T = 500 and Tb = 498. The number of monthly variables with missing observations at
both Tb + 1 and Tb + 2 is one (n = 20) and four (n = 120), and the number of fully observed
monthly series is three (n = 10) and 36 (n = 120).

20

Number of
variables (n)

Relative cost (Adaptive/SS15)

1.00

10
20
40
120

0.75

0.50

0.25

0.00
3

6

9

12

Number of lags (p)

Figure 5: Relative cost of the adaptive algorithm. The example uses T = 500, Tb = 498
and nq = 1. The number of monthly variables with missing observations at both Tb + 1 and
Tb + 2 is one (n = 10, 20, 40) and three (n = 120), and the number of fully observed monthly
variables is three (n = 10), six (n = 20), 12 (n = 40) and 36 (n = 120).
posterior draws in their large model takes about 5.5 hours; adding a quarterly variable to
their model would increase the overall computational time to approximately 7 hours using the
adaptive procedure. If instead SS15 is used, estimating the model would take approximately
24 hours.
To more clearly see where gains of the adaptive algorithm are larger, Figure 5 presents
the relative cost of the adaptive algorithm relative to the SS15 algorithm. It more explicitly
details the pattern that previous figures have documented: the adaptive algorithm scales
better with p, and it is primarily for large-dimensional models that the adaptive algorithm
excels and provides substantial improvements. The precise level of the gains also depends
on the observational pattern in the data. While the SS15 and the blocked procedures are
unaffected by the specific observational pattern (given Tb and T ), the adaptive procedure is
more apt the more variables are observed. Consequently, situations in which the data set
includes a large number of financial variables that are observed immediately are especially
suitable for the adaptive algorithm. The adaptive algorithm therefore makes use of largedimensional VARs for nowcasting in the presence of mixed-frequency data feasible.

21

5

Conclusion

The increasing interest in large vector autoregressive models means that existing methods
and algorithms are put to the test as large models are substantially more computationally
demanding. In order to facilitate estimation of large-dimensional VARs with mixed-frequency
data for real-time nowcasting we have developed methods that cope better with the large
dimensionality. Our preferred algorithm is adaptive and augments the state vector in the
simulation smoother at each time point as necessary, thereby avoiding to sample series we
already know. The adaptive algorithm exploits the ragged edges of the data to ameliorate
estimation when the data set is unbalanced. The algorithm consistently improves upon the
Schorfheide and Song (2015) simulation smoother, with the largest gain obtained when the
number of variables and the number of lags are high. Given that recent influential papers
such as Bańbura et al. (2010) and Carriero et al. (2019) estimate models with the number
of variables being in the range 125–131 while the number of lags is set to 13, the situation
in which we find the largest improvements is clearly of high interest in the literature. Our
algorithm can therefore be used as an efficient building block in incorporating additional
variables sampled at lower frequencies in existing large-dimensional VARs.

References
Anderson, B. D., Deistler, M., Felsenstein, E., and Koelbl, L. (2016). The structure of multivariate AR and ARMA systems: Regular and singular systems; the
single and the mixed frequency case.
Journal of Econometrics, 192(2):366–373,
doi:10.1016/j.jeconom.2016.02.004.
Ankargren, S., Unosson, M., and Yang, Y. (2018). A Mixed-Frequency Bayesian Vector
Autoregression with a Steady-State Prior. Working Paper No. 2018:2, Department of
Statistics, Uppsala University.
Bańbura, M., Giannone, D., and Reichlin, L. (2010). Large Bayesian Vector Auto Regressions. Journal of Applied Econometrics, 25(1):71–92, doi:10.1002/jae.1137.
Carriero, A., Clark, T. E., and Marcellino, M. (2019). Large Vector Autoregressions with
Stochastic Volatility and Non-Conjugate Priors. Journal of Econometrics. Forthcoming.
Carter, C. K. and Kohn, R. (1994). On Gibbs Sampling for State Space Models. Biometrika,
81(3):541–553, doi:10.1093/biomet/81.3.541.

22

Cimadomo, J. and D’Agostino, A. (2016). Combining Time Variation and Mixed Frequencies:
An Analysis of Government Spending Multipliers in Italy. Journal of Applied Econometrics, 31:1276–1290, doi:10.1002/jae.2489.
Deistler, M., Koelbl, L., and Anderson, B. D. (2017). Non-identifiability of VMA and
VARMA systems in the mixed frequency case. Econometrics and Statistics, 4:31–38,
doi:10.1016/j.ecosta.2016.11.006.
Durbin, J. and Koopman, S. J. (2002). A Simple and Efficient Simulation Smoother for
State Space Time Series Analysis. Biometrika, 89(3):603–615.
Eddelbuettel, D. and Sanderson, C. (2014). RcppArmadillo: Accelerating R with HighPerformance C++ Linear Algebra. Computational Statistics and Data Analysis, 71:1054–
1063, doi:10.1016/j.csda.2013.02.005.
Eraker, B., Chiu, C. W., Foerster, A. T., Kim, T. B., and Seoane, H. D. (2015).
Bayesian Mixed Frequency VARs. Journal of Financial Econometrics, 13(3):698–721,
doi:10.1093/jjfinec/nbu027.
Foroni, C., Marcellino, M., and Stevanovic, D. (2019). Mixed frequency models with MA
components. Journal of Applied Econometrics, doi:10.1002/jae.2701.
Frühwirth-Schnatter, S. (1994). Data Augmentation and Dynamic Linear Models. Journal
of Time Series Analysis, 15(2):183–202, doi:10.1111/j.1467-9892.1994.tb00184.x.
Ghysels, E. (2016). Macroeconomics and the reality of mixed frequency data. Journal of Econometrics, 193(2):294 – 314, doi:10.1016/j.jeconom.2016.04.008, http://
www.sciencedirect.com/science/article/pii/S0304407616300653. The Econometric
Analysis of Mixed Frequency Data Sampling.
Ghysels, E., Santa-Clara, P., and Valkanov, R. (2006). Predicting volatility: getting the most
out of return data sampled at different frequencies. Journal of Econometrics, 131(1):59 –
95, doi:10.1016/j.jeconom.2005.01.004.
Ghysels, E., Sinko, A., and Valkanov, R. (2007). MIDAS Regressions: Further Results and
New Directions. Econometric Reviews, 26(1):53–90, doi:10.1080/07474930600972467.
Götz, T. B. and Hauzenberger, K. (2018). Large Mixed-Frequency VARs with a Parsimonious
Time-Varying Parameter Structure. Discussion Paper No. 40, Deutsche Bundesbank.

23

Götz, T. B., Hecq, A., and Smeekes, S. (2016).
Testing for Granger causality in large mixed-frequency VARs.
Journal of Econometrics, 193(2):418–432,
doi:10.1016/j.jeconom.2016.04.015.
Jarociński, M. (2015).
A note on implementing the Durbin and Koopman
simulation smoother.
Computational Statistics & Data Analysis, 91:1–3,
doi:https://doi.org/10.1016/j.csda.2015.05.001, http://www.sciencedirect.
com/science/article/pii/S0167947315001176.
Koop, G. M. (2013). Forecasting with Medium and Large Bayesian VARs. Journal of Applied
Econometrics, 28(2):177–203, doi:10.1002/jae.1270.
Marcellino, M., Porqueddu, M., and Venditti, F. (2016). Short-Term GDP Forecasting With
a Mixed-Frequency Dynamic Factor Model With Stochastic Volatility. Journal of Business
& Economic Statistics, 34, doi:10.1080/07350015.2015.1006773.
Mariano, R. S. and Murasawa, Y. (2003). A New Coincident Index of Business Cycles
Based on Monthly and Quarterly Series. Journal of Applied Econometrics, 18(4):427–443,
doi:10.1002/jae.695.
Mariano, R. S. and Murasawa, Y. (2010). A Coincident Index, Common Factors,
and Monthly Real GDP. Oxford Bulletin of Economics and Statistics, 72(1):27–46,
doi:10.1111/j.1468-0084.2009.00567.x.
McCracken, M. W. and Ng, S. (2016). FRED-MD: A Monthly Database for Macroeconomic Research.
Journal of Business & Economic Statistics, 34(4):574–589,
doi:10.1080/07350015.2015.108.
McCracken, M. W., Owyang, M. T., and Sekhposyan, T. (2015). Real-Time Forecasting
with a Large, Mixed Frequency, Bayesian VAR. Working Papers 2015-30, Federal Reserve
Bank of St. Louis, doi:10.20955/wp.2015.030.
Qian, H. (2016).
A computationally efficient method for vector autoregression with mixed frequency data.
Journal of Econometrics, 193(2):433–437,
doi:10.1016/j.jeconom.2016.04.016.
R Core Team (2019). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing, Vienna, Austria, http://www.R-project.org/.
Sanderson, C. and Curtin, R. (2016). Armadillo: A Template-Based C++ Library for Linear
Algebra. Journal of Open Source Software, 1(2):1–26, doi:10.21105/joss.00026.
24

Schorfheide, F. and Song, D. (2015).
Real-Time Forecasting with a MixedFrequency VAR.
Journal of Business & Economic Statistics, 33(3):366–380,
doi:10.1080/07350015.2014.954707.
Strid, I. and Walentin, K. (2009). Block Kalman Filtering for Large-Scale DSGE Models.
Computational Economics, 33(3):277–304, doi:10.1007/s10614-008-9160-4.
Tanner, M. A. and Wong, W. H. (1987). The Calculation of Posterior Distributions by
Data Augmentation. Journal of the American Statistical Association, 82(398):528–540,
doi:10.1080/01621459.1987.10478458.
Zadrozny, P. A. (2016).
Extended Yule-Walker identification of VARMA models
with single- or mixed-frequency data.
Journal of Econometrics, 193(2):438–446,
doi:10.1016/j.jeconom.2016.04.017.

A

Transitions in the SS15 simulation smoother

0
From compact to companion At t = Tb , we obtain aTb +1 and PTb +1 for αt = (x0q,t , zq,t−1
)0 .
If we instead use α̃t = (zt0 , x0t−p )0 , we see that these now represent



ãTb |Tb

xm,Tb

 xq,Tb

 x
 m,Tb −1

=E
 xq,Tb −1

..

.

 x
 m,Tb −p
xq,t−p






xm,Tb
  (1)

  aT |T 
b b
 

  x

  m,Tb −1 
  (2)



yTb , yTb −1 , . . . 
 =  aTb |Tb 
 

..
 

.
 

  x

  m,Tb −p 
(p+1)
aTb |Tb

25

(35)

(1)0

(p)0

where at|t = (at|t , . . . , at|t )0 . Moreover,


P̃Tb |Tb







=V 









xm,Tb

 
xq,Tb
 
 
xm,Tb −1
 
 
xq,Tb −1 yTb , yTb −1 , . . . 
=
 
..
 
.
 
 
xm,Tb −p

xq,t−p

0
0
0
0
..
.

0
(1,1)

PTb |Tb
0
(2,1)
PTb |Tb

..
.

(p+1,1)

0 PTb |Tb

0
0
0
0
..
.

0
(1,2)

PTb |Tb
0
(2,2)
PTb |Tb

..
.

(p+1,2)

0 PTb |Tb

···
···
···
···
..
.
···

0
(1,p+1)

PTb |Tb
0

(2,p+1)
PTb |Tb

..
.

(p+1,p+1)







,





PTb |Tb

(36)
(i,j)

where PTb |Tb is the nq × nq (i, j) block of PTb |Tb .
Now, we can see that
ãTb +1 = F1 (Π)ãTb |Tb + Fc (Π)

(37)

P̃Tb +1 = F1 (Π)P̃Tb |Tb F1 (Π)0 + Ω(Σt ).

(38)

The companion-based filter is obtained by using ãTb +1 and P̃Tb +1 as starting values
ˆ s = E(α̃s |yT , yT −1 , . . . ) for
and then proceeding as usual. By smoothing, we obtain α̃
s = T, . . . , Tb + 1.
From companion to compact The final step is to move from the companion form to the
compact representation. Doing so is accomplished by
rTb = PT−1
(α̂Tb +1 − aTb +1 )
b +1

(39)

Hence, to move from the companion form back to the compact representation, we extract
ˆ T +1 . After that, we can smooth using (12) initialized
α̂Tb +1 = E(αTb +1 |yT , yT −1 , . . . ) from α̃
b
with rTb .

B

Adaptive filtering: Example

System matrices for t = 1, . . . , Tb For t = 1, . . . , Tb , monthly variables are fully observed
and the quarterly variable is observed every third month. When t corresponds to a month in
which the quarterly variable is not observed, the fourth row of Zt , Ct and Gt is deleted. We
i,j
let Πi,j
l denote element (i, j) of Πl , and wt element (i, j) of the lower-triangular Cholesky

26

factor Wt .

1,4
1,4
0 Π1,4
Π
Π
1
2
3

2,4
2,4 

 0 Π2,4
Π
Π
1
2
3 
Zt = 
 0 Π3,4 Π3,4 Π3,4  ,

1
2
3 
1
1
1
0
3
3
3





1,1
1,1
1,2
1,2
1,2
1,3
1,3
1,3
Π1,1
Π
Π
Π
Π
Π
Π
Π
Π
1
2
3
1
2
3
1
2
3
 2,1
2,1
2,2
2,2
2,2
2,3
2,3
2,3 
Π1 Π2,1
Π3 Π1 Π2 Π3 Π1 Π2 Π3 
2

Ct = 
Π3,1 Π3,1 Π3,1 Π3,2 Π3,2 Π3,2 Π3,3 Π3,3 Π3,3 
 1
2
3
1
2
3
1
2
3 
0
0
0
0
0
0
0
0
0
(40)

wt1,1 0
0
 2,1
2,2
wt
wt
0
Gt = 
w3,1 w3,2 w3,3
 t
t
t
0
0
0


0

0
,
0

0



Π14,4 Π4,4
Π4,4
2
3

 1
0
0
Tt = 
 0
1
0

0
0
1


0

0

0

0

(41)




Π14,1 Π4,1
Π4,1
Π4,2
Π4,2
Π4,2
Π4,3
Π24,3 Π34,3
2
3
1
2
3
1


 0
0
0
0
0
0
0
0
0 
,

Dt = 

0
0
0
0
0
0
0
0
0


0
0
0
0
0
0
0
0
0




wt4,1 wt4,2 wt4,3 wt4,4


 0
0
0
0 


Ht = 

0
0
0
0


0
0
0
0
(42)

27

System matrices for t = Tb + 1
Zt =

0 Π1,4
Π1,4
Π1,4
1
2
3
2,4
2,4
0 Π1 Π2 Π2,4
3

!
,

Ct =

Π1,1
Π1,1
Π1,1
Π11,2 Π21,2 Π31,2 Π1,3
Π21,3 Π1,3
1
2
3
1
3
2,1
2,1
2,1
2,2
2,2
2,2
2,3
2,3
2,3
Π1 Π2 Π3 Π1 Π2 Π3 Π1 Π2 Π3

Gt =

!
wt1,1 0 0 0
,
wt2,1 wt2,2 0 0

(43)

Π13,4 Π3,4
Π3,4
2
3
 4,4
Π1 Π24,4 Π4,4
3

 0
0
0


 1
0
0
Tt = 
 0
0
0


 0
1
0

 0
0
0

0
0
1

!


0

0

0


0

0


0

0

0

(44)




Π3,1
Π3,1
Π3,1
Π3,2
Π3,2
Π3,2
Π3,3
Π3,3
Π33,3
1
2
3
1
2
3
1
2
 4,1
4,1
4,2
4,2
4,2
4,3
4,3
4,3 
Π1 Π4,1

Π
Π
Π
Π
Π
Π
Π
2
3
1
2
3
1
2
3


 0
0
0
0
0
0
1
0
0 




 0

0
0
0
0
0
0
0
0
,
Dt = 
 0
0
0
0
0
0
0
1
0 




 0

0
0
0
0
0
0
0
0


 0
0
0
0
0
0
0
0
1 


0
0
0
0
0
0
0
0
0




wt3,1 wt3,2 wt3,3 0
 4,1
4,2
4,3
4,4 
w t

w
w
w
t
t
t


 0
0
0
0 




 0

0
0
0

Ht = 
 0
0
0
0 




 0

0
0
0


 0
0
0
0 


0
0
0
0
(45)

28

System matrices for t = Tb + 2


Zt = 0 0

Π1,3
1

Π1,4
1

Π1,3
2

Π1,4
2

Π1,3
3

Π1,4
3



,

Ct =



Π11,1

Π1,1
2

Π1,1
3

Π1,2
1

Π21,2





Gt = wt1,1 0 0 0 ,

Π12,3 Π2,4
Π2,3
Π2,4
Π32,3 Π32,4
1
2
2
 3,3
Π1 Π13,4 Π3,3
Π3,4
Π33,3 Π33,4
2
2

Π4,3 Π4,4 Π4,3 Π4,4 Π4,3 Π4,4
 1
1
2
2
3
3

 0
0
0
0
0
0

 1
0
0
0
0
0


 0
1
0
0
0
0
Tt = 
 0
0
0
0
0
0


 0
0
1
0
0
0

 0
0
0
1
0
0


 0
0
0
0
0
0

 0
0
0
0
1
0

0
0
0
0
0
1




Π2,1
Π2,1
Π2,1
Π2,2
Π2,2
Π32,2
1
2
3
1
2
 3,1
3,1
3,2
3,2
3,2 

Π1 Π3,1
Π
Π
Π
Π
2
3
1
2
3 

Π4,1 Π4,1 Π4,1 Π4,2 Π4,2 Π4,2 
 1
2
3
1
2
3 


 0

0
0
1
0
0


 0

0
0
0
0
0




 0

0
0
0
0
0
,
Dt = 
 0

0
0
0
1
0




 0

0
0
0
0
0



 0
0
0
0
0
0





 0
0
0
0
0
1



 0
0
0
0
0
0


0
0
0
0
0
0



wt2,1 wt2,2 0
 3,1
w t
wt3,2 wt3,3

w4,1 w4,2 w4,3
 t
t
t

 0
0
0

 0
0
0


 0
0
0
Ht = 
 0
0
0


 0
0
0

 0
0
0


 0
0
0

 0
0
0

0
0
0

Π1,2
3



(46)

0 0

0 0

0 0


0 0

0 0


0 0

0 0


0 0

0 0


0 0

0 0

0 0
(47)

0

0 

wt4,4 


0 

0 


0 

0 


0 

0 


0 

0 

0
(48)

29

