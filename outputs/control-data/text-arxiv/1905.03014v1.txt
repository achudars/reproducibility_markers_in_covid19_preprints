arXiv:1905.03014v1 [math.LO] 8 May 2019

On Church’s Thesis in Cubical Assemblies
Andrew W Swan and Taichi Uemura
May 9, 2019
Abstract
We show that Church’s thesis, the axiom stating that all functions
on the naturals are computable, does not hold in the cubical assemblies
model of cubical type theory.
We show that nevertheless Church’s thesis is consistent with univalent
type theory by constructing a reflective subuniverse of cubical assemblies
where it holds.

1

Introduction

One of the main branches of constructive mathematics is that of recursive or
“Russian” constructivism, where to justify the existence of mathematical objects, one must show how to compute them. A rather extreme interpretation
of this philosophy is the axiom of Church’s thesis, which states that all functions from N to N are computable. Despite (or perhaps because) of its highly
non-classical nature it has been well studied by logicians and turns out to be
consistent with a wide variety of formal theories for constructive mathematics.
This is usually proved using realizability models based on computable functions,
starting with Kleene’s model of Heyting arithmetic[Kle45], but with many later
variants and generalisations. See for example [TvD88, Chapter 4, Section 4] for
a standard reference.
When interpreting Church’s thesis in type theory an additional complication
is introduced. Logical statements are usually interpreted in type theory using
the propositions-as-types interpretation. Applying this to Church’s thesis would
give us the type below.
Y XYX
T (e, x, z) ∧ U (z) = f (x)
f :N→N e:N x:N z:N

However it is straightforward to use function extensionality to show that this
type is empty.1 It is therefore impossible in any case to show that the above
1 Surprisingly, however, this version is consistent with intensional type theory as long as one
drops the ξ rule, which was proved by Ishihara, Maietti, Maschio and Streicher in [IMMS18].
They leave the case where one has the ξ rule but not function extensionality open and to the
authors’ knowledge it remains an open problem.

1

“untruncated” version of Church’s thesis is consistent with univalence, since
univalence implies function extensionality [Uni13, Theorem 4.9.4].
To have any hope of showing Church’s thesis is consistent with univalence we
need a different formulation. We will use the interpretation of logical statements
advocated in [Uni13, Section 3.7], and commonly used in homotopy type theory
and elsewhere. In this approach one uses the higher inductive type of propositional truncation at disjunction and existential quantifiers, which ensures that
the resulting type is always an hproposition (i.e. that any two of its elements
are equal). This yields the following version of Church’s thesis, which is the one
we will study here.
Y

f :N→N

XYX

T (e, x, z) × U (z) = f (x)

e:N x:N z:N

It is well known that Church’s thesis holds in the internal logic of Hyland’s
effective topos (see for instance [vO08, Section 3.1] for a standard reference).
Similar arguments show that in fact it already holds in its simpler subcategory
of assemblies, and even in cubical assemblies, when they are viewed as regular
locally cartesian closed categories and thereby, following Awodey and Bauer in
[AB04] or Maietti in [Mai05] as models of extensional type theory with propositional truncation. However, the interpretation of cubical type theory in cubical
assemblies due to the second author [Uem18] is very different to the interpretation of extensional type theory. We draw attention in particular to the fact
that for extensional type theory hpropositions are implemented as maps where
in the internal logic each fibre has at most one element.2 On the other hand in
the interpretation of cubical type theory, each fibre can have multiple elements
as long as any two elements are joined by a path, telling us to always treat
them as “propositionally equal.” For propositional truncation we don’t strictly
identify elements by quotienting, but instead add new paths. Our first result is
that Church’s thesis is in fact false in the interpretation of cubical type theory
in cubical assemblies, even though it holds in the internal logic.
To show Church’s thesis is consistent with univalence we will combine cubical assemblies with the work of Rijke, Shulman and Spitters on modalities
and Σ-closed reflective subuniverses in [RSS17]. We will construct a reflective
subuniverse where Church’s thesis is forced to hold, and then use properties of
cubical assemblies to show that this reflective subuniverse is non trivial. Our
model can also be viewed as a kind of stack model akin to those used by Coquand
for various independence and consistency results, including the independence of
countable choice from homotopy type theory [Coq18], although our formulation
will be quite different to Coquand’s.
2 Equivalently, the map is a monomorphism, and for this reason hpropositions are sometimes
referred to as mono types.

2

Acknowledgements
The first author is grateful for some helpful discussions on higher inductive types
with Simon Huber, Anders Mörtberg and Christian Sattler at the Hausdorff
Research Institute for Mathematics during the trimester program Types, Sets
and Constructions. The second author is supported by the research programme
“The Computational Content of Homotopy Type Theory” with project number
613.001.602, which is financed by the Netherlands Organisation for Scientific
Research (NWO). We are grateful to Benno van den Berg for helpful comments
and corrections.

2

Models of Type Theories

In this paper we use models of different kinds of type theory: extensional dependent type theory; intensional dependent type theory (with the univalence
axiom). All of them are based on the notion of a category with families [Dyb96].
Definition 2.1. Let C be a category. R A cwf-structure
over C is a pair (T, E)
op
→ Set such that, for any object
of presheaves T : C op → Set and E : C T
Γ ∈ C and element X ∈ T (Γ), the presheaf
(C/Γ)op ∋ (f : ∆ → Γ) 7→ E(∆, X · f ) ∈ Set
is representable. The representing object for this presheaf is denoted by χ(X) :
{X} → Γ or χ(X) : Γ.X → Γ. A category with families, cwf in short, is a triple
E = (CE , TE , EE ) such that CE is a category with a terminal object and (TE , EE )
is a cwf-structure over CE .
In general a model E of a type theory consists of a category with families
(CE , TE , EE ) and algebraic operations on the presheaves TE and EE . An object
Γ of CE is called a context. An element X of TE (Γ) is called a type and written
Γ ⊢E X. An element a of EE (Γ, X) is called an element of type X and written
Γ ⊢E a : X. The subscript of ⊢E is omitted when the model E is clear from the
context. An algebraic operation on those presheaves is expressed by the schema
Γ ⊢ J1
...
Γ ⊢ Jn
Γ ⊢ A(J1 , . . . , Jn )
where Γ ⊢ Jj and Γ ⊢ A(J1 , . . . , Jn ) are either of the form Γ.X1 . . . . .Xm ⊢ Y or
of the form Γ.X1 . . . . .Xm ⊢ b : Y with (Γ ⊢ X1 ), . . . , (Γ.X1 . . . . .Xm−1 ⊢ Xm ). In
this schema we always assume that the operation A(J1 , . . . , Jn ) is stable under
reindexing: if f : ∆ → Γ is a morphism in CE , then we have A(J1 , . . . , Jn ) · f =
A(J1 · f, . . . , Jn · f ).
Example 2.2. Let E be a cwf. We say E supports dependent product types if it
has operations
Γ⊢X
Γ.X ⊢ Y
Γ ⊢ Π(X, Y )

Γ⊢X
Γ.X ⊢ Y
Γ.X ⊢ b : Y
Γ ⊢ λ(X, Y, b) : Π(X, Y )
3

such that the map E(Γ.X, Y ) ∋ b 7→ λ(X, Y, b) ∈ E(Γ, Π(X, Y )) is bijective.
It is a kind of routine to describe other type constructors such as dependent
sum types, extensional and intensional identity types, inductive types, higher
inductive types and universes.
For a model E of a type theory, we denote by [[−]]E the interpretation of the
type theory in the model E.
Definition 2.3. By a model of univalent type theory we mean a cwf that supports dependent product types, dependent sum type, intensional identity types,
unit type, finite coproducts, natural numbers, propositional truncation and a
countable chain
U0 : U1 : U2 : . . .
of univalent universes.

2.1

Internal Languages

Formally we will work with models of type theories, but we will construct types
and terms of those models in a syntactic way using their internal languages. Let
E = (CE , TE , EE , . . . ) be a model of a type theory. For a context Γ ∈ CE and
a type Γ ⊢ X, we introduce a variable x and write (Γ, x : X) for the context
Γ.X. For another type Γ ⊢ Y , the weakening Γ, x : X ⊢ Y is interpreted
as the reindexing Γ.X ⊢ Y · χ(X). For an element Γ ⊢ a : X and a type
Γ, x : X ⊢ Y (x), the substitution Γ ⊢ Y (a) is interpreted as the reindexing
Γ ⊢ Y · ā, where ā : Γ → Γ.X is the section of Γ.X → Γ corresponding to
the element Γ ⊢ a : X. All type and term constructors of the type theory are
soundly interpreted in E in a natural way. Note that types and terms built in
the internal language are stable under reindexing.

2.2

W -types with Reductions

We will later use W -types with reductions to construct higher inductive types.
So that we can use them internally in type theory we give below a new, split
formulation. This is based on the non-dependent special case of the version in
[Swa18].
Let E = (CE , TE , EE , . . . ) be a model of a type theory with dependent product types, dependent sum types and extensional identity types. Suppose that
E has types 1 ⊢ F and ϕ : F ⊢ [ϕ] such that ϕ : F, x : [ϕ], y : [ϕ] ⊢ x = y. We
call an element of F a cofibrant proposition. We often omit [−] and regard an
element ϕ : F itself as a type. A cofibrant polynomial with reductions over a
context Γ ∈ CE consists of the following data:
• a type Γ ⊢ Y of constructors;
• a type Γ, y : Y ⊢ X(y) of arities;
• a cofibrant proposition Γ, y : Y ⊢ R(y) : F together with an element
Γ, y : Y, r : R(y) ⊢ k(y, r) : X(y) which we refer to as the reductions.
4

An algebra for a cofibrant polynomial with reductions (Y, X, R, k) over Γ ∈ CE
is a type Γ ⊢ W together with an element Γ, y : Y, α : X(y) → W ⊢ s(y, α) : W
such that Γ, y : Y, α : X(y) → W, r : R(y) ⊢ s(y, α) = α(k(y, r)). Algebras for
(Y, X, R, k) form a category in the obvious way and we say E supports cofibrant
W -types with reductions if every cofibrant polynomial with reductions has an
initial algebra preserved by reindexing.

3

Orton-Pitts Construction

Assumption 3.1. Let E be a model of dependent type theory that supports
dependent product types, dependent sum types, extensional identity types, unit
type, finite colimits, natural numbers, propositional truncation and a countable
chain of universes. We further assume that every context Γ ∈ CE is isomorphic
to 1.X for some type X over the terminal object 1. Suppose the following:
• E has a type 1 ⊢ I equipped with two constants 0 and 1 and two binary
operators ⊓ and ⊔;
• E has types 1 ⊢ F and ϕ : F ⊢ [ϕ] such that ϕ : F, x : [ϕ], y : [ϕ] ⊢ x = y.
An element of F is called a cofibrant proposition. We often omit [−] and
regard an element ϕ : F itself as a type;
• I and F satisfy ax1 –ax9 given by Orton and Pitts [OP18];
Q
• F satisfies propositional extensionality: ϕ,ψ:F (ϕ ⇔ ψ) ⇒ (ϕ = ψ);
• the exponential functor (−)I : CE → CE has a right adjoint;
• E supports cofibrant W -types with reductions.
Note that the axioms in [OP18] are written in the internal language of an
elementary topos, but they are easily translated into dependent type theory
with I and F as above. We require propositional extensionality which trivially
holds when F is a subobject of the subobject classifier of an elementary topos.
Under these assumptions, we will build a model Ee of univalent type theory
as follows:
e

• the base category CE is that of E;
• the types Γ ⊢Ee X are the types Γ ⊢E X equipped with a “fibration structure”;
• the elements Γ ⊢Ee a : X are the elements Γ ⊢E a : X of the underlying
type X in E;
By the construction given in [OP18], this model Ee supports dependent product
types, dependent sum types, identity types, unit type, finite coproducts and
natural numbers. For a countable chain of univalent universes, use the right
adjoint to (−)I as in [LOPS18]. It remains to show that Ee supports propositional
5

truncation, which will be proved in Section 3.1 using cofibrant W -types with
reductions. We call a model of univalent type theory of the form Ee an OrtonPitts model.

3.1

Higher Inductive Types in Orton-Pitts Models

We are still working with a model E of type theory that satisfies Assumption
e Our techniques
3.1. We will show how to construct higher inductive types in E.
are fairly general, although we will focus on the HITs that we will need for the
main theorem. The techniques developed by Coquand Huber and Mörtberg in
[CHM18] are already very close to working in arbitrary Orton-Pitts models. The
only exception is that the underlying objects for the HITs are given by certain
initial algebras, which are constructed directly for cubical sets. This definition
doesn’t quite work for cubical assemblies for two reasons. Firstly we are using
a different cube category, and secondly we are working internally in assemblies.
Rather than proving the same results again for cubical assemblies we will use
a more general approach based on W -types with reductions that covers both
cases. The first author already showed in [Swa18, Section 4] that (non-split)
W -types with locally decidable reductions can be constructed in any category
of presheaf assemblies and we’ll see later how to ensure that we get in fact split
W -types with reductions in presheaf assemblies.
Finally, we will also make some minor adjustments related to the fact that
we do not assume the interval object has reversals.
When we construct higher inductive types, we will use formulations based
on Path types, following Coquand, Huber and Mörtberg. Technically these
formulations can only be stated in cubical type theory, and not in intensional
type theory in general. However, it is straightforward to derive versions based
on Id types using the equivalence of Path and Id types, which are then valid in
e We note that although computation rules hold definitionally for both point
E.
and path constructors for the Path type versions, after translating to Id types,
the definitional equality only holds for point constructors. However, neither
definitional equality will be needed for our end result.
Definition 3.2. Given a type Γ ⊢E A, we define the local fibrant replacement
of A, LFR(A) to be the W -type with reductions defined as follows.
• When a : A, we add an element inc(a) to LFR(A).
P
• When ϕ : F, ǫ ∈ {0, 1} and u : i:I ((i = ǫ) ∨ ϕ) → LFR(A), we add an
element hcomp(ϕ, ǫ, u) to LFR(A).
• If p : ϕ and ǫ and u are as above then hcomp(ϕ, ǫ, u) reduces to u(1 − ǫ, p).
Formally, we define the constructors Y to be the coproduct A + (F × 2). We
take the arity X(inl(a)) to be the empty type for a : A and X(ϕ, ǫ) to be
P
i:I ϕ ∨ (i = ǫ) for (ϕ, ǫ) : F × 2. We take the reductions R(inl(a))
P to be ⊥ for
a : A and R(ϕ, ǫ) to be ϕ together with the map p : ϕ ⊢ (1−ǫ, p) : i:I ϕ∨(i = ǫ).
6

Theorem 3.3. The model Ee supports suspensions.

Proof. Suppose we are given a type Γ ⊢Ee X. We first construct the naı̈ve
suspension, Susp0 (X) as the pushout below.
X×2

2

X×I

p
Susp0 (X)

We next take the local fibrant replacement, to get LFR(Susp0 (X)). This is
then an initial Susp(X) algebra, as defined by Coquand, Huber and Mörtberg
in [CHM18, Section 2.2] and so we can then proceed with the same proof as
they do there.
Theorem 3.4. The model Ee supports propositional truncation.

Proof. Suppose we are given a type Γ ⊢Ee A. We first define the underlying
object of kAk to be the W -type with reductions defined as follows.
• When a : A, we add an element inc(a) to kAk.
P
• When ϕ : F, ǫ ∈ {0, 1} and u : i:I ((i = ǫ) ∨ ϕ) → kAk, we add an
element hcomp(ϕ, ǫ, u) to kAk.
• If p : ϕ and ǫ and u are as above then hcomp(ϕ, ǫ, u) reduces to u(1 − ǫ, p).
• If x, y : kAk and i : I, then kAk contains an element of the form sq(x, y, i).
• If x, y, i are as above and i = 0, then sq(x, y, i) reduces to x.
• If x, y, i are as above and i = 1, then sq(x, y, i) reduces to y.
Formally, we define this by taking the coproduct of two polynomials with
reductions. The first is the one we used before for LFR. The second has
constructors Y := I, with the arity defined by X(i) := 2, and reductions
R(i) := (i = 0) ∨ (i = 1) together with the map p : (i = 0) ∨ (i = 1) ⊢ k(p) : 2
defined by k(p) = 0 if p : i = 0 and k(p) = 1 if p : i = 1.
The remainder of the proof is the same as the syntactic description of
propositional truncation by Coquand, Huber and Mörtberg in [CHM18, Section 3.3.4].
We now construct a new higher inductive type, which is a simplified version
of the higher inductive type JF defined by Rijke, Shulman and Spitters in
[RSS17, Section 2.2]. Given families of types Γ ⊢Ee A and Γ, a : A ⊢Ee B(a) we
Γ
will construct a higher inductive type KB
defined as follows.
• When a : A and f : B(a) → KB , we add an element ext(a, f ) to KB .
• When a : A, f : B(a) → KB and b : B(a) we add an element isext(a, f, b)
to Path(ext(a, f ), f (b)).
7

We require that KB satisfies the following elimination rule. Suppose we are
given a family of types Γ, x : KB ⊢Ee P (x) together with the terms below.


Y
Y
Y

P (f (b)) → P (ext(f, c))
R:
a:A f :B(a)→KB

S:

Y

Y

b:B(a)

a:A f :B(a)→KB f ′ :

Q

Y Y

Y

P (isext(a, f, b)(i))

i:I
b:B(a) P (f (b)) b:B(a)

Suppose further that S satisfies the equalities
S(a, f, f ′ , b, 0) = R(f ′ )
S(a, f, f ′ , b, 1) = f ′ (b)
Then we have a choice of term Γ, x : KB ⊢ s(x) : P (x) satisfying the following
computation rules for a : A, f : B(a) → KB and b : B(a).
s(ext(a, f )) = R(a, f, s ◦ f )
s(isext(a, f, b)(i)) = S(a, f, s ◦ f, b, i)
Moreover the choice of term is strictly preserved by reindexing.
We use the techniques developed by Coquand, Huber and Mörtberg together
with W -types with reductions for constructing the actual objects. In order to
Γ
give KB
the structure of a fibration we need to define a composition operator.
We will do this by freely adding an hcomp operator, and then combining it with
a transport operator, which we will explicitly define.
Definition 3.5. Let Γ ⊢E X be a type. We define the naı̈ve cone, Cone(X) to
be the following pushout3 .
X

1

h1X ,δ0 i

X ×I

inl

inr

Cone(X)

Γ
We can now define KB
to be the following W -type with reductions.

• When a : A, c : Cone(B(a)) and f : B(a) → KB , we add an element
pastecone(a, c, f ) to KB .
• If a, c, f are as above and c is of the form inr(b, 1) for b : B(a), then
pastecone(a, c, f ) reduces to f (b).
P
• When ϕ : F and u :
i:I ((i = 0) ∨ ϕ) → KB , we add an element
hcomp(ϕ, u) to KB .
• If p : ϕ and u is as above then hcomp(ϕ, u) reduces to u(1, p).
3 Pushout

in the usual categorical sense, not the homotopy pushout.

8

To check that this really is a W -type with reductions, we need to define the
polynomial with reductions. We take it to be the coproduct of the following two
polynomials with reductions.
We define the firstPcomponent of the coproduct as follows. We take the
constructors Y to be a:A Cone(B(a)) and the arities X(a, c) to be B(a). We
take the reductions R(a, inl(∗)) to be ⊥ and R(a, inr(b, i))
Pto be (i = 1) together
with the map R(a, inr(b, i)) ⊢ b : B(a). Note that R : ( a:A Cone(B(a))) → F
is well-defined because we have (0 = 1) = ⊥ by propositional extensionality.
The second component in the coproduct is the polynomial with reductions
that we used for local fibrant replacement.
Γ
Lemma 3.6. We construct a transport operator for KB
, in the sense defined
in [CHM18, Definition 2.3].

Proof. Suppose we are given ϕ : F and a path γ in Γ which is constant on ϕ.
We need to define a transport operator, which is a map t : KB(γ(0)) → KB(γ(1))
such that t is the identity when ϕ is true. Formally this map can be defined by
giving an appropriate algebra structure on KB(γ(1)) and then using the initiality
of KB(γ(0)) . However, for clarity we will present the proof as an argument by
higher recursion on the definition of KB(γ(0)) .
We need to show how to define t(pastecone(a, c, f )) and t(hcomp(ψ, u)), and
then check that the definition respects the reduction equations. For the latter we define the transport operator so that it preserves the hcomp structure,
which determines it uniquely, following [CHM18]. For the former, we recall that
Cone(B(a)) was defined as a pushout, and so we can split into a further two
cases. Either c is of the form inl(∗), or it is of the form inr(b, i) where b : B(a)
and i : I. Now in addition to the reduction equation, we have to also satisfy
t(inl(∗)) = t(inr(b, 0)) in order to eliminate out of the pushout.
Q Write tA for the transport A(γ(0)) → A(γ(1)) and tB for the transport
a:A(Γ(0)) B(a) → B(tA (a)) ensuring that tA (a) = a and tB (b) = b when
−1
ϕ = ⊤,
for the homotopy inQ for all a : A(γ(0)) and b : B(a). Write tB −1
verse a:A(Γ(0)) B(tA (a)) → B(a), again ensuring that tB (b) = b when ϕ = ⊤.
Since we are only guaranteed the existence of a homotopy inverse, not a strict
inverse, we
have t−1
B ◦ tB = 1B(a) . We can however construct
Q don’t necessarily
Q
paths p : a:A(Γ(0)) b:B(a) I → B(a) satisfying for all a : A(Γ(0)) and b : B(a)
that p(a, b, 0) = t−1
B (tB (b)) and p(a, b, 1) = b. Furthermore, we may assume that
for any a, b and i, if ϕ = ⊤ then p(a, b, i) = b.
We define t(pastecone(a, inl(∗), f )) to be of the form pastecone(tA (a), inl(∗), f ′ ),
where we still need to define a function f ′ : B(tA (a)) → KB(γ(1)) . Note that
we may assume by recursion that for each b : B(a), t(f (b)) has already been
defined and belongs to KB(γ(1)) . Hence we can simply define f ′ to be t ◦ f ◦ t−1
B .
The obvious first attempt at defining t(pastecone(a, inr(b, i), f )), would be
pastecone(tA (a), inr(tB (b), i), t ◦ f ◦ t−1
B ). Note however that this does not satisfy
the reduction equations. This is because when i = 1, pastecone(a, inr(b, i), f ) re−1
duces to f (b) and pastecone(tA (a), inr(tB (b), i), t◦f ◦t−1
B ) reduces to t(f (tB (tB (b))))
which is not necessarily strictly equal to t(f (b)). We fix this using the hcomp
9

constructor, following the construction of homotopy pushouts in [CHM18, SectionP2.3]. We define ψ : F to be ϕ ∨ (i = 0) ∨ (i = 1). We then define
u : j:I (ψ ∨ (j = 0)) → KB(γ(a)) as follows.

pastecone(tA (a), inr(tB (b), i), t ◦ f ◦ t−1

B )


pastecone(a, inr(b, i), t ◦ f )
u(j, ∗) :≡
−1

pastecone(tA (a), inl(∗), t ◦ f ◦ tB
)



t(f (p(a, b, j)))

j=0
ϕ=⊤
i=0
i=1

We then define t(pastecone(a, inr(b, i), f )) to be hcomp(ψ, 0, u). The reduction
equation for hcomp then ensures that we do satisfy the reduction equation for
pastecone and also retain the necessary equations for the pushout and furthermore ensures that the resulting map t : KB(γ(0)) → KB(γ(1)) is a transport
operator.
Theorem 3.7. We construct a fibration structure for each KB , which is strictly
preserved by reindexing.
Proof. By lemma 3.6 and [CHM18, Lemma 2.5].
Lemma 3.8. We construct terms ext and isext for KB that satisfy the appropriate equations.
Proof.
ext(a, f ) :≡ pastecone(a, inl(∗), f )
isext(a, f, b)(i) :≡ pastecone(a, inr(b, i), f )

Lemma 3.9. KB satisfies the necessary induction principle.
Proof. Suppose we are given a family of types Γ, x : KB ⊢Ee P (x) together with
the terms below.


Y
Y
Y

P (f (b)) → P (ext(f, c))
R:
a:A f :B(a)→KB

S:

Y

Y

b:B(a)

a:A f :B(a)→KB f ′ :

Q

Y Y

Y

b:B(a)

P (isext(a, f, b)(i))

P (f (b)) b:B(a) i:I

We need to define a term Γ, x : KB ⊢ s(x) : P (x) satisfying the appropriate
equalities. We define s by higher recursion on the construction of KB . We first
deal with the case s(pastecone(a, c, f )). Recalling that Cone(B(a)) is defined as
a pushout, we can split into the two cases c = inl(∗) and c = inr(b, i) for some
b : B(a) and i : I.

10

We define
s(pastecone(a, inl(∗), f )) :≡ R(a, f, s ◦ f )
s(pastecone(a, inr(b, i), f )) :≡ S(a, f, s ◦ f, b, i)
It is straightforward to check that this does preserve the reduction and pushout
equations and so does give a well defined map. One can show it is a section
again by higher recursion and the computation rules are satisfied by definition.
Finally, to define s(hcomp(ϕ, u)) we use the fibration structure on Γ, x :
KB ⊢E P (x).

3.2

Internal Cubical Models

Let S be a model of dependent type theory with dependent product types,
dependent sum types, extensional identity types, unit type, finite colimits, W types and a countable chain of universes. We also assume that every context of
S is isomorphic to 1.X for some type 1 ⊢S X. In particular, the category CS is
finitely complete so that internal categories in CS make sense. Let  denote the
internal category in CS in which the objects are the natural numbers and the
morphisms from n to m are the order-preserving functions 2n → 2m . Note that
S has a natural number object since it has W -types. We will refer to internal
presheaves over  as internal cubical objects.
Theorem 3.10. Under those assumptions, the category of internal cubical objects in S is part of a model of type theory that satisfies Assumption 3.1.
Example 3.11. Let A be a partial combinatory algebra. It is well-known that
the category Asm(A) of assemblies on A is part of a model of type theory with
dependent product types, dependent sum types, extensional identity types, unit
type, finite colimits. It is also known that Asm(A) has W -types (an explicit
construction is found in [vdB06, Section 2.2]). Assuming a countable chain of
Grothendieck universes in the set theory, Asm(A) has a countable chain of
universes. Thus the category CAsm(A) of internal cubical objects in Asm(A)
is part of a model of type theory that satisfies Assumption 3.1.
It is shown in [OP18] that, when S = Set, the category of presheaves over
 satisfies all the axioms of Orton and Pitts if we take F to be the presheaf of
locally decidable propositions. The proof works for an arbitrary S and one can
show that the category of internal cubical objects in S is part of a model of type
theory satisfying Assumption 3.1 except the existence of cofibrant W -types with
reductions (see also [Uem18]). To construct cofibrant W -types with reductions,
we recall the following from [Swa18].
Theorem 3.12. Let E be a locally cartesian closed category with finite colimits
and disjoint coproducts and W -types, and let C be an internal category in E.
Then the category P(C) of internal presheaves over C has all locally decidable
W -types with reductions.

11

We furthermore observe that one can show that this construction is stable
under pullback up to isomorphism using a technique similar to the one used by
Gambino and Hyland for ordinary W -types. The reason is that pointed polynomial endofunctors are stable under pullback because they are constructed from
Σ types, Π types and pushouts, all of which are preserved by pullback, and in
locally cartesian closed categories the initial algebras of such pointed endofunctors are also stable under pullback. However, to ensure that the construction is
strictly preserved requires a little more work.
We show how to use the non split version above to construct split W -types
with reductions. The essential idea is to carry out the construction given
above “pointwise,” expanding out the method suggested by Coquand, Huber
and Mörtberg in [CHM18, Section 2.2]. Since we define cubical sets here as
a category of presheaves in the usual, contravariant sense, we work with contravariant presheaves here, although the original proof in [Swa18] is phrased in
terms of covariant presheaves. We also make minor adjustments to fit with the
“split” version appearing in section 2.2.
a context Γ ∈ P(C) together with a type Y ∈
R
RSuppose that we are given
{Y
}),
X
∈
P(
P( C Γ), a type
C
R a locally decidable monomorphism R ֌ Y
Q
and a map k : y:R X(y) over C Γ.
We need to show how to define a strict version of the W -type with reductions
W (Y, X, R). We willRrefer to the new strict version as W ′ (Y, X, R). This should
be an element of P( C Γ), so in particular we need to define a family of types
W ′ (Y, X, R)(c, γ) indexed by objects c of C and elements γ : Γ(c).
We fix such a c and γ. We first note that we have a a locally decidable
R polynomial with reductions Yγ , Xγ , Rγ in the internal presheaf category P( C C(−, c))
given by reindexing along the map C(−, c) → Γ given by Yoneda. We Rthen carry
out the “non strict” construction to get a presheaf W (Yγ , Xγ , Rγ ) on C C(−, c)
and finally we define W ′ (Y, X, R)(c, γ) to be W (Yγ , Xγ , Rγ )(c, 1c ).
For completeness, we unfold the definitions to obtain the following explicit
description of W ′ (Y, X, R)(c, γ). We first define
R the dependent W -type N0 of
normal forms indexed by the
objects
(d,
f
)
of
C C(−, c).
R
If (d, f ) is an object of C C(−, c) we add an element to N0 (d, f ) of the form
sup(y, α) whenever y is an element of Y (d, Γ(f )(γ)) that does not belong to the
subobject R(d, Γ(f )(γ)) and α is an element of the following type.
Y
N0 (e, f ◦ g)X(f ◦g,Γ(f ◦g)(γ),Y (g)(y))
g:e→d

The next step is to define maps N0 (d, f ) → N0 (e, f ◦ g) whenever g : e → d
and f : d → c in C. Say that we are given an element of N0 (d, f ) of the
form sup(y, α). We recall that N0 (g)(sup(y, α)) is defined by splitting into
cases depending on whether or not y belongs to the subobject R(d, Γ(f )(γ)).
If it does, we define N0 (g)(sup(y, α)) to be α(g, k(y)). Otherwise, we define
N0 (g)(sup(y, α)) to be sup(Y (g)(y), α′ ) where α′ (h, x) is defined to be α(g◦h, x).
We then define N (d, f ) for each f : d → c to be the subobject of N0 (d, f )
consisting of hereditarily natural elements and verify that this does indeed define
12

R
a presheaf on C C(−, c). But this is identical to [Swa18, Section 4] so we omit
the details.
If we then define W ′ (Y, X, R)(c, γ) to be N (c, 1c ), then this is strictly stable
under reindexing by definition.
One can construct by recursion an isomorphism between N (d, f ) and W (Y, X, R)(d, Γ(f )(γ))
for each f : d → c. In particular this gives us an isomorphism between
N (c, 1c ) and W (Y, X, R)(c, γ), and so we have a canonical isomorphism between
W ′ (Y, X, R)(c, γ) and W (Y, X, R)(c, γ). It follows that we can assign an initial
algebra structure to W ′ (Y, X, R)(c, γ) by transferring the algebra structure on
W (Y, X, R)(c, γ) via the isomorphism.

3.3

Discrete Types

We introduce a class of types in an Orton-Pitts model for future use. Let E be
a model of type theory satisfying Assumption 3.1.
Definition 3.13. A type 1 ⊢ X is said to be discrete if the map λx.λi.x : X →
X I is an isomorphism.
The proofs of the following propositions are found in [Uem18].
Proposition 3.14. Every discrete type 1 ⊢ X carries a fibration structure.
Proposition 3.15. If a type 1 ⊢ X has decidable equality, then it is discrete.
Corollary 3.16. The natural number object in E is discrete.

4

Church’s Thesis

We consider a dependent type theory with dependent product types, dependent
sum types, identity types, unit type, disjoint finite coproducts, propositional
truncation and natural numbers. In such a dependent type theory, one can
define Kleene’s computation predicate T (e, x, z) and result extraction function
U (z) as primitive recursive functions T : N × N × N → 2 and U : N → N. The
statement T (e, x, z) means that z codes a computation on Turing machine e
with input x and U (z) is the output of the computation. Church’s Thesis is the
following axiom.
∀f :N→N ∃e:N ∀x:N ∃z:N T (e, x, z) ∧ U (z) = f (x)
P

Since the type z:N T (e, x, z) × U (z) = f (x) is a proposition, Church’s Thesis
is equivalent to the type
Y

f :N→N

XYX

T (e, x, z) × U (z) = f (x) .

e:N x:N z:N

13

4.1

Failure of Church’s Thesis in Internal Cubical Models

Let S be a model of type theory as in Section 3.2. We have seen that the
category P() of internal cubical objects in S is part of a model of type theory
satisfying Assumption 3.1. In this section we show the following theorem.
Theorem 4.1. The negation of Church’s Thesis holds in the model of univalent
type theory ^
P().
To prove Theorem 4.1, we recall from [Uem18] the notion of a codiscrete
presheaf. The constant presheaf functor ∆ : S → P() extends to a morphism
of cwf’s and preserves (at least up to isomorphism) several type constructors.
Here we only need the following.
Proposition 4.2. The morphism ∆ : S → P() of cwf ’s preserves dependent product types, dependent sum types, extensional identity types and natural
number objects.
A constant presheaf ∆X is regarded as a type in ^
P() by the following
proposition and Proposition 3.14.
Proposition 4.3. Constant presheaves are discrete.
For types 1 ⊢S X and x : X ⊢S Y (x), one can define a type x : ∆X ⊢P()
∇X Y (x) called the codiscrete presheaf which has the following properties.
Proposition 4.4. ∇X is the right adjoint to the evaluation functor (−)0 at
0 ∈ : for any type x : ∆X ⊢P() Z(x), we have a natural bijection between
the set of elements x : ∆X, z : Z(x) ⊢P() b : ∇X Y (x) and the set of elements
x : X, z : Z0 (x) ⊢S b : Y (x). Note that (∆X)0 = X and thus Z0 is a type in S
over X.
Proposition 4.5. For a type x : X ⊢S Y (x), the type x : ∆X ⊢P() ∇X Y (x)
has a composition structure and is a proposition in ^
P().
P Q P
Proof of Theorem 4.1. We define types f : N → N ⊢ C ′ (f ) :≡ e:N x:N z:N T (e, x, z)×
U (x) = f (x) and f : N → N ⊢ C(f ) :≡ kC ′ (f )k. Let N denote the natP() as
ural number object in S. Then Church’s Thesis is interpreted in ^
Q
^
P()
(f ) by Proposition 4.2. We will construct two functions
f :∆(N →N ) [[C]]
^
in P():
Q

^
P()

(f ) → ∇N →N [[C ′ ]]S (f );
Q

′ S
•
∇
[[C
]]
(f
)
→ 0.
N
→N
f :∆(N →N )
•

f :∆(N →N ) [[C]]

Then we readily get a function

Q


^
P()
[[C]]
(f
)
→ 0.
f :∆(N →N )

14

^

For the former one it suffices to give a function [[C ′ ]]P() (f ) → ∇N →N [[C ′ ]]S (f )
for all f : ∆(N → N ) by the recursion principle of the propositional truncation
because the codomain is a proposition by Proposition 4.5. By the adjunction
^
P()

(−)0 ⊣ ∇N →N it suffices to give a function [[C ′ ]]0
→ [[C ′ ]]S but we have an
^
isomorphism [[C ′ ]]P() ∼
= (∆[[C ′ ]]S )0 = [[C ′ ]]S by Proposition 4.2.
Q

Q
′ S
For the latter function, observe that f :∆(N →N ) ∇N →N [[C ′ ]]S (f ) ∼
= ∇1
f :N →N [[C ]] (f )
Q

′ S
and that ∇1 0 ∼
[[C
]]
(f
)
→0
= 0. Then we apply ∇1 to the function
f :N →N
in S obtained from the inconsistency of Church’s Thesis with the axiom of choice
and function extensionality.

5

Null Types

Let E be a model of univalent type theory. Based on Rijke, Shulman and
Spitters’ null types [RSS17] we define a notion of null structure as follows.
Let a : A ⊢ B(a) be a proposition in E. For a type Γ ⊢ X in E, we define a
proposition Γ ⊢ isNullB (X) as
Y
Γ⊢
isEquiv(λ(x : X).λ(b : B(a)).x)
a:A

and call a term of isNullB (X) a B-null structure on X. A B-null type is a type
Γ ⊢ X equipped with a B-null structure n on X. That is, a B-null type has a
witness that the canonical map X → X B(a) is an equivalence for each a.
Definition 5.1. We define a cwf EB as follows:
• the contexts are those of E;
• the types are the B-null types in E;
• the elements of Γ ⊢EB X are those of the underlying type X in E.
We have the obvious forgetful morphism EB → E of cwf’s.
For a proposition a : A ⊢ B(a), a nullification operator assigns
• each type Γ ⊢ X a B-null type Γ ⊢ LB X and an element Γ ⊢ ηX : X →
LB X; and
• each pair of type Γ ⊢ X and B-null type Γ ⊢ Y an element Γ ⊢ e :
isEquiv(λ(f : LB X → Y ).f ◦ ηX .
We also require that a nullification operator is preserved by reindexing.
We review some properties of null types. See [RSS17] for further details.
Proposition 5.2. Let Γ ⊢ X and Γ, x : X ⊢ Y (x) be types in E.
Q
Q
• There exists a term of type Γ ⊢ ( x:X isNullB (Y (x))) → isNullB ( x:X Y (x)).
15

Q
• There exists
P a term of type Γ ⊢ isNullB (X) → ( x:X isNullB (Y (x))) →
isNullB ( x:X Y (x)).
Q
• There exists a term of type Γ ⊢ isNullB (X) → x0 ,x1 :X isNullB (IdX (x0 , x1 )).
Consequently, EB supports dependent product, dependent sum and intensional
identity types preserved by the morphism EB → E.
For a universe U we define a subuniverse UB of U as
UB ≡ {X : U | isNullB (X)}.
Proposition 5.3. The universe UB has a B-null structure.
Proof. Our condition that each B(a) is a proposition corresponds to Rijke, Shulman and Spitters’ notion of topological modality. They prove in [RSS17, Corollary 3.11 and Theorem 3.12] that for any such modality the universe of modal
types is itself modal.
Proposition 5.4. If a nullification operator LB exists, then it preserves propositions.
Proof. This is true for any modality by [RSS17, Lemma 1.28].
Corollary 5.5. Suppose that E has a nullification operator LB . Then a : A ⊢
LB B(a) is contractible.
Q
Proof. Since LB B(a) is a proposition, it suffices to find an element of a:A LB B(a).
Assume that a : A is given. Since LB B(a) is B-null, it is enough to give a function B(a) → LB B(a), so take the constructor ηB(a) : B(a) → LB B(a).
Corollary 5.6. Suppose that E has a nullification operator LB . Then X 7→
LB kXk gives propositional truncation in the model EB .
Proof. By Proposition 5.4, LB kXk is a proposition. For any B-null proposition
Z, we have equivalences
(LB kXk → Z) ≃ (kXk → Z)
≃ (X → Z).

5.1

Null Types in Orton-Pitts Models

Let Ee be an Orton-Pitts model.

Definition 5.7. A type a : A ⊢ B(a) in E or Ee is said to be well-supported if the
propositional truncation a : A ⊢E kB(a)k taken in the model E of extensional
dependent type theory is inhabited.

16

Proposition 5.8. Let 1 ⊢E X be a type and a : A ⊢Ee B(a) a proposition. If X
is discrete and B is well-supported, then X has a B-null structure.
Proof. We show that, for any a : A, the function ka :≡ λx.λb.x : X → (B(a) →
X) is an isomorphism in the internal language of E. Since B is well-supported,
ka is injective. To prove surjectivity we assume that f : B(a) → X is given. By
the well-supportedness of B there exists some element b : B(a). We show that
e we have
f = ka (f (b)). Assume b′ : B(a) is given. Since B is a proposition in E
a path p : I → B(a) such that p0 = b′ and p1 = b. By the discreteness of X the
path f ◦ p : I → X is constant, which implies that f (b′ ) = f (b). Hence we have
f = ka (f (b)) by function extensionality.
We easily deduce the following corollaries.
Corollary 5.9. If B is well-supported, then 0 has a B-null structure.
Corollary 5.10. If B is well-supported, then N has a B-null structure.
Proposition 5.11. Let a : A ⊢Ee B(a) be a proposition and Γ ⊢Ee X and Γ ⊢Ee Y
types. Then there exists a term of type
Γ ⊢ isNullB (X) → isNullB (Y ) → isNullB (X + Y ).
Proof. We proceed in the internal language of E. Suppose that X and Y has a
B-null structure. Assume that a : A is given. Since the function (X + Y ) →
(B(a) → (X + Y )) factors as
X +Y

B(a) → (X + Y )
Φ

(B(a) → X) + (B(a) → Y ),
it suffices to show that the function Φ : ((B(a) → X) + (B(a) → Y )) →
(B(a) → (X + Y )) is an isomorphism. The injectivity of Φ follows from the
well-supportedness of B. To prove the surjectivity we assume that f : B(a) →
(X + Y ) is given. We show that (∀b:B(a) f b ∈ X) ∨ (∀b:B(a) f b ∈ Y ). Since B
is well-supported, there exists some element b0 : B(a). We know that f b0 ∈
X ∨ f b0 ∈ Y . Suppose that f b0 ∈ X. Assume b : B(a) is given. Since B
e we have a path p : I → B(a) such that p0 = b0 and
is a proposition in E,
p1 = b. Since the exponential functor (−)I preserves colimits because it has a
right adjoint, we have (∀i:I f (pi) ∈ X) ∨ (∀i:I f (pi) ∈ Y ). Now f (p0) ∈ X and
thus we have ∀i:I f (pi) ∈ X. In particular, f b ∈ X. In a similar manner, we have
∀b:B(a) f b ∈ Y assuming f b0 ∈ Y . Hence we get (∀b:B(a) f b ∈ X) ∨ (∀b:B(a) f b ∈
Y ).
By Corollary 3.16, Propositions 5.2, 5.8 and 5.11, for any type X defined
in dependent type theory only using dependent product types, dependent sum
types, identity types, unit type, disjoint finite coproducts and natural numbers,
17

e

the interpretation [[X]]E has a B-null structure for any well-supported propoe In particular, if [[X]]Ee is inhabited, then so is [[X]]EeB for any
sition B in E.
e
well-supported proposition B in E.
Example 5.12. Markov’s Principle is the following axiom.
∀α:N→2 ¬¬(∃n:N α(n)) → ∃n:N α(n)
It is equivalent to the type
Y

α:N→2 p:(

Q

Y

n:N α(n)→0)→0

X

α(n) .

n:N

P
For a decidable
α : N → 2, the proposition k n:N α(n)k is equivalent
P predicateQ
to the type n:N α(n) × k:N α(k) → n ≤ k which is defined without propositional truncation. Hence, if the model E of extensional dependent type theory
satisfies Markov’s Principle, then so does the model EeB of univalent type theory
e
for any well-supported proposition B in E.
We now show how to define nullification operators in Orton-Pitts models.
Following Rijke, Shulman and Spitters in [RSS17, Section 2.2] we will first define
an operator JB , although we will only consider the case of nullification, since
that is all we need here.
Lemma 5.13. For types a : A ⊢Ee B(a) and Γ ⊢Ee X, we have the higher
inductive JB (X) defined as follows.
• When x : X, then JB (X) contains an element αB
X (x).
• When a : A and f : B(a) → KB , then JB (X) contains an element
ext(a, f ).
• When a : A, f : B(a) → KB and b : B(a) then Id(ext(a, f ), f (b)) contains
an element isext(a, f, b).
Proof. JB (X) differs from KB by having an extra point constructor αB
X : X →
JB (X).
We define A′ to be the type A + X and define the family of types a : A′ ⊢
′
B (a) as follows.
B ′ (inl(a)) :≡ B(a)
B ′ (inr(x)) :≡ 0
We can then take JB (X) to be KB ′ , as defined in section 3.1. We take αB
X (x)
to be ext(inr(x), ⊥KB ) where ⊥KB is the unique map from 0 to KB .
Theorem 5.14. Ee has a nullification operator LB for every type a : A ⊢Ee B(a).

Proof. This follows from [RSS17, Theorem 2.16], observing that for the case of
nullification the pushout appearing there is just a suspension, which we have
already shown how to implement in theorem 3.3, and we showed in lemma 5.13
how to implement their J operator.
18

6

Church’s Thesis in Null Types

Consider a dependent type theory with dependent product types, dependent
sum types, identity types, unit type, disjoint finite coproducts, propositional
truncation and natural numbers. Let a : A ⊢ B(a) be a type in this type theory
where A and B are definable only using dependent product types, dependent
sum types, identity type of 2, unit type, finite coproducts and natural numbers.
e the underlying
We define a : A ⊢ C(a) := kB(a)k. For an Orton-Pitts model E,
Ee
Ee
E
E
types of the interpretations [[A]] and [[B]] are [[A]] and [[B]] respectively.
e
Theorem 6.1. Let Ee be an Orton-Pitts model. Suppose that [[B]]E is wellsupported. Then the proposition C holds in the model of univalent type theory
Ee[[C]]Ee .
e

e

Proof. Let D = [[C]]E . By assumption [[B]]E is well-supported and so is its
e
truncation D. By Corollary 3.16 and Propositions 5.2, 5.8 and 5.11, [[A]]E and
e
e
e
[[B]]E have D-null structures. Hence we have [[C]]ED = LD [[C]]E by Corollary 5.6,
and this type is inhabited by Corollary 5.5.
Corollary 6.2. Let S be a model of type theory as in Section 3.2. If the proposition C holds in S, then C also holds in the model of univalent type theory
Ee[[C]]Ee where E = P().

Proof. Since C = kBk holds in S, the type [[B]]S is well-supported. Then
e
[[B]]E = [[B]]E is also well-supported because the constant presheaf functor S → E
preserves all structures of the type theory. Then use Theorem 6.1.
Example 6.3. Recall that Church’s Thesis is equivalent to the type
Y

f :N→N

XYX

T (e, x, z) × U (z) = f (x) .

e:N x:N z:N

Also note that the equality of natural numbers is decidable, and thus there
exists a function =N : N → N → 2 such that the type U (z) = f (x) is equivalent
to (U (z) =N f (x)) = 1. Therefore Church’s Thesis is equivalent to a type of the
form
Y
kB(a)k
a:A

with a type a : A ⊢ B(a) definable only using dependent product types, dependent sum types, identity of 2, unit type, finite coproducts and natural numbers.
Since Church’s Thesis holds in the category Asm(K1 ) of assemblies on Kleene’s
first model K1 , by Corollary 6.2 the model of univalent type theory Ee[[C]]Ee satisfies Church’s Thesis where E = CAsm(K1 ).
We can now prove our second main result, which informally says that univalent type theory is consistent with the main principles of Recursive Constructive
Mathematics.
19

Theorem 6.4. Martin-Löf type theory remains consistent when all of the following extra structure and axioms are added.
1. Propositional truncation.
2. The axiom of univalence.
3. Church’s Thesis.
4. Markov’s Principle.
Proof. We prove consistency by constructing a model where all of the above
holds and where there is no element of type ⊥. Consider the Orton-Pitts model
Ee with E = CAsm(K1 ). We have seen that Ee satisfies Church’s Thesis in
Example 6.3. It remains to show that Ee satisfies Markov’s Principle and ⊥ is
empty in this model.
Using well supportness again, and example 5.12 we see that to show Markov’s
principle holds, it suffices to show it holds in cubical assemblies (as a model of
extensional type theory). Again, we observe that the type corresponding to
Markov’s principle is preserved by the constant presheaves functor, and so it
suffices to show that Markov’s principle holds in assemblies, which is again a
standard argument.
Using well supportness once more, and corollary 5.9 we see that ⊥ is the
same in null types as in cubical assemblies. It follows that it has no global
sections, i.e. there is no element of type ⊥ in the model.
We can use Theorem 6.1 for other principles.
Example 6.5. Brouwer’s Continuity Principle is the following axiom.
∀F :(N→N)→N ∀α:N→N ∃n:N ∀β:N→N (∀m:N m < n → α(m) = β(m)) → F (α) = F (β)
The standard ordering < on N is decidable, and thus Brouwer’s Continuity
Principle is an instance of Theorem 6.1.
We obtain a new proof of the following result originally proved by Coquand
using cubical stacks [Coq18]4 . See also [CMR17] for an earlier stack model based
on groupoids.
Theorem 6.6. Martin-Löf type theory remains consistent when all of the following extra structure and axioms are added.
1. Propositional truncation.
2. The axiom of univalence.
3. Brouwer’s Continuity Principle.
Proof. This is the same as for theorem 6.4. See e.g. [vO08, Proposition 3.1.6]
for a proof that Brouwer’s principle holds in the the effective topos (the same
proof applies for assemblies).
4 Coquand’s proof can also be said to use reflective subuniverses, although in a very different
way to our proof.

20

7

Conclusion and Further Work

We have constructed a model of type theory that satisfies the main axiom of homotopy type theory (univalence) and the main axioms of recursive constructive
mathematics (Church’s thesis and Markov’s principle). However, in both fields
there are additional axioms that are natural to consider, but which we have left
for future work.
With regards to homotopy type theory, we expect that the remaining higher
inductive types appearing in [Uni13] can be implemented following the technique
suggested in [RSS17, Remark 3.23] together with the technique of [CHM18] for
constructing the necessary higher inductive types in cubical assemblies.
The situation with the remaining axioms of recursive constructive mathematics is more difficult. The axiom of countable choice is often included, but
it is unclear whether countable choice holds in our model, or how to adjust the
model to ensure countable choice does hold. The other main axiom of recursive
constructive mathematics is extended Church’s thesis, which states that certain
partial functions from N to N are computable. The main issue here is that it is
unclear what is the most natural way to formulate partial functions in homotopy type theory. Much progress on this has been made by Escardó and Knapp
in [EK17]. However, as they show, a weak form of countable choice is needed
for their definition to work as expected. We expect that for any reasonable
formulation of extended Church’s thesis Theorem 6.1 can be used to construct
a model where it holds.
Another open problem is to find a good definition of (∞, 1)-effective topos,
which should be to the effective topos what (∞, 1)-toposes are to Grothendieck
toposes. In particular the effective topos should be recovered as the localisation of the hsets in the (∞, 1)-effective topos, and commonly seen theorems and
definitions in the effective topos should be special cases of corresponding higher
versions. One possible definition is cubical assemblies. We can now see another
possibility in the form of reflective subuniverses of cubical assemblies. However, our definition is dependent on particular a choice of axioms that satisfy
the necessary conditions to apply Theorem 6.1, so we leave open the problem
of finding a “natural” definition that satisfies axioms such as Church’s thesis
without needing to ensure they hold in the definition.

References
[AB04]

Steve Awodey and Andrej Bauer.
Propositions as [types].
Journal of Logic and Computation, 14(4):447–471, 2004.
doi:10.1093/logcom/14.4.447.

[CHM18] Thierry Coquand, Simon Huber, and Anders Mörtberg. On higher
inductive types in cubical type theory. In Proceedings of the
33rd Annual ACM/IEEE Symposium on Logic in Computer Science, LICS ’18, pages 255–264, New York, NY, USA, 2018. ACM.
doi:10.1145/3209108.3209197.
21

[CMR17] T. Coquand, B. Mannaa, and F. Ruch.
Stack semantics of
type theory.
In 2017 32nd Annual ACM/IEEE Symposium
on Logic in Computer Science (LICS), pages 1–11, June 2017.
doi:10.1109/LICS.2017.8005130.
[Coq18]

Thierry Coquand. Cubical stacks. Unpublished note available at
http://www.cse.chalmers.se/~coquand/stack.pdf, 2018.

[Dyb96]

Peter Dybjer. Internal Type Theory. In Stefano Berardi and Mario
Coppo, editors, Types for Proofs and Programs: International Workshop, TYPES ’95 Torino, Italy, June 5–8, 1995 Selected Papers,
pages 120–134. Springer Berlin Heidelberg, Berlin, Heidelberg, 1996.
doi:10.1007/3-540-61780-9_66.

[EK17]

Martı́n H. Escardó and Cory M. Knapp. Partial Elements and Recursion via Dominances in Univalent Type Theory. In Valentin Goranko
and Mads Dam, editors, 26th EACSL Annual Conference on Computer Science Logic (CSL 2017), volume 82 of Leibniz International
Proceedings in Informatics (LIPIcs), pages 21:1–21:16, Dagstuhl,
Germany, 2017. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik.
URL: http://drops.dagstuhl.de/opus/volltexte/2017/7682,
doi:10.4230/LIPIcs.CSL.2017.21.

[IMMS18] Hajime Ishihara, Maria Emilia Maietti, Samuele Maschio, and
Thomas Streicher.
Consistency of the intensional level of
the minimalist foundation with Church’s thesis and axiom of
choice. Archive for Mathematical Logic, 57(7):873–888, Nov 2018.
doi:10.1007/s00153-018-0612-9.
[Kle45]

S. C. Kleene. On the interpretation of intuitionistic number
theory.
J. Symbolic Logic, 10(4):109–124, 12 1945.
URL:
https://projecteuclid.org:443/euclid.jsl/1183391476.

[LOPS18] Daniel R. Licata, Ian Orton, Andrew M. Pitts, and Bas Spitters.
Internal Universes in Models of Homotopy Type Theory. In Hélène
Kirchner, editor, 3rd International Conference on Formal Structures
for Computation and Deduction (FSCD 2018), volume 108 of Leibniz
International Proceedings in Informatics (LIPIcs), pages 22:1–22:17,
Dagstuhl, Germany, 2018. Schloss Dagstuhl–Leibniz-Zentrum fuer
Informatik. doi:10.4230/LIPIcs.FSCD.2018.22.
[Mai05]

Maria Emilia Maietti. Modular correspondence between dependent
type theories and categories including pretopoi and topoi. Mathematical Structures in Computer Science, 15:1089–1149, 12 2005.
doi:10.1017/S0960129505004962.

[OP18]

Ian Orton and Andrew M. Pitts. Axioms for Modelling Cubical Type
Theory in a Topos. Logical Methods in Computer Science, 14, Dec
2018. doi:10.23638/LMCS-14(4:23)2018.
22

[RSS17]

Egbert Rijke, Michael Shulman, and Bas Spitters. Modalities in
homotopy type theory, June 2017. arXiv:1706.07526.

[Swa18]

Andrew W Swan. W types with reductions and the small object
argument, 2018. arXiv:1802.07588.

[TvD88]

Anne Troelstra and Dirk van Dalen. Constructivism in Mathematics, Volume I, volume 121 of Studies in logic and the foundations of
mathematics. Elsevier, 1988.

[Uem18]

Taichi Uemura. Cubical assemblies and the independence of the
propositional resizing axiom, 2018. arXiv:1803.06649.

[Uni13]

Univalent
Foundations
Program.
Homotopy
Type
Theory:
Univalent
Foundations
of
Mathematics.
http://homotopytypetheory.org/book, Institute for Advanced
Study, 2013.

[vdB06]

Benno van den Berg. Predicative topos theory and models for constructive set theory. PhD thesis, University of Utrecht, 2006.

[vO08]

Jaap van Oosten. Realizability: An Introduction to its Categorical
Side, volume 152 of Studies in logic and the foundations of mathematics. Elsevier, 2008.

23

