Table of Contents

arXiv:1907.03723v2 [cs.SE] 10 Jul 2019

1
2

3
4

5
6
7
8
9
A
B
C
D

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1 Basic Mathematical Notations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Architecture Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 Contracts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.5 Isabelle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Running Example: A Reliable Adder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Modeling Architecture Proofs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1 Verifying Reliable Adder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2 Soundness and Completeness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
From APML to Isabelle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Modeling Architecture Proofs in FACT UM Studio . . . . . . . . . . . . . . . . . . . . . . .
Case Study: Trainguard MT Control System . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Proof for Thm. 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Proof for Thm. 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
RAdder Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
TGMT Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1
2
2
3
3
4
5
5
7
8
9
11
12
13
14
15
i
iii
vi
x

APML: An Architecture Proof Modeling Language?
Diego Marmsoler and Genc Blakqori
Technische Universität München, Germany
diego.marmsoler@tum.de

Abstract. To address the increasing size and complexity of modern software
systems, compositional verification separates the verification of single components
from the verification of their composition. In architecture-based verification, the
former is done using Model Checking, while the latter is done using interactive
theorem proving (ITP). As of today, however, architects are usually not trained in
using a full-fledged interactive theorem prover. Thus, to bridge the gap between
ITP and the architecture domain, we developed APML: an architecture proof
modeling language. APML allows one to sketch proofs about component composition at the level of architecture using notations similar to Message Sequence
Charts. With this paper, we introduce APML: We describe the language, show
its soundness and completeness for the verification of architecture contracts, and
provide an algorithm to map an APML proof to a corresponding proof for the
interactive theorem prover Isabelle. Moreover, we describe its implementation
in terms of an Eclipse/EMF modeling application, demonstrate it by means of a
running example, and evaluate it in terms of a larger case study. Although our
results are promising, the case study also reveals some limitations, which lead to
new directions for future work.

Keywords: Compositional Verification, Interactive Theorem Proving, Architecturebased Verification, FACT UM, Isabelle

1

Introduction

Software intensive systems are becoming increasingly big and complex, which makes
their verification a challenge. To address this challenge, compositional verification
techniques separate the verification of single components from the verification of their
composition. In architecture-based verification (ABV) [30], for example, verification
of such systems is split into two parts: First, suitable contracts are identified for the
involved components and their implementation is verified against these contracts. Since
a single component is usually of limited complexity, in ABV this step is fully automated
using Model Checking [2]. In a second step, component contracts are combined to verify
overall system properties. Reasoning about the composition of contracts, however, might
be difficult and sometimes requires manual interaction [29]. Thus, in ABV, it is done
using interactive theorem provers, such as Isabelle [33].
?

This is a post-peer-review, pre-copyedit version of an article to be published in the proceedings
of the 23rd International Symposium on Formal Methods, which will appear in Springer’s
Lecture Notes in Computer Science.

A full-fledged interactive theorem prover, however, can be quite complex and its
usage usually requires expertise which is not always available in the architecture context [28]. Thus, in an effort to bridge the gap between interactive theorem proving and
the architecture domain, we developed APML: a language to specify proofs for the
composition of contracts using abstractions an architect is familiar with. APML comes
with a graphical notation, similar to Message Sequence Charts [15], to sketch proofs at
the architecture level and it is shown to be sound and complete regarding the verification of architecture contracts. It is implemented in Eclipse/EMF [40], where it can be
used to model proofs for architecture contracts and synthesize corresponding proofs for
Isabelle’s structured proof language Isar [42,43].
The aim of this paper is to introduce APML. To this end, we provide the following
contributions: (i) We provide a formal description of APML, including a formal semantics
for architecture contracts. (ii) We show soundness and completeness of APML for the
verification of architecture contracts. (iii) We present an algorithm to map an APML
proof to a corresponding proof in Isabelle/Isar. (iv) We describe its implementation in
terms of an Eclipse/EMF modeling application. (v) We demonstrate the approach by
means of a running example and report on the outcome of a case study in which we
applied APML for the verification of a railway control system. Thereby, to the best of
our knowledge, this is the first attempt to synthesize proofs for an interactive theorem
prover from an architecture description.
Our presentation is structured as follows: In section 2, we provide some background
to clarify our understanding of architecture in general and specifically our notion of
architecture contract. In section 3, we describe our running example, a reliable calculator.
In section 4, we introduce APML, demonstrate it by verifying a property for our running
example, and present our soundness and completeness results. In section 5, we present
our algorithm to map an APML proof to a corresponding proof in Isabelle/Isar and
demonstrate it by means of the running example. In section 6, we describe the implementation of APML in terms of an Eclipse/EMF modeling application and in section 7
we describe our effort to evaluate APML by means of a larger case study. In section 8,
we discuss related work before we conclude the paper in section 9 with a brief summary
and a discussion of future work.

2
2.1

Background
Basic Mathematical Notations

For a function f : D → R, we shall use f |D0 : D0 → R to denote the restriction of f to
domain D0 ⊆ D. In addition, we shall use partial functions f : D 99K R for which we
denote with dom (f ) ⊆ D its domain and with ran (f ) ⊆ R its range.
We will also use finite as well as infinite sequences of elements. Thereby, we denote
with (E)∗ the set of all finite sequences over elements of a given set E, by (E)∞ the set of
all infinite sequences over E, and by (E)ω the set of all finite and infinite sequences over
E. The n-th element of a sequence s is denoted with s(n−1) and the first element is s(0).
Moreover, we shall use #s ∈ N∞ to denote the length of s. For a sequence s ∈ (D →
R)∞ of functions we shall use s|D0 to denote the sequence of all restrictions s(n)|D0 .
2

2.2

Architecture Model

In our model [27,32], components communicate to each other by exchanging messages
over ports. Thus, we assume the existence of set M, containing all messages, and set P,
containing all ports, respectively. Moreover, we postulate the existence of a type function
T : P → ℘(M)

(1)

which assigns a set of messages to each port.
Ports are means to exchange messages between a component and its environment.
This is achieved through the notion of port valuation. Roughly speaking, a valuation for
a set of ports is an assignment of messages to each port.
Definition 1 (Port Valuation). For a set of ports P ⊆ P, we denote with P the set of
all possible, type-compatible port valuations, formally:
n
o

def
P =
µ ∈ P → M | ∀p ∈ P : µ(p) ∈ T (p)
Components communicate through interfaces by receiving messages on its input
ports and sending messages through its output ports.
Definition 2 (Interface). An interface is a pair (I , O), consisting of disjoint sets of
input ports I ⊆ P and output ports O ⊆ P. For an interface f , we denote by in(f ) the
set of input ports, out(f ) the set of output ports, and port(f ) the set of all ports. A set
of interfaces is called disjoint iff its interfaces do not share any ports. For such sets of
interfaces, we shall use the same notation as introduced for single interfaces, to denote
their input, output, and all ports.
In addition, a component has a behavior which is given in terms of a non-empty set of
sequences of port valuations over its interface.
In our model, an architecture connects input and output ports of a set of interfaces.
Thereby, the types of connected ports must be compatible.
Definition 3 (Architecture). An architecture is a pair (F, N ), consisting of a disjoint
set of interfaces F and a connection N : in(F ) 99K out(F ), such that
∀p ∈ dom (N ) : T (N (p)) ⊆ T (p)

(2)

Note that a connection is modeled as a partial function from input to output ports,
meaning that not every input port of an architecture is connected to a corresponding
output port and vice versa. Thus, ports of an architecture can be classified as either connected (given by dom (N ) ∪ ran (N )) or disconnected (given by (in(F ) \ dom (N )) ∪
(out(F ) \ ran (N ))).
2.3

Composition

The interface of an architecture with its environment is given by its disconnected ports.
3

Definition 4 (Architecture Interface). For an architecture A = (F, N ), its interface
is defined as A ⊗ = (I , O), consisting of input ports I = in(F ) \ dom (N ) and output
ports O = out(F ) \ ran (N ).
Note that, since F is required to be disjoint, an architecture’s input and output ports are
guaranteed to be disjoint, too. Thus, an architecture interface fulfills all the requirements
of definition 2 and thus represents a valid interface. Hence, we can use the same notation
as introduced for interfaces to access its ports.
We can now define a notion of composition to obtain the behavior of an architecture
from the behavior of its components.
Definition 5 (Architecture Behavior). Given an architecture A = (F, N ) and a nonempty behavior Bf ⊆ (port(f ))∞ for all of its interfaces f ∈ F . The behavior of the
composition is given by a set of traces A ⊗ B ⊆ (port(A ⊗))∞ , defined as follows:

def
=
t|port(A ⊗) | t ∈ (port(F ))∞ ∧
(3)
A⊗ B

∀f ∈ F : t|port(f ) ∈ Bf ∧
(4)
(∀(i, o) ∈ N, n ∈ N : t(n)(i) = t(n)(o))

(5)

Roughly speaking, the behavior of a composition is defined as all traces over the architecture’s interface (Eq. (3)), which respect the behavior of each component (Eq. (4)) and
the connections imposed by the architecture (Eq. (5)).
2.4

Contracts

In the following, we are considered with the specification of architectures (as they were
described in the previous section). To this end, we assume the existence of a set of
predicates Γ (P ) to specify valuations for a set of ports P ⊆ P.
Our notion of contract is inspired by Dwyer’s work on specification patterns [18]
which is often found in practice [24]. Thereby, contracts have the form: “if P is true then
Q happens after d time points”.
Definition 6 (Contracts). A contract for an interface (I , O) is a triple (tg, gr , d ), consisting of a (possibly empty) trigger tg ∈ (Γ (I ) × N)∗ , a guarantee gr ∈ Γ (O), and
a duration d ∈ N. For every entry e of a trigger, we denote by state(e) its predicate
and with time(e) its time point. Moreover, we require the following conditions for a
contract:
– The time point of the first trigger is 0: time(tg(0)) = 0 (if #tg > 0).
– Triggers are ordered by their time points: ∀j, j 0 < #tg : j ≤ j 0 =⇒ time(tg(j)) ≤
time(tg(j 0 )).
– The guarantee is after the last trigger: d > time(tg(#tg −1)) (or d > 0 if tg = hi).
Moreover, since they are specified over interfaces, contracts can be specified for components as well as for architectures. They are best expressed graphically using a notation
similar to Message Sequence Charts [15] (see fig. 4 or fig. 5 for an example).
In the following, we define what it means for a behavior of a component (or architecture) to satisfy a corresponding contract. Thereby, we denote with µ |= γ that a valuation
µ ∈ P satisfies a predicate γ ∈ Γ (P ).
4

Definition 7 (Satisfaction). A behavior B for an interface satisfies a contract k =
(tg, gr , d ) for that interface, written B |= k, whenever for all t ∈ B, satisfaction of the
triggers implies satisfaction of the guarantee:



∀n ∈ N : ∀j < #tg : t(n + time(tg(j))) |= state(tg(j)) =⇒ t(n + d ) |= gr
Again, the same definition can be applied for component contracts as well as for architecture contracts.
2.5

Isabelle

Isabelle [33] is a generic proof assistant which allows mathematical formulæ to be
expressed in a formal language and which provides tools for proving those formulas in
a logical calculus. The version of Isabelle used for the work presented in this paper is
Isabelle/HOL, which includes tools to support the specification of datatypes, inductive
definitions, and recursive functions.
locale name =
Specifications in Isabelle are grouped into sofixes parameter 1 :: 0a ⇒ 0a ⇒ bool
called theories, which may import other theories.
and parameter 2 :: 0a ⇒ 0a ⇒ bool
..
To modularize results, Isabelle supports the de.
velopment of abstract specifications by means of
assumes “formula 0 ”
and “formula 1 ”
locales [3]. Figure 1 shows how such a locale usu..
ally looks like: It consists of a name, a list of pa.
rameters, and a list of assumptions about these pa- begin
..
.
rameters. In previous work [29], we show how to
map an architecture specification to a correspond- end
Fig. 1: A typical Isabelle locale.
ing Isabelle locale. Thereby, ports are mapped to
corresponding locale parameters and specifications to locale assumptions.
In Isabelle, proofs can be exproof
pressed in a natural way using
assume label 0 : “formula 0 ”
Isabelle’s structured proof lanfrom label 0 have label 1 : “formula 1 ” by blast
..
guage Isar [43]. A typical Isar
.
proof is depicted in fig. 2: It confrom label 0 , label 1 , . . . show “formula n ” by blast
sists of a sequence of proof steps, qed
which are discharged by some
Fig. 2: A typical Isabelle/Isar proof.
proof methods. For example, Isabelle’s classical reasoner blast can perform long chains of reasoning steps to prove
formulas. Or the simplifier simp can reason with and about equations. Moreover, external,
first-order provers can be invoked through sledgehammer.

3

Running Example: A Reliable Adder

As a running example, let us consider a simple system which calculates the sum of
two numbers in a redundant way. Its architecture is depicted in fig. 3: It consists of
a dispatcher component which receives two numbers as input from its environment
and forwards copies of these numbers to two different adder components. The adder
5

components then calculate the sum of the two numbers and communicate their result to
a merger component. The merger component compares the two results and forwards the
final result to its environment.
i1

i1
o1 i2
o2
o3
o4 i1
i2

Dispatcher

i2

o

Adder1

i1
Merger

i2
Adder2

o

o

Fig. 3: Architecture for a reliable adder.
The behavior of each component is specified in terms of contracts (as introduced
by definition 6) by the sequence diagrams depicted in fig. 4: Figure 4a depicts contract
dispatch for the dispatcher component. It requires a dispatcher to forward incoming
messages received at ports i1 and i2, on its output ports o1 − o4, within one time unit.
The contracts for the two adder components, add1 and add2, are depicted in fig. 4b
and fig. 4c, respectively. They both require an adder to calculate the sum of the numbers
obtained on its input ports i1 and i2 and output it on its output port o. For our example,
we assume that the two components use different algorithms to calculate the sum, which
is why Adder1 requires four time units while Adder2 requires only three time units
to output its result. Figure 4d, fig. 4e, and fig. 4f, depict three different contracts for
the merger component. Contract merge1 requires the merger component to compare
the messages received on its input ports i1 and i2, and for the case they coincide, to
forward the message after two time units on its output port o. Contracts merge2 and
merge3 require the merger component to cope with a potential delay of one time unit
for messages received on its input ports i2 and i1, respectively.
Dispatcher
[n]

i1=x, i2=y

[n + 1]

[n]
o1=x, o2=y
o3=x, o4=y

(a) Contract dispatch.
Merger
[n]

i1=x, i2=x

[n + 2]

Adder1

o=x

(d) Contract merge1.

i1=x, i2=y

[n + 4]

Adder2
[n]

o=x+y

(b) Contract add1.
Merger

i1=x, i2=y

[n + 3]

(c) Contract add2.
Merger

[n] i1=x

[n] i2=x

[n + 1] i2=x

[n + 1] i1=x
o=x

[n + 3]

(e) Contract merge2.

o=x+y

[n + 3]

o=x

(f) Contract merge3.

Fig. 4: Contracts for components of reliable adder.
Among other things, we expect the resulting system to output the sum of two numbers
it receives on its input ports i1 and i2 after seven time units on its output port o . This
6

can be expressed in terms of a contract over its architecture as specified by the sequence
diagram depicted in fig. 5.
Note that our running example is deliberately
Reliable Adder
oversimplified, since its main purpose is to demonstrate our concepts and ideas rather than evaluati1=x, i2=y
ing the approach in a real world scenario. For [n]
details about how the approach works on a real
o=x+y
[n + 7]
example, we refer to the description of the case
Fig. 5: Contract for reliable adder.
study in section 7.

4

Modeling Architecture Proofs

An architecture contract can be verified from a set of contracts for its components through
a sequence of proof steps.
Definition 8 (Proof Step). A proof step for an architecture (F, N ) and corresponding
contracts Kf for its interfaces f ∈ F , is a 4-tuple s = (tp, γ, r , rf ), consisting of
– a time point tp ∈ N denoted time(s),
– an architecture state γ ∈ Γ (out(f )) (for some f ∈ F ) denoted state(s),
– a rationale r = (tg, gr , d ) ∈ Kf (for some f ∈ F ) denoted rat(s),
– a (possibly empty) sequence of references rf ∈ (R)∗ denoted ref (s), such that
#rf = #tg and where R is a non-empty set of elements N ∪ (N × ℘(N )).
Note that an element of R is either a reference to an assumption N of the architecture
contract we want to prove, or a reference to another proof step N and a set of connections
℘(N ). An architecture proof is given by a sequence of corresponding proof steps.
Definition 9 (Architecture Proof). Given an architecture A = (F, N ) and corresponding contracts Kf for its interfaces f ∈ F . An architecture proof for a contract (tg, gr , d )
over the architecture’s interface A ⊗ is a finite, non-empty sequence ps of proof steps,
such that the state of the last entry implies the guarantee of the architecture contract:
state(ps(#ps − 1)) =⇒ gr

(6)

the time of the last entry corresponds to the duration of the architecture contract:
time(ps(#ps − 1)) = d

(7)

and for all entries 0 ≤ i < #ps, such that rat(ps(i)) = (tg 0 , gr 0 , d 0 ):
1. ps(i) refers only to triggers of the architecture contract or previous proof steps:
∀j < #ref (ps(i)) :
∀k ∈ ref (ps(i))(j) : k < #tg



∧ ∀(k, n) ∈ ref (ps(i))(j) : k < i



Note that this implies that ref (ps(0)) contains only references to triggers tg of the
architecture contract.
7

2. The time points of the referenced entries respect the time points of the triggers of the
rationale. Thus, we first introduce a function time (for #ref (ps(i)) > 0) to return
the relative time point of a reference:
(
time(tg(k)) if k ∈ ref (ps(i))(j)
time(ref (ps(i))(j)) =
time(ps(k)) if (k, n) ∈ ref (ps(i))(j)
Now we can use this function to formalize the condition (note that by definition 8,
#ref (ps(i)) = #tg 0 ):
∀j < #ref (ps(i)) : time(ref (ps(i))(j)) = time(ref (ps(i))(0)) + time(tg 0 (j))
Note that this condition implies that for all j < #ref (ps(i)), the referenced time
points of all entries e ∈ ref (ps(i))(j) is the same.
3. The referenced entries imply the corresponding triggers of the rationale:

∀j < #ref (ps(i)) : 


^

state(tg(k)) ∧

k∈ref (ps(i))(j)




^

state(ps(k)) ∧


(k,n)∈ref (ps(i))(j)

^

pi = po  =⇒ state(tg 0 (j))

(pi ,po )∈n

4. The time of the current entry respects the duration of the rationale (note that the time
of ref (ps(i))(0) corresponds to the time point of the first trigger of the rationale):
time(ps(i)) = time(ref (ps(i))(0)) + d 0
5. The guarantee of the rationale implies the current state:
gr 0 =⇒ state(ps(i))
Similar as for contracts, architecture proofs are best expressed graphically using a
notation similar to Message Sequence Charts (see fig. 6 for an example).
4.1

Verifying Reliable Adder

Table 1 shows an architecture proof for the contract of our running example depicted
in fig. 5. It consists of four steps: 0. First, we apply contract dispatch of the dispatcher component to trigger 0 of the architecture contract, to obtain a valuation of the
dispatcher’s output ports at time point 1 with messages x and y, respectively. 1. Then,
we use connections (a1i1 , do1 ) and (a1i2 , do2 ) to pass messages x and y to the corresponding input ports of Adder1 and apply contract add1 to obtain a new state for time
point 5, in which the output port of Adder1 contains the sum of x and y. 2. Similarly,
we can use connections (a2i1 , do3 ) and (a2i2 , do4 ) to apply contract add2 to the
architecture state given by step 0, to obtain a new state for time point 4, in which the
8

Table 1: Architecture proof for reliable adder.
0
1
2
3

tp

γ

r

rf

1
5
4
7

do1 = x ∧ do2 = y
a1o = x + y
a2o = x + y
mo = x + y

dispatch
add1
add2
merge3

{0}
{(0, {(a1i1 , do1 ), (a1i2 , do2 )})}
{(0, {(a2i1 , do3 ), (a2i2 , do4 )})}
{(1, {(mi1 , a1o)}), (2, {(mi2 , a2o)})}

output port of Adder2 contains the sum of x and y. 3. Finally, we can use connections
(mi1 , a1o) and (mi2 , a2o) to pass the calculated sums to the input of the merger component and apply contract merge3 to forward it on its output port. Note that the proof
is only valid, since we chose contract merge3 for the merger component. If we had
chosen merge1 or merge2, the proof would have violated condition 2 of definition 9.
As mentioned above, architecture proofs can also be expressed graphically using a
notation similar to Message Sequence Charts. For example, the proof from table 1, could
also be expressed graphically as depicted in fig. 6.
Dispatcher
[n]

Adder1

Merger

Adder2

i1=x, i2=y
[n + 1]

dispatch

o1=x, o2=y
i1=x, i2=y

i1=x, i2=y

add2

add1
[n + 4]
[n + 5]

o=x+y

o=x+y

merge3

i2=x+y
i1=x+y
[n + 7]

o=x+y

Fig. 6: Architecture proof by means of Message Sequence Chart.
4.2

Soundness and Completeness

In the following, we provide two theoretical results for APML. The first one ensures
that if we can prove an architecture contract from the contracts of its components using
APML, then, an architecture in which the components satisfy the corresponding contracts
is indeed guaranteed to satisfy the architecture contract.
Theorem 1 (Soundness). Given an architecture A = (F, N ) and corresponding contracts Kf for each interface f ∈ F , such that ∀f ∈ F : Bf |= Kf . If there exists an
architecture proof ps for an architecture contract k = (tg, gr , d ), we have A ⊗B |= k.
Proof (The full proof is provided in appendix A). According to definition 7 we have
to show that for all t ∈ A ⊗B and all n ∈ N, ∀j < #tg : t(n + time(tg(j))) |=
state(tg(j)) =⇒ t(n+d ) |= gr . Thus, we assume ∀j < #tg : t(n+time(tg(j))) |=
state(tg(j)) and we show by complete induction over the length of the proof sequence
that ∀i < #ps : t(n+time(ps(i))) |= state(ps(i)). Thus, t(n+time(ps(#ps − 1))) |=
state(ps(#ps − 1)) and, by eq. (6) and eq. (7), we can conclude t(n + d ) |= gr .
t
u
9

The second result guarantees that, whenever the satisfaction of contracts for components of an architecture leads to the satisfaction of a corresponding contract for the
architecture, then it is possible to find a corresponding APML proof.
Theorem 2 (Completeness). Given an architecture A = (F, N ) and corresponding
contracts Kf for each interface f ∈ F . For each architecture contract k, such that for
all possible behaviors B:

∀f ∈ F : Bf |= Kf =⇒ A ⊗B |= k
(8)
there exists an architecture proof ps for k = (tg, gr , d ).
Proof (The full proof is provided in appendix B). For the proof we construct a “maximal”
architecture proof ps, according to definition 9, by repeatedly applying all feasible
contracts. If we eventually reach an entry such that state(ps(#ps − 1)) =⇒ gr
and time(ps(#ps − 1)) = d then we are done. If not, then we build an architecture
trace t ∈ (port(F ))∞ , such that ∀j < #tg : t(time(tg(j))) |= state(tg(j)) and ∀i <
#ps : t(time(ps(i))) |= state(ps(i)) and t(d ) 6|= gr and for all other n, we choose
t(n), such that the projection to every interface f ∈ F does not satisfy the assumptions
of any contract Kf . Now, we can show that ∀f ∈ F : Bf |= Kf and thus, by eq. (8) we
can conclude A ⊗B |= k. Thus, since ∀j < #tg : t(time(tg(j))) |= state(tg(j)), we
can conclude t(d ) |= gr which is a contradiction to t(d ) 6|= gr .
t
u
Algorithm 1 Mapping an APML proof to a corresponding proof in Isabelle/ISAR
Input: a proof ps according to definition 9 and a function toIsabelle to convert port predicates
Output: a proof in Isabelle/Isar [42]
1: i = 0
2: while i < #ps do
3:
(tp, γ, r , rf ) := ps(i); (tg, gr , d ) := r ;
4:
if rf = hi then print “have s” + i + “: ” + toIsabelle(γ, tp) + “ by simp” else
5:
i0 = 0
6:
while i0 < #rf do
7:
if i0 > 0 then print “moreover ” end if
8:
print “from ”
9:
for all i00 ∈ rf (i0 ) do print “a” + i00 + “ ” end for
10:
for all (i00 , n0 ) ∈ rf (i0 ) do print “s” + i00 + “ ” end for
11:
print “have ” + toIsabelle(state(tg(i0 )), time(tg(i0 ))) + “ ”
12:
if rf (i0 ) \ N 6= ∅ then print “using ” end if
13:
for all (i00 , n0 ) ∈ rf (i0 ) and (pi , po ) ∈ n0 do print “pi _po ” end for
14:
print “ by simp”
15:
i0 + +
16:
end while
17:
if i0 = 1 then print “hence ” else
18:
if i0 > 1 then print “ultimately have ” end if
19:
print “s” + i + “: ” + toIsabelle(γ, tp) + “ using ” + r + “ by blast” end if
20:
i++
21: end while
22: print “thus ?thesis by auto”

10

5

From APML to Isabelle

To verify soundness of an APML proof, algorithm 1 shows how an APML proof can be
mapped to a corresponding Isar proof for the interactive theorem prover Isabelle.
Let us see how the algorithm can be applied to generate an Isar proof for the APML
proof of our running example, described in section 4.1. First, we create an Isabelle locale
for the architecture as described in fig. 3:
locale rsum =
fixes
— Dispatcher: di1::nat⇒nat and di2::nat⇒nat
and do1::nat⇒nat and do2::nat⇒nat and do3::nat⇒nat and do4::nat⇒nat
— Adder1: and a1i1::nat⇒nat and a1i2::nat⇒nat and a1o::nat⇒nat
— Adder2: and a2i1::nat⇒nat and a2i2::nat⇒nat and a2o::nat⇒nat
— Merger: and mi1::nat⇒nat and mi2::nat⇒nat and mo::nat⇒nat
— Contracts:
V
assumes dispatch: n x y. [[di1 n = x; di2 n = y]] =⇒
do1 (n+1)
V = x ∧ do2 (n+1) = y ∧ do3 (n+1) = x ∧ do4 (n+1) = y
and add1: Vn x y. [[a1i1 n = x; a1i2 n = y]] =⇒ a1o (n+4) = x + y
and add2: nVx y. [[a2i1 n = x; a2i2 n = y]] =⇒ a2o (n+3) = x + y
and merge1: Vn x. [[mi1 n = x; mi2 n = x]] =⇒ mo (n+2) = x
and merge2: Vn x. [[mi1 n = x; mi2 (n+1) = x]] =⇒ mo (n+3) = x
and merge3: n x. [[mi2 n = x; mi1 (n+1) = x]] =⇒ mo (n+3) = x
— Connections V
V
and do1-a1i1: Vn. a1i1 n = do1 n and a1i2-do2: Vn. a1i2 n = do2 n
and do3-a2i1:V n. a2i1 n = do3 n and a2i2-do4:
V n. a2i2 n = do4 n
and a1o-mi1: n. mi1 n = a1o n and mi2-a2o: n. mi2 n = a2o n

Note that each contract, as presented in fig. 4, results in a corresponding locale assumption. Now, we can create a theorem for the architecture contract described by fig. 5:
theorem sum:
fixes n x y assumes a0: di1 n = x ∧ di2 n = y
shows mo (n+7) = x + y

Finally, we can apply algorithm 1 to create an Isar proof for the theorem from the APML
proof described in table 1:
proof −
from a0 have di1 n = x ∧ di2 n = y by auto
hence s1: do1 (n+1) = x ∧ do2 (n+1) = y ∧ do3 (n+1) = x ∧ do4 (n+1) = y
using dispatch by blast
from s1 have a1i1 (n+1) = x ∧ a1i2 (n+1) = y using do1-a1i1 a1i2-do2 by auto
hence s2: a1o (n+5) = x + y using add1 by blast
from s1 have a2i1 (n+1) = x ∧ a2i2 (n+1) = y using do3-a2i1 a2i2-do4 by auto
hence s3: a2o (n+4) = x + y using add2 by blast
from s2 have mi1 (n+5) = x + y using a1o-mi1 by auto
moreover from s3 have mi2 (n+4) = x + y using mi2-a2o by auto
ultimately have mo (n+7) = x+y using merge3 by blast
thus ?thesis by auto
qed

11

6

Modeling Architecture Proofs in FACT UM Studio

To support the development of APML proofs in practice, we implemented the language in
FACT UM Studio [31]: an architecture modeling application based on Eclipse/EMF [40].
FACT UM Studio now supports the user in the development of “correct” APML proofs
by means of three key features: (i) It analyses the structure of a given APML proof and
checks it for syntactical errors. (ii) It uses so-called validators to check for violations of
the conditions described in definition 8 and, to a limited extent, also the ones described in
definition 9. (iii) The textual development of APML proofs in Xtext [5] is complemented
by corresponding graphical notations using Sirius [34]. To support the verification of single proof steps, we implemented algorithm 1 in FACT UM Studio. Thus, after specifying
an APML proof, a user can automatically generate a corresponding Isar proof for Isabelle.
Figure 7 depicts the specification of our running example in FACT UM Studio:
First, the architecture is specified graphically in terms of interfaces (represented as gray
rectangles) and connections between their input (empty circles) and output (filled circles)
ports. Then, contracts can be added for each component using a textual notation.

Fig. 7: Specification of reliable adder in FACT UM Studio.
Figure 8 shows how we can verify the
adder system using FACT UM Studio’s
APML implementation: After specifying
the contract, we can provide a corresponding proof in terms of a sequence of proof
steps as described in definition 8.
As mentioned above, FACT UM Studio performs several checks to ensure consistency of proofs: (i) For each step it
checks whether enough rationales are provided (last condition of definition 8). (ii) It
verifies that only existing connections are
used in the “with” clause (last condition
of definition 8). (iii) It ensures that each
step only refers to triggers of the contract
or previous proof steps (condition 1 of
definition 9) (iv) It ensures consistency of Fig. 8: APML proof in FACT UM Studio.
the time points of contracts with those of rationales (conditions 2 and 4 of definition 9).
12

Fig. 9: Automatic Train Control System

7

Case Study: Trainguard MT Control System

We evaluated our approach by applying it for the verification of a railway-control system.
To investigate whether the approach can indeed be used to apply interactive theorem
proving by users not trained in using this technology, verification was performed by a
subject with no prior experience with formal methods in general and specifically with
the use of interactive theorem provers. The subject holds a Bachelor of Science degree
in computer science and has four years of industrial experience as software developer in
the domain of business information systems.
Study Context. Trainguard MT (TGMT) is an automatic train control system for
metros, rapid transit, commuter, and light rail systems currently in development by one of
our industrial partners. For the purpose of this case study, we focused on the verification
of one key feature of TGMT: controlling of the platform screen doors (PSDs). The
situation is depicted by fig. 9: In an effort to make train stations safer for the passengers,
modern stations protect their rail zone with a wall (represented by a black line) with
several doors (represented by gray lines), the so-called PSDs. When a train arrives at the
station, its onboard control unit communicates with the Wayside control unit to control
opening/closing of the PSDs.
Study Setup. To model the PSD functionality, the company provided four documents
as input, which were taken directly from the PSD development: a high-level system
requirements specification (59 pages), a more detailed system architecture specification
(299 pages), a performance specification (57 pages), and a glossary (42 pages). Based
on the documents, we specified a corresponding architecture for the PSD functionality,
consisting of 33 components with 36 contracts in total.
Study Execution. The subject then verified five architecture contracts: (P1) If the
train is moving, the PSDs are closed. (P2) If the train is at standstill and the position of
the train doors match the position of the PSDs, the PSDs are opened. (P3) If the train
doors open on the right hand side, the platform must be on the right hand side. (P4) If
door release is permissive and the train is at standstill, its doors are open. (P5) When
the train indicates that the doors are closed, the PSDs are closed.
Results. After a study of the architecture and a brief introduction into APML, the
subject was able to verify versions of all the properties with no further guidance.
Figure 10 depicts the verification effort in terms
15
P5
of APML proof steps required for each property.
1
P4
In total, the subject required roughly 25 working
1
P3
hours to develop the proofs. Sometimes, however,
14
P2
the original contracts needed to be adapted to
14
P1
fit the structure of a contract as defined by definition 6. This was mainly due to two reasons: Fig. 10: Number of proof steps for
(i) Some of the contracts required to express state- each property.
13

ments of the form “whenever x happens, after n time points y happens and in between
z holds”. (ii) In addition, some components required contracts combined by disjunction
rather than conjunction. Moreover, the proofs for properties P1 and P5 share a common
proof sequence of 8 proof steps, which is more than 50% of the steps required to proof
the properties. Finally, some of the proof steps could only be discharged by adapting
the generated Isabelle script to tune the simplifier and the logical reasoner, respectively.
Conclusions. From our results, we derive the following conclusions:
C1 The approach can be used to support users with no prior experience with formal
methods in the development of proofs for interactive theorem provers.
C2 Some of the properties sometimes required in a practical setting cannot yet be
expressed by the notion of contract used in this paper.
C3 The verification of properties can involve considerable, redundant proof sequences.
C4 Some initial setup may be required to automatically discharge generated proof steps.

8

Related Work

Related work can be found in two different areas: verification of contract-based specifications and interactive verification of component-based systems.
Verification of contract-based specifications. Verification of contract-based specifications is not a new topic, at all. First works in this area go back to Pnueli’s work
about modular model checking [36] and Clarke’s work on compositional model checking [14], in which they investigated possibilities to leverage assumptions about a component’s environment for the verification of its implementation. Later on, attempts
were made to automatically synthesize minimal assumptions from a component’s implementation [7,19,20,35]. In all these studies, the focus is mainly on the verification
of component implementations under the presence of assumptions about its environment. In contrary, the focus of the work presented in this paper, is on the verification of
contract-composition, without even considering component implementations.
Another line of research in this area is work which focuses on the analysis of contract
compatibility. In parametric AG reasoning [38], there may even be many assumptions
and guarantees for each component. An example of work in this area is Damm et al. [16],
in which the authors describe an approach for virtual integration testing based on rich
components. Another example is the work of Chilton et al. [11], which provides an
approach to AG reasoning for safety properties. Later on, Kugele and Marmsoler [25]
provide an approach to check compatibility of AG contracts using SMT solvers [17].
Finally, Broy [8] provides a detailed characterization about compatible assumptions and
guarantees for F OCUS [9]. While the work in this line of research also focuses on the
verification at the level of contracts, the focus is mainly on the verification of contract
compatibility. With our work, however, we focus on a related, though different problem:
verification of refinement of contracts.
Work in this area of research which is most closely related to our work is Cimatti’s
work on OCRA [12,13]. Here, the author proposes an approach based on bounded model
checking [6] to verify refinement of LTL-based contracts. With our work, we follow a
similar goal by applying an alternative approach based on interactive theorem proving,
which is why we actually complement Cimatti’s work.
14

Interactive Verification Component based Systems. There exists some work which
investigates the application of interactive theorem proving (ITP) for the verification
of component-based systems. Fensel and Schnogge [21], for example, apply the KIV
interactive theorem prover [37] to verify architectures in the area of knowledge-based
systems. More recently, some attempts were made to apply ITP for the verification of
architectural connectors: Li and Sun [26], for example, apply the Coq proof assistant [4]
to verify connectors specified in Reo [1]. Moreover, there exists work on the formalization
of OCL [41] in Isabelle [10]. In addition, Spichkova [39] provides a framework for the
verification of component-based systems in Isabelle and Marmsoler [28] extends the work
to deal with dynamic reconfiguration. Also the mechanization of UTP [23] in Isabelle,
due by Foster et al. [22], belongs to this line of research. However, while most of these
works focus on the interactive verification of component based systems, verification
is usually done at the level of the prover. With the work presented in this paper, we
aim to contribute to this line of research by exploring possibilities and limitations of
synthesizing proofs for the provers from architectural descriptions.
Summary. Concluding, to the best of our knowledge, this is the first attempt to synthesize proof for an interactive theorem prover for the verification of contract composition
from architectural descriptions.

9

Conclusion

With this paper, we introduced APML: an architecture proof modeling language. To this
end, we first introduced a formal semantics for component contracts as well as architecture contracts. Then, we described APML and showed soundness and completeness
of it for the verification of architecture contracts. Moreover, we presented an algorithm
to map an APML proof to a corresponding proof in Isabelle/Isar and discussed its implementation in Eclipse/EMF. Finally, we demonstrated the approach by means of a running
example and evaluated it by means of a larger case study from the railway domain.
Our theoretical results (Section 4.2) show that APML can indeed be used to specify
abstract proofs for the composition of contracts using a notation similar to Message
Sequence Charts. Moreover, as indicated by C1 of our case study, it supports users with
no prior experience in interactive theorem proving in the development of proofs. Thus,
APML indeed contributes to the overall goal of bridging the gap between software architecture and interactive theorem proving. Nevertheless, the case study also revealed some
limitations of the approach, which should be addressed by future work: As indicated
by C2, future work should investigate possibilities to enhance expressiveness of the
contracts. Specifically, the support for until-like contracts and disjunction of contracts
should be investigated. Moreover, as indicated by C3, future work should investigate possibilities to support reuse of proof sequences. To this end, a proof step should be allowed
to reference to already verified contracts. Finally, as indicated by C4, future work should
investigate possibilities to increase automation at the level of interactive theorem proving.
Acknowledgments. We would like to thank Simon Foster and Mario Gleirscher for
inspiring discussions about APML. Parts of the work on which we report in this paper
was funded by the German Federal Ministry of Education and Research (BMBF) under
grant no. 01Is16043A.
15

References
1. Arbab, F.: Reo: a channel-based coordination model for component composition. Mathematical structures in computer science 14(03), 329–366 (2004)
2. Baier, C., Katoen, J., Larsen, K.: Principles of Model Checking. Mit Press, MIT Press (2008),
https://books.google.de/books?id=nDQiAQAAIAAJ
3. Ballarin, C.: Locales and locale expressions in Isabelle/Isar. Lecture notes in computer science
3085, 34–50 (2004)
4. Barras, B., Boutin, S., Cornes, C., Courant, J., Filliatre, J.C., Gimenez, E., Herbelin, H., Huet,
G., Munoz, C., Murthy, C., et al.: The Coq proof assistant reference manual: Version 6.1.
Ph.D. thesis, Inria (1997)
5. Bettini, L.: Implementing domain-specific languages with Xtext and Xtend. Packt Publishing
Ltd (2016)
6. Biere, A., Cimatti, A., Clarke, E., Zhu, Y.: Symbolic model checking without BDDs. In:
International conference on tools and algorithms for the construction and analysis of systems.
pp. 193–207. Springer (1999)
7. Bobaru, M.G., Păsăreanu, C.S., Giannakopoulou, D.: Automated assume-guarantee reasoning
by abstraction refinement. In: International Conference on Computer Aided Verification. pp.
135–148. Springer (2008)
8. Broy, M.: Theory and methodology of assumption/commitment based system interface specification and architectural contracts. Formal Methods in System Design 52(1), 33–87 (2018),
https://doi.org/10.1007/s10703-017-0304-9
9. Broy, M., Stølen, K.: Specification and development of interactive systems: F OCUS on streams,
interfaces, and refinement. Springer Science & Business Media (2012)
10. Brucker, A.D., Wolff, B.: A proposal for a formal OCL semantics in Isabelle/HOL. In: Carreño,
V.A., Muñoz, C.A., Tahar, S. (eds.) Theorem Proving in Higher Order Logics. pp. 99–114.
Springer Berlin Heidelberg, Berlin, Heidelberg (2002)
11. Chilton, C., Jonsson, B., Kwiatkowska, M.: Assume-guarantee reasoning for safe component
behaviours. In: International Workshop on Formal Aspects of Component Software. pp.
92–109. Springer (2012)
12. Cimatti, A., Dorigatti, M., Tonetta, S.: OCRA: A tool for checking the refinement of temporal contracts. In: 2013 28th IEEE/ACM International Conference on Automated Software
Engineering (ASE). pp. 702–705 (Nov 2013)
13. Cimatti, A., Tonetta, S.: Contracts-refinement proof system for component-based embedded
systems. Sci. Comput. Program. 97(P3), 333–348 (Jan 2015), http://dx.doi.org/10.
1016/j.scico.2014.06.011
14. Clarke, E.M., Long, D.E., McMillan, K.L.: Compositional model checking. In: [1989] Proceedings. Fourth Annual Symposium on Logic in Computer Science. pp. 353–362. IEEE
(1989)
15. Damm, W., Harel, D.: LSCs: Breathing life into message sequence charts. Formal methods in
system design 19(1), 45–80 (2001)
16. Damm, W., Hungar, H., Josko, B., Peikenkamp, T., Stierand, I.: Using contract-based component specifications for virtual integration testing and architecture design. In: 2011 Design,
Automation & Test in Europe. pp. 1–6. IEEE (2011)
17. De Moura, L., Bjørner, N.: Satisfiability modulo theories: Introduction and applications. Commun. ACM 54(9), 69–77 (Sep 2011), http://doi.acm.org/10.1145/1995376.
1995394
18. Dwyer, M.B., Avrunin, G.S., Corbett, J.C.: Patterns in property specifications for finite-state
verification. In: Proceedings of the 1999 International Conference on Software Engineering
(IEEE Cat. No. 99CB37002). pp. 411–420. IEEE (1999)

16

19. Elkader, K.A., Grumberg, O., Pasareanu, C.S., Shoham, S.: Automated circular assumeguarantee reasoning. In: Bjørner, N., de Boer, F.S. (eds.) FM 2015: Formal Methods - 20th
International Symposium, Oslo, Norway, June 24-26, 2015, Proceedings. Lecture Notes
in Computer Science, vol. 9109, pp. 23–39. Springer (2015), https://doi.org/10.
1007/978-3-319-19249-9_3
20. Emmi, M., Giannakopoulou, D., Pasareanu, C.S.: Assume-guarantee verification for interface
automata. In: Cuéllar, J., Maibaum, T.S.E., Sere, K. (eds.) FM 2008: Formal Methods, 15th
International Symposium on Formal Methods, Turku, Finland, May 26-30, 2008, Proceedings.
Lecture Notes in Computer Science, vol. 5014, pp. 116–131. Springer (2008), https:
//doi.org/10.1007/978-3-540-68237-0_10
21. Fensel, D., Schnogge, A.: Using KIV to specify and verify architectures of knowledge-based
systems. In: Automated Software Engineering. pp. 71–80 (Nov 1997)
22. Foster, S., Zeyda, F., Woodcock, J.: Isabelle/UTP: A mechanised theory engineering framework. In: Naumann, D. (ed.) Unifying Theories of Programming. pp. 21–41. Springer International Publishing, Cham (2015)
23. Hoare, C.A.R., Jifeng, H.: Unifying theories of programming, vol. 14. Prentice Hall Englewood Cliffs (1998)
24. Huber, F., Schätz, B., Schmidt, A., Spies, K.: Autofocus—a tool for distributed systems
specification. In: International Symposium on Formal Techniques in Real-Time and FaultTolerant Systems. pp. 467–470. Springer (1996)
25. Kugele, S., Marmsoler, D., Mata, N., Werther, K.: Verification of component architectures using mode-based contracts. In: 2016 ACM/IEEE International Conference on Formal Methods
and Models for System Design, MEMOCODE 2016, Kanpur, India, November 18-20, 2016.
pp. 133–142. IEEE (2016), https://doi.org/10.1109/MEMCOD.2016.7797758
26. Li, Y., Sun, M.: Modeling and analysis of component connectors in Coq. In: Fiadeiro, J.L., Liu,
Z., Xue, J. (eds.) Formal Aspects of Component Software - 10th International Symposium,
FACS 2013, Nanchang, China, October 27-29, 2013, Revised Selected Papers. Lecture Notes
in Computer Science, vol. 8348, pp. 273–290. Springer (2013), https://doi.org/10.
1007/978-3-319-07602-7_17
27. Marmsoler, D., Gleirscher, M.: On activation, connection, and behavior in dynamic architectures. Scientific Annals of Computer Science 26(2), 187–248 (2016)
28. Marmsoler, D.: A framework for interactive verification of architectural design patterns in
Isabelle/HOL. In: The 20th International Conference on Formal Engineering Methods, ICFEM
2018, Proceedings (2018)
29. Marmsoler, D.: Hierarchical specication and verication of architecture design patterns. In:
Fundamental Approaches to Software Engineering - 21th International Conference, FASE
2018, Held as Part of the European Joint Conferences on Theory and Practice of Software,
ETAPS 2018, Thessaloniki, Greece, April 14-20, 2018, Proceedings (2018)
30. Marmsoler, D.: Verifying dynamic architectures using model checking and interactive theorem
proving. Software Engineering und Software Management 2019 (2019)
31. Marmsoler, D., Gidey, H.K.: FACT UM Studio: A tool for the axiomatic specification and
verification of architectural design patterns. In: International Conference on Formal Aspects
of Component Software. pp. 279–287. Springer (2018)
32. Marmsoler, D., Gleirscher, M.: Specifying properties of dynamic architectures using configuration traces. In: International Colloquium on Theoretical Aspects of Computing, pp. 235–254.
Springer (2016)
33. Nipkow, T., Paulson, L.C., Wenzel, M.: Isabelle/HOL: a proof assistant for higher-order logic,
vol. 2283. Springer Science & Business Media (2002)
34. Obeo: Sirius. https://www.eclipse.org/sirius/

17

35. Pasareanu, C.S., Dwyer, M.B., Huth, M.: Assume-guarantee model checking of software: A comparative case study. In: Proceedings of the 5th and 6th International SPIN
Workshops on Theoretical and Practical Aspects of SPIN Model Checking. pp. 168–183.
Springer-Verlag, Berlin, Heidelberg (1999), http://dl.acm.org/citation.cfm?
id=645879.672067
36. Pnueli, A.: In transition from global to modular temporal reasoning about programs. In: Logics
and models of concurrent systems, pp. 123–144. Springer (1985)
37. Reif, W.: The KIV-approach to software verification. KORSO: Methods, Languages, and
Tools for the Construction of Correct Software pp. 339–368 (1995)
38. Reussner, R.H., Becker, S., Firus, V.: Component composition with parametric contracts.
Tagungsband der Net. ObjectDays 2004, 155–169 (2004)
39. Spichkova, M.: F OCUS on Isabelle: From specification to verification. In: 21 st International
Conference on Theorem Proving in Higher Order Logics. p. 104. Citeseer (2008)
40. Steinberg, D., Budinsky, F., Merks, E., Paternostro, M.: EMF: Eclipse Modeling Framework.
Pearson Education (2008)
41. Warmer, J.B., Kleppe, A.G.: The Object Constraint Language: Precise modeling with UML.
Addison-Wesley object technology series (1998)
42. Wenzel, M.: The Isabelle/Isar reference manual (2004)
43. Wenzel, M.: Isabelle/Isar – a generic framework for human-readable proof documents. From
Insight to Proof – Festschrift in Honour of Andrzej Trybulec 10(23), 277–298 (2007)

18

A

Proof for Thm. 1

The following diagram depicts an overview of the main concepts and its relationships
and marks the proof obligation with a question mark:
ps
k
|=

|=

Kf

A

Bf

?

A ⊗B

Def. 5

According to Def. 7 we have to show that for all t ∈ A ⊗B and all n ∈ N, ∀i <
#tg : t(n + time(tg(i))) |= state(tg(i)) =⇒ t(n + d ) |= gr .
– Thus, we assume
∀i < #tg : t(n + time(tg(i))) |= state(tg(i))

(9)

and we show by induction that ∀i < #ps : t(n + time(ps(i))) |= state(ps(i)).
• Thus, fix i < #ps and assume ∀i0 < i : t(n + time(ps(i0 ))) |= state(ps(i0 )).
• Let (tp, γ, r , rf ) = ps(i).
• Since, by assumption, we have ∀f ∈ F : Bf |= Kf , conclude Bf |= r for some
f ∈ F.
0
0
00
• Thus, let r = (tg 0 , gr 0 , d 0 ) and by Def. 7 have
<
 ∀t ∈ 0Bf ,0 n ∈0 N : ∀i
0
0 00
0 00
0 0
0
#tg : t (n + time(tg (i ))) |= state(tg (i )) =⇒ t (n + d ) |= gr .
• Thus, by Eq. (4) of Def. 5 have ∀n0 ∈ N : ∀i00 < #tg 0 : t(n0 +
time(tg 0 (i00 ))) |= state(tg 0 (i00 )) =⇒ t(n0 + d 0 ) |= gr 0 .
• Thus, we show ∀i00 < #tg 0 : t(n + time(rf (0)) + time(tg 0 (i00 ))) |=
state(tg 0 (i00 )) to conclude t(n + time(rf (0)) + d 0 ) |= gr 0 .
∗ Thus, let i00 < #tg 0 and since by Def. 8 #rf = #tg 0 , conclude i00 < #rf .
∗ Thus, by condition 3 of Def. 9 have


^

state(tg(i000 )) ∧
i000 ∈rf (i00 )




^



state(ps(i000 ))∧

(i000 ,n00 )∈rf (i00 )

^

pi =po  =⇒ state(tg 0 (i00 ))

(pi ,po )∈n00

∗ Thus, we show
∀i000 ∈ rf (i00 ) : t(n + time(rf (0)) + time(tg 0 (i00 ))) |= state(tg(i000 ))
(10)
and
∀(i000 ,n00 )∈rf (i00 ) : t(n+time(rf (0))+time(tg 0 (i00 )))|=state(ps(i000 ))
∧ ∀(pi , po ) ∈ n00 : t(n + time(rf (0)) + time(tg 0 (i00 ))) |= pi = po
(11)
i

to conclude t(n + time(rf (0)) + time(tg 0 (i00 ))) |= state(tg 0 (i00 )):
· Eq. (10): Let i000 ∈ rf (i00 ) and have i000 < #tg by condition 1 of Def. 9.
Thus, have t(n + time(tg(i000 ))) |= state(tg(i000 )) by Eq. (9). Moreover, since i000 ∈ rf (i00 ) have time(rf (i00 )) = time(tg(i000 )) from the
definition of time in condition 2 of Def. 9. Thus, since rf = ref (ps(i))
and i00 < #ref (ps(i)) (since i00 < #tg 0 and by Def. 8 #tg 0 =
#ref (ps(i))) have time(tg(i000 )) = time(rf (0)) + time(tg 0 (i00 ))
by condition 2 of Def. 9. Thus, since t(n + time(tg(i000 ))) |=
state(tg(i000 )) conclude t(n + time(rf (0)) + time(tg 0 (i00 ))) |=
state(tg(i000 )).
· Eq. (11): We show that for all (i000 , n00 ) ∈ rf (i00 ),
t(n + time(rf (0)) + time(tg 0 (i00 ))) |= state(ps(i000 ))

(12)

and
∀(pi , po ) ∈ n00 : t(n+time(rf (0))+time(tg 0 (i00 ))) |= pi = po (13)
Thus, let (i000 , n00 ) ∈ rf (i00 ).
· Eq. (12): By condition 1 of Def. 9, i000 < i and thus we can apply the
induction hypothesis to have t(n+time(ps(i000 ))) |= state(ps(i000 )).
Moreover, since (i000 , n00 ) ∈ rf (i00 ) have time(ps(i000 )) =
time(rf (i00 )) from the definition of time in condition 2 of Def. 9.
Thus, since rf = ref (ps(i)) and i00 < #ref (ps(i)) (since i00 <
#tg 0 and by Def. 8 #tg 0 = #ref (ps(i))) have time(ps(i000 )) =
time(rf (0)) + time(tg 0 (i00 )) by condition 2 of Def. 9. Thus,
since t(n + time(ps(i000 ))) |= state(ps(i000 )) conclude t(n +
time(rf (0)) + time(tg 0 (i00 ))) |= state(ps(i000 )).
· Eq. (13): Let (pi , po ) ∈ n00 and conclude (pi , po ) ∈ N from
Def. 8. Thus, by Eq. (5) of Def. 5 have t(n + time(rf (0)) +
time(tg 0 (i00 )))(i) = t(n+time(rf (0))+time(tg 0 (i00 )))(o). Finally
conclude t(n + time(rf (0)) + time(tg 0 (i00 ))) |= pi = po .
• From t(n+time(rf (0))+d 0 ) |= gr 0 we can conclude t(n+time(ps(i))) |= gr 0
by condition 4 of Def. 9 (since rf = ref (ps(i))).
• Thus, we conclude t(n + time(ps(i))) |= state(ps(i)) by condition 5 of Def. 9.
– From ∀i < #ps : t(n + time(ps(i))) |= state(ps(i)) have t(n + time(ps(#ps −
1))) |= state(ps(#ps − 1)) (since by Def. 9 #ps ≥ 1).
– Thus, from Eq. (6) of Def. 9 have t(n + time(ps(#ps − 1))) |= gr .
– Thus, from Eq. (7) of Def. 9 have t(n + d) |= gr .
t
u

ii

B

Proof for Thm. 2

The proof proceeds in four steps: First, we construct a “maximal” architecture proof.
If it is a valid proof for the architecture contract, we are done, otherwise, we derive a
contradiction: To this end, we construct an architecture trace which satisfies all contracts
but violates the guarantee of the architecture contract.
The following figure depicts the relationship of an architecture proof (consisting
of a sequence of proof steps) and an architecture trace (consisting of a sequence of
architecture states).

...

Constructing the Architecture Proof
For the proof we construct a “maximal” architecture proof ps, according to Def. 9, by
repeatedly applying all feasible contracts:
– closure: for all contracts (tg 0 , gr 0 , d 0 ) we have:
∀i < #tg 0 ∃n :
^

^

state(x ) ∧

{x ∈tg : time(x )=n+time(tg 0 (i))}

state(s)

{s∈ps : time(s)=n+time(tg 0 (i))}

=⇒ state(tg 0 (i))

(14)

implies
∃i0 < #ps : rat(ps(i0 )) = c ∧ time(ps(i0 )) = n + d 0

(15)

– strongest: for all i < #ps, such that rat(ps(i)) = (tg 0 , gr 0 , d 0 ), we have
state(ps(i)) =⇒ gr 0
If we eventually reach an entry such that state(ps(#ps − 1))
time(ps(#ps − 1)) = d then we are done.

(16)
=⇒

gr and

Constructing the Architecture Trace
If not, then we build an architecture trace t ∈ (port(F ))∞ , such that
– t is the weakest architecture satisfying the architectural assumptions, i.e., for all
n ∈ N, such that ∃i < #tg : time(tg(i)) = n or ∃i < #ps : time(ps(i)) = n, we
have
^
^
t(n) |=
state(x ) ∧
state(s)
(17)
{x ∈tg : time(x )=n}

{s∈ps : time(s)=n}

iii

and
∀P ∈ Γ (out(F )) : (t(n) |= P ) =⇒

^

state(x ) ∧
{x ∈tg : time(x )=n}


^



state(s) =⇒ P 

(18)

{s∈ps : time(s)=n}

– for all other n ∈ N (where ¬∃i < #tg : time(tg(i)) = n and ¬∃i <
#ps : time(ps(i)) = n) it does not satisfy any assumption:

∀n0 ∈ N, (tg 0 , gr 0 , d 0 ) ∈ Kf , i < #tg 0 : n0 + time(tg 0 (i)) = n ∧

∀i0 < #tg 0 : n0 +time(tg 0 (i0 )) 6= n =⇒ t(n0 +time(tg 0 (i0 ))) |= state(tg 0 (i0 ))
=⇒ t(n0 + time(tg 0 (i))) 6|= state(tg 0 (i))
(19)
– t does not satisfy the guarantee at the time point given by the duration:
t(d ) 6|= gr

(20)

Lemma: Application of Contracts in Proofs
If a contract can be applied to t, then it is applied in the proof:
∀n ∈ N, c = (tg 0 , gr 0 , d 0 ) ∈ Kf :

(∀i < #tg 0 : (t(n + time(tg 0 (i))) |= state(tg 0 (i))))
=⇒ (∃i0 < #ps : rat(ps(i0 )) = c ∧ time(ps(i0 )) = n + d 0 )



(21)

– Assume there exists an n and c = (tg 0 , gr 0 , d 0 ) ∈ Kf , such that
∀i < #tg 0 : (t(n + time(tg 0 (i))) |= state(tg 0 (i)))

(22)

– According to Eq. (19), (17), (18), for all i < #tg 0
t(n + time(tg 0 (i))) |=
^

state(x ) ∧

{x ∈tg : time(x )=n+time(tg 0 (i))}

^

state(s)

{s∈ps : time(s)=n+time(tg 0 (i))}

(23)
and
∀P ∈ Γ (out(F )) : (t(n + time(tg 0 (i))) |= P ) =⇒
^
^
state(x ) ∧
{x ∈tg : time(x )=n+time(tg 0 (i))}

state(s)

{s∈ps : time(s)=n+time(tg 0 (i))}

=⇒ P
iv

(24)

– Thus, since ∀i < #tg 0 : t(n + time(tg 0 (i))) |= state(tg 0 (i)) we have for all
i < #tg 0 :
^

state(x ) ∧

{x ∈tg : time(x )=n+time(tg 0 (i))}

^

state(s)

{s∈ps : time(s)=n+time(tg 0 (i))}

=⇒ state(tg 0 (i))

(25)

– Thus, since ps is maximal (Eq. (15)), there must exist an entry i0 < #ps, such that
rat(ps(i0 )) = c ∧ time(ps(i0 )) = n + d 0 .
Deriving the Contradiction
Now, we can show that ∀f ∈ F : Bf |= Kf .
– Assume ¬∀f ∈ F : Bf |= Kf .
0
0
0
– Thus, ∃f ∈ F : Bf 6|= Kf and hence ∃K = (tg
 , gr , d ) ∈ Kf : t 6|= K.
– Thus, according to Def. 7 we have ∃n ∈ N : ∀i < #tg 0 : t(n + time(tg 0 (i))) |=


state(tg 0 (i)) ∧ t(n + d 0 ) 6|= gr 0 .
– Thus, according to Eq. (21), ∃i0 < #ps : rat(ps(i0 )) = K ∧ time(ps(i0 )) = n + d 0 .
– Thus, according to Eq. (17), t(n + d 0 ) |= state(ps(i0 )).
– Moreover, since rat(ps(i0 )) = K have state(ps(i0 )) =⇒ gr 0 according to
Eq. (16).
– Thus, since t(n + d 0 ) |= state(ps(i0 )) conclude t(n + d 0 ) |= gr 0 which is a
contradiction to t(n + d 0 ) 6|= gr 0 .
Thus, by Eq. (8) we can conclude A ⊗B |= k. Moreover, by Eq. (17) we can conclude
∀i < #tg : t(time(tg(i))) |= state(tg(i)). Thus, since A ⊗B |= k, according to Def. 7,
we can conclude t(d ) |= gr which is a contradiction to Eq. (20).
t
u

v

C

RAdder Model

Pattern TrainguardMT ShortName tgmt {
DTSpec {
DT Basic (
Sort NAT
Operation add: NAT, NAT => NAT
)
}
CTypes {
CType Merger {
InputPorts {
InputPort i1 (Type: Basic.NAT),
InputPort i2 (Type: Basic.NAT)
}
OutputPorts {
OutputPort o (Type: Basic.NAT)
}
Contracts {
Contract merge1 {
var x: Basic.NAT
triggers {
t1: [i1=x] /\ [i2=x]
}
guarantees {
[o=x]
}
duration 7
},
Contract merge2 {
var x: Basic.NAT
triggers {
t1: [i1=x],
t2: [i2=x] at 1
}
guarantees {
[o=x]
}
duration 3
},
Contract merge3 {
var x: Basic.NAT
triggers {
t1: [i2=x],
t2: [i1=x] at 1
vi

}
guarantees {
[o=x]
}
duration 3
}
}
},
CType Dispatcher {
InputPorts {
InputPort i1 (Type: Basic.NAT),
InputPort i2 (Type: Basic.NAT)
}
OutputPorts {
OutputPort o1 (Type: Basic.NAT),
OutputPort o2 (Type: Basic.NAT),
OutputPort o3 (Type: Basic.NAT),
OutputPort o4 (Type: Basic.NAT)
}
Contracts {
Contract dispatch {
var x: Basic.NAT,
var y: Basic.NAT
triggers {
t1: [i1=x] /\ [i2=y]
}
guarantees {
[o1=x] /\ [o2=y] /\ [o3=x] /\ [o4=y]
}
duration 1
}
}
},
CType Adder1 {
InputPorts {
InputPort i1 (Type: Basic.NAT),
InputPort i2 (Type: Basic.NAT)
}
OutputPorts {
OutputPort o (Type: Basic.NAT)
}
Contracts {
Contract add1 {
var x: Basic.NAT,
var y: Basic.NAT

vii

triggers {
t1: [i1=x] /\ [i2=y]
}
guarantees {
[o=Basic.add[x,y]]
}
duration 4
}
}
},
CType Adder2 {
InputPorts {
InputPort i1 (Type: Basic.NAT),
InputPort i2 (Type: Basic.NAT)
}
OutputPorts {
OutputPort o (Type: Basic.NAT)
}
Contracts {
Contract add2 {
var x: Basic.NAT,
var y: Basic.NAT
triggers {
t1: [i1=x] /\ [i2=y]
}
guarantees {
[o=Basic.add[x,y]]
}
duration 3
}
}
}
}
Contracts {
Contract sum {
var x: Basic.NAT,
var y: Basic.NAT
triggers {
t1: [Dispatcher.i1=x] /\ [Dispatcher.i2=y]
}
guarantees {
[Merger.o=Basic.add[x,y]]
}
duration 7
proof {

viii

s0: at 1
have [Dispatcher.o1=x] /\ [Dispatcher.o2=y]
from [
t1
]
using Dispatcher.dispatch,
s1: at 5
have
[Adder1.o=Basic.add[x,y]]
from [
s0 with [
(Adder1.i1, Dispatcher.o1),
(Adder1.i2, Dispatcher.o2)
]
]
using Adder1.add1,
s2: at 4
have
[Adder2.o=Basic.add[x,y]]
from [
s0 with [
(Adder2.i1, Dispatcher.o3),
(Adder2.i2, Dispatcher.o4)
]
]
using Adder2.add2,
s3: at 7
have
[Merger.o=Basic.add[x,y]]
from [
s1 with [
(Merger.i1, Adder1.o)
],
s2 with [
(Merger.i2, Adder2.o)
]
]
using Merger.merge3
}
}
}
}

ix

D

TGMT Model

Pattern TrainguardMT ShortName tgmt {
DTSpec {
DT Status (
Sort INT
),
DT Int (
Sort INT
Operation add: INT, INT => INT,
sub: INT, INT => INT
),
DT DoorStatus (
Sort DoorStatus
Predicate DT_DoorStatus_DoorsOpen: DoorStatus,
DT_DoorStatus_DoorsVitalClosed: DoorStatus
),
DT Bool (
Sort BOOLEAN
Predicate true: BOOLEAN,
false: BOOLEAN
),
DT Comparison (
Operation ls: Int.INT, Int.INT => Bool.BOOLEAN,
x

gt: Int.INT, Int.INT => Bool.BOOLEAN
),
DT Command (
Sort STRING
),
DT DoorReleaseCommand (
Sort DoorReleaseCommand
Predicate DT_DoorReleaseCommand_Right:
DoorReleaseCommand,
DT_DoorReleaseCommand_Left: DoorReleaseCommand,
DT_DoorReleaseCommand_Both: DoorReleaseCommand,
DT_DoorReleaseCommand_Deactivate: DoorReleaseCommand
),
DT DoorOpenStrategy (
Sort DoorOpenStrategy
Predicate DT_DoorOpenStrategy_Right: DoorOpenStrategy,
DT_DoorOpenStrategy_Left: DoorOpenStrategy
),
DT DoorReleaseStatus (
Sort DoorReleaseStatus
Predicate DT_DoorReleaseStatus_Released:
DoorReleaseStatus,
DT_DoorReleaseStatus_Locked: DoorReleaseStatus

xi

),
DT DoorStatus (
Sort DoorStatus
Predicate DT_DoorStatus_Opened: DoorStatus,
DT_DoorStatus_Closed: DoorStatus
),
DT MovingStatus (
Sort MovingStatus
Predicate DT_TrainMovingStatus_Moving: MovingStatus,
DT_TrainMovingStatus_StandStill: MovingStatus
),
DT DoorCommand (
Sort DoorCommand
Predicate DT_DoorCommand_Open: DoorCommand,
DT_DoorCommand_Close: DoorCommand
),
DT TrainControlLevel (
Sort TrainControlLevel
Predicate DT_TrainControlLevel_CTC: TrainControlLevel,
DT_TrainControlLevel_ITC: TrainControlLevel
),
DT PSD_Authorization (
Sort PSD_Authorization

xii

Predicate DT_PSD_Authorization_Authorize:
PSD_Authorization,
DT_PSD_Authorization_Not_Authorize: PSD_Authorization
),
DT PlatformPSDStatus (
Sort PlatformPSDStatus
Predicate DT_PlatformPSDStatus_Has_PSD:
PlatformPSDStatus,
DT_PlatformPSDStatus_Has_Not_PSD: PlatformPSDStatus
),
DT StoppingWindow (
Sort StoppingWindow
Predicate DT_StoppingWindow_WithinStoppingWindow:
StoppingWindow,
DT_StoppingWindow_OutsideStoppingWindow:
StoppingWindow
),
DT Time (
Sort INT
),
DT Authority (
Sort STRING
)
}

xiii

CTypes {
/*
* OBCU ATO Components
*/
CType OBCU_ATO_In_Converter {
InputPorts {
InputPort AB_I_Door_Operating_Mode (Type: DoorStatus.
DoorStatus),
InputPort AB_I_Premissive_Door_Button (Type: Bool.
BOOLEAN),
InputPort CAB_I_Door_Command (Type: DoorCommand.
DoorCommand),
InputPort CL_I_Door_Closed_Indication (Type:
DoorStatus.DoorStatus)
}
OutputPorts {
OutputPort doorStatus (Type: Status.INT),
OutputPort cabDoorCommand (Type: DoorCommand.
DoorCommand),
OutputPort cabPremissiveDoorButton (Type: Bool.
BOOLEAN),
OutputPort cabPremissiveDoorMode (Type: Status.INT)
}
},
CType OBCU_ATO_Door_Mode_Controller {
InputPorts {

xiv

InputPort trainOperationMode (Type: Status.INT),
InputPort platformPSDStatus (Type: Status.INT),
InputPort trainControlLevel(Type: Status.INT),
InputPort cabPremissiveDoorButton (Type: Bool.BOOLEAN
),
InputPort cabPremissiveDoorMode (Type: Status.INT)
}
OutputPorts {
OutputPort doorMode (Type: Status.INT)
}
},
CType OBCU_ATO_Door_Open_Controller {
InputPorts {
InputPort doorMode (Type: Status.INT),
InputPort dwellTimeElapsed (Type: Bool.BOOLEAN),
InputPort releaseForcedByPermissiveDoorButton (Type:
Bool.BOOLEAN),
InputPort doorReleaseStatus (Type: DoorReleaseStatus.
DoorReleaseStatus),
InputPort trainControlLevel (Type: Status.INT)
}
OutputPorts {
OutputPort doorOpenCommand (Type: DoorCommand.
DoorCommand)

xv

}
Contracts {
Contract doorsOpened {
triggers {
doorReleased: DoorReleaseStatus.
DT_DoorReleaseStatus_Released[doorReleaseStatus
],
timeNotElapsed: Bool.false[dwellTimeElapsed] at 1
}
guarantees {
DoorCommand.DT_DoorCommand_Open[doorOpenCommand]
}
duration 2
},
Contract doorsClosed {
triggers {
doorReleased: DoorReleaseStatus.
DT_DoorReleaseStatus_Locked[doorReleaseStatus]
}
guarantees {
DoorCommand.DT_DoorCommand_Close[doorOpenCommand]
}
duration 1
}

xvi

}
},
CType OBCU_ATO_Train_Door_Supervision_Mode_Controller {
InputPorts {
InputPort movingStatus (Type: MovingStatus.
MovingStatus),
InputPort doorReleaseStatus (Type: Time.INT),
InputPort cabPremissiveDoorButton (Type: Bool.BOOLEAN
),
InputPort trainControlLevel (Type: Status.INT),
InputPort doorStatus (Type: Status.INT)
}
OutputPorts {
OutputPort trainSupervision (Type: Bool.BOOLEAN)
}
},
CType OBCU_ATO_Train_Door_Supervision_Controller {
InputPorts {
InputPort trainSupervision (Type: Bool.BOOLEAN),
InputPort trainControlLevel (Type: Status.INT),
InputPort doorStatus (Type: Status.INT)
}
OutputPorts {
OutputPort trainMovement (Type: Bool.BOOLEAN)

xvii

}
},
CType OBCU_ATO_PSD_Door_Controller {
InputPorts {
InputPort openDoorCommand (Type: DoorCommand.
DoorCommand),
InputPort cabDoorCommand (Type: DoorCommand.
DoorCommand),
InputPort trainControlLevel (Type: TrainControlLevel.
TrainControlLevel)
}
OutputPorts {
OutputPort psdDoorCommand (Type: DoorCommand.
DoorCommand)
}
Contracts {
Contract forwardDoorCommand {
triggers {
controlLevelCTC: TrainControlLevel.
DT_TrainControlLevel_CTC[trainControlLevel]
}
guarantees {
[psdDoorCommand = openDoorCommand]
}
duration 1

xviii

}
}
},
CType OBCU_ATO_PSD_Door_Command_State {
InputPorts {
InputPort openDoorCommand (Type: DoorCommand.
DoorCommand)
}
OutputPorts {
OutputPort psdDoorCommandState (Type: DoorCommand.
DoorCommand)
}
Contracts {
Contract forwardingCommand {
guarantees {
[psdDoorCommandState = openDoorCommand]
}
duration 1
}
}
},
CType OBCU_ATO_Telegram_Builder {
InputPorts {

xix

InputPort psdDoorCommandState (Type: DoorCommand.
DoorCommand)
}
OutputPorts {
OutputPort OBCU_WCU_PlatformDoor (Type: DoorCommand.
DoorCommand)
}
Contracts {
Contract forwardingCommand {
guarantees {
[OBCU_WCU_PlatformDoor = psdDoorCommandState]
}
duration 1
}
}
},
CType OBCU_ATO_Out_Converter {
InputPorts {
InputPort openDoorCommand (Type: DoorCommand.
DoorCommand)
}
OutputPorts {
OutputPort TCL_O_Door_Opening_Closing (Type: Status.
INT)
}

xx

},

/*
* OBCU ITF Components
*/

CType OBCU_ITF_WWA_Telegram_Extractor {
InputPorts {
InputPort WCU_OBCU_MovementAuthority (Type: Authority
.STRING)
}
OutputPorts {
OutputPort rauz (Type: Status.INT)
}
},
CType OBCU_ITF_Out_Convertor {
InputPorts {
InputPort doorStatusHMI (Type: Status.INT),
InputPort psdStatusHMI (Type: Status.INT),
InputPort currentDoorModeHMI (Type: Status.INT),
InputPort doorReleaseStatusHMI (Type: Status.INT)
}

xxi

OutputPorts {
OutputPort HMI_O_Train_Door_Release (Type: Status.INT
),
OutputPort HMI_O_Train_Door_Mode (Type: Status.INT),
OutputPort HMI_O_PSD (Type: Status.INT),
OutputPort HMI_O_Train_Door_Status (Type: Status.INT)
}
},
CType OBCU_ITF_HMI_Status_Function {
InputPorts {
InputPort rauz (Type: Status.INT),
InputPort doorReleaseStatus (Type: Status.INT),
InputPort trainControlLevel (Type: Status.INT),
InputPort doorMode (Type: Status.INT),
InputPort doorStatus (Type: Status.INT)
}
OutputPorts {
OutputPort doorStatusHMI (Type: Status.INT),
OutputPort psdStatusHMI (Type: Status.INT),
OutputPort currentDoorModeHMI (Type: Status.INT),
OutputPort doorReleaseStatusHMI (Type: Status.INT)
}
},

xxii

CType OBCU_ITF_FWD_Movement_Authority {
InputPorts {
InputPort WCU_OBCU_MovementAuthority (Type: Authority
.STRING)
}
OutputPorts {
OutputPort WCU_OBCU_MovementAuthority (Type:
Authority.STRING)
}
},
CType OBCU_ITF_FWD_Position_Report {
InputPorts {
InputPort WCU_OBCU_PositionReport (Type:
PSD_Authorization.PSD_Authorization)
}
OutputPorts {
OutputPort WCU_OBCU_PositionReport_Out (Type:
PSD_Authorization.PSD_Authorization)
}
Contracts {
Contract forwardAuthorization {
guarantees {
[WCU_OBCU_PositionReport_Out =
WCU_OBCU_PositionReport]
}

xxiii

duration 1
}
}
},
CType OBCU_ITF_FWD_Platform_Door {
InputPorts {
InputPort WCU_OBCU_PlatformDoor (Type: DoorCommand.
DoorCommand)
}
OutputPorts {
OutputPort WCU_OBCU_PlatformDoor_Out (Type:
DoorCommand.DoorCommand)
}
Contracts {
Contract forwardingCommand {
guarantees {
[WCU_OBCU_PlatformDoor_Out = WCU_OBCU_PlatformDoor]
}
duration 1
}
}
},

xxiv

/*
* OBCU ATP Components
*/

CType OBCU_ATP_In_Converter {
InputPorts {
InputPort TCL_I_Door_Closed_Indication (Type:
DoorStatus.DoorStatus),
InputPort TCL_I_Door_Closed_Button (Type: Bool.
BOOLEAN)
}
OutputPorts {
OutputPort trainControlLevel (Type: Status.INT),
OutputPort cabPremissiveDoorButton (Type: Bool.
BOOLEAN),
OutputPort doorStatus (Type: DoorStatus.DoorStatus)
}
Contracts {
Contract forwardDoorStatus {
guarantees {
[doorStatus = TCL_I_Door_Closed_Indication]
}
duration 1
}

xxv

}
},
CType OBCU_ATP_Out_Converter {
InputPorts {
InputPort propulsion (Type: Bool.BOOLEAN),
InputPort doorReleaseCommand (Type:
DoorReleaseCommand.DoorReleaseCommand)
}
OutputPorts {
OutputPort TCL_O_Propulsion_Release (Type: Bool.
BOOLEAN),
OutputPort TCL_O_Door_Release (Type: Bool.BOOLEAN)
}
Contracts {
Contract doorsReleased {
triggers {
doorsReleased: DoorReleaseCommand.
DT_DoorReleaseCommand_Left[doorReleaseCommand]
\/ DoorReleaseCommand.DT_DoorReleaseCommand_Right[
doorReleaseCommand]
\/ DoorReleaseCommand.DT_DoorReleaseCommand_Both[
doorReleaseCommand]
}
guarantees {
Bool.true[TCL_O_Door_Release]

xxvi

}
duration 1
},
Contract doorsNotReleased {
triggers {
doorsReleased: DoorReleaseCommand.
DT_DoorReleaseCommand_Deactivate[
doorReleaseCommand]
}
guarantees {
Bool.true[TCL_O_Door_Release]
}
duration 1
}
}
},
CType OBCU_ATP_WMA_Telegram_Extractor{
InputPorts {
InputPort WCU_OBCU_MovementAuthority_out (Type:
Authority.STRING)
}
OutputPorts {
OutputPort rauz (Type: Status.INT)
}

xxvii

},
CType OBCU_ATP_PSD_Authorization_State_Tracker {
InputPorts {
InputPort authorizePSDOpening (Type:
PSD_Authorization.PSD_Authorization)
}
OutputPorts {
OutputPort psdAuthorizationState (Type:
PSD_Authorization.PSD_Authorization)
}
Contracts {
Contract forwardAuthorization {
guarantees {
[psdAuthorizationState = authorizePSDOpening]
}
duration 1
}
}
},
CType OBCU_ATP_PSD_Authorization_Controller {
InputPorts {
InputPort trainControlLevel (Type: TrainControlLevel.
TrainControlLevel),
InputPort doorReleaseStatus (Type: DoorReleaseStatus.
DoorReleaseStatus)

xxviii

}
OutputPorts {
OutputPort authorizePSDOpening (Type:
PSD_Authorization.PSD_Authorization)
}
Contracts {
Contract notAuthorized {
triggers {
trainControlLevelCTC: TrainControlLevel.
DT_TrainControlLevel_CTC[trainControlLevel],
doorReleaseStatusLocked: DoorReleaseStatus.
DT_DoorReleaseStatus_Locked[doorReleaseStatus]
at 1
}
guarantees {
PSD_Authorization.
DT_PSD_Authorization_Not_Authorize[
authorizePSDOpening]
}
duration 2
},
Contract authorized {
triggers {
trainControlLevelCTC: TrainControlLevel.
DT_TrainControlLevel_ITC[trainControlLevel],

xxix

doorReleaseStatusLocked: DoorReleaseStatus.
DT_DoorReleaseStatus_Released[doorReleaseStatus]
at 1
}
guarantees {
PSD_Authorization.DT_PSD_Authorization_Authorize[
authorizePSDOpening]
}
duration 2
}
}
},
CType OBCU_ATP_Telegram_Builder {
InputPorts {
InputPort psdAuthorizationState (Type:
PSD_Authorization.PSD_Authorization)
}
OutputPorts {
OutputPort OBCU_WCU_PositionReport (Type:
PSD_Authorization.PSD_Authorization)
}
Contracts {
Contract forwardAuthorization {
guarantees {
[OBCU_WCU_PositionReport = psdAuthorizationState]

xxx

}
duration 1
}
}
},
CType OBCU_ATP_Propulson_Function {
InputPorts {
InputPort doorStatus (Type: Status.INT),
InputPort trainControlLevel (Type: Status.INT),
InputPort rauz (Type: Status.INT),
InputPort authorizePSDOpening (Type: Bool.BOOLEAN)
}
OutputPorts {
OutputPort propulsion (Type: Bool.BOOLEAN)
}
},
CType OBCU_ATP_Door_Release_Controller {
InputPorts {
InputPort doorStatus (Type: DoorStatus.DoorStatus),
InputPort trainControlLevel (Type: Status.INT),
InputPort trainOperationMode (Type: Status.INT),
InputPort platformPSDStatus (Type: Status.INT),

xxxi

InputPort cabPremissiveDoorButton (Type: Bool.BOOLEAN
),
InputPort berthed (Type: Status.INT),
InputPort stoppingWindowMinus (Type: Bool.BOOLEAN),
InputPort stoppingPoint (Type: Bool.BOOLEAN),
InputPort stopingWindowPlus (Type: Bool.BOOLEAN),
InputPort trainPosition (Type: Int.INT),
InputPort movingStatus (Type: MovingStatus.
MovingStatus),
InputPort platformSide (Type: DoorOpenStrategy.
DoorOpenStrategy)
}
OutputPorts {
OutputPort doorReleaseCommand (Type:
DoorReleaseCommand.DoorReleaseCommand),
OutputPort doorReleaseStatus (Type: DoorReleaseStatus
.DoorReleaseStatus),
OutputPort releaseForcedByPermissiveDoorButton (Type:
Bool.BOOLEAN)
}
Contracts {
Contract openingLeftDoorSide {
triggers {
trigger1: DoorOpenStrategy.DT_DoorOpenStrategy_Left
[platformSide]
}

xxxii

guarantees {
DoorReleaseCommand.DT_DoorReleaseCommand_Left[
doorReleaseCommand]
}
duration 1
},
Contract openingRightDoorSide {
triggers {
trigger1: DoorOpenStrategy.
DT_DoorOpenStrategy_Right[platformSide]
}
guarantees {
DoorReleaseCommand.DT_DoorReleaseCommand_Right[
doorReleaseCommand]
}
duration 1
},
Contract doorsReleased {
var trainInStoppingWindow: Bool.BOOLEAN,
var premissiveRelease: Bool.BOOLEAN

triggers {
standStill: MovingStatus.
DT_TrainMovingStatus_StandStill[movingStatus],

xxxiii

trainInStoppingPosition: Bool.true[
trainInStoppingWindow] at 1,
premissiveRelease: Bool.false[premissiveRelease] at
2
}
guarantees {
DoorReleaseStatus.DT_DoorReleaseStatus_Released[
doorReleaseStatus]
}
duration 2
},
Contract doorsNotReleasedWhileMoving {
triggers {
moving: MovingStatus.DT_TrainMovingStatus_Moving[
movingStatus]
}
guarantees {
DoorReleaseStatus.DT_DoorReleaseStatus_Locked[
doorReleaseStatus] /\
DoorReleaseCommand.DT_DoorReleaseCommand_Deactivate
[doorReleaseCommand]
}
duration 1
},
Contract doorsClosedWhenClosedIndication {
triggers {

xxxiv

closedIndication: DoorStatus.DT_DoorStatus_Closed[
doorStatus]
}
guarantees {
DoorReleaseStatus.DT_DoorReleaseStatus_Locked[
doorReleaseStatus] /\
DoorReleaseCommand.DT_DoorReleaseCommand_Deactivate
[doorReleaseCommand]
}
duration 1
},
Contract doorsReleasedIfStandstillAndInStoppingWindow
{
triggers {
standstill: MovingStatus.
DT_TrainMovingStatus_StandStill[movingStatus],
hasPSD: PlatformPSDStatus.
DT_PlatformPSDStatus_Has_PSD[platformPSDStatus]
at 1,
inStopingPosition: Bool.true[Comparison.ls[Int.sub[
stoppingPoint, stoppingWindowMinus],
trainPosition]] /\
Bool.true[Comparison.gt[Int.sub[stoppingPoint,
stopingWindowPlus], trainPosition]] at 2
}
guarantees {
DoorReleaseStatus.DT_DoorReleaseStatus_Released[
doorReleaseStatus]

xxxv

}
duration 3
}
}
},

/*
* Wayside Components
*/
CType Wayside_In_Converter {
InputPorts {
InputPort PSD_I_PSD_Overwrite (Type: Bool.BOOLEAN),
InputPort PSD_I_PSD_Closed (Type: Bool.BOOLEAN),
InputPort ATS_I_Select_Door_Open_Strategy (Type:
Status.INT)
}
OutputPorts {
OutputPort selectedDoorStrategy (Type: Status.INT),
OutputPort psdClosed (Type: Status.INT),
OutputPort psdOverwrite (Type: Status.INT)
}
Contracts {
Contract selectedDoorStrategy {

xxxvi

guarantees {
[selectedDoorStrategy =
ATS_I_Select_Door_Open_Strategy]
}
duration 1
},
Contract psdClosed {
triggers {
trigger1: Bool.true[PSD_I_PSD_Closed]
}
guarantees {
DoorStatus.DT_DoorStatus_DoorsVitalClosed[psdClosed
]
}
duration 1
}
}
},
CType Wayside_OPD_Telegram_Extractor {
InputPorts {
InputPort OBCU_WCU_PlatformDoor (Type: DoorCommand.
DoorCommand)
}
OutputPorts {

xxxvii

OutputPort psdOpenCommand (Type: DoorCommand.
DoorCommand)
}
Contracts {
Contract forwardCommand {
guarantees {
[psdOpenCommand = OBCU_WCU_PlatformDoor]
}
duration 1
}
}
},
CType Wayside_OPR_Telegram_Extractor {
InputPorts {
InputPort OBCU_WCU_PositionReport (Type:
PSD_Authorization.PSD_Authorization)
}
OutputPorts {
OutputPort doorOpenAuthorization (Type:
PSD_Authorization.PSD_Authorization)
}
Contracts {
Contract forwardAuthorization {
guarantees {

xxxviii

[doorOpenAuthorization = OBCU_WCU_PositionReport]
}
duration 1
}
}
},
CType Wayside_PSD_Control_Function {
InputPorts {
InputPort trainControlLevel (Type: TrainControlLevel.
TrainControlLevel),
InputPort doorOpenAuthorization (Type:
PSD_Authorization.PSD_Authorization),
InputPort psdOpenCommand (Type: DoorCommand.
DoorCommand)
}
OutputPorts {
OutputPort psdOpen (Type: Bool.BOOLEAN)
}
Contracts {
Contract doorOpen {
triggers {
trainControlLevelITC: TrainControlLevel.
DT_TrainControlLevel_ITC[trainControlLevel],

xxxix

authorized: PSD_Authorization.
DT_PSD_Authorization_Authorize[
doorOpenAuthorization] at 1,
psdOpenCommand: DoorCommand.DT_DoorCommand_Open[
psdOpenCommand] at 2
}
guarantees {
Bool.true[psdOpen]
}
duration 3
},
Contract doorClosedCTC {
triggers {
trainControlLevelITC: TrainControlLevel.
DT_TrainControlLevel_CTC[trainControlLevel]
}
guarantees {
Bool.false[psdOpen]
}
duration 1
},
Contract doorClosedNotAuthorized {
triggers {
notAuthorized: PSD_Authorization.
DT_PSD_Authorization_Not_Authorize[
doorOpenAuthorization]

xl

}
guarantees {
Bool.false[psdOpen]
}
duration 1
},
Contract doorClosed {
triggers {
notAuthorized: PSD_Authorization.
DT_PSD_Authorization_Not_Authorize[
doorOpenAuthorization],
psdCloseCommand: DoorCommand.DT_DoorCommand_Close[
psdOpenCommand] at 1
}
guarantees {
Bool.false[psdOpen]
}
duration 2
},
Contract doorClosedCommandClose {
triggers {
psdCloseCommand: DoorCommand.DT_DoorCommand_Close[
psdOpenCommand]
}

xli

guarantees {
Bool.false[psdOpen]
}
duration 1
}
}
},
CType Wayside_RAUZ_Control_Function {
InputPorts {
InputPort psdOverwrite (Type: Status.INT),
InputPort trainControlLevel (Type: Status.INT),
InputPort psdClosed (Type: Bool.BOOLEAN)
}
OutputPorts {
OutputPort rauz (Type: Status.INT),
OutputPort zoneBlockedATS (Type: Bool.BOOLEAN)
}
},
CType Wayside_Door_Strategy_Function {
InputPorts {
InputPort selectedDoorStrategy (Type: Status.INT),
InputPort defaultDoorStrategy (Type: Status.INT),
InputPort trainControlLevel (Type: Status.INT)

xlii

}
OutputPorts {
OutputPort currentDoorStrategy (Type: Status.INT)
}
},
CType Wayside_ATS_Status_Function{
InputPorts {
InputPort currentDoorStrategy (Type: Status.INT),
InputPort trainControlLevel (Type: Status.INT)
}
OutputPorts {
OutputPort psdStatusATS (Type: Status.INT),
OutputPort psdAuthorizationATS (Type: Authority.
STRING),
OutputPort psdRequestATS (Type: Status.INT),
OutputPort doorStrategyStatusToATS (Type: Status.INT)
}
},
CType Wayside_PSD_Door_Command_State_Tracker {
InputPorts {
InputPort rauz (Type: Status.INT)
}
OutputPorts {

xliii

OutputPort rauzState (Type: Status.INT)
}
},
CType Wayside_TelegramBuilder {
InputPorts {
InputPort rausState (Type: Status.INT)
}
OutputPorts {
OutputPort WCU_OBCU_MovementAuthority (Type:
Authority.STRING)
}
},
CType Wayside_Out_Converter {
InputPorts {
InputPort psdOpen (Type: Bool.BOOLEAN),
InputPort psdStatusATS (Type: Status.INT),
InputPort psdAuthorizationATS (Type: Authority.STRING
),
InputPort psdRequestATS (Type: Status.INT),
InputPort doorStrategyStatusToATS (Type: Status.INT)
}
OutputPorts {
OutputPort PSD_O_PSD_Close (Type: Bool.BOOLEAN),

xliv

OutputPort PSD_O_PSD_Open (Type: Bool.BOOLEAN),
OutputPort ATS_O_PSD_Authorization (Type: Authority.
STRING),
OutputPort ATS_O_PSD_Status (Type: Status.INT),
OutputPort ATS_O_PSD_Request (Type: Status.INT),
OutputPort ATS_O_Door_Strategy (Type: Status.INT)
}
Contracts {
Contract psdOpen {
triggers {
open: Bool.true[psdOpen]
}
guarantees {
Bool.true[PSD_O_PSD_Open] /\ Bool.false[
PSD_O_PSD_Close]
}

duration 1
},
Contract psdClose {
triggers {
open: Bool.false[psdOpen]
}
guarantees {

xlv

Bool.false[PSD_O_PSD_Open] /\ Bool.true[
PSD_O_PSD_Close]
}

duration 1
}
}
}
}
Contracts {
// 1) If the train is moving, the PSDs are closed.
Contract PSDAreClosedWhenTrainIsMoving {
triggers {
trigger1: MovingStatus.DT_TrainMovingStatus_Moving[
OBCU_ATP_Door_Release_Controller.movingStatus]
}
guarantees {
Bool.true[Wayside_Out_Converter.PSD_O_PSD_Close] /\
Bool.false[Wayside_Out_Converter.PSD_O_PSD_Open]
}
duration 13
proof {
step1:
at 3

xlvi

have
DoorReleaseCommand.DT_DoorReleaseCommand_Deactivate[
OBCU_ATP_Door_Release_Controller.
doorReleaseCommand] /\
DoorReleaseStatus.DT_DoorReleaseStatus_Locked[
OBCU_ATP_Door_Release_Controller.doorReleaseStatus
]
from [
trigger1
]
using
OBCU_ATP_Door_Release_Controller.
doorsNotReleasedWhileMoving,
step2:
at 4
have
PSD_Authorization.DT_PSD_Authorization_Not_Authorize[
OBCU_ATP_PSD_Authorization_Controller.
authorizePSDOpening]
from [
step1 with [
(OBCU_ATP_PSD_Authorization_Controller.
doorReleaseStatus,
OBCU_ATP_Door_Release_Controller.doorReleaseStatus
)
]
]

xlvii

using
OBCU_ATP_PSD_Authorization_Controller.notAuthorized,
step3:
at 5
have
PSD_Authorization.DT_PSD_Authorization_Not_Authorize[
OBCU_ATP_PSD_Authorization_State_Tracker.
psdAuthorizationState]
from [
step2 with [
(OBCU_ATP_PSD_Authorization_State_Tracker.
authorizePSDOpening,
OBCU_ATP_PSD_Authorization_Controller.
authorizePSDOpening)
]
]
using
OBCU_ATP_PSD_Authorization_State_Tracker.
forwardAuthorization,
step4:
at 6
have
PSD_Authorization.DT_PSD_Authorization_Not_Authorize[
OBCU_ATP_Telegram_Builder.OBCU_WCU_PositionReport]
from [
step3 with [

xlviii

(OBCU_ATP_Telegram_Builder.psdAuthorizationState,
OBCU_ATP_PSD_Authorization_State_Tracker.
psdAuthorizationState)
]
]
using
OBCU_ATP_Telegram_Builder.forwardAuthorization,
step5:
at 4
have
DoorCommand.DT_DoorCommand_Close[
OBCU_ATO_Door_Open_Controller.doorOpenCommand]
from [
step1 with [
(OBCU_ATO_Door_Open_Controller.doorReleaseStatus,
OBCU_ATP_Door_Release_Controller.doorReleaseStatus
)
]
]
using
OBCU_ATO_Door_Open_Controller.doorsClosed,
step6:
at 5
have
DoorCommand.DT_DoorCommand_Close[
OBCU_ATO_PSD_Door_Controller.psdDoorCommand]

xlix

from [
step5 with [
(OBCU_ATO_PSD_Door_Controller.psdDoorCommand,
OBCU_ATO_Door_Open_Controller.doorReleaseStatus)
]
]
using
OBCU_ATO_PSD_Door_Controller.forwardDoorCommand,
step7:
at 6
have
DoorCommand.DT_DoorCommand_Close[
OBCU_ATO_PSD_Door_Command_State.
psdDoorCommandState]
from [
step6 with [
(OBCU_ATO_PSD_Door_Command_State.openDoorCommand,
OBCU_ATO_PSD_Door_Controller.psdDoorCommand)
]
]
using
OBCU_ATO_PSD_Door_Command_State.forwardingCommand,
step8:
at 7

l

have
DoorCommand.DT_DoorCommand_Close[
OBCU_ATO_Telegram_Builder.OBCU_WCU_PlatformDoor]
from [
step7 with [
(OBCU_ATO_Telegram_Builder.psdDoorCommandState,
OBCU_ATO_PSD_Door_Command_State.
psdDoorCommandState)
]
]
using
OBCU_ATO_Telegram_Builder.forwardingCommand,
step9:
at 8
have
DoorCommand.DT_DoorCommand_Close[
OBCU_ITF_FWD_Platform_Door.
WCU_OBCU_PlatformDoor_Out]
from [
step8 with [
(OBCU_ITF_FWD_Platform_Door.WCU_OBCU_PlatformDoor,
OBCU_ATO_Telegram_Builder.OBCU_WCU_PlatformDoor)
]
]
using
OBCU_ITF_FWD_Platform_Door.forwardingCommand,

li

step10:
at 7
have
PSD_Authorization.DT_PSD_Authorization_Not_Authorize[
OBCU_ITF_FWD_Position_Report.
WCU_OBCU_PositionReport_Out]
from [
step4 with [
(OBCU_ITF_FWD_Position_Report.WCU_OBCU_PositionReport
, OBCU_ATP_Telegram_Builder.
OBCU_WCU_PositionReport)
]
]
using
OBCU_ITF_FWD_Position_Report.forwardAuthorization,
step11:
at 8
have
PSD_Authorization.DT_PSD_Authorization_Not_Authorize[
Wayside_OPR_Telegram_Extractor.
doorOpenAuthorization]
from [
step10 with [
(Wayside_OPR_Telegram_Extractor.
OBCU_WCU_PositionReport,
OBCU_ITF_FWD_Position_Report.
WCU_OBCU_PositionReport_Out)

lii

]
]
using
Wayside_OPR_Telegram_Extractor.forwardAuthorization,
step12:
at 9
have
DoorCommand.DT_DoorCommand_Close[
Wayside_OPD_Telegram_Extractor.psdOpenCommand]
from [
step9 with [
(Wayside_OPD_Telegram_Extractor.OBCU_WCU_PlatformDoor
, OBCU_ITF_FWD_Platform_Door.
WCU_OBCU_PlatformDoor_Out)
]
]
using
Wayside_OPD_Telegram_Extractor.forwardCommand,
step13:
at 11
have
Bool.false[Wayside_PSD_Control_Function.psdOpen]
from [
step12 with [

liii

(Wayside_PSD_Control_Function.psdOpenCommand,
Wayside_OPD_Telegram_Extractor.psdOpenCommand)
],
step11 with [
(Wayside_PSD_Control_Function.doorOpenAuthorization,
Wayside_OPR_Telegram_Extractor.
doorOpenAuthorization)
]
]
using
Wayside_PSD_Control_Function.doorClosed,
step14:
at 13
have
Bool.true[Wayside_Out_Converter.PSD_O_PSD_Close] /\
Bool.false[Wayside_Out_Converter.PSD_O_PSD_Open]
from [
step13 with [
(Wayside_Out_Converter.psdOpen,
Wayside_PSD_Control_Function.psdOpen)
]
]
using
Wayside_Out_Converter.psdClose
}

liv

},
// 2) If the train is at standstill and the position of
the train doors match the position of the PSDs,
then, the PSDs are opened.
Contract PSDAreOpenIfNotMovingAndMatchingPosition {
triggers {
standstill: MovingStatus.
DT_TrainMovingStatus_StandStill[
OBCU_ATP_Door_Release_Controller.movingStatus],
hasPSD: PlatformPSDStatus.
DT_PlatformPSDStatus_Has_PSD[
OBCU_ATP_Door_Release_Controller.platformPSDStatus
] at 1,
inStopingPosition: Bool.true[Comparison.ls[Int.sub[
OBCU_ATP_Door_Release_Controller.stoppingPoint,
OBCU_ATP_Door_Release_Controller.
stoppingWindowMinus],
OBCU_ATP_Door_Release_Controller.trainPosition]]
/\
Bool.true[Comparison.gt[Int.sub[
OBCU_ATP_Door_Release_Controller.stoppingPoint,
OBCU_ATP_Door_Release_Controller.stopingWindowPlus
], OBCU_ATP_Door_Release_Controller.trainPosition
]] at 2
}
guarantees {
Bool.true[Wayside_Out_Converter.PSD_O_PSD_Open] /\
Bool.false[Wayside_Out_Converter.PSD_O_PSD_Close]
}
duration 13
proof {

lv

step1:
at 3
have
DoorReleaseCommand.DT_DoorReleaseCommand_Deactivate[
OBCU_ATP_Door_Release_Controller.
doorReleaseCommand] /\
DoorReleaseStatus.DT_DoorReleaseStatus_Locked[
OBCU_ATP_Door_Release_Controller.doorReleaseStatus
]
from [
standstill, hasPSD, inStopingPosition
]
using
OBCU_ATP_Door_Release_Controller.
doorsReleasedIfStandstillAndInStoppingWindow,
step2:
at 4
have
PSD_Authorization.DT_PSD_Authorization_Authorize[
OBCU_ATP_PSD_Authorization_Controller.
authorizePSDOpening]
from [
step1 with [
(OBCU_ATP_PSD_Authorization_Controller.
doorReleaseStatus,
OBCU_ATP_Door_Release_Controller.doorReleaseStatus
)

lvi

]
]
using
OBCU_ATP_PSD_Authorization_Controller.notAuthorized,
step3:
at 5
have
PSD_Authorization.DT_PSD_Authorization_Authorize[
OBCU_ATP_PSD_Authorization_State_Tracker.
psdAuthorizationState]
from [
step2 with [
(OBCU_ATP_PSD_Authorization_State_Tracker.
authorizePSDOpening,
OBCU_ATP_PSD_Authorization_Controller.
authorizePSDOpening)
]
]
using
OBCU_ATP_PSD_Authorization_State_Tracker.
forwardAuthorization,
step4:
at 6
have
PSD_Authorization.DT_PSD_Authorization_Authorize[
OBCU_ATP_Telegram_Builder.OBCU_WCU_PositionReport]

lvii

from [
step3 with [
(OBCU_ATP_Telegram_Builder.psdAuthorizationState,
OBCU_ATP_PSD_Authorization_State_Tracker.
psdAuthorizationState)
]
]
using
OBCU_ATP_Telegram_Builder.forwardAuthorization,
step5:
at 4
have
DoorCommand.DT_DoorCommand_Open[
OBCU_ATO_Door_Open_Controller.doorOpenCommand]
from [
step1 with [
(OBCU_ATO_Door_Open_Controller.doorReleaseStatus,
OBCU_ATP_Door_Release_Controller.doorReleaseStatus
)
]
]
using
OBCU_ATO_Door_Open_Controller.doorsClosed,
step6:
at 5

lviii

have
DoorCommand.DT_DoorCommand_Open[
OBCU_ATO_PSD_Door_Controller.psdDoorCommand]
from [
step5 with [
(OBCU_ATO_PSD_Door_Controller.psdDoorCommand,
OBCU_ATO_Door_Open_Controller.doorReleaseStatus)
]
]
using
OBCU_ATO_PSD_Door_Controller.forwardDoorCommand,
step7:
at 6
have
DoorCommand.DT_DoorCommand_Open[
OBCU_ATO_PSD_Door_Command_State.
psdDoorCommandState]
from [
step6 with [
(OBCU_ATO_PSD_Door_Command_State.openDoorCommand,
OBCU_ATO_PSD_Door_Controller.psdDoorCommand)
]
]
using
OBCU_ATO_PSD_Door_Command_State.forwardingCommand,

lix

step8:
at 7
have
DoorCommand.DT_DoorCommand_Open[
OBCU_ATO_Telegram_Builder.OBCU_WCU_PlatformDoor]
from [
step7 with [
(OBCU_ATO_Telegram_Builder.psdDoorCommandState,
OBCU_ATO_PSD_Door_Command_State.
psdDoorCommandState)
]
]
using
OBCU_ATO_Telegram_Builder.forwardingCommand,
step9:
at 8
have
DoorCommand.DT_DoorCommand_Open[
OBCU_ITF_FWD_Platform_Door.
WCU_OBCU_PlatformDoor_Out]
from [
step8 with [
(OBCU_ITF_FWD_Platform_Door.WCU_OBCU_PlatformDoor,
OBCU_ATO_Telegram_Builder.OBCU_WCU_PlatformDoor)
]
]

lx

using
OBCU_ITF_FWD_Platform_Door.forwardingCommand,
step10:
at 7
have
PSD_Authorization.DT_PSD_Authorization_Authorize[
OBCU_ITF_FWD_Position_Report.
WCU_OBCU_PositionReport_Out]
from [
step4 with [
(OBCU_ITF_FWD_Position_Report.WCU_OBCU_PositionReport
, OBCU_ATP_Telegram_Builder.
OBCU_WCU_PositionReport)
]
]
using
OBCU_ITF_FWD_Position_Report.forwardAuthorization,
step11:
at 8
have
PSD_Authorization.DT_PSD_Authorization_Authorize[
Wayside_OPR_Telegram_Extractor.
doorOpenAuthorization]
from [
step10 with [

lxi

(Wayside_OPR_Telegram_Extractor.
OBCU_WCU_PositionReport,
OBCU_ITF_FWD_Position_Report.
WCU_OBCU_PositionReport_Out)
]
]
using
Wayside_OPR_Telegram_Extractor.forwardAuthorization,
step12:
at 9
have
DoorCommand.DT_DoorCommand_Open[
Wayside_OPD_Telegram_Extractor.psdOpenCommand]
from [
step9 with [
(Wayside_OPD_Telegram_Extractor.OBCU_WCU_PlatformDoor
, OBCU_ITF_FWD_Platform_Door.
WCU_OBCU_PlatformDoor_Out)
]
]
using
Wayside_OPD_Telegram_Extractor.forwardCommand,
step13:
at 11
have
Bool.true[Wayside_PSD_Control_Function.psdOpen]

lxii

from [
step12 with [
(Wayside_PSD_Control_Function.psdOpenCommand,
Wayside_OPD_Telegram_Extractor.psdOpenCommand)
],
step11 with [
(Wayside_PSD_Control_Function.doorOpenAuthorization,
Wayside_OPR_Telegram_Extractor.
doorOpenAuthorization)
]
]
using
Wayside_PSD_Control_Function.doorClosed,
step14:
at 13
have
Bool.true[Wayside_Out_Converter.PSD_O_PSD_Close] /\
Bool.false[Wayside_Out_Converter.PSD_O_PSD_Open]
from [
step13 with [
(Wayside_Out_Converter.psdOpen,
Wayside_PSD_Control_Function.psdOpen)
]
]
using

lxiii

Wayside_Out_Converter.psdClose

}
},
// 3) If the train doors open on the right hand side,
the platform must be on the right hand
Contract trainOpensTheDoorOnTheRightSide {
triggers {
openRightDoorStrategy: DoorOpenStrategy.
DT_DoorOpenStrategy_Right[
OBCU_ATP_Door_Release_Controller.platformSide]
}
guarantees {
DoorReleaseCommand.DT_DoorReleaseCommand_Right[
OBCU_ATP_Door_Release_Controller.
doorReleaseCommand]
}
duration 1
proof {
step1:
at 1
have
DoorReleaseCommand.DT_DoorReleaseCommand_Right[
OBCU_ATP_Door_Release_Controller.
doorReleaseCommand]
from [

lxiv

openRightDoorStrategy
]
using
OBCU_ATP_Door_Release_Controller.openingRightDoorSide
}
},
// 4) If permissive release and the train is at
standstill then both doors are open
Contract trainOpensTheDoorOnTheRightSide {
triggers {
standstill: MovingStatus.
DT_TrainMovingStatus_StandStill[
OBCU_ATP_Door_Release_Controller.movingStatus],
permissiveButtonPresset: Bool.true[
OBCU_ATP_Door_Release_Controller.
cabPremissiveDoorButton]
}
guarantees {
Bool.true[Wayside_Out_Converter.PSD_O_PSD_Open] /\
Bool.false[Wayside_Out_Converter.PSD_O_PSD_Close]
/\
DoorReleaseCommand.DT_DoorReleaseCommand_Right[
OBCU_ATP_Door_Release_Controller.
doorReleaseCommand]
}
duration 1
proof {

lxv

step1:
at 3
have
DoorReleaseCommand.DT_DoorReleaseCommand_Both[
OBCU_ATP_Door_Release_Controller.
doorReleaseCommand] /\
DoorReleaseStatus.DT_DoorReleaseStatus_Released[
OBCU_ATP_Door_Release_Controller.doorStatus] /\
Bool.true[OBCU_ATP_Door_Release_Controller.
releaseForcedByPermissiveDoorButton]
from [
standstill, permissiveButtonPresset
]
using
OBCU_ATP_Door_Release_Controller.
doorsReleasedIfStandstillAndInStoppingWindow
}
},
// 5) When the train indicates that the doors are
closed, PSDs are closed
Contract PSDAreClosedWhenTrainGivesClosedIndication {
triggers {
trigger1: DoorStatus.DT_DoorStatus_DoorsVitalClosed[
OBCU_ATP_In_Converter.TCL_I_Door_Closed_Indication
]
}

lxvi

guarantees {
Bool.true[Wayside_Out_Converter.PSD_O_PSD_Close] /\
Bool.false[Wayside_Out_Converter.PSD_O_PSD_Open]
}
duration 14
proof {
step1:
at 1
have
DoorStatus.DT_DoorStatus_DoorsVitalClosed[
OBCU_ATP_In_Converter.doorStatus]
from [
trigger1
]
using
OBCU_ATP_In_Converter.forwardDoorStatus,
step2:
at 4
have
DoorReleaseCommand.DT_DoorReleaseCommand_Deactivate[
OBCU_ATP_Door_Release_Controller.
doorReleaseCommand] /\
DoorReleaseStatus.DT_DoorReleaseStatus_Locked[
OBCU_ATP_Door_Release_Controller.doorReleaseStatus
]
from [

lxvii

step1 with [
(OBCU_ATP_Door_Release_Controller.doorStatus,
OBCU_ATP_In_Converter.doorStatus)
]
]
using
OBCU_ATP_Door_Release_Controller.
doorsClosedWhenClosedIndication,
step3:
at 5
have
PSD_Authorization.DT_PSD_Authorization_Not_Authorize[
OBCU_ATP_PSD_Authorization_Controller.
authorizePSDOpening]
from [
step2 with [
(OBCU_ATP_PSD_Authorization_Controller.
doorReleaseStatus,
OBCU_ATP_Door_Release_Controller.doorReleaseStatus
)
]
]
using
OBCU_ATP_PSD_Authorization_Controller.notAuthorized,
step4:
at 6

lxviii

have
PSD_Authorization.DT_PSD_Authorization_Not_Authorize[
OBCU_ATP_PSD_Authorization_State_Tracker.
psdAuthorizationState]
from [
step3 with [
(OBCU_ATP_PSD_Authorization_State_Tracker.
authorizePSDOpening,
OBCU_ATP_PSD_Authorization_Controller.
authorizePSDOpening)
]
]
using
OBCU_ATP_PSD_Authorization_State_Tracker.
forwardAuthorization,
step5:
at 7
have
PSD_Authorization.DT_PSD_Authorization_Not_Authorize[
OBCU_ATP_Telegram_Builder.OBCU_WCU_PositionReport]
from [
step4 with [
(OBCU_ATP_Telegram_Builder.psdAuthorizationState,
OBCU_ATP_PSD_Authorization_State_Tracker.
psdAuthorizationState)
]
]

lxix

using
OBCU_ATP_Telegram_Builder.forwardAuthorization,
step6:
at 5
have
DoorCommand.DT_DoorCommand_Close[
OBCU_ATO_Door_Open_Controller.doorOpenCommand]
from [
step2 with [
(OBCU_ATO_Door_Open_Controller.doorReleaseStatus,
OBCU_ATP_Door_Release_Controller.doorReleaseStatus
)
]
]
using
OBCU_ATO_Door_Open_Controller.doorsClosed,
step7:
at 6
have
DoorCommand.DT_DoorCommand_Close[
OBCU_ATO_PSD_Door_Controller.psdDoorCommand]
from [
step6 with [
(OBCU_ATO_PSD_Door_Controller.psdDoorCommand,
OBCU_ATO_Door_Open_Controller.doorReleaseStatus)

lxx

]
]
using
OBCU_ATO_PSD_Door_Controller.forwardDoorCommand,
step8:
at 7
have
DoorCommand.DT_DoorCommand_Close[
OBCU_ATO_PSD_Door_Command_State.
psdDoorCommandState]
from [
step7 with [
(OBCU_ATO_PSD_Door_Command_State.openDoorCommand,
OBCU_ATO_PSD_Door_Controller.psdDoorCommand)
]
]
using
OBCU_ATO_PSD_Door_Command_State.forwardingCommand,
step9:
at 8
have
DoorCommand.DT_DoorCommand_Close[
OBCU_ATO_Telegram_Builder.OBCU_WCU_PlatformDoor]
from [

lxxi

step8 with [
(OBCU_ATO_Telegram_Builder.psdDoorCommandState,
OBCU_ATO_PSD_Door_Command_State.
psdDoorCommandState)
]
]
using
OBCU_ATO_Telegram_Builder.forwardingCommand,
step10:
at 9
have
DoorCommand.DT_DoorCommand_Close[
OBCU_ITF_FWD_Platform_Door.
WCU_OBCU_PlatformDoor_Out]
from [
step9 with [
(OBCU_ITF_FWD_Platform_Door.WCU_OBCU_PlatformDoor,
OBCU_ATO_Telegram_Builder.OBCU_WCU_PlatformDoor)
]
]
using
OBCU_ITF_FWD_Platform_Door.forwardingCommand,
step11:
at 8
have

lxxii

PSD_Authorization.DT_PSD_Authorization_Not_Authorize[
OBCU_ITF_FWD_Position_Report.
WCU_OBCU_PositionReport_Out]
from [
step5 with [
(OBCU_ITF_FWD_Position_Report.WCU_OBCU_PositionReport
, OBCU_ATP_Telegram_Builder.
OBCU_WCU_PositionReport)
]
]
using
OBCU_ITF_FWD_Position_Report.forwardAuthorization,
step12:
at 9
have
PSD_Authorization.DT_PSD_Authorization_Not_Authorize[
Wayside_OPR_Telegram_Extractor.
doorOpenAuthorization]
from [
step11 with [
(Wayside_OPR_Telegram_Extractor.
OBCU_WCU_PositionReport,
OBCU_ITF_FWD_Position_Report.
WCU_OBCU_PositionReport_Out)
]
]
using

lxxiii

Wayside_OPR_Telegram_Extractor.forwardAuthorization,
step13:
at 10
have
DoorCommand.DT_DoorCommand_Close[
Wayside_OPD_Telegram_Extractor.psdOpenCommand]
from [
step10 with [
(Wayside_OPD_Telegram_Extractor.OBCU_WCU_PlatformDoor
, OBCU_ITF_FWD_Platform_Door.
WCU_OBCU_PlatformDoor_Out)
]
]
using
Wayside_OPD_Telegram_Extractor.forwardCommand,
step14:
at 12
have
Bool.false[Wayside_PSD_Control_Function.psdOpen]
from [
step12 with [
(Wayside_PSD_Control_Function.doorOpenAuthorization,
Wayside_OPR_Telegram_Extractor.
doorOpenAuthorization)
],

lxxiv

step13 with [
(Wayside_PSD_Control_Function.psdOpenCommand,
Wayside_OPD_Telegram_Extractor.psdOpenCommand)
]
]
using
Wayside_PSD_Control_Function.doorClosed,
step15:
at 14
have
Bool.true[Wayside_Out_Converter.PSD_O_PSD_Close] /\
Bool.false[Wayside_Out_Converter.PSD_O_PSD_Open]
from [
step14 with [
(Wayside_Out_Converter.psdOpen,
Wayside_PSD_Control_Function.psdOpen)
]
]
using
Wayside_Out_Converter.psdClose
}
}
}
}

lxxv

