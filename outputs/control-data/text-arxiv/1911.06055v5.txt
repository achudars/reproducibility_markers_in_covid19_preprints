The RaPID-‚Ñ¶ system:
Room and Proctor Intelligent Decider
for large scale tests programming
Fernando A Moralesa
a Escuela

arXiv:1911.06055v5 [cs.MS] 17 Jul 2020

de MatemaÃÅticas Universidad Nacional de Colombia, Sede Medellƒ±ÃÅn
Carrera 65 # 59A‚Äì110, Bloque 43, of 106, Medellƒ±ÃÅn - Colombia

Abstract
We present the mathematical modeling for the problem of choosing rooms and proctoring crews for massive
tests, together with its implementation as the open-box system RaPIDE‚Ñ¶. The mathematical model is a binary
integer programming problem: a combination of the 0-1 Knapsack problem and the job-assignment problem.
The model makes decisions according the following criteria in order of priority: minimization of labor-hours,
maximization of equity in the distribution of duties and maximization of the proctoring quality. The software is
a digital solution for the aforementioned problem, which is a common need in educational institutions offering
large, coordinated, lower-division courses. The system can be downloaded from [1]:
https://sites.google.com/a/unal.edu.co/fernando-a-morales-j/home/research/software
Keywords: Open-box software, Python Program Documentation, Binary Integer Programming
2010 MSC: 90C10, 90B80, 68N15

1. Introduction
In this work we present the mathematical modeling and documentation of the open-box system RaPIDE‚Ñ¶,
designed to optimize the rooms choice and the proctor scheduling for the logistics of massive tests. This
problem is frequent in educational institutions having large coordinated courses (specially for the lower division
ones) with simultaneous common tests. Here, we propose a novel mathematical model for this problem and
implement a digital solution. Its structure is highly modular, which makes it easy for a programmer to make
modifications, it is flexible due to the defined data sets and it is efficient. The software was constructed based
on the needs of a specific case: Escuela de MatemaÃÅticas (School of Mathematics) at Universidad Nacional de
Colombia, Sede Medellƒ±ÃÅn (National University of Colombia at Medellƒ±ÃÅn). Hence, the simple model examples we
present are based on our study case.
The School of Mathematics is part of the College of Science within the National University of Colombia
at Medellƒ±ÃÅn, it teaches two types of courses: specialization (advanced undergraduate and graduate courses in
mathematics) and service courses (lower division) for the whole University. The latter are: Differential Calculus
(DC), Integral Calculus (IC), Vector Calculus (VC), Differential Equations (ODE), Vector & Analytic Geometry
(VAG), Linear Algebra (LA), Numerical Methods (NM), Discrete Mathematics (DM), Applied Mathematics
(AM) and Basic Mathematics (BM, college algebra). The total demand of these courses amounts to an
average of 7200 enrollment registrations per semester. The last three courses, DM, AM, BM, do not test their
‚ú© This

material is based upon work supported by project HERMES 41491 from Universidad Nacional de Colombia, Sede Medellƒ±ÃÅn.
Author
Email address: famoralesj@unal.edu.co (Fernando A Morales)

‚àó Corresponding

Preprint submitted to arXiv

July 20, 2020

students in a coordinated fashion but independently (i.e., each lecturer designs his/her own evaluation method);
consequently they will not be subject to this analysis. Given that most of the students attending the National
University of Colombia at Medellƒ±ÃÅn pursue degrees in Engineering, the courses DC, IC, VC, ODE, VAG, LA and
MN are massive and they pose significant logistic challenges for booking their respective evaluations; see Table
1 below. On a typical semester these courses are divided in sections (between 8 and 22, depending on the
Table 1: Historical Enrollment Table

Semester

DC

IC

VC

VAG

LA

ODE

NM

Total

2010‚Äì1

1631

782

381

1089

983

668

142

5676

2010‚Äì2

1299

1150

427

1003

1007

562

261

5709

2011‚Äì1

1271

1136

512

1078

900

663

269

5829

2011‚Äì2

951

850

513

652

812

1170

289

5237

2012‚Äì1

1619

1096

559

1110

1116

752

366

6618

2012‚Äì2

1486

1190

601

1076

1144

825

356

6678

2013‚Äì1

1476

1044

604

1231

1037

902

319

6613

2013‚Äì2

1446

1212

549

1187

1103

786

326

6609

2014‚Äì1

1460

1184

676

1192

1000

890

295

6697

2014‚Äì2

1399

1126

564

1198

1012

695

234

6228

2015‚Äì1

1097

925

565

1076

793

601

201

5258

2015‚Äì2

1797

1214

605

1314

1099

808

274

7111

2016‚Äì1

1675

1323

582

1549

1017

950

263

7359

2016‚Äì2

1569

1296

594

1355

1009

1019

284

7126

2017‚Äì1

1513

1315

515

1088

798

736

134

6099

Mean

1445.9

1122.9

549.8

1146.5

988.7

801.8

267.5

6323.1

enrollment) of sizes ranging from 80 to 140 (because of classroom seat capacities). The evaluation consists
in three exams which the students take simultaneously, the personnel in charge of proctoring duties consists
of approximately 45 lecturers among tenured and adjunct faculty, as well as 70 teaching assistants among
graduate and undergraduate students. Moreover the Teaching Assistants and Adjunct Faculty are not fulltime employees ergo, they introduce significant time constraints in the task assignment, due to their schedule.
Typically, each of the coordinated courses takes three tests during the semester, therefore three rounds of
tests need to be scheduled each semester. Currently, each round‚Äôs selection of rooms and proctoring duties
assignment is decided with the RaPIDE‚Ñ¶ system.
In contrast with black-box commercial software, this open-box tool is aimed to be easily used and/or modified
to the needs of other programming scenarios (most likely other educational institutions with different but similar
testing procedures). It shares the spirit (and inspiration) of other open-box systems such as [2] and [3]. We
tackle the problem in three steps. First, we model the rooms‚Äô optimal choice problem with the Knapsack
Problem (see [4] and [5]), here we minimize the total number of necessary proctors. Second, we model the
problem of choosing proctoring crews as the Job Assignment Problem (see [6]), this is done maximizing the
equity in the proctoring hours among the personnel. Third, the chose crew is organized in order to maximize
the proctoring quality conditions of each room, according to the experience record of each proctor. This is done
2

with a Greedy Algorithm (see [7]), which accommodates the proctors in that order of priority. Each of the steps
previously mentioned has a corresponding module inside the system RaPIDE‚Ñ¶, these are: Room Decision.py,
Personnel Decision.py and Crew Organization.py. The system is implemented in Python 3.4, it uses libraries
such as pandas (Python Data Analysis Library) and SciPy. RaPIDE‚Ñ¶ runs from command line and it can be
freely downloaded from [1]:
https://sites.google.com/a/unal.edu.co/fernando-a-morales-j/home/research/software
Three versions are available: a Windows, a Linux-Mac and a Collab version.
The rest of the paper is organized as follows: Section 2 exposes the modeling and algorithms for the first
module of the system concerned about optimal room choice and number of students in each room. Section 3
presents the modeling algorithms of the second step regarding the choice of proctors among available personnel.
Section 4 presents the algorithm to decide the optimal position to proctor a test, starting from a previously
scheduled crew. In Section 5 the input datasets are exposed, together with its meaning and its format, in
Section 6 the output files are presented, two of these files are final while two are intermediate. Section 7 gives
brief directions of execution & problems and Section 8 summarizes the conclusions. The sections 2, 3 and 4
are of mathematical interest and for a developer who wants to make adjustments to the current system. On
the other hand, a mere user needs to understand only sections 5, 6 7. We close this section presenting a Flux
Diagram of the RaPIPDE‚Ñ¶-sysem, see Figure 1.




Input DB



Personnel Time.xls



Input DB

Input DB





Available Rooms.xls

Ô£Æ

Room Decision.py

Input DB



Room Data.xls

Ô£π

Ô£∞Proctor hours minimizationÔ£ª



Professors.xls



Input DB

Dynamic Programming







Output and imput DB

Scheduled Rooms.xls

Proctor Log.xls

Ô£Æ
Ô£π
Personnel Decision.py
Ô£∞ Equity maximization Ô£ª
Job Assignment Problem

Ô£´

Output DB

Ô£∂



Ô£≠New Proctor Log.xlsÔ£∏
(updated version)

Output and Input DB



Scheduled Crew.xls

Ô£Æ

Crew Organization.py



Output DB

Ô£π

Ô£∞Optimizaing Proctoring QualityÔ£ª
Greedy Algorithm



Proposed Programming.xls

Figure 1: Flux diagram RaPIDE‚Ñ¶. We use curly brackets to indicate input data bases, square brackets for the algorithms and in
round brackets the data bases to be saved for futre and/or direct use.

3

2. The Room Decision Problem: module Room Decision.py
The first module we are to attack is: choosing for each test, a set of rooms that minimizes the number of
needed proctors. This process is done independently for each test, because there is never time conflict between
scheduled tests. therefore the rooms are not exchangeable items; it consists in two steps. First, the choice of
rooms, this is modeled with a 0-1 knapsack problem and solved with dynamic programming algorithm, which is
implemented in algorithm 1. Second, the optimal use of the slack between students and available seats (which
usually is nonzero), which is solved with a greedy algorithm, which is implemented in algorithm 2.
2.1. Modeling Choice of Rooms
In this subsection we explain how we model the rooms‚Äô selection. Before starting, two values need to be
introduced

Definition 1. Let ci : 1 ‚â§ i ‚â§ N be the list of capacities (quantity of seats) of the available rooms for a
given test, define
r ‚àà N the student-proctor rate,
def  ci 
wi =
the weight/cost of each room.
r

(1)

Here, it is understood that the label i = 1, 2, . . . , N stands for each available room and that the ceiling function
def
x 7‚Üí ‚åàx‚åâ = min{n ‚àà Z : n ‚â• x}, assigns to any real number x ‚àà R the minimum integer greater or equal
than x. The student-proctor rate r , is the number of students that an individual must proctor (the system has
54 as default value).
Therefore, the problem of choosing rooms is modeled by the 0-1 minimization Knapsack problem

Problem 1. Let ci : 1 ‚â§ i ‚â§ N be the list of capacities of the available rooms for a given test and let D (the
demand) be the number of students taking the test. Let (wi : 1 ‚â§ i ‚â§ N) be the list of weights for each room
as introduced in Definition 1 then, the problem of minimizing proctors is given by
min

N
X

(2a)

wi xi .

i =1

Subject to
N
X

ci xi ‚â• D,

xi ‚àà {0, 1},

for all i = 1, 2, . . . , N.

(2b)

i =1

Here, for each i = 1, . . . , N, the binary variable xi indicates whether the room i is chosen (xi = 1) or not
(xi = 0).
Observe that the solution of Problem 1 above can be found using the solution of the following Knapsack
Problem
Problem 2.
max

X

(3a)

pi yi ,

i ‚àà [N]

subject to
X

i ‚àà [N]

ci yi ‚â§

X

(3b)

ci ‚àí D,

i ‚àà [N]

yi ‚àà {0, 1},

for all i ‚àà [N].
4

(3c)


def
def
N
Proposition 1. Let y = yi : i ‚àà [N] ‚àà
 {0, 1} Nbe a solution to Problem 2 and define xi = 1 ‚àí yi for all
i ‚àà [N] then, the vector x = xi : i ‚àà [N] ‚àà {0, 1} is a solution to Problem 1.

Proof. The proof uses the well-known classic transformation of complementary binary variables, xi = 1‚àíŒæi ‚àà
{0, 1} for all i ‚àà [N], to relate the problems 1 and 2 (see Section 13.3.3 in [4] for details).

There are several ways for solving the 0-1 Knapsack problem 2. In the RaPIDE‚Ñ¶ system the problem is solved
using the technique of dynamic programming (see Section 11.3 in [8] or Section 2.3 in [4] for details), whose
computational complexity is given by
Theorem 2 (Dynamic Programming Complexity). The 0-1 Knapsack problem can be solved in time O(n2 pmax ).
Proof. See Theorem 11.1 in [8].
Finally, the implementation is given by the algorithm 1.
Algorithm 1 Room Decision Algorithm, decides the choice of rooms and the slack distribution once an optimal
solution to Problem 1 is found.
1: procedure Room Decision(Available Rooms.xls file, Student-Proctor Rate: r .
User Decision: Student-Proctor rate r )
2:
create the Excel book Scheduled Rooms.xls
‚ä≤ Each column is a test, e.g., Table 4
3:
for column of Available Rooms.xls do
4:
create the sheet corresponding to the test.
5:
retrieve from Available Rooms.xls the information: Rooms‚Äô List, Capacities: (ci )N
i =1 and Demand:
D corresponding to the test.
PN
N
6:
call dynamic programming solver (Input: {(ci )N
i =1 ,
i =1 ci ‚àí D}, Output (Œæi )i =1 )
def

compute xi = Œæi for i = 1, . . . , N
N
N
call Algorithm 2 (Input {(ci )N
i =1 , (xi =1 ), D}, Output: (Ei )i =1 quantity of students in each chosen

7:

8:

room)
9:
10:
11:
12:

N
N
save (xi )N
i =1 , (Ei )i =1 , (wi )i =1 in the sheet corresponding to the test together with the remaining
information displayed in Table 10.
end for
save book Scheduled Rooms.xls
end procedure

2.2. The Slack between available seats and students
For most instances of Problem 1, the optimal solution (xi )N
i =1 will not satisfy actively the constraint (2b) i.e.,
P
there will be a slack between the number of available seats ( N
i = 1 ci xi ) and the students taking the test (D).
The distribution of the slack among the chosen rooms gives rise to a new optimization process. For instance,
suppose there are only two rooms available with of 55 seats each, 108 students and the student-proctor rate is
r = 54. Then, the problem 1 will choose both rooms i.e., x1 = x2 = 1. Next, the greedy algorithm will program
54 students in each room in order to need 2 proctors, instead of programming 53, 55 which would demand 3
proctors. Essentially, the algorithm 2, tries to optimize the slack (from the previously attained solution) in order
to reduce the number of proctors once more. To present the algorithm we define the following parameters

Definition 2. Let ci : 1 ‚â§ i ‚â§ N be the list of capacities of the available rooms for a given test, let D be the
number of students taking the test and let r be the student-proctor rate. Let (xi )N
i =1 be an optimal solution of
Problem 1.
def

(i) We say that the total slack is given by S =

N
P

ci xi ‚àí D.

i =1

5

(ii) For each room, define the list of slack priority coefficients by
si ‚â° ci

mod r,

with 0 ‚â§ si < r,

(4)

for all i = 1, . . . , N. Where it is understood that ci = qi r + si with 0 ‚â§ si < r being the remainder output
in the Euclid‚Äôs Division Algorithm (see Section 3.3 in [9] for details).
With the definitions above the, greedy algorithm 2 below is implemented.
Algorithm 2 Optimal Slack Distribution Algorithm, decides the slack distribution once an optimal solution
(xi )N
i =1 to Problem 1 is found.
1:
2:
3:
4:

procedure Slack Distribution(Capacities: (ci )N
i =1 , Demand: D, Student-Proctor Rate: r )
compute list of specific slack priority coefficients (si )N
‚ä≤ Introduced in Definition 2.
i =1
sort the list (si )N
in
ascending
order
i =1
denote by œÉ ‚àà S[N] the associated ordering permutation, i.e.,
for all i = 1, . . . , N ‚àí 1.

sœÉ(i ) ‚â§ sœÉ(i +1) ,
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:

def

Sl ack =
def

PN

i =1 ci

(5)

‚ä≤ Initializing the available slack

‚àíD

ei = ci for all i = 1, . . . , N
‚ä≤ Initializing the located students in each room (overcounted)
for i = 1, . . . , N do
if (0 < Sl ack) and (Sl ack ‚â§ sœÉ(i ) ) then
eœÉ(i ) = eœÉ(i ) ‚àí Sl ack
else if (Sl ack > sœÉ(i ) ) then
eœÉ(i ) = eœÉ(i ) ‚àí sœÉ(i )
Sl ack = Sl ack ‚àí (sœÉ(i ) + 1)
end if
def  
‚ä≤ Updated number of needed proctors
compute wi = eri .
end for
N
return (ei )N
i =1 , (wi )i =1
end procedure

Remark 1. The slack priority coefficient, introduced in Definition 2 essentially seeks in which rooms a proctor
can be reduced by removing the minimum possible number of programmed students. Namely, if t = 54 a room
with 55 students can be proctored by only one TA, by removing only one student. If the room has 56, two
students should be removed to attain the previous result, which is a stronger requirement in terms of available
slack. In the same reasoning, it is better to remove one student from a room of 109 (s = 1) than 2 from a
room of 56 (s = 2).
Theorem 3. The computational complexity of Algorithm 2 is O(N log2 N), where N is the total number of
chosen rooms.
Proof. This is a Greedy Algorithm based on sorting. It is known that the standard MergeSort algorithm
does the job in O(N log2 N), see Section 19.2.2 in [10]
3. The Personnel Selection Problem: module Personnel Decision.py
In this section we present the mathematical model for the problem of choosing personnel for proctoring
shifts with a sense of equity. The input of this problem can be seen in Figure 1: ‚Ä¢ The number of tests, rooms
and quantity of TA‚Äôs needed to proctor (contained in the file Scheduled Rooms.xls) ‚Ä¢ The time availability
6

for each TA ‚Ä¢ The lecturers directly assigned to proctor (Professors.xls) ‚Ä¢ The record of previous service
of the each TA in a time window of interest (Proctor Log.xls). Also notice that in this particular case all
the TAs are exchangeable (unlike the lecturers) therefore, the problem of choosing a proctoring crew will be
done simultaneously for all the tests in the round, in contrast with the test-wise design model of Section 2.
This section is divided in two parts, the presentation of the mathematical model and the presentation of the
algorithm.
3.1. The mathematical model
In this section we derive a mathematical model for the problem of selecting personnel for proctoring duties
(or shifts). It will be seen that the model is the Job Assignment problem with constraints. Before we can
introduce it, some definitions are in order
Definition 3. Let T be the number of tests in the round and let P be the total number of part-time employed
TAs.
(t) N(t)

(i) For each test t, let N = N(t) be the number of scheduled rooms for the test and let (wi )i =1 be the list
of needed proctors in each booked room. Then, the total number of proctors needed in the test is given
by
N(t)
X (t)
(t) def
W
=
wi .
(6)
i =1

(ii) For each t = 1, . . . , T and p = 1, . . . , P , let yp(t) ‚àà {0, 1} be the decision variable defined by
(
1, if proctor p is assigned to test t ,
(t) def
yp =
0, otherwise.

(7)

(t)

Also define the availability coefficient ap ‚àà {0, 1} by
(
1, if proctor p is available at the time of test t,
(t) def
ap =
0, otherwise.

(8)

(iii) For each p (identifying a TA), denote by Lp the number of served shifts in the Proctor Log.xls file (i.e.,
the TA‚Äôs service record before running the algorithm).
(iv) The global service average Œ±, after the current round of tests, is computed in the natural way, i.e.,
def

Œ±=

P
T

X
1X
Lp +
W (t) .
P p=1
t =1

(9)

Remark
that due to the expression (9) the quantity Œ± is known. On the other hand, observe
PT 2. Observe
(t)
that
y
quantifies
the total number of shifts that each TA has in the current round of tests. The
p
t=1
P
P
(t)
alternative definition Œ± = P1 Pp = 1 (Lp + Tt=1 yp ), would be mathematically equivalent to (9), but it would
(unnecessarily) include Œ± as a variable.
With the definitions above, it is direct to see that we want to solve the following problem
Problem 3.
P

min max
p=1

T
X

yp(t) + Lp ‚àí Œ± .

t =1

7

(10a)

Subject to
P
X

ap(t) yp(t) = W (t) ,

for all t = 1, . . . , T.

(10b)

p=1

yp(t) ‚àà {0, 1},

for all t = 1, . . . T and p = 1, . . . , P.

(10c)

The problem 3 is clearly not a linear programming problem. In order to transform
it, we introduce a new
PT
(t)
continuous variable z (not necessarily integer), verifying the constraints
y
t = 1 p + Lp ‚àí Œ± ‚â§ z for all
p = 1 . . . , P . Clearly, the absolute sense can be decoupled in two inequality constraints and given that this is
an integer programming problem, the following refinement is introduced
T
X

yp(t) + Lp ‚àí ‚åàŒ±‚åâ ‚â§

t =1

T
X

yp(t) + Lp ‚àí Œ± ‚â§ z,

t =1

‚àíz ‚â§

T
X

yp(t)

+ Lp ‚àí Œ± ‚â§

t =1

T
X

(11)
yp(t)

+ Lp ‚àí ‚åäŒ±‚åã.

t =1

With the introduction of the variable z above and the natural linear relaxation, the problem 3 can be reformulated
as the following linear optimization problem.
Problem 4. With the variables and quantities introduced in Definition 3, the problem of assigning TAs for
proctoring duties as fairly as possible, considering their time constraints, is modeled by the problem
min z.

(12a)

Subject to
T
X

yp(t) ‚àí z ‚â§ ‚àíLp + ‚åàŒ±‚åâ,

t =1
T
X

(12b)
yp(t) ‚àí z ‚â§ Lp ‚àí ‚åäŒ±‚åã,

‚àÄp = 1, . . . , P.

t =1

P
X

ap(t) yp(t) = W (t) ,

for all t = 1, . . . , T.

(12c)

p=1

0 ‚â§ yp(t) ‚â§ 1,

for all t = 1, . . . , T and p = 1, . . . , P.

(12d)

Theorem 4. For the job assignment problem, the binary integer choice constraint (10c), can be replaced by
the natural linear relaxation constraint (12d) and both problems have the same integer optimal solution.
Proof. See Chapter 4 in [6].
3.2. The Personnel Decision.py module
With the exposition above, the algorithm of the module Personnel Decision.py is summarized in the pseudocode 3.
8

Algorithm 3 Personnel Decision Algorithm, decides the proctoring crew for all the tests in the round.
1: procedure Personnnel Decision(Scheduled Rooms.xls file, Personnel Time.xls, Proctor Log.xls, Profesors.xls.)
2:
load the information corresponding to the input files.
3:
include the lecturers in the file Scheduled Crew.xls, assigned to their corresponding courses.
4:
compute the number of necessary proctors for each test.
‚ä≤ Coefficients (W (t) , t = 1, . . . , T ),
Equation, (6).
5:
account for the time constraint coefficients for each TA.
‚ä≤ Coefficientes
(t)
(ap , t = 1, . . . , T, p = 1, . . . , P ), Equation (8).
6:
include the proctors necessity constraints
‚ä≤ Equation (12c).
7:
compute the service average value
‚ä≤ Coefficient Œ±, Equation (9).
8:
include the proctors service-equity constraints
‚ä≤ Equation (12b).
9:
solve the Problem 4 ‚Üê call a linear program solver
‚ä≤ The system uses scipy.optimize.linprog
10:
create and save the Updated Proctor Log.xls file.
11:
create and save the Scheduled Crew.xls file.
12: end procedure

Remark 3 (Computational Complexity). The algorithm 3 solves the problem using the Simplex method. It
is know that the Simplex algorithm can grow exponentially with respect to the number of constraints, for some
particular cases (see Theorem 3.5 in [8]). However, it has been observed in the practice that the method
typically takes O(m) iterations and O(mn) operations per iteration. Where m is the number of constraints and
n is the dimension of the vector. In the particular case of RaPIDE‚Ñ¶, it can be safely assumed that this is the
computational complexity of Algorithm 3. Given that n = T √ó P + 1 and m = 2T + P , it follows that the
algorithm runs in time

O (2T + P )2 (T + P ) ,
(13)
i.e., it is polynomial in the number of tests and the number of proctors.

4. The Crew Organization Problem: module Crew Organization.py
Once the proctoring crew is decided in the previous steps, the final step is to distribute the TAs in strategic
positions in order to maximize the proctoring quality. More specifically, it is clear that rooms with only one
proctor assigned should get the more experienced proctors, while a mixed experienced-unexperienced couple
should be assigned to rooms needing two proctors. In the same fashion, the supervisor should be an experienced
undergraduate TA, as it is a position with higher responsibility. At this point the proctors are no longer
exchangeable between tests, therefore the process is done independently as in Section 2. Although, it is
possible to construct a mathematical integer programming model for this stage, it is more practical to use a
greedy algorithm for making these decisions (see [11] for a comprehensive exposition on greedy algorithms).
The greedy algorithm 4 is based on lexicographic sorting of the scheduled crew‚Äôs data. More specifically a
pairing (match) has to be done: the proctoring positions and the proctors themselves. It is direct to see that
the proctors should be sorted according to their academic level in the first place (3 Undergraduate, 2 Graduate,
1 Lecturer) and to their experience in the second place (see Table 6). The proctoring positions need further
explanation. Observe that any test will need a number of supervisors (according to the enrollment size) and a
number of proctors in each room. The process of selecting supervisors and the process of selecting proctoring
positions are different. Hence, two separate steps will be done for completing the tasks.
With the observations above, the Crew Organization.py module works with the algorithm 4 below.
Remark 4. Some clarifications are necessary for a deeper understanding of the design and purpose of the
algorithm 4.
9

Algorithm 4 Crew Organization Algorithm, decides proctoring positions.
1: procedure Crew Organization(Scheduled Rooms.xls, Scheduled Crew.xls )
2:
load the sheet Scheduled Crew.xls as Data Frame
3:
load the Excel book Scheduled Rooms.xls as Data Frame
4:
create column ‚ÄúNum Level‚Äù in Scheduled Rooms.xls (3 Undergraduate, 2 Graduate, 1 PhD)
5:
create the Excel book Proposed Programming.xls
‚ä≤ Each sheet in the book is a test.
6:
for test idx in Scheduled Rooms.xls do
7:
create sheet test idx in the book Proposed Programming.xls
8:
select the rooms scheduled for test idx, i.e., Scheduled Rooms[test = test idx].
9:
create the Local Test Frame, with columns: Room, Proctors, Position, Students ‚ä≤ The column
‚ÄúPosition‚Äù indicates if it is the 1st, 2nd, 3rd... proctor in the room.
def
10:
define ns = the number of needed supervisors.
11:
create Local Proctors Frame ‚Üê Scheduled Crew[Test = test idx] ‚ä≤ The proctors assigned to the
test.
12:
sort lexicographically the Local Proctors Frame with the priority: [‚ÄúNum Level‚Äù, ‚ÄúExperience‚Äù] in
the order [Descending, Descending].
13:
select Undergraduate Local Proctors Frame ‚Üê Local Proctors Frame[Level = Undergraduate] ‚ä≤
Choose the undergraduate proctors from the local scheduled proctors frame.
14:
assign the first ns proctors from Undergraduate Local Proctors Frame as supervisors.
15:
save the supervisors in the sheet test idx
16:
remove the chosen supervisors from Local Proctors Frame.
17:
remove the supervisors‚Äô rows from Local Test Frame.
18:
sort lexicographically the Local Test Frame with the priority: [‚ÄúProctors‚Äù, ‚ÄúPosition‚Äù, ‚ÄúStudents‚Äù]
in the orders [Ascending, Ascending, Descending].
19:
paste Local Test Frame with Local Test Frame and define the outcome as Local Programming.
20:
save Local Programming in the sheet test idx of the book Proposed Programming.xls.
21:
end for
22:
save book Proposed Programming.xls
23: end procedure
Table 2: Example of Scheduled Rooms Remark 4

Room
16-223
46-209
46-307
Supervisor 1

Proctors
2
1
2

Students
63
50
80

Table 3: Example of Sorted Rooms Remark 4

Room
46-209
46-307
16-223
46-307
16-223
Supervisor 1

Proctors
1
2
2
2
2

10

Position
1
1
1
2
2

Students
50
80
63
80
63

(i) To understand the line 9 in Algorithm 4 consider the example of Table 2. One supervisor is needed, the
room 46-209 needs one proctor while the rooms 16-223 and 46-307 need two. Hence, a data frame
including positions, has to be created; see Table 3.
(ii) The command of line 18 in Algorithm 4 has the following motivation. Consider the example of Table 2.
Then, line 16 in Algorithm 4 would deliver the table 3 below. It is clear that once the scheduled proctors
are sorted as indicated in line 10 of the algorithm 4, the most experienced proctors will be distributed, as
evenly as possible through the rooms; taking first the rows with one proctor first. The next rows will be
those of 2 proctors with higher number of students having label ‚Äú1‚Äù in the column ‚ÄúPosition‚Äù, here will
be assigned the not so experienced proctors. Next, the less experienced proctors will be assigned to the
rows having ‚Äú2‚Äù in the column ‚ÄúPosition‚Äù, and so forth.
Theorem 5. The computational complexity of Algorithm 4 is O(P log2 P ), where P is the maximum number
of proctors that a test in the round has.
Proof. This is a Greedy Algorithm based on sorting. It is known that the standard MergeSort algorithm
does the job in O(N log2 N), see Section 19.2.2 in [10]
5. The Input Datasets
In the present section we describe the input data files for the RaPIDE‚Ñ¶ system, explain the contents and
structure of each dataset, as well as its motivation. In our study case, a round of tests for the seven courses
is typically scheduled in the span of two weeks. The input files are five: Available Rooms.xls, Room Data.xls,
Personnel Time.xls, Proctor Log.xls and Professors.xls. The first two are concerned with physical spaces, while
the last three accounting for human resources.
5.1. The Available Rooms.xls file
The first input data is the spreadsheet Available Rooms.xls, which contains the structure presented in the
example of Table 4 below. For the School of Mathematics, the first step in programming an examination is to
request the necessary seats for each activity to the University‚Äôs Office of Building Management. The information
sent is summarized in the last three rows of Table 4. Conversely, the Office of Building Management replies
a list of rooms available at the time and date requested and capable of holding the necessary enrollment, see
Table 4 for an example. It should be noticed that there is a slack for all the cases i.e., the total capacity of
the available rooms always exceeds the number of students: DC 1354, IC 1093, VC 626, VAG 1006, LA 626,
ODE 897, MN 402. Consequently, the choice of available rooms can be done so to minimize the number of
necessary proctors.
Remark 5 (Format Available Rooms.xls). Some format guidelines must be observed in the Available Rooms.xls
file for the correct functioning of RaPIDE‚Ñ¶.
(i) The time must include the abbreviation day, a blank space, two digits for each hour and a hyphen in
between: dd TT-TT, e.g., Mo 08-10 instead of Mo 8-10. Of course, the time slots can be modified
according to the scheduling needs (e.g. Monday from 9:00 to 12:00), as long as the format dd TT-TT,
is consistently preserved through the datasets (e.g. the file Personnel Time.xls in Section 5.3).
(ii) The names of the courses (acronyms or not) in the columns can be modified as long as the labels are
consistent with those in the file Professors.xls. Naturally, the columns of the file can be increased or
decreased according to necessity.
(iii) The data in the column ‚ÄúRoom‚Äù, need not be sorted.

11

Table 4: Example of Available Rooms
Room

DC

03-210

30

04-108

29

04-109
04-110

60

IC

VC

VAG

LA

ODE

NM

58

04-111
04-206
05-101
11-102
11-124

65
79
56
22

22

11-125

41

11-202
11-203

39

39

150
43

11-208

50

50

50

11-209
11-225

30

30
60

30
60

14-109
14-232

51
50

49

16-223

63

63

63

63

63

16-224
21-303

60
34

72

60

72
34

60

21-307

52

21-314
21-320

79
64

21-328
21-331

60

50

52
79
64

52

79
64

70
64

79
64

58

30
29

24-307

170

25-301
41-102
41-103

58

90

79

106

102

106
106

106

106

43-110
43-111

54

46-114
46-208

47

47

46-209

50

50

46-210
46-211

52
52

46-212

49

46-301
46-303

44

44
43

46-304
46-307

41
100

41
100

46-311

53
53

56
47
50

50

52

52

52

52
49
44
43
41
100

100

41

Students

1300

1050

608

951

600

822

150

Date
Time

30-III
Sa 12-14

01-IV
Mo 08-10

06-IV
Sa 14-16

01-IV
Mo 10-12

06-IV
Sa 12-14

02-IV
Mo 10-12

05-IV
Mo 08-10

12

(iv) The capacity of each room need not be written on the courses columns, it suffices to write ‚Äú1‚Äù, to indicate
that the room is available for the activity. The system will actually read the value of the room capacity
from the file Room Data.xls (see Section 5.2); however, it may be desirable to write the capacity in this
file, in order to check on the input spreadsheet itself, if the number of available seats is greater or equal
than the number of students.
5.2. The Room Data.xls file
The Room Data.xls sheet centralizes the information about all the classrooms on campus, not only those
needed for the examination activities, see Table 5 for a minimal example.
Table 5: Example of Room Data

Room

Capacity

Observations

03-210

32

Doorkeeper

04-108
04-109

28
70

Key
Access Code

04-207
05-101

70
80

Wheelchair Ramp
Doorkeeper

11-102

56

Card

The table contains the number of seats or capacity of each room and a column of observations where some
annotations can be made such as: how is the room to be opened or if it has accommodations for students
with disabilities. This file is the most stable of all, as it changes only when the nature of the rooms change,
therefore it is less vulnerable to human error than the file Available Rooms.xls; this is why RaPIDE‚Ñ¶ reads the
capacities from this file.
5.3. The Personnel Time.xls file
The third input data for the system is the spreadsheet Personnel Time.xls, it has the structure presented
in the minimal example of Table 6 below. As explained in the introduction the team of proctors is not made of
full-time employees, therefore there are time constraints when scheduling a test. This is particularly acute in
the case of the Teaching Assistants whose labor duties amount to 10 hours per week and their academic duties
may be time-conflicting with the examination activities.
Table 6: Example of Time Personnel

Name

Cell

email

ID

Experience

Level

Mo 10-12

Mo 12-14

Sa 08-10

TA 1
TA 2

C1
C2

1@m.co
2@m.co

ID 1
ID 2

1
2

Undergraduate
Undergraduate

Day Off
Busy

1

1
1

TA 3
TA 4

C3
C4

3@m.co
4@m.co

ID 3
ID 4

1
1

Undergraduate
Undergraduate

1
1

Class
1

1
1

TA 5
TA 6

C5
C6

5@m.co
6@m.co

ID 5
ID 6

2
2

Undergraduate
Postgraduate

1
1

NA
0

1
1

The table contains fields for identification (‚ÄúName‚Äù and ‚ÄúID‚Äù), contact (‚ÄúCell‚Äù, ‚Äúemail‚Äù) and rating (‚ÄúExperience‚Äù and ‚ÄúLevel‚Äù). Finally, the availability fields are represented by multiple time slots; in this minimal
13

example only three time-slots were included: Mo 08-10, Mo 10-12, Sa 08-10. In practice, all possible time-slots
should be contained in the table, namely: Mo 08-10, Mo 10-12, ..., Mo 16-18, Td 08-10, ..., Fr 16-18, Sa
08-10, ..., Sa 16-18.
Remark 6 (Format Personnel Time.xls). The following instructions must be observed when building the Personnel Time.xls sheet.
(i) The time slots dd TT-TT, must be consistent with those of the file Available Rooms.xls (see Remark
5 (iii) Section 5.1) for the system to work properly. They can be modified according to the scheduling
needs (e.g. Monday from 9:00 to 12:00), as long as the consistency between datasets and the format dd
XX-YY are preserved.
(ii) The time slots columns dd TT-TT must indicate whether or not an individual is available. To indicate
availability use ‚Äú1‚Äù.
(iii) Only availability indicated by the number ‚Äú1‚Äù is important for later calculations. In particular, if any other
information is set (e.g. ‚ÄúAvailable‚Äù, ‚ÄúFree‚Äù, ‚ÄúBusy‚Äù, etc.) the system will understand that the individual
is unavailable at that time slot.
(iv) There is no need to indicate unavailability. As shown in the example, the reason why a TA is not available,
can be declared or not. Unavailability can also be marked with a ‚Äú0‚Äù as in the example above. However,
this annotations will not impact on the system.
(v) The column ‚ÄúLevel‚Äù has to be filled with the words ‚ÄúUndergraduate‚Äù or ‚ÄúPostgraduate‚Äù, for the system
to understand the academic level of each TA. Furthermore, this information will play a key role in the
greedy algorithms of the module Crew Organization.xls, see Section 4 and Algorithm 4.
5.4. The Proctor Log.xls file
The Proctor Log.xls is a file containing the record of proctoring duties that the TAs have served in an
observation time-window namely: a term, a semester or a year (depending on the institutional policy). Its structure is presented in the minimal example of Table 7 below and it is fairly similar to that of Personnel Time.xls; it
agrees on the columns holding each TA‚Äôs information. Each of the remaining columns represent an examination
activity that took place in the observation time-window, up to the programming date. For each examination
event, the number ‚Äú1‚Äù indicates that the individual served on it. The column ‚ÄúTotal‚Äù indicates the total number
of shifts the TA has taken so far.
Remark 7. Some observations about this file are the following
(i) When the system is initiated for the first time this file has to contain all the columns holding the information
of each TA (‚ÄúName‚Äù, ‚ÄúCell‚Äù, ‚Äúemail‚Äù, ‚ÄúID‚Äù, ‚ÄúExperience‚Äù, ‚ÄúLevel‚Äù) and the column ‚ÄúTotal‚Äù with value
‚Äú0‚Äù in all its rows.
(ii) Once the system is executed for the next round of tests, an updated file: Updated Proctor Log.xls will
be generated automatically, see Section 6.2 and Table 11 for this file.
5.5. The Professors.xls file
The input file Professors.xls, is a spreadsheet with the structure of the minimal example presented in Table
8 below. Unlike the TAs, the lecturers are full-time employees, therefore they pose no time constraints when
scheduled for proctoring duties. The column ‚ÄúCoordinator‚Äù indicates if the Lecturer is the coordinator of the
course and will be the general supervisor of the examination activity, therefore he/she will not be scheduled for
proctoring testing rooms. The columns ‚ÄúSubject‚Äù, ‚ÄúSubject 2‚Äù indicate which subject are they lecturing in the
academic period.
14

Table 7: Example of Proctor Log

Name

Cell

email

ID

Experience

Level

ODE, 04-II

Total

TA 1
TA 2

C1
C2

1@m.co
2@m.co

ID 1
ID 2

1
2

Undergraduate
Undergraduate

1

0
1

TA 3
TA 4

C3
C4

3@m.co
4@m.co

ID 3
ID 4

1
1

Undergraduate
Undergraduate

1
1

1
1

TA 5
TA 6

C5
C6

5@m.co
6@m.co

ID 5
ID 6

2
2

Undergraduate
Postgraduate

1

1
0

Remark 8. Some observations are
(i) Indicating that a faculty member is a course coordinator must be done with the word ‚Äúyes‚Äù. If any other
character or word is set (e.g. ‚ÄúYes‚Äù, ‚Äú1‚Äù, ‚Äúcoordinator‚Äù) the system will not understand the corresponding
individual as coordinator and will include him/her in the proctoring duties as any other lecturer.
(ii) By default, the system will assign an instructor to proctor only the examination activities of the subject
he/she is lecturing. More specifically, in Table 8 Lec 3 will be assigned to proctor only examinations of
DC.
(iii) Some instructors may have two or more service courses assigned, however, the system takes into account
only the first subject for proctoring duties, e.g., Lec 4 will be assigned to proctor only examinations of
ODE and not those of AL. Therefore, the remaining subjects may be omitted.
(iv) If it is the User Institution‚Äôs policy is to make lecturers participate in the proctoring of every subject they
teach, it suffices to create one more row for the second subject. For instance Lec 6 teaches two subjects,
therefore two rows should be created for he/she, one having ‚ÄúVAG‚Äù in the column ‚ÄúSubject‚Äù, the other
having ‚ÄúDC‚Äù in the same column.
(v) If the User Institution has the policy of having only the TAs proctoring the tests, the column ‚ÄúCoordinator‚Äù
should be filled with the word ‚Äúyes‚Äù. This will suffice to exclude the instructors from the job assignment
(as it does with the actual coordinator), but is important to stress that the Professors.xls file must exist,
with the columns described above (even if it is empty), for RaPIDE‚Ñ¶ to work correctly.

Table 8: Example of Professors file

Name

Coordinator

Subject

Lec 1

yes

Subject 2

Cell

email

VC

C 100

Lec1@m.co

Lec 2

NM

C 200

Lec2@m.co

Lec 3
Lec 4

DC
ODE

AL

C 300
C 400

Lec3@m.co
Lec4@m.co

Lec 5
Lec 6

MD
VAG

DC

C 500
C 600

Lec5@m.co
Lec6@m.co

15

6. The Output Files
In the present section we describe the output files that RaPIDE‚Ñ¶ produces and explain its contents. From the
user‚Äôs point of view, only two files are important: Proposed Programming.xls and Updated Proctor Log.xls,
which will be explained first. However, a developer should understand the other two files which are produced
as an intermediate step towards the final solution, from one system‚Äôs module to the next; these are: Scheduled Rooms.xls and Sheduled Crew.xls
6.1. The Proposed Programming.xls file
The Proposed Programming.xls file is an excel book and it is the ultimate goal of the system. Here, there
is a sheet for each course in the round; in our study case: DC, IC, VC, VAG, LA, ODE and NM. Each sheet has
the structure of Table 9. The fields are Room (code of the room), Envelope (or pack of tests), Observations,
Capacity, Students, Slack, Test, Date, Proctors (number of assigned proctors), Name (name of the assigned
proctors), Cell and email.
Remark 9. Two observations are in order
(i) The number of assigned proctors to a room depends on the number of students. The default value is
one proctor per 54 students, which can be changed by the user at the time of executing RaPIDE‚Ñ¶, see
Section 2.1, Definition 1 to change this value.
(ii) If two (or more) proctors are assigned to one room, two (or more) rows will be equal except for the name
of the proctor (e.g., the first and second row in Table 9). As a consequence of these repetitions, the sum
of the column ‚ÄúStudents‚Äù in this file, will not yield the number of students taking the test, as it happens
in the example at hand.
6.2. The New Proctor Log.xls file
Once the system is executed for a next round of tests, an updated file
New Proctor Log.xls, will be generated automatically. This will have the previous service record and it will
paste it on the left: one column per examination activity. In each column a ‚Äú1‚Äù will be written if the individual
was selected to serve in the corresponding activity and also the ‚ÄúTotal‚Äù column will be updated.
Consider the minimal example presented in Table 11. Here, it is understood that the proctor log file is that
of Table 7 (only one examination ODE on February the 4th took place before) and the system is programming
only one examination in the next round, which is AVG on March the 4th. The updated log of Table 11 writes
the proctoring duties for all the employees and an updated ‚ÄúTotal‚Äù of service.
Remark 10. The following must be observed
(i) Typically, the updated version of the proctors‚Äô log should increase its columns in more than one. In
our study case, the School of Mathematics from Universidad Nacional de Colombia, Sede Medellƒ±ÃÅn, the
update increases seven columns each round, because that is the number of massive courses that RaPIDE‚Ñ¶
manages for the User Institution.
(ii) The more courses that are programmed in one round, the more chances for optimization instances. The
examination rounds need not be equal as some courses may take two midterms, while others take three.
(iii) The file New Proctor Log.xls is created independently from Proctor Log.xls, instead of simply overwriting
it, for security reasons. It will also be useful for later manual corrections, for instance, some employees
selected to proctor may have a license (medical or personal). Due to the random nature of these exceptions,
it will be wiser to handle them manually, by a human supervisor, than trying to incorporate them in the
system.
(iv) Once the round of examinations is over, for the next round of tests, the Proctor Log.xls file must be
replaced by the New Proctor Log.xls file.
16

Table 9: Example of Proposed Programming CV, 608 Students
Room
41-103
41-103
46-307
46-307
46-209
16-224
16-224
21-320
21-320
21-314
21-314
46-210
21-307
16-223
16-223
Supervisor 1

Envelope
1
1
2
2
3
4
4
5
5
6
6
7
8
9
9
na

Observations
Doorkeeper
Doorkeeper
Card
Card
Card
Card
Card
Card
Card
Card
Card
Card
Card
Card
Card
na

Capacity
106
106
80
80
50
72
72
79
79
79
79
52
52
63
63
na

Students
106
106
80
80
50
57
57
79
79
79
79
52
52
53
53
na

Slack
0
0
0
0
0
15
15
0
0
0
0
0
0
10
10
na

Test
VC
VC
VC
VC
VC
VC
VC
VC
VC
VC
VC
VC
VC
VC
VC
VC

Sa
Sa
Sa
Sa
Sa
Sa
Sa
Sa
Sa
Sa
Sa
Sa
Sa
Sa
Sa
Sa

Date
14-16 06-IV
14-16 06-IV
14-16 06-IV
14-16 06-IV
14-16 06-IV
14-16 06-IV
14-16 06-IV
14-16 06-IV
14-16 06-IV
14-16 06-IV
14-16 06-IV
14-16 06-IV
14-16 06-IV
14-16 06-IV
14-16 06-IV
14-16 06-IV

Proctors
2
2
2
2
1
2
2
2
2
2
2
1
1
2
2
1

Table 10: Example of Scheduled Rooms CV, 608 Students
Proctors
Observations
Capacity Students
Slack

Envelope

46-210

1

1

Card

52

52

21-314
16-223

2
3

2
2

Card
Card

79
63

79
53

46-209

4

1

Card

50

46-307
21-307

5
6

2
1

Card
Card

80
52

16-224

7

2

Card

21-320
41-103

8
9

2
2

Card
Doorkeeper

Supervisor 1

na

1

na

Cell
C7
C 41
C 20
C 48
C 65
C 28
C 63
C 23
C 55
C 24
C 59
C 1700
C 2500
C4
C 67
C 46

email
7@m.co
41@m.co
20@m.co
48@m.co
65@m.co
28@m.co
63@m.co
23@m.co
55@m.co
24@m.co
59@m.co
Lec17@m.co
Lec25@m.co
4@m.co
67@m.co
46@m.co

Test

Date

0

VC

Sa 14-16 06-IV

0
10

VC
VC

Sa 14-16 06-IV
Sa 14-16 06-IV

50

0

VC

Sa 14-16 06-IV

80
52

0
0

VC
VC

Sa 14-16 06-IV
Sa 14-16 06-IV

72

57

15

VC

Sa 14-16 06-IV

79
106

79
106

0
0

VC
VC

Sa 14-16 06-IV
Sa 14-16 06-IV

na

na

na

VC

Sa 14-16 06-IV

17

Room

Name
TA 7
TA 41
TA 20
TA 48
TA 65
TA 28
TA 63
TA 23
TA 55
TA 24
TA 59
Lec 17
Lec 25
TA 4
TA 67
TA 46

Table 11: Example of Updated Proctor Log

Name

Cell

email

ID

Experience

Level

ODE, 04-II

AVG, 04-III

Total

TA 1
TA 2

C1
C2

1@m.co
2@m.co

ID 1
ID 2

1
2

Undergraduate
Undergraduate

1

1
1

1

TA 3
TA 4

C3
C4

3@m.co
4@m.co

ID 3
ID 4

1
1

Undergraduate
Undergraduate

1
1

1

2
1

TA 5
TA 6

C5
C6

5@m.co
6@m.co

ID 5
ID 6

2
2

Undergraduate
Postgraduate

1

1

2
0

6.3. The Scheduled Rooms.xls file
The first module of the system Room Decision.py processes the file Available Rooms.xls (see Table 4)
and chooses rooms in order to minimize the number of necessary proctors (see Section 2 for the exposition of
its algorithm). Its results are summarized in the file Scheduled Rooms.xls, which is an excel book having one
sheet for each programmed test in the round. Each sheet has the structure of Table 10. As it can be observed
it is very similar to the Proposed Programming.xls file but without the assigned proctors. This is because the
Scheduled Rooms.xls file is an intermediate step, when only the rooms have been decided. Hence, it is an
internal file, moreover it is part of the input data for the module Personnel Decision.py, which selects a team
of proctors (see Section 3 for the presentation of its algorithm).
6.4. The Scheduled Crew.xls file
The second module of the system Personnel Decision.py processes the input files Personnel Time.xls,
Proctor Log.xls, Professors.xls together with the internal file Scheduled Rooms.xls to make job assignment
decisions based on fairness. More specifically, the system tries to keep as close as possible, the number of shifts
that each TA has in his/her service record. Its decisions are summarized in the file Scheduled Crew.xls, a
minimal (and incomplete) example can be observed in Table 12. At this stage, each examination has a crew of
proctors which can be gathered/identified by the label Test, indicating which test is going to be proctored by
each individual in the file. This file, together with Scheduled Rooms.xls are the input data for the third module,
Crew Organization.py to decide how to organize the previously selected team according to proctoring quality
control (see Section 4 for the explanation of the algorithm).
Table 12: Example of Scheduled Crew file
Cell

Experience

Level

Name

Test

email

C 12

3

Undergraduate

TA 12

LA

12@m.co

C 11

1

Undergraduate

TA 11

ODE

11@m.co

C 10
C 10

2
2

Undergraduate
Undergraduate

TA 10
TA 10

DC
IC

10@m.co
10@m.co

C 800
C 700

10
10

PhD
PhD

Lec 8
Lec 7

LA
DC

Lec8@m.co
Lec7@m.co

18

7. Execution and Problems Description
7.1. Execution
In order to run the program notice that the downloaded folder will contain all the necessary files for a full
example, these are:
(i) The Python scripts: Room Decision.py, Personnel Decision.py, Crew Organizacion.py,
Attendance Lists.py and RaPID-Omega.py.
(ii) The input files: Available Rooms.xls, Room Data.xls, Personnel Time.xls, Proctor Log.xls and Professors.xls.
The program runs from command line on a computer having installed Python 3.4.4 or later using the instruction:
(i) Windows version
python.exe RaPID-Omega.py -t 54 (54 states the student-proctor rate).
(ii) Linux-Mac version
python3 RaPID-Omega.py -t 54 (54 states the student-proctor rate).
Once the program is executed the following files are generated: Scheduled Rooms.xls, Scheduled Crew.xls,
Proctor Log.xls, New Proctor Log.xls and Proposed Programming.xls
7.2. Problems Description and Hints
I. Troubleshooting. The system RaPIDE‚Ñ¶ may present the following problems when starting it
(i) The python version installed in your computer is not 3.4. In such case, you need to modify manually
the first line of the four codes: Room Decision.py, Personnel Decision.py, Crew Organization and
RaPID-Omega.py
(ii) The necessary libraries are not installed. Verify that pandas, scipy and numpy are installed.
(iii) RaPIDE‚Ñ¶ can be run directly from python editors like IDLE or Spider inside Anaconda. Before trying,
make sure it is possible to do it without having to do a conversion format work (this is the case for
Jupyter inside Anaconda).
(iv) Hint. It is highly recommendable that you begin by making run the system in the Full Example folder
(includes full data sets), so you can check RaPIDE‚Ñ¶ works properly on your computer.
(v) Installation. If you require assistance installing on your computer the necessary software to run
RaPIDE‚Ñ¶ check the following websites: Python [12], Numpy and Scipy [13], Pandas [14]. A comfortable installer of python libraries is PIP, see [15]
II. Data basis. The RaPIDE‚Ñ¶ solution depends critically on the input data basis, therefore, these files are
the main source of potential problems which we describe below.
(i) Consistency between data basis. A common source of errors is the consistency of the labels used
across the several data sets. For instance if the time windows used for the tests do not agree in
format with those of the personnel time availability, or that the name of an employee in the data
base Personnel Time.xls, does not agree with his/her name in the file Registro Vigilancias.xls. See
the section 5 for more details and examples.
19

(ii) Repeated data. It is possible that the file Personnel Time.xls and/or Registro Vigilancias.xls present
two or more repeated names. This, due to human error or mere coincidence (two employees with the
same name). This will cause errors in the execution of the program. First, make sure that there are
no mistakes in the names written in both data basis. If by coincidence two or more employees have
the same name differentiate them artificially, e.g., John I, John II, etc.
(iii) Hint. When building your own data sets, start from those in this folder, modifying them one by
one. This way, you can make partial checks to see if your data sets are constructed correctly. If, the
format/structure of the data sets of the Institution/Client at hand is different from those defined
in RaPIDE‚Ñ¶, it is safer (and presumably easier) to develop an independent module migrating the
Institution‚Äôs formats to the RaPIDE‚Ñ¶ formats.
8. Conclusions
The present work delivers the following conclusions
(i) The problem of programming classrooms with proctoring personnel for large scale tests has been analyzed,
dividing the process in three sub-problems: the choice of rooms, the choice of proctoring crews and the
crew organization.
(ii) Each of the three problems is mathematically modeled with an integer programming problem and solved
independently. Its corresponding digital implementation constitutes a module in the RaPIDE‚Ñ¶ system. In
addition, the nature of the problem suggests which input data sets to define, their structure, as well as
the format of the output given by the system.
(iii) The model is successful, practical and flexible. Its good mathematical results, robustness and its correct
implementation are tested by years of service at the School of Mathematics at the National University of
Colombia.
(iv) The computational complexity of the model is the sum of the complexities of each module. The first
module solves the problem with dynamic programming which is solved in pseudo-polynomial time, as
stated in Theorem 2 and a Greedy Algorithm which also runs in polynomial time, see Theorem 3. The
second module uses the Simplex method, the particular usage or RaPIDE‚Ñ¶ (as well as literature on the
field) has shown a polynomial running time average behavior, see Remark 3. The third module uses a mere
Greedy Algorithm which runs in polynomial time as discussed in Theorem 5. It follows that the whole
system runs in polynomial time with respect to the size of the data that is requested to handle.
(v) The modular approach to the problem makes it easy for a programmer to introduce modifications according
to the needs of the Institution at hand. Its spirit is to stay as an open-box system, furnishing the algorithmic
core treatment of the problem.
(vi) The system RaPIDE‚Ñ¶ is coded in python 3.4, therefore is completely free as it uses only free tools and
libraries, even its input and output excel books and sheets can be handled with their corresponding open
versions (Apache, Libre, etc.), because the system does not depend on excel for its computations; it only
uses as input and output format.
Acknowledgements
The Author wishes to thank Universidad Nacional de Colombia, Sede Medellƒ±ÃÅn for supporting the production
of this work through the project Hermes 45713.

20

References

[1] F. A. Morales, Professional Website: free software webpage, https://sites.google.com/a/unal.edu.co/fernando-a-morales-j/home/resear
[2] J. Alberty, C. Carstensen, S. A. Funken, R. Klose, Matlab implementation of the finite element method in elasticity, Computing 69 (3) (2002) 239263. doi:10.1007/s00607-002-1459-8.
URL https://doi.org/10.1007/s00607-002-1459-8
[3] C. Bahriawati, C. Carstensen, Three matlab implementations of the lowest-order raviart-thomas mfem with a posteriori error
control, in: Computational Methods in Applied Mathematics, 2005, pp. 333‚Äì361.
[4] H. Kellerer, U. Pferschy, D. Pisinger, Knapsack Problems, Discrete Mathematics and its Applications, Springer, Berlin,
Heidelberg, Ney York, 2004.
[5] S. Martello, P. Toth, Knapsack Problems: Algorithms and Computer Implementations, Wiley-Interscience series in discrete
mathematics and optimization, John Wiley & Sons Ltd., West Sussex, England, 1990.
[6] M. Conforti, G. CornueÃÅjlos, G. Zambelli, Integer Programming, Graduate Texts in Mathematics, Springer, Switzerland, 2014.
[7] T. H. Cormen, C. E. Leiserson, R. L. Rivest, C. Stein, Introduction to Algorithms, Third Edition, 3rd Edition, The MIT Press,
2009.
[8] D. Bertsimas, J. N. Tritsiklis, Introduction to Linear Optimization, Athena Scientific and Dynamic Ideas, LLC, Belmont, MA,
1997.
[9] R. Johnsonbaugh, Discrete Mathematics, 5th Edition, Prentice Hall, Upper Saddle River, NJ, 2001.
[10] MikloÃÅs BoÃÅna A Walk Through Combinatorics: An Introduction to Enumeration and Graph Theory Fourth Edition, World
Scientific Publishing Company, 2016.
URL https://books.google.com.co/books?id=uZRIDQAAQBAJ
[11] S. Dasgupta, C. Papadimitriou, U. Vazirani, Algorithms, 1st Edition, Education, McGraw-Hill, New York, NY, 2006.
[12] python.org: documentation, https://www.python.org/doc/.
[13] scipy.org: documentation, https://docs.scipy.org/doc//.
[14] pandas.pydata.org: documentation, https://pandas.pydata.org/docs/.
[15] pip.pypa.io: documentation, https://pip.pypa.io/en/stable/.

21

