Multidimensional Dominance Drawings
Giacomo Ortali∗ and Ioannis G. Tollis∗∗
University of Perugia giacomo.ortali@gmail.com
∗∗
Computer Science Department, University of Crete, Heraklion, Crete, Greece
and Tom Sawyer Software, Inc. Berkeley, CA 94707 U.S.A. tollis@csd.uoc.gr

arXiv:1906.09224v1 [cs.DS] 21 Jun 2019

∗

Abstract. Let G be a DAG with n vertices and m edges. Two vertices
u, v are incomparable if u doesn’t reach v and vice versa. We denote
by width of a DAG G, wG , the maximum size of a set of incomparable
vertices of G. In this paper we present an algorithm that computes a
dominance drawing of a DAG G in k dimensions, where wG ≤ k ≤ n2 .
The time required by the algorithm is O(kn), with a precomputation time
of O(km), needed to compute a compressed transitive closure of G, and
extra O(n2 wG ) or O(n3 ) time, if we want k = wG . Our algorithm gives
a tighter bound to the dominance dimension of a DAG. As corollaries, a
new family of graphs having a 2-dimensional dominance drawing and a
new upper bound to the dimension of a partial order are obtained. We
also introduce the concept of transitive module and dimensional neck,
wN , of a DAG G and we show how to improve the results given previously
using these concepts.

1

Introduction

Dominance drawings of directed acyclic graphs (DAGs) are very important in
many areas of research, including graph drawing [7], computational geometry [4],
information visualization[17], even in very large databases [18,20], just to mention a few. They combine the aspect of drawing a DAG on the grid with the
fact that the transitive closure of the DAG is apparently obvious by the dominance relation between grid points associated with the vertices. In other words,
in a dominance drawing a vertex v is reachable from a vertex u if and only if
all the coordinates of v are greater than or equal to the coordinates of u in Γ .
In a DAG G with n vertices and m edges two vertices u, v are incomparable
if u doesn’t reach v and vice versa. We denote by width of a DAG G, wG , the
maximum size of a set of incomparable vertices of G. Notice that it is not possible to find dominance drawings in 2-dimensions for most DAGs. The smallest
number d for which a given DAG G has a d-dimensional dominance drawing is
called dominance drawing dimension, denoted by dG , and it is a known NP-hard
problem to compute it [19]. In this paper we present algorithms for computing
a k-dimensional dominance drawing of G, where k ≥ dG . Our algorithms are
efficient and are based on various decomposition techniques on the DAG.
In 2-dimensions the dominance drawing method for planar DAGs has many
important aesthetic properties, including small number of bends, good vertex
placement, and symmetry display [4,3]. A 2-dimensional dominance drawing Γ

of a planar DAG G can be computed in linear time, such that for any two vertices
u and v there is a directed path from u to v in G if and only if x(u) ≤ x(v) and
y(u) ≤ y(v) in Γ [4,3]. Since most DAGs have dominance dimension higher that
two, the concept of weak dominance drawings was introduced in [10,11]. This
concept has many applications including the drawing of DAGs in the overloaded
orthogonal model [12]. In weak dominance, for any two vertices u and v if there
is a directed path from u to v in G then x(u) ≤ y(v) and y(u) ≤ y(v) in
Γ . However, the reverse does not hold. Hence, we have a falsely implied path
(fip) when x(u) ≤ y(v) and y(u) ≤ y(v), but there is no path from u to v.
Kornaropoulos and Tollis [10] proved that the problem of minimizing the number
of fips is NP-hard and gave some upper bounds on the number of fips.
Several researchers adopted the concept of weak dominance drawing in order
to construct a compact representation of the reachability information of very
large graphs that are produced by very large datasets in the database community [18]. Li, Hua, and Zhou considered high dimensional dominance drawings
in order to reduce the number of fips and obtain efficient solutions to the reachability problem [13]. Namely, they use high dimensional dominance drawings in
order to reduce the number of fips and describe heuristics to obtain a system
that resolves reachability queries in linear (or constant) time as demonstrated
by their experimental work [13].
In this paper we present an algorithm, called kD-Draw, that computes a
dominance drawing of a DAG G in k dimensions, where wG ≤ k ≤ n2 . The
time required by the algorithm is O(kn), with a precomputation time of O(km),
needed to compute a "special" transitive closure of G, called compressed transitive closure. If we want to have k = wG then an extra O(n2 wG ) or O(n3 ) time is
required to find a proper decomposition of G. Algorithm kD-Draw defines a new
upper bound to the dominance dimension of a DAG. As corollaries we obtain
(a) a new family of graphs that admit a 2-dimensional dominance drawing and
(b) a new upper bound to the dimension of a partial order. We also introduce
the concepts of transitive modules and dimensional neck wN of a DAG G and
we show how to use them in order to improve our results using these concepts.
Our paper is structured as follows: In Section 2 we describe necessary preliminary results. In Section 3 we first introduce the new dominance drawing
technique for 2 dimensions, and then these results are extended to k dimensions.
We introduce a new upper bound to the dominance dimension of a DAG and we
discuss some additional implications of the results of this section. In Section 4 we
introduce the concept of transitive modules and we use it to improve the upper
bound on the number of dimensions presented in the previous section. In Section 5 we present our conclusions and we discuss interesting open problems that
naturally arise from our two different approaches to k-dimensional dominance
drawing.
2

2

Preliminaries

Let G = (V, E) be an directed acyclic graph (DAG) with n vertices and m edges.
An st-graph is a DAG with one source s and one sink t. In order to simplify our
presentation, for the rest of the paper we will assume that every DAG is an
st-graph. We do it without loss of generality, since we can obtain an st-graph
from any DAG by adding a virtual source and a virtual sink and connecting
them to all sources and sinks, respectively. Testing if G has dominance drawing
dimension 2 requires linear time [15], while testing if its dimension is greater
than or equal to 3 is NP-complete [19]. An efficient algorithm to compute 2dimensional dominance drawings for planar st-graphs is shown in [3]. A partial
order is a mathematical formalization of the concept of ordering. Any partial
order P can be viewed as a transitive DAG. The results obtained for DAGs and
their dominance drawing dimension transfer directly to partial orders and their
dimension and vice-versa. Hence, we can talk about the results known for partial
orders and for DAGs with no distinction. In [8] Hiraguchi proved a theorem that
gives a tight upper bound on the dominance dimension of G, which is n2 , as
shown in the following lemma [8] (for a different proof, see [1]):

Lemma 1. The dominance dimension of an st-graph G having n vertices is at
most n2 . In other words: dG ≤ n2 .
Now we introduce the concept of channel, which is a generalization of the
concept of path. Then we will introduce a graph decomposition into channels,
called channel decomposition. This decomposition will be used in the next section
to improve the upper bound stated in Lemma 1.
A channel C is an ordered set of vertices such that, given any two vertices
v, w ∈ C, v precedes w in the order of channel C if and only if w is reachable from
v in G. If u precedes v in the order of a channel C then v is a successor of u in
C. We denote by channel decomposition of G a set of channels Sc = {C1 , ..., Ck }
so that the source s and the sink t of G are contained in every channel and every
other vertex of G is contained in exactly one channel. The number of channels
of a decomposition Sc is called size of Sc .
Figure 1 shows an st-graph and a minimum size channel decomposition of it.
The source and the sink of the st-graph G depicted in Part (a) are respectively
0 and 15. Red edges of Part (b) connect two consecutive vertices of a same
channel. The dashed red edges represent edges of the transitive closure of G
that do not belong to G. The channel decomposition showed in Part (b) is Sc =
{C1 , C2 , C3 , C4 }, where: C1 = {0, 1, 4, 5, 12, 13, 15}; C2 = {0, 3, 7, 11, 15}; C3 =
{0, 2, 6, 10, 14, 15}; C4 = {0, 8, 9, 15}. Notice that this channel decomposition is
minimum, since the width of G is four. We will revisit this graph and will show
a different dominance drawing obtained using the concept of transitive modules
that we will introduce in Section 4.
3

15

15
14

13
11
5

14

13

C3

12

12
10
9

7

4

C1
5

6

3

C2
4

11

10
9

7
6

3

8

8

C4

2

2

1

1

0

0

(a)

(b)

Fig. 1: (a) An st-graph and a channel decomposition of it, with source 0 and sink 15.
(b) A minimum size channel decomposition of G is Sc = {C1 , C2 , C3 , C4 }, where: C1 =
{0, 1, 4, 5, 12, 13, 15}; C2 = {0, 3, 7, 11, 15}; C3 = {0, 2, 6, 10, 14, 15}; C4 = {0, 8, 9, 15}.

2.1

Minimum Size Channel Decomposition

In this section we introduce the concept of width of an st-graph and we give
a short description of an algorithm that computes a minimum size channel decomposition of an st-graph. Two vertices u, v ∈ V are incomparable if u doesn’t
reach v and vice versa. We denote by width of a DAG G, wG , the maximum size
of a set of incomparable vertices of G. Computing the width of a graph requires
linear time [9]. Additionally, the following result is proved in [5]:
Lemma 2. The minimum size of a channel decomposition of G is equal to the
width wG of G.
Jagadish [9] presented an algorithm to compute a channel decomposition with
the minimum number of channels in O(n3 ) time. To make our paper self-contained,
in the next paragraph we outline a simple variation of this algorithm.
First we compute a graph G0 from G such that: (a) any vertex v of G is
associated with exactly two vertices of G0 , that we call xv and yv ; (b) (xv , yv )
is an edge of G0 for any couple of vertices xv , yv ; and (c) each edge (u, v) of
G is associated with an edge (yu , xv ) of G0 . Any channel C = (s, vi , ..., vj , t)
starting from the source s and ending at the sink t of G corresponds to a channel
C 0 = (xs , ys , xvi , yvi , ..., xvj , yvj , xy , yt ) of G0 . Now we solve the standard maxflow problem on the acyclic graph G0 by techniques such as [6]. In order to find
a channel C of G from the flow of G0 we firstly add vertex s as the first element
of C and we decrease the flow sent through edge (xs , ys ) by one; then, if v is the
last vertex added to C, we look for an edge (yv , xu ) having a positive flow, we
decrease its flow by one and we add u as the last element of C. We repeat this
process until t is added to C. We find channels until every vertex of G belongs
to at least one channel. A vertex could be inserted to more than one channels;
in this case we simply remove it from all the channels it belongs to, except for
one. The computed channels constitute a minimum size channel decomposition.
4

A faster algorithm, that runs in in O(wG n2 ) time, to compute a channel
decomposition with the minimum number of channels is presented in [2]. We call
this algorithm "Algorithm Channels-Generation". Hence, we have the following
lemma:
Lemma 3. Algorithm Channels-Generation computes a channel decomposition
of a DAG G having wG channels in O(wG n2 ) time.

2.2

Projections and Compressed Transitive Closure

Now we are ready to introduce the concept of projection of a vertex v on a
channel C. We will also briefly talk about a data structure, called compressed
transitive closure, that can be used to store all the projections for any vertex
efficiently. The projections of a vertex v will be used to decide its coordinates in
all the dimensions of our multidimensional dominance drawing.
We denote by u = (i, j) the fact that u is the jth vertex of channel Ci . By
the definition of channel decomposition we have t = (i, |Ci |) and s = (i, 0) for
any i ∈ [1, k]. We denote by projection of a vertex u ∈ V on a channel C ∈ S
the vertex v ∈ C having the lowest position in C among all the vertices of C
reachable from u. We denote it by P rojC (u) = v, if u ∈ C then P rojC (u) = u.
Notice that all the vertices can reach at least a vertex of every channel, since
the sink t of the graph belongs to all the channels. Hence, the projection uC is
defined for any couple (u, C) ∈ (V, Sc ).
The following lemma is immediate by the definition of projection:
Lemma 4. Let u ∈ V be a vertex and let P rojCi (u) = v = (i, j) be the projection of u on Ci ; u can reach a vertex v 0 = (i, j 0 ) ∈ Ci if and only if j 0 ≥ j.
Lemma 4 shows that we can use the projections to study the reachability
properties of G. Jagadish describes in [9] a data structure that we can use to
store all the projections of any vertex of G efficiently. This data structure is called
compressed transitive closure. In the same paper he shows how to compute the
compressed transitive closure of G in O(km) time, store it in O(kn) space and
use it to read any projection P rojC (u) = v for any vertex u and any channel C
in constant time.
Figure 2 shows a representation of the compressed transitive closure of graph
G depicted in Figure 1(a) given a channel decomposition of it, which is depicted
in Figure 1(b). In order to have a better visualization, we restrict the representation of the compressed transitive closure to only two channels. Figure 2(a)
shows the compressed transitive closure restricted to channels C1 and C2 . The
red edges connect vertices of the same channel. Let u and v be two vertices not
belonging to the same channel. A gray edge (u, v) indicates that v is the projection of u on the channel of vertex v. Part (b), Part (c), Part (d), Part (e),
Part (f) represent the compressed transitive closure for the pairs of channels:
(C1 , C3 ), (C1 , C4 ), (C2 , C3 ), (C2 , C4 ) and (C3 , C4 ), respectively.
5

15
13

C2

12

C1
5

15

4

15

C3

12

11

C1

7

5

10
4

3

C4

14

13

13
12

C1
5

6

9
4
8

2

1

1

1

0

0

(a)

0

(b)

(c)
15

15

15

14

14

C3
C2

11

C3

10

C2

7
6

3

10

11

9
9

7

3
8

6

C4

8

C4

2
2
0

(d)

0

0

(e)

(f)

Fig. 2: Representation of the compressed transitive closure of graph G depicted in Figure 1(a) given the channel decomposition of it that is depicted in Figure 1(b). In order to
have a clearer figure, we restrict the representation of the compressed transitive closure
by showing pairs of channels at a time.

6

3

Multidimensional Dominance Drawing

Let Sc = {C1 , ..., Ck } be a channel decomposition of size k of st-graph G =
(V, E). In this section we explain how we can use Sc and the projections of the
vertices of G in order to create a dominance drawing of G in k dimensions.
In Subsection 3.1 we present Algorithm 2-Dimensional-Draw (or simply 2DDraw), that, for k = 2, computes a 2 dimensional dominance drawing of G.
In Subsection 3.2 we extend the 2-dimensional algorithm by introducing Algorithm k-Dimensional-Draw (or simply kD-Draw), that computes a k dimensional
dominance drawing of G for any channel decomposition of size k.

3.1

Base case: 2 Channels

Let Sc = {C1 , C2 } be a channel decomposition of an st-graph G = (V, E) of
size 2. We will present Algorithm 2D-Draw that receives as input G and Sc and
produces a two dimensional dominance drawing Γ of G.
The algorithm uses the order of the vertices in each channel, C1 and C2 , in
order to assign X and Y coordinates to the vertices of C1 and C2 . Then the
algorithm assigns appropriate X coordinates to the vertices that do not belong
to channel C1 and Y coordinates to the vertices that do not belong to channel
C2 . It does this by assigning an X-coordinate to each vertex in C2 using the
corresponding projection’s X-coordinate, that was already assigned before (as
shown in Line 4). Similarly, it assigns a Y -coordinate to each vertex in C1 using
the corresponding projection Y -coordinate, that was already assigned before (as
shown in Line 6). This process is shown in Lines 7-12.
Algorithm 2D-Draw(G, Sc )
1.
Γ = new 2-dimensional drawing
2.
For any v = (i, j) ∈ V :
3.
If (i = 1):
4.
X(v) = j
5.
Else:
6.
Y (v) = j:
7.
For any v ∈ C1
8.
P rojC2 (v) = (2, j)
9.
Y (v) = j
10. For any v ∈ C2
11.
P rojC1 (v) = (1, j)
12.
X(v) = j
13. output: Γ

Figure 3 is an illustration of Algorithm 2D-Draw. Part (a) shows an stgraph G. The source of G is vertex 0 and the sink of G is vertex 7. Part (b)
shows a channel decomposition Sc = {C1 , C2 } of G, where: C1 = {0, 3, 4, 7};
C2 = {0, 1, 2, 5, 6, 7}. Part (c) shows the projections of the vertices of G on
7

the channels they don’t belong to. Part (d) shows the X coordinate assignment
for the vertices of C1 and the Y coordinate assignment for the vertices of C2 .
These assignments are shown by writing the number of a vertex next to the
corresponding coordinate; this is performed in Lines 2-6 of Algorithm 2D-Draw.
Part (e) shows the assignment of the other coordinate to every vertex of G,
that performed by Algorithm 2D-Draw in Lines 7-12 by using the projections of
the vertices. For example, The projection of vertex 1 of channel C2 is 4, hence,
X(1) = X(4).

7

7

C2
6

6

7

C2

C1

C1

6

5

4

5

4

5

4

2

3

2

3

2

3

1

1

1
0

0

(a)

0

(b)

(c)
Y

Y
5

7

4

6

3

5

2

2

1

1

0 0
0

4

7
6

3

5
2
1

3

4

7

1

2

3

X

X

(d)

(e)

Fig. 3: Illustration of Algorithm 2D-Draw: (a) an st-graph G; (b) a two-channel decomposition Sc = {C1 , C2 } of G, where: C1 = {0, 3, 4, 7}; C2 = {0, 1, 2, 5, 6, 7}; (c)
the projections of the vertices of G on the channels they do not belong to; (d) the X
coordinate assignment for the vertices of C1 and the Y coordinate assignment for the
vertices of C2 ; (e) the assignment of the other coordinate of every vertex of G.

We denote by r(u, v) = yes the fact that there exists a path starting from
u and ending at v in G and by r(u, v) = no the fact that this path does not
exist. Let Γ be a drawing of G. We denote by u  v the fact that all the
coordinates of u are less than or equal to the coordinates of v in all dimensions
8

of Γ . The main result of this subsection is that Algorithm 2D-Draw computes
a 2-dimensional dominance drawing of G. In other words, we prove that, for
any u, v ∈ G: r(u, v) = yes ⇔ u  v. This result will be proved in Lemma 8.
Before we are able to prove that however, we need the following three lemmas
(Lemma 5, Lemma 6 and Lemma7) that will be used in the proof of Lemma 8.
Lemma 5. Any two distinct vertices v, w ∈ V are placed on distinct points in
Γ.
Proof. Let v = (1, j) and u = (h, l) be two different vertices. Without loss of
generality we suppose that v ∈ C1 . We have two cases: (1) u ∈ C1 ; (2) u ∈ C2 .
We need to prove that X(v) 6= X(u) or Y (v) 6= Y (u):
1. h = 1 and u = (1, l). We have X(v) = j 6= l = X(u), since in this case j = l
would imply that v and u are the same vertex.
2. h = 2 and u = (2, l). Let v 0 = P rojC2 = (2, l0 ) and u0 = P rojC1 = (1, j 0 ) be
the projections of v and u. According to the algorithm X(v) = j, Y (v) = l0
and X(u) = j 0 , Y (u) = l. The vertices v and u would be placed in the same
point if and only if l = l0 and j = j 0 , thus v = u0 and u = v 0 . In this case
r(v, u) = yes and r(u, v) = yes by definition of projection, so there must
be a cycle in G. This is a contradiction, since G is a DAG. Consequently
X(v) 6= X(u) or Y (v) 6= Y (u).
Lemma 6. Let v be a vertex of G. The source s is dominated by v and the sink
t dominates v in Γ . In other words: X(s) ≤ X(v) ≤ X(t) and Y (s) ≤ Y (v) ≤
Y (t).
Proof. Algorithm 2D-Draw places s such that X(s) = Y (s) = 0 and it places
t such that X(t) = |C1 | and Y (t) = |C2 |. Moreover, it places any v such that
0 ≤ X(v) ≤ |C1 | and 0 ≤ Y (v) ≤ |C2 |.
Lemma 7. Let u and v be two vertices of G. If u ∈ C1 : r(u, v) = yes ⇔ X(u) ≤
X(v). Else, if u ∈ C2 : r(u, v) = yes ⇔ Y (u) ≤ Y (v).
Proof. If u ∈ C1 Algorithm 2D-Draw places v such that X(v) = j, where
P rojC1 (v) = (1, j). If u ∈ C2 Algorithm 2D-Draw places v such that Y (v) = j,
where P rojC2 (v) = (2, j). The proof is given by Lemma 4.
Now, we are ready to prove Lemma 8, which states that Algorithm 2D-Draw
computes a dominance drawing.
Lemma 8. Drawing Γ = 2D-Draw(G, Sc ), computed by Algorithm 2D-Draw is
a dominance drawing.
Proof. Let v = (1, j) and u = (h, l) be two vertices, and assume without loss
of generality, that v ∈ C1 . If u or v is the source or the sink the theorem is
true by Lemma 6. Recall that by Lemma 5 Algorithm 2D-Draw never places
two distinct vertices on the same point of Γ . Hence, in order to prove that Γ is
a dominance drawing we have to prove: u  v ⇔ r(u, v) = yes. By Lemma 7
9

we have that: u  v ⇒ r(u, v) = yes. Thus we have to prove the following:
u  v ⇐ r(u, v) = yes. For that, suppose that u is reachable from v. Let u0 , v 0
be the projections of u, v on the channel they don’t belong to, respectively. If
r(u, v) = yes we have two cases: (1) v and u are in the same channel or (2) they
belong to different channels.
1. Let v 0 = P rojC2 (v) = (2, j 0 ) and u0 = P rojC1 (u) = (2, l0 ) be the projections
of v and u. We have that l < j, since r(u, v) = yes and by definition of
channels, therefore X(u) = l < j = X(v). If u0 is a successor of v 0 then
there is a cycle, therefore u0 = v 0 or v 0 is a successor of u0 . This implies that
l0 ≤ j 0 , which implies that Y (u) ≤ Y (v), since Y (v) = j 0 and Y (u) = l0 .
Hence, u  v.
2. In this case v = (1, j), u = (2, l), u0 = P rojC1 (u) = (1, l0 ) and v 0 =
P rojC2 (v) = (2, j 0 ). We have X(v) = j, X(u) = l0 and r(u, v) = yes. By
Lemma 7 we conclude X(u) ≤ X(v). We have Y (v) = j 0 and Y (u) = l.
Additionally, if it were Y (v) = j 0 < l = Y (u) then r(v, u) by Lemma 7.
In this case G has a cycle, which is a contradiction. Since by hypothesis
r(u, v) = yes therefore Y (u) = l ≤ l0 = Y (v) and u  v.

3.2

Generalization: from 2 to k Channels

In this subsection we extend the result obtained above by showing how to construct dominance drawings in k dimensions. The algorithm that we present is
called Algorithm kD-Draw. The input to the algorithm is a graph G and a
channel decomposition with k channels, Sc = {C1 , ..., Ck }. The output of the
algorithm is a dominance drawing Γ of G in k dimensions. Similar to the two
dimensional case, the k-dimensional algorithm uses the order of the vertices in
each channel, C1 , ..., Ck , in order to assign coordinates, D1 , ..., Dk . Clearly, in
the previous section we had k = 2, and the dimensions were called D1 = X and
D2 = Y .
Given any vertex v = (i, j) ∈ Ci , Algorithm kD-Draw will assign the ith
dimension of v as Di (v) = j. Then the algorithm assigns appropriate coordinates Dh (v), for all h 6= i, as follows: Dh (v) = l, where l is the position of the
corresponding projection of v in channel Ch , i.e., u = P rojCh (v) = (h, l). In
other words, the position of u in channel Ch . This is done for all vertices and all
dimensions/channels.
Algorithm kD-Draw(G,Sc = {C1 , ..., Ck })
1.
Γ = new k-dimensional drawing
2.
For any v = (i, j) ∈ V :
3.
Di (v) = j
4.
For any v ∈ V :
5.
For any Ch ∈ Sc such that v 6∈ Ch :
6.
P rojCh (v) = (h, l)
7.
Dh (v) = l
8.
output: Γ
10

Figure 4 shows an illustration of Algorithm kD-Draw. The input of the algorithm is the same graph G as depicted in Figure 1(a) and the channel decomposition Sc of G as depicted in Figure 1(b). In this case k = 4, hence, Algorithm
kD-Draw will produce a 4-dimensional dominance drawing of G. Part (a) shows
the initialization step, where the algorithm assigns the value of the coordinate
in the dimension Di for every vertex v ∈ Ci (0 ≤ i ≤ 4). These assignments
are shown by writing the number of a vertex next to the corresponding coordinate; this operation is performed in Lines 2-3 of the algorithm. Part (b) shows
the assignment of the other coordinates. The vertex placement is performed by
kD-Draw in Lines 4-7 by using the projections of the vertices, which are shown
in Figure 2. We do not show the edges on the graph, since in the depicted two
planes of the 4-dimensional drawing some vertices are positioned in a same point
and it could create ambiguities in the representation of the edges.
Clearly, if k = 2, kD-Draw and 2D-Draw compute the same drawing. Hence,
kD-Draw is a generalization of 2D-Draw. As we did in the previous section, before proving that Γ = kD-Draw(G, Sc ) is a dominance drawing we prove some
intermediate results.
Lemma 9. Any two distinct vertices v, w ∈ V are placed on distinct points in
Γ.
Proof. Let v = (i, j) and u = (h, l) be two vertices of G. It is sufficient to prove
that there exists at least one dimension Dx such that Dx (v) 6= Dx (u) for any
pair of vertices u, v. Following arguments similar to the ones used in the proof
of Lemma 5 it is easy to prove that Di or Dh can be Dx .
The following two lemmas can be proved using similar arguments to the ones
used to prove Lemma 6 and Lemma 7:
Lemma 10. For any vertex v ∈ G: s  v and v  t.
Lemma 11. Let u ∈ Ci and v be two vertices of G. r(u, v) = yes ⇔ Di (u) ≤
Di (v).
We are ready now to prove the main result of this section:
Theorem 1. Let G be an st-graph and Sc = {C1 , ..., Ck } be a channel decomposition of G. Given G, Sc and the set of all the projections for any vertex
(provided by the compressed transitive closure), Algorithm kD-Draw computes a
k-dimensional dominance drawing Γ of G. Moreover:
(a) kD-Draw requires O(kn) time.
(b) A preprocessing step required to compute all the projections of the vertices of
G takes time O(mk).
(c) If k is required to be equal to the width of G, wG , then the preprocessing step
requires time O(n3 ) or O(wG n2 ).
11

D2
4

15

D4

3

11

3

15

2

7

2

9

1

3

1

8

1

0

0
0

1

4

5

2

3

13

12
4

15
6

5

0

0

D1

0

2

6

10

14

15

1

2

3

4

5

D3

(a)

D2
12
5
2,4
1

0

6,8,9,10,14,15

13

D4
10

11
6

7
1,2
3

D1

0

3,4,5,7,11,12,13,14,15
9

8

D3

(b)
Fig. 4: Illustration of Algorithm kD-Draw on graph G depicted in Figure 1(a) and the
channel decomposition Sc of G depicted in Figure 1(b): (a) shows the initialization
step, where the algorithm assigns the value of the coordinate in dimension Di for every
vertex v ∈ Ci (0 ≤ i ≤ 4); (b) shows the assignment of the other coordinates, computed
by Algorithm kD-Draw in Lines 4-7 by using the projections of the vertices, as shown
in Figure 2. We do not show the edges of the graph, since in the depicted two planes
of the 4-dimensional drawing some vertices are positioned in a same point and it could
create ambiguities in the representation of the edges.

12

Proof. First, we prove the correctness of the algorithm, i.e., we prove that the
drawing computed by our algorithm is a dominance drawing. Then we will prove
the time complexity of the algorithm. Let v = (i, j) and u = (h, l) be two
different vertices. If u or v are the source or the sink the theorem is clearly
true by Lemma 10. Otherwise, without loss of generality, suppose that i = 1
i.e., v = (1, j). Lemma 9 proves that u and v are never placed in a same point.
Moreover, Lemma 11 proves that u  v ⇒ r(u, v) = yes. We need to prove that:
r(u, v) = yes ⇐ u  v. Let Dp be a dimension of Γ (p ∈ [1, k]). We prove that
Dp (u) ≤ Dp (v) for any possible value of p. First we assume that p = i or p = h.
Next, we consider all other cases.
1. We can prove that Dp (u) ≤ Dp (v) using arguments similar to the ones used
in Case (1) of the proof of Lemma 8.
2. Suppose u0 = P rojCp (u) = (p, l0 ) and v 0 = P rojCp (v) = (p, j 0 ). We have
r(u, v 0 ) = yes, since r(u, v) = yes and r(v, v 0 ) by definition of projection.
The vertex u0 has the lowest position in Cp among the vertices of Cp reachable
from u. Therefore it must be equal to v 0 or one of its successors. Consequently
l0 ≤ j and Dp (u) ≤ Dp (v).
Finally, regarding the computational time:
(a) kD-Draw needs O(n) time for the Lines 2-3 and O(nk) time for the Lines
4-7 by Lemma 4.
(b) We store the projections of the vertices of G in a compressed transitive
closure. The time needed to compute the compressed transitive closure is
O(km) [9].
(c) A channel decomposition with the minimum number of channels, k, can be
computed in O(n3 ) or O(wG n2 ) time [9,2].
Dominance Drawing with Distinct Coordinates is a dominance drawing where the value of the coordinates of the vertices in every dimension is a
topological sorting of the vertices (i.e., distinct coordinates). In the rest of the
section we show how we can compute a k-dimensional dominance Drawing with
distinct coordinates ΓT of G given a k-dimensional dominance drawing Γ of G.
Suppose that the vertices of G are topologically sorted and let T (v) be the
order of vertex v in the topological sorting. Let Dg be a dimension of Γ and let
{v1 , ..., vl } be the set of vertices having the same coordinate in dimension Dg ,
i.e., Dg (v1 ) = Dg (v2 ) = ... = Dg (vl ) = α. Suppose T (v1 ) < T (v2 ) < ... < T (vl ).
Let Vα,g be the set of vertices having coordinate higher than α in dimension
Dg . We shift the vertices of Vα,g by l positions and we shift every vertex vi ,
i = 1, 2, ..., l by i − 1 positions. We do continue with this process until there is no
pair of vertices placed in the same position. It is easy to see that the resulting
drawing ΓT is a dominance drawing with distinct coordinates.
Figure 5 shows a dominance drawing with distinct coordinates obtained from
the dominance drawings shown in Figure 4(b).
13

D2
15
14
10
9
8
6
13
12
11
5
7
4
2
3
1
0

D1
D4
15
14
13
12
11
7
5
4
3

10
9
6
8
2
1
0

D3
Fig. 5: A dominance drawing with distinct coordinates obtained from the drawings shown
in Figure 4(b)

14

3.3

Corollaries

The dominance drawing algorithm presented above provides interesting corollaries in the general dimension theory of DAGs. Namely, the following corollary is
a direct consequence of Lemma 1, Lemma 2 and Theorem 1. We point out that
Algorithm kD-Draw provides a new upper bound to the dominance dimension
of an st-graph:
Corollary 1. Let G be any st-graph (or DAG) with n vertices. Then dG ≤
min( n2 , wG ).
As discussed in the introduction, any st-planar graph has a 2-dimensional dominance drawing [4,3]. The next corollary presents a new family of DAGs that have
a 2-dimensional dominance drawing. Obviously these DAGs are not contained
in the st-planar family.
Corollary 2. Every DAG G of width 2 has a 2-dimensional dominance drawing.
As discussed in the preliminaries, a partial order is a mathematical formalization on the concept of ordering and the results obtained for DAGs and their
dominance drawing dimension transfer directly to partial orders and their dimension and vice versa. Therefore, let dP be the dimension of partial order P .
As a consequence of the previous corollary we have the following:
Corollary 3. Let P be any partial order with n elements. Then dP ≤ min( n2 , wP ).

4

Modules and Dominance Drawings

In this section we will exploit the concept of modules in directed acyclic graphs
in order to obtain dominance drawings having potentially less dimensions. Let
G = (V, E) be an st-graph with n vertices and m edges. A module M of G
is a non-empty subset of V such that all vertices in M have the same sets of
predecessors and successors in V − M . Decomposing a graph into modules may
help in various graph problems [16].
The trivial modules of G are: the set V and the singleton sets {v}, for any
v ∈ V . A graph is called prime if it does not possess non-trivial modules. Two
modules overlap if they have a non empty intersection, and one does not contain
the other. A module is a strong module if it does not overlap with any module,
otherwise it is a weak module.
A modular decomposition of G is a representation of all modules of G. The
decomposition forms a tree, whose nodes are the strong modules of G, ordered
by the subset relationship. In particular, the root of the modular decomposition
tree is V , and its leaves are the singleton sets.
The congruence partition CP = {M1 , ..., Mh } of V is a partition of V into
modules (i.e., each vertex belongs to exactly one module Mi , with 1 ≤ i ≤ h).
It is easy to obtain a congruence partition from a modular decomposition. Each
DAG has an exponential number of congruence partitions [14,16]. The quotient
graph G0 of G given CP is the graph obtained from G by merging the nodes
15

of each module in CP . We denote by µi the vertex representing Mi in G0 . The
following lemma is true due to the definitions of module and of quotient graph:
Lemma 12. Let u, v be two vertices of G such that u ∈ Gi and v ∈ Gj . Vertex
µj is reachable from vertex µi in G0 if and only if v is reachable from u in G.
Let G∗ be the transitive closure of G. A module M of G∗ is a transitive
module of G. The transitive congruence partition CP of V is a partition of V into
transitive modules. The transitive quotient graph G/CP is the graph obtained
from G by merging the nodes of each transitive module in CP .
Figure 6(a) shows a transitive congruence partition CP = {M1 , M2 , M3 , M4 }
of the graph G depicted in Figure 1(a), where: M1 = { 0, 1, 2}; M2 = {3, 4, 5,
7, 11, 12, 13}; M3 = {6, 8, 9, 10}; M4 = {14, 15}. Figure 6(b) shows the quotient
graph G0 of G given CP .

15

M4
14

13

µ4
G0

M2 12
11
5

10

4

M3

6

3

µ3

µ2

9

7

8

µ1

2
1
0

M1

(a)

(b)

Fig. 6: (a) A transitive congruence partition CP = {M1 , M2 , M3 , M4 } of graph G shown
in Figure 1(a), where: M1 = {0, 1, 2}; M2 = {3, 4, 5, 7, 11, 12, 13}; M3 = {6, 8, 9, 10};
M4 = {14, 15}; (b) the quotient graph G0 .

A modular decomposition of G can be computed in linear time [14,16]. Hence,
computing a transitive modular decomposition of G requires O(nm) times, since
it is equivalent to computing the modular decomposition of G∗ . From now on
we will only deal with transitive modules, transitive congruence partitions and
transitive quotient graph, so in our description we will omit the term "transitive".
Let CP = {M1 , ..., Mh } be a congruence partition of G and let G0 be the
quotient graph G/CP . We denote by µi the vertex representing Mi in G0 . We
denote by module-induced graph of Mi the graph Gi = (Mi , E(Mi )), where
E(Mi ) is the subset of edges of E which are incident to two vertices of Mi .
Without loss of generality we assume that every Gi is an st-graph. If Gi is not
an st-graph we do the operations described in the next paragraph.
16

If Gi contains the source of the graph, we add a virtual sink ti to it; if it
contains the sink of the graph, we add a virtual source si to it; else, we add a
virtual source si and a virtual sink ti to it. Then: we add some edges connecting
all the vertices of V − Mi reaching Mi to si ; we add some edges connecting ti
to all the vertices of V − Mi reached by Mi ; we remove all the edges of V − Mi
adjacent to a vertex of Mi different from si and ti .
Figure 7 shows the graph obtained by adding a sink and a source to every
module of the graph depicted in Figure 6 following the steps described in the
above paragraph.

15 = t4

M4
t2

14

s4

13

M2

12

t3

11
5

10

7

4

M3
9

6

3

8

t1

s2

s3
M1
2

1
0 = s1

Fig. 7: The graph obtained from the graph G shown in Figure 6 after adding a sink and
a source to every module of the G.

Figure 8 shows the induced graphs of graph G shown in Figure 7.
Let G(CP ) = {G0 , G1 , ..., Gh } be the set of all the module-induced graphs of
G augmented with G0 . We denote by wi the width of Gi (i.e., wGi = wi ). We
denote by dimensional neck wN of CP and G(CP ) the value of the maximum
width among all the graphs in G(CP ). Any graph Gi ∈ G(CP ) is isomorphic
to a subgraph of G∗ and the width of G is equal to the width of it s transitive
closure. Hence, wN ≤ wG∗ = wG .
Let G(CP ) = {G0 , G1 , ..., Gh } be the set of all the module-induced graphs
of G augmented with G0 . We denote by wi the width of Gi (wGi = wi ). We
denote by dimensional neck wN of CP and G(CP ) the value of the maximum
width among all the graphs in G(CP ). Any graph Gi ∈ G(CP ) is isomorphic
17

t2

G2

G3

13

G1

12

t1

11
2

1

5

G4

t3

7

4

15 = t4

10
9

14

6

3

8

0 = s1

s4

s3
s2

Fig. 8: The induced graphs of graph G shown in Figure 7.

to a subgraph of G∗ and the width of G is equal to the width of its transitive
closure. This means that wn ≤ wG∗ = wG . Hence we have the following:
Lemma 13. The dimensional neck of G(CP ) is not greater than the width of
G. In other words, wN ≤ wG .
We are interested in calculating a dominance drawing Γi for each graph Gi of
CP . Moreover, we want to merge these drawings into a single dominance drawing
of G. In order to do that, we want the drawings Γ0 , ..., Γh to have the same
number of dimensions. Notice that, given a channel decomposition of a graph
Gi having size α, it is always possible to compute a channel decomposition of
Gi = (Vi , Ei ) having size α+β, for any β, by adding to the channel decomposition
β (dummy) channels containing only the source and the sink of Gi .
The following algorithm, called Algorithm Drawings-Computation, receives
as input the set G(CP ) = {G0 , ..., Gh } and it gives as output the set of wN dimensional dominance drawings Γ1 , ..., Γh , where Γi is a wN -dimensional dominance drawing of Gi , for any i = 1, 2, ..., h.
In Line 1 we compute the dimensional neck wN of G(CP ). This is trivial, since
we can simply compute the width of any DAG in G(CP ) (as described in [9])
and pick up the highest one. This operation requires linear time. In Lines 2-3 we
i
of minimum size for any Gi by using Alcompute a channel decomposition SC
gorithm Channels-Generation, which was introduced in Section 2.2. In Lines 4-6
i
we add channels containing only the source and the sink of Gi to any SC
until
its size is wN . Then we compute a wN -dimensional dominance drawing Γi of
each Gi using Algorithm kD-Draw, as described in Section 3.

Algorithm Drawings-Computation(G(CP ))
1.
Compute the dimensional neck wN of G(CP ).
2.
For each Gi = G0 , G1 , ..., Gh
i
3.
SC
= Channels-Generation(Gi )
4.
While Sci contains less than wN channels
18

5.
6.
7.
8.

C|Sci |+1 = {si , ti }
SC .add(C|Sci |+1 )
i
Γi = kD-Draw(Gi , SC
)
output: Γ0 , ..., Γh

Figure 9 shows the output of Algorithm Drawings-Computation given the
set G(CP ) = {G0 , G1 , G2 , G3 , G4 }, where G0 is depicted in Figure 6(b) and
the induced graphs G1 , G2 , G3 , and G4 are depicted in Figure 8. Part (a)
shows: a channel decomposition {C01 , C02 } of minimum size of G0 , computed
in Line 3 of Algorithm Drawings-Computation, where C01 = {µ1 , µ2 , µ4 } and
C02 = {µ1 , µ3 , µ4 }; the dominance drawing Γ0 of G0 , computed in Line 7 of Algorithm Drawings-Computation. Similarly: Part (b) shows {C11 , C12 }, where C11 =
{0, 1, t1 } and C12 = {0, 2, t1 }, and Γ1 ; Part (c) shows {C21 , C22 }, where C21 =
{s2 , 3, 4, 5, 12, 13, t2 } and C22 = {s2 , 7, 11, t2 }, and Γ2 ; Part (d) shows {C31 , C32 },
where C31 = {s3 , 6, 10, t3 } and C32 = {s3 , 8, 9, t3 }, and Γ3 ; Part (e) shows
{C41 , C42 }, where C41 is the empty channel {s4 , 15} and C42 = {s4 , 14, 15},
and Γ4 .
We recall that computing wN from a graph requires linear time [9]. It is
easy to see that the time complexity of the algorithm depends on Line 3, where
we compute the minimum-size channel decomposition of any graph in G(CP ),
and Line 7, where we compute the dominance drawings Γ0 , ..., Γh . In order to
characterize this time complexity we give some further definitions. We denote
by ni the number of vertices of Gi . We recall that the number of vertices of G0
is equal to the number of modules of CP and that the number of vertices of any
Gi is equal to the number of vertices of the module Mi . Hence, n0 = |CP | and
ni = |Mi | for any 0 < i ≤ h. Let ρ be the maximum ni for i ∈ [0, h] and let wρ
be the maximum width among the graphs of G(CP ) having wρ vertices.
Lemma 14. The maximum number of vertices of a module of CP , ρ, is greater
than or equal to the dimensional neck of G(CP ). In other words, wN ≤ ρ.
Proof. Let Gi be the graph such that wi = wN . We have that wN is less than
ni by Lemma 1 and ni is less than ρ by the definition of ρ. In other words:
wN ≤ ni ≤ ρ.
The time complexity of Line 3 is O(wρ ρ2 ), Lemma 3, and the time complexity
of Line 8 is O(wN ρ). Moreover, O(wN ρ) ∈ O(wρ ρ2 ) by Lemma 14. It means that
the computational complexity of Algorithm Drawings-Computation depends on
Line 3. Hence, we have the following lemma:
Lemma 15. Algorithm Drawings-Computation requires O(wρ ρ2 ) time.
Lemma 15 tells that the time complexity of the algorithm depends on the maximum number of vertices ρ belonging to a same module and on the width wrho
of the graph having such a number of vertices.
As discussed earlier, our final goal is to merge the wN -dimensional dominance
drawings Γ0 , ..., Γh of graphs G0 , ..., Gh into a wN -dominance drawing Γ of the
19

Y

Y

µ4

t1

µ4

µ3

C02

C01
µ2

µ1

t1
1

2

1

µ2
µ1

C12

C11

µ3

2

0 = s1

X

0 = s1

(a)

X

(b)

Y
t2
11

t2
C21
5

13

12
4

C22
11
7

7

Y

13
10
C31
6

12
5

4

3

6

9
C32
8
s3

3

t3

10

t3

9
8
s3

X

s2
X

(c)

(d)

15 = t4
14
C41
C42
s4

Y
14 15 = t4
s4

X

(e)
Fig. 9: The output of Algorithm Drawings-Computation given the set G(CP ) =
{G0 , G1 , G2 , G3 , G4 }, where G0 is depicted in Figure 6(b) and the induced graphs G1 ,
G2 , G3 , and G4 are depicted in Figure 8.

20

original graph G. Our strategy is to create space in the dominance drawing Γ0 of
the quotient graph G0 in order to insert the drawings Γ1 , ..., Γh in it by simply
using vertex µi as the new origin of drawing Γi for any i ∈ [1, h].
We create space by shifting, as described in Algorithm Shifter. It receives
as input the drawings Γ0 , ..., Γh and gives as output a modified drawing Γ0 ,
where the vertices are shifted. Suppose that we want to shift µj with respect
of µi in dimension Dg (notice that all the possible ordered couples of vertices
of G0 are chosen in Lines 1-2 and that all the dimensions are chosen for every
ordered couple of vertices in Line 3). We shift µj if and only if one of the following conditions is true: its coordinate in some dimension Dg is greater than
the corresponding coordinate of µi ; the coordinates of µi and µj are equal (in
dimension Dg ) and µj is reachable from µi . This check is done in Line 4. In
that case, let y be the maximum value of a coordinate in Dg in drawing Γj , i.e.,
the coordinate of tj (Line 6). We shift µj in dimension Dg by y positions (Line 7).
Algorithm Shifter(Γ0 , ..., Γh )
1.
For each µi ∈ G0 :
2.
For each µj ∈ G0 such that i 6= j:
3.
For each Dg = D1 , ..., DwN
4.
If [Dg (µi ) < Dg (µj ) ∨ (Dg (µi ) = Dg (µj ) ∧ r(µi , µj ))]
5.
Let y be equal to the coordinate of tj in Γj
6.
Dg (µj )+ = y
7.
output: Γ0
Figure 10 is an illustration of Algorithm Shifter. The algorithm receives as input
the drawings depicted in Figure 9. Part (a) shows drawing Γ0 . Part (b) shows
the drawing Γ0 after we perform the shifting to accommodate Γ1 . Part (c) shows
drawing Γ0 after we perform the shifting to accommodate Γ2 . Finally, Part (d)
shows drawing Γ0 after we perform the shifting to accommodate Γ3 . The space
reserved for each Γ1 , Γ2 , and Γ3 during the algorithm is shown with a red box.
Recall that the number of vertices of G0 is equal to h, which is the number of
modules of CP . Moreover, the number of dimensions of Γ0 are wN . Algorithm
Shifter shifts in constant time every vertex of G0 with respect to every other
vertex of G0 in every dimension of Γ0 in constant time. Hence, we have the
following lemma:
Lemma 16. The time complexity of Algorithm Shifter is O(wN h2 ).
Finally, putting everything together, we present Algorithm Neck-DimensionalDraw (or simply ND-Draw). It takes as input G(CP ) and produces as output a
dominance drawing of G. First we compute the dominance drawings Γ0 , ..., Γh of
the module induced graphs G0 , ..., Gh ∈ G(CP ) by using Algorithm DrawingsComputation (Line 1 of ND-Draw). Next we use Algorithm Shifter to shift the
vertices of Γ0 in order to create space for the vertices of G1 , ..., Gh , which are
already placed in Γ1 , ..., Γh (Line 2). Finally, we place every vertex of v ∈ Gi
in Γ0 (Lines 3-8). We denote by Dg (v, Γ0 ) the coordinate of the vertex v in the
21

µ4

µ3

Γ2

µ4

µ3
µ3

µ2

µ4

µ2

Γ1

Γ1
µ2

µ1

µ1

µ1

(a)

(b)

(c)

µ4

Y

Γ3

µ3

Γ2

µ2

Γ1

µ1

X

(d)
Fig. 10: Illustration of Algorithm Shifter using as input the drawings depicted in Figure 9: (a) shows the drawing Γ0 ; (b) shows Γ0 after the shifting done with respect to Γ1 ;
(c) shows Γ0 after the shifting done with respect to Γ2 ; (d) shows Γ0 after the shifting
done with respect to Γ3 . The space reserved for Γ1 , Γ2 , and Γ3 during the algorithm is
always shown with red boxes.

22

dimension Dg of drawing Γ0 . The coordinate in the dimension Dg of v in Γ0 is
the sum of the coordinate of µi in Γ0 with the coordinate of v in Γi (Line 6). This
calculation is made for every v ∈ V . The output of the algorithm is a dominance
drawing Γ of G having wN dimensions.

Algorithm ND-Draw(G(CP ))
1. Γ0 , ..., Γh = Drawings-Computation(G(CP ))
2. Γ0 = Shifter(Γ0 , ..., Γh )
3. For each Γi = Γ1 , ..., Γh :
4.
For any v ∈ Gi
5.
For each Dg = D1 , ..., DwN
6.
Dg (v, Γ0 ) = Dg (µi , Γ0 ) + Dg (v, Γi )
7.
remove µi from Γ0
8. output: Γ = Γ0
Figure 11 shows a representation of the output of Algorithm ND-Draw when
the input of the algorithm is the set G(CP ) = {G0 , G1 , G2 , G3 , G4 }, where G0 is
depicted in Figure 6(b) and the induced graphs G1 , G2 , G3 , and G4 are depicted
in Figure 8. This drawing is obtained by substituting the drawings in Figure 9
in the respective space reserved for them in Figure 10 as described by Algorithm
ND-Draw.
Figure 12 shows the drawing of Figure 11 where the added sources and sinks
are removed and the original edges of the graph are restored. Notice that this
is the same DAG as the one shown in Figure 1 along with its four channels.
According to that channel decomposition, the DAG requires four dimensions,
whereas, after using the module decomposition technique it requires only two
dimensions.
Important Observation on the New Dominance Drawing Technique
The graph shown in Figure 11 and Figure 12 is the same graph G shown in
Figure 1. Recall that G has a minimum size channel decomposition as shown
in Figure 1 (b) Sc = {C1 , C2 , C3 , C4 }, where: C1 = {0, 1, 4, 5, 12, 13, 15}; C2 =
{0, 3, 7, 11, 15}; C3 = {0, 2, 6, 10, 14, 15}; C4 = {0, 8, 9, 15}. Therefore according
to Algorithm kD-Draw it can be drawn as a 4-dimensional dominance drawing,
which is the best that can be done by using only the channel decomposition
approach. However, after using the module decomposition techniques of this
section, we are able to reduce the number of required dimensions to two, as
shown Figures 11 and 12. Therefore, the use of module decomposition allows us
to "group" parts of the graph so that the total number of dimensions is cut in
half for this example graph.

23

Y
14
s4

15

t3

10

9
8
s3
t2
11
7

13
12

5
4
3
s2
t1
1

2

0

X

Fig. 11: Output of Algorithm ND-Draw when the input is the set G(CP ) =
{G0 , G1 , G2 , G3 , G4 }, where G0 is depicted in Figure 6(b) and the induced graphs G1 ,
G2 , G3 , and G4 are depicted in Figure 8. This drawing is obtained by substituting the
drawings in Figure 9 in the respective space reserved for them of Figure 10 as described
by Algorithm ND-Draw.

24

Y
14 15

10
6

9
8

11
7

13
12

5
4
3

1
2
0
X
Fig. 12: The drawing of Figure 11 where the added sources and sinks are removed and
the original edges of the graph are restored.

25

We are ready now to state the main result of this section:
Theorem 2. Let G be an st-graph and CP = {M1 , ..., Mh } be a congruence
partition of G. Let G(CP ) = {G0 , G1 , ..., Gh } be the set of all the module-induced
graphs of G augmented with the quotient graph G0 . Let wN be the dimensional
neck of G(CP ). Algorithm ND-Draw computes a wN -dimensional dominance
drawing Γ of G in O(wρ ρ2 + wN (h2 + n)) time.
Proof. First, we prove the correctness of the algorithm, i.e., we prove that the
computed drawing is a dominance drawing. Then we prove the time complexity
of the algorithm. Let u, v be two vertices, where u ∈ Gi and v ∈ Gj . We need
to prove that r(u, v) = yes ⇔ u  v for any choice of u and v. We have
r(u, v) = yes ⇔ u  v in G if j = i, since the relative position of u and v in
Γ do not change in Γi , which is a dominance drawing of Gi . Suppose i 6= j and
r(u, v) = yes. In that case µi reaches µj in G0 by Lemma 12 and µi  µj in
Γ0 , since Γ0 is a dominance drawing of G0 . The vertex µj is shifted with respect
of µi in any dimension Dg in Γ0 by Dg (u, Γi ) ≤ Dg (ti , Γi ) positions. Moreover,
Dg (u, Γ0 ) = Dg (µi , Γ0 )+Dg (u, Γi ) ≤ Dg (µj , Γ0 ) ≤ Dg (v, Γ0 ), which implies that
u  v. Now suppose i 6= j and r(u, v) = no. In this case, there exists at least
one dimension Dx for which Dx (µi ) > Dx (µj ) by Lemma 9 and Lemma 12. The
vertex µi is not shifted with respect of µj in Dx . On the contrary, µj is shifted
with respect of µi by Dx (ti , Γi ) positions. Hence, Dx (µi ) > Dx (µj ) also after
the shifting and in the final drawing. The computational time required has three
contributions: O(wρ ρ2 ) time is needed due to Line 1 and Lemma 15; O(wn h2 )
time is needed due to Line 2 and Lemma 16; O(wN n) time is needed since every
vertex is placed in wN dimensions.
The following corollaries are similar to the ones presented in Subsection 3.3,
but they give improved bounds since the dimensional neck wN is potentially
much better than the width wG of any DAG G:
Corollary 4. Let G be an st-graph (or DAG) having n vertices and a congruence
partition CP . If wN is the dimensional neck of G(CP ), then: dG ≤ min( n2 , wN )
Corollary 5. Every DAG G having a congruence partition CP with dimensional
neck equal to 2 has a 2-dimensional dominance drawing.
If we define a congruence partition and its dimensional neck for a partial order
P as we did for the DAGs, we have the following corollary:
Corollary 6. For any partial order P having n elements and any congruence
partition of it. If wN is the dimensional neck of CP , then: dP ≤ min( n2 , wN )

5

Conclusions and Open Problems

The contributions of our paper are as follows: we proved that every DAG G of
width 2 has a 2-dimensional dominance drawing; we proved that min( n2 , wG ) is
an upper bound of the dominance dimension dG of the DAG G; we proved that
26

min( n2 , wP ) is an upper bound for the dimension dP of a partial order P ; we
introduced the dimensional neck wN of a DAG G, we proved that wN ≤ wG and
we improved the upper bounds described above using this new parameter. This
clearly visible by the fact that the DAG of Figure 1 requires four dimensions due
to the given channel decomposition, whereas it requires only two dimensions
after applying the module decomposition techniques.
An interesting open problem is to reduce the number of dimensions of the
drawings computed by the algorithms described in this paper in order to have
a weak dominance drawing with a bounded number of fips. In this direction
approximation algorithms as well as heuristic algorithms should be developed.
Another open problem could be the extension of the family of DAGs having
a 2-dimensional dominance drawing with DAGs having width higher than 2.
We propose to study the problem of computing a congruence partition having
a minimum dimensional neck, since it let us compute dominance drawing with
less dimensions in less time. It could be interesting to better understand the
relationship between this problem and the NP-hard problem of computing the
dominance dimension of a DAG. Additionally, we propose to study the problem
of computing a congruence partition having small size (h), a small wρ , and a
small ρ, since the time complexity of ND-Draw depends also on these parameters. Finally, perhaps the most interesting open problem is to find families of
graphs and prove a mathematical relationship between the number of dimensions
(wG ) required by Algorithm kD-Draw and the number of dimensions required by
Algorithm ND-draw, similar to the one that we observed for the example graph
of Figure 1 shown in Figures 4 and 12.

Acknowledgement: We thank Roberto Tamassia for useful discussions and for
pointing our attention to Hiraguchi’s results.

27

References
1. K. P. Bogart. Maximal dimensional partially ordered sets i. hiraguchi’s theorem. Discrete Mathematics, 5(1):21–31, 1973. URL: https://doi.org/10.1016/
0012-365X(73)90024-1, doi:10.1016/0012-365X(73)90024-1.
2. Y. Chen and Y. Chen. On the dag decomposition. British Journal of Mathematics
and Computer Science, 2014. 10(6): 1-27, 2015, Article no.BJMCS.19380, ISSN:
2231-0851.
3. G. Di Battista, P. Eades, R. Tamassia, and I. Tollis. Graph Drawing: Algorithms
for the Visualization of Graphs. Prentice Hall, 1998. pp. 112–127.
4. G. Di Battista, R. Tamassia, and I. G. Tollis. Area requirement and symmetry display of planar upward drawings. Discrete & Computational Geometry, 7:381–401,
1992. URL: https://doi.org/10.1007/BF02187850, doi:10.1007/BF02187850.
5. R. P. Dilworth. A decomposition theorem for partially ordered sets. ann. math.
52, (1950), 161-166.
6. Y. A. Dinitz. Algorithm for solution of a problem of maximum flow in networks
with power estimation. Soviet Math. Doklady, 11:1277–1280, 1970. URL: https:
//ci.nii.ac.jp/naid/10021311931/en/.
7. H. A. ElGindy, M. E. Houle, W. Lenhart, M. Miller, D. Rappaport, and S. Whitesides. Dominance drawings of bipartite graphs. In Proceedings of the 5th Canadian
Conference on Computational Geometry, Waterloo, Ontario, Canada, August 1993,
pages 187–191, 1993.
8. T. Hiraguchi. On the dimension of partially ordered sets. Sci. Rep. Kanazawa
Univ., pages 77–94, 1951.
9. H. V. Jagadish. A compression technique to materialize transitive closure. ACM
Trans. Database Syst., 15(4):558–598, 1990. URL: http://doi.acm.org/10.1145/
99935.99944, doi:10.1145/99935.99944.
10. E. M. Kornaropoulos and I. G. Tollis. Weak dominance drawings and linear extension diameter. CoRR, abs/1108.1439, 2011. URL: http://arxiv.org/abs/1108.
1439, arXiv:1108.1439.
11. E. M. Kornaropoulos and I. G. Tollis. Weak dominance drawings for directed
acyclic graphs. In Graph Drawing - 20th International Symposium, GD 2012,
Redmond, WA, USA, September 19-21, 2012, Revised Selected Papers, pages
559–560, 2012. URL: https://doi.org/10.1007/978-3-642-36763-2_52, doi:
10.1007/978-3-642-36763-2\_52.
12. E. M. Kornaropoulos and I. G. Tollis. Algorithms for overloaded orthogonal drawings. J. Graph Algorithms Appl., 20(2):217–246, 2016. URL: https://doi.org/
10.7155/jgaa.00391, doi:10.7155/jgaa.00391.
13. L. Li, W. Hua, and X. Zhou.
HD-GDD: high dimensional graph dominance drawing approach for reachability query. World Wide Web, 20(4):677–
696, 2017. URL: https://doi.org/10.1007/s11280-016-0407-z, doi:10.1007/
s11280-016-0407-z.
14. R. M. McConnell and F. de Montgolfier. Linear-time modular decomposition of directed graphs. Discrete Applied Mathematics, 145(2):198–209, 2005. URL: https:
//doi.org/10.1016/j.dam.2004.02.017, doi:10.1016/j.dam.2004.02.017.
15. R. M. McConnell and J. Spinrad. Linear-time transitive orientation. SODA, pages
19–25, 1997.
16. R. M. McConnell and J. P. Spinrad. Modular decomposition and transitive orientation. Discrete Mathematics, 201(1-3):189–241, 1999. URL: https://doi.org/
10.1016/S0012-365X(98)00319-7, doi:10.1016/S0012-365X(98)00319-7.

28

17. J. M. Six and I. G. Tollis. Automated visualization of process diagrams. In
P. Mutzel, M. Jünger, and S. Leipert, editors, Graph Drawing, pages 45–59, Berlin,
Heidelberg, 2002. Springer Berlin Heidelberg.
18. R. R. Veloso, L. Cerf, W. M. Jr., and M. J. Zaki. Reachability queries in very
large graphs: A fast refined online search approach. In Proceedings of the 17th
International Conference on Extending Database Technology, EDBT 2014, Athens,
Greece, March 24-28, 2014., pages 511–522, 2014. URL: https://doi.org/10.
5441/002/edbt.2014.46, doi:10.5441/002/edbt.2014.46.
19. M. Yannakakis. The complexity of the partial order dimension problem. SIAM J.
Algebraic and Discrete Methods, 3:303–322, 1982.
20. J. Zhou, S. Zhou, J. X. Yu, H. Wei, Z. Chen, and X. Tang. Dag reduction: Fast
answering reachability queries. In Proceedings of the 2017 ACM International
Conference on Management of Data, SIGMOD ’17, pages 375–390, New York,
NY, USA, 2017. ACM. URL: http://doi.acm.org/10.1145/3035918.3035927,
doi:10.1145/3035918.3035927.

29

