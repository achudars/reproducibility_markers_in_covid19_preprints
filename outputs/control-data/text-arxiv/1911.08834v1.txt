Fast Actively Secure OT Extension for Short Secrets

arXiv:1911.08834v1 [cs.CR] 20 Nov 2019

Arpita Patra ∗

Pratik Sarkar †

Ajith Suresh ‡

Abstract
Oblivious Transfer (OT) is one of the most fundamental cryptographic primitives with wide-spread
application in general secure multi-party computation (MPC) as well as in a number of tailored and
special-purpose problems of interest such as private set intersection (PSI), private information retrieval
(PIR), contract signing to name a few. Often the instantiations of OT require prohibitive communication
and computation complexity. OT extension protocols are introduced to compute a very large number of
OTs referred as extended OTs at the cost of a small number of OTs referred as seed OTs.
We present a fast OT extension protocol for small secrets in active setting. Our protocol when used to
produce 1-out-of-n OTs outperforms all the known actively secure OT extensions. Our protocol is built
on the semi-honest secure extension protocol of Kolesnikov and Kumaresan of CRYPTO’13 (referred
as KK13 protocol henceforth) which is the best known OT extension for short secrets. At the heart
of our protocol lies an efficient consistency checking mechanism that relies on the linearity of WalshHadamard (WH) codes. Asymptotically, our protocol adds a communication overhead of O(µ log κ) bits
over KK13 protocol irrespective of the number of extended OTs, where κ and µ refer to computational
and statistical security parameter respectively. Concretely, our protocol when used to generate a large
enough number of OTs adds only 0.011-0.028% communication overhead and 4-6% runtime overhead
both in LAN and WAN over KK13 extension. The runtime overheads drop below 2% when in addition
the number of inputs of the sender in the extended OTs is large enough.
As an application of our proposed extension protocol, we show that it can be used to obtain the most
efficient PSI protocol secure against a malicious receiver and a semi-honest sender.

1 Introduction
Oblivious Transfer (OT) [NP05, Kil88, BCR86, EGL85, Rab81] is perhaps the most fundamental primitive
in cryptographic protocol theory. It is a two party protocol between a sender S and a receiver R. The sender
holds an array of inputs and the receiver holds an index indicating its intended pick from the sender’s array.
OT allows the sender to send the receiver’s selected input while preserving the secrecy of the sender’s other
inputs on the one hand and the choice of the receiver on the other. The necessity and sufficiency of OT for
secure multi-party computation (MPC) [Kil88, GV87, GMW87, Yao86] backs the theoretical importance
of OT. On the practical front, OT has been pivotal in building several state-of-the-art practically efficient
general MPC protocols [Lin16, LP15, LR15, HKK+14, FJN+ 13, SS13, NO09] and several protocols for
special-purpose problems of interest such as private set intersection (PSI) [PSSZ15, PSZ14, DCW13].
There is a fundamental limitation to OT’s efficiency as it is unlikely that OT is possible without publickey cryptography and solely relying on symmetric-key cryptography [IR89]. The OT extension protocols
[KOS15, ALSZ15, KK13, ALSZ13, NNOB12, IKNP03, Bea96] have been introduced to theoretically circumvent the above limitation of OTs. They produce a large number of OTs referred as extended OTs from
a small number of OTs referred as seed OTs and symmetric-key primitives. When the goal is to generate a
∗

Indian Institute of Science. Email: arpita@csa.iisc.ernet.in.
Indian Institute of Science. Email: pratik.sarkar@csa.iisc.ernet.in.
‡
Indian Institute of Science. Email: ajith.s@csa.iisc.ernet.in.

†

1

large number of OTs which is usually the case for the applications of OT, the amortized cost of generating a
single OT via OT extensions turns out to be a constant number of symmetric-key operations. So most of the
known practically efficient general and special-purpose MPC protocols are byproduct of concretely efficient
OT extension protocols. Of particular interest to cryptographic community are the following variants of
OT: (a) In a 1-out-of-2 OT [EGL85], S holds two inputs x0 , x1 , and R holds a choice bit b. The output
to R is xb and no other party learns anything. (b) A straight-forward extension of 1-out-of-2 OT is 1-outof-n OT [BCR86] where S holds n inputs and R holds a choice index of log n bits. While the first kind
finds application in MPC [GMW87, Yao82], the second kind is useful in PSI [PSSZ15, PSZ14], symmetric
PIR [NP05], and oblivious sampling [NP05], oblivious polynomial evaluation [NP99]. As discussed below,
attempts have been made to construct OT extension protocols to output both the above kinds of OTs.

1.1 OT Extensions
The theoretical feasibility of OT extension was proved by Beaver [Bea96]. Ishai, Kilian, Nissim and Petrank [IKNP03] (referred as IKNP protocol henceforth) presented the first efficient OT extension protocol
that builds on κ seed OTs and requires computing and sending just two hash values per extended OT. In
[ALSZ13], IKNP protocol has seen several optimizations that boost both its communication and computation complexity. Specifically, the communication per extended OT is brought down to one hash value
for a special case where the extended OTs are needed for random inputs of the sender. The computation
bottleneck for implementing matrix transposition is tackled by introducing a cache-oblivious algorithm. Yet
another contribution from [ALSZ13] is their crucial observation that the actual bottleneck in the runtime of
IKNP protocol results from its communication time, particularly in wide area networks (WANs) that have
high latency and low bandwidth. In a first of its kind approach, Kolesnikov and Kumaresan [KK13] (referred
as KK13 protocol henceforth) presented an OT extension protocol that outputs 1-out-of-n OTs starting from
2κ 1-out-of-2 seed OTs and relying on specifics of Walsh-Hadamard (WH) codes. KK13 protocol improves
over all its predecessors (including IKNP) customized to generate 1-out-of-n OTs by a factor O(log n) in
communication complexity when the inputs of the extended OTs are of short size. So far KK13 protocol remains to be the most efficient way of generating 1-out-of-n OTs for short inputs. All the protocols discussed
above work when the adversary is assumed to be semi-honest. A passive or semi-honest adversary follows
the protocol specification but attempts to learn more than allowed by inspecting the protocol transcript. An
adversary is referred as active or malicious when it behaves in any arbitrary way in an attempt to break the
security of the protocol.
OT extension literature finds numerous attempts to achieve active security. All the attempts restrict their
attention in transforming the semi-honest secure IKNP protocol to an actively secure one. Since the IKNP
protocol is resilient to any malicious behavior of the sender, an actively secure IKNP style protocol needs to
enforce honest behaviour for the receiver. Adding consistency checks for the receiver has been the strategy
followed in all the known constructions. The efficiency (both communication and computation wise) of the
consistency checks defines the overhead for an actively secure IKNP style protocol. The consistency check
introduced in [IKNP03] employs expensive cut-and-choose technique on µ parallel instances of the semihonest IKNP protocol where µ is a statistical security parameter. [HIKN08, Nie07] proposes consistency
checks per extended OTs. This is improved in [NNOB12] where the checks are done per seed OT. In order to
tackle information leakage in their consistency check, [NNOB12] needs to start with 83 κ seed OTs which is
8
3 times more than what IKNP protocol needs. This inflates their concrete communication and computation
complexity by the same factor. [ALSZ15] improves over [NNOB12] by trading computation in consistency
checks for a reduced number of seed OTs. Namely, the OT extension of [ALSZ15] requires κ + 1.55µ seed
OTs compared to 38 κ of [NNOB12] and thus improves the communication done via seed OTs. In a recent
work, [KOS15] reports the most efficient actively secure IKNP style protocol that brings back the number
of seed OTs to κ and handles the information leakage in the consistency check by sacrificing κ + µ extended
2

OTs. The check requires an O(κ) bits communication irrespective of the number of extended OTs and two
finite field operations per extended OT.
Above we concentrated on practically efficient OT extension literature. Some interesting theoretical
questions on OT extension are addressed in [Lar14, LZ13].

1.2 Our Contribution
We present an actively secure OT extension for short secrets building upon the semi-honest secure protocol
of [KK13]. Like KK13 protocol, our extension protocol turns 1-out-of-2 seed OTs to 1-out-of-n extended
OTs. Similar to IKNP protocol, KK13 protocol is secure against any malicious behaviour of sender but
falls apart in the face of a maliciously corrupt receiver. We present a concrete attack on KK13 and add an
efficient consistency check to enforce correct behaviour of the receiver. Our check relies on the linearity of
WH codes. Combined with an additional trick, our efficient consistency check incurs a communication of
O(µ log κ) bits irrespective of the number of generated extended OTs. Asymptotically, our OT extension
matches the KK13 protocol in every respect. Table 1 shows the efficiency of various OT extension protocols
achieving 2−κ computational security and 2−µ statistical security for producing m 1-out-of-n OTs with ℓ-bit
inputs of the sender. The following parameters have been used for comparison: (i) number of seed OTs, (ii)
communication complexity and (iii) computation complexity in terms of number of hash value computations.
Table 1: Asymptotic cost of various OT extensions for producing m 1-out-of-n OTs with ℓ-bit inputs of the sender and for
achieving 2−κ computational security and 2−µ statistical security.
Reference

# Seed OTs

Communication (bits) /
Computation (# hashes)

Security

[KK13]
[IKNP03]
[NNOB12]
[ALSZ15]
[KOS15]
This Paper

2κ
κ
8
3κ
κ + 1.55µ
κ
2κ

O(m(κ + nℓ))
O(m(κ log n + nℓ))
O(m(κ log n + nℓ))
O(m(κ log n + nℓ))
O(m(κ log n + nℓ))
O(m(κ + nℓ))

semi-honest
semi-honest
active
active
active
active

Concretely, our protocol when used to generate large enough number of OTs adds only 0.011-0.028%
communication overhead and 4-6% runtime overhead both in LAN and WAN over KK13 protocol. The
runtime overheads drop below 2% when in addition the number of inputs of the sender in the extended OTs
is large enough. Our construction put in the context of other OT extensions are presented in Table 2. The
table presents figures for generating 1.25 × 106 1-out-of-16 OTs with sender’s input length as 4 bits. The
overheads are calculated with respect to KK13 protocol. The implementation of [KOS15] is not available
in the same platform as the other OT extensions given in the table. As per the claim made in [KOS15], the
runtime of their OT extension bears an overhead of 5% with respect to IKNP protocol both in LAN and
WAN. So the runtime and overhead in runtime of [KOS15] with respect to KK13 protocol are calculated
based on that claim. As evident from Table 2, our protocol when used to compute 1-out-of-n OTs with
short inputs of the sender outperforms all the known actively secure OT extensions and secures the second
best spot among all the OT extension protocols listed in Table 2 closely trailing KK13 which is the overall
winner. More elaborate empirical results supporting the above claim with varied number of extended OTs
and varied number of inputs of the sender in the extended OTs appear later in the paper.
Lastly, the OT extensions presented in all the works in the table except [KK13] inherently produce 1out-of-2 OTs. The transformation from 1-out-of-2 to 1-out-of-n OT given in [NP05] is used to transform
their extended OTs to 1-out-of-n OTs. The transformation that works for reverse direction [NP05] is unfortunately not maliciously secure. This prevents us from claiming a similar gain when our protocol is used to
generate 1-out-of-2 OTs. We leave open the question of finding an efficient actively secure transformation
from 1-out-of-n to 1-out-of-2 OT.
3

Table 2: Concrete cost of various OT extension protocols for producing 1.25 × 106 1-out-of-16 OTs with sender’s input length
as 4 and for achieving computational security of 2−128 and statistical security of 2−40 .
Reference
[KK13]
[IKNP03]
[NNOB12]
[ALSZ15]
[KOS15]
This Paper

# Seed
OTs
256
128
342
190
128
256

Comm

Runtime (in sec)

Overhead w.r.t. [KK13] (in %)

(in MB)

LAN

WAN

Communication

Runtime in LAN

Runtime in WAN

47.69
87.74
215.95
166.54
> 87.74
47.70

21.68
24.07
24.84
24.81
> 25.27
22.50

115.34
133.81
143.20
158.6
> 140.5
121.94

0
84
352.7
249.1
> 84
0.028

0
11.02
14.6
14.4
> 16.5
3.78

0
16
24.14
37.5
> 21.8
5.72

We show an interesting application of our proposed extension protocol in OT-based PSI protocols.
Specifically, we use our maliciously secure OT extension in the PSI protocol of [Lam16] to obtain the most
efficient PSI protocol that is maliciously secure against a corrupt receiver and semi-honestly secure against
a corrupt sender. In brief, a PSI protocol between two parties, namely a sender S and a receiver R holding
sets X = {x1 , x2 , . . . xn1 } and Y = {y1 , y2 , . . . yn2 } respectively, outputs the intersection X ∩ Y to the
receiver and nothing to the sender. As evident from the theoretical and experimental results presented in this
work, our maliciously secure OT extension protocol is a better choice compared to the existing maliciously
secure extension protocols [ALSZ15, NNOB12, KOS15] when 1-out-of-n OTs are required as output. As
PSI employs 1-out-of-n (instead of 1-out-of-2) OTs, our extension protocol fits the bill. Lastly, we find a
concrete vulnerability for the malicious corrupt receiver case in Lambæk’s PSI protocol when semi-honest
KK13 OT protocol is used in it. This confirms Lambæk’s concern of privacy breach of his PSI protocol
that may result from privacy breach of the underlying OT protocols and further confirms the necessity of
maliciously secure OT extension in Lambæk’s PSI protocol.

2 Preliminaries
We present below the required preliminaries and techniques. We revisit the KK13 [KK13] protocol and
present a concrete attack on it in Section 3. Next, our proposed actively secure protocol with efficiency and
security analysis is presented in Section 4. Section 5 shows our empirical findings and analysis. Lastly, the
application of our actively secure protocol in PSI appear in Section 6.

2.1 Notations
We use ⊕ to denote bitwise XOR operation and ⊙ to denote bitwise AND operation. We denote vectors
in bold smalls and matrices in bold capitals. For a matrix A, we let aj denote the jth row of A, and ai
denote the ith column of A. For a vector a, ai denotes the ith element in the vector. For two vectors a
and b of length p, we use the notation a ⊕ b to denote the vector (a1 ⊕ b1 , · · · , ap ⊕ bp ) and the notation
m
L
a ⊙ b to denote the vector (a1 ⊙ b1 , · · · , ap ⊙ bp ). The notation
aj denotes the XOR of m vectors, i.e.
j=1

a1 ⊕ · · · ⊕ am . We denote by a ⊗ b the inner-product value

p
L

ai ⊙ bi . Finally, suppose c ∈ {0, 1}, then

i=1

c ⊙ a denotes the vector (c ⊙ a1 , · · · , c ⊙ ap ). We denote by a ←R A the random sampling of a from a
distribution A. We denote by [x], the set of elements {1, . . . , x}.
We denote by HDI a function that takes two binary vectors of same length and returns the indices where
the input vectors are different. For a vector c of length, say p, and an index set I ⊂ [p], PRNI (c) denotes the
pruned vector that remains after removing the bits of c corresponding to the indices listed in I. For a set C
of vectors {c1 , . . . , cm }, PRNI (C) denotes the set of pruned vectors {PRNI (c1 ), . . . , PRNI (cm )}.
4

Security Parameters. We denote the statistical security parameter by µ and the cryptographic security parameter by κ. A negligible function in κ (µ) is denoted by negl(κ) (negl(µ)), while negl(κ, µ) denotes a
function which is negligible in both κ and µ. A function negl(·) is negligible if for every polynomial p(·)
1
. We write PPT for probabilistic
there exists a value N such that for all n > N it holds that negl(n) < p(n)
polynomial-time.
Oblivious Transfers. For oblivious transfers, we denote the sender by S and the receiver by R. In a 1-outof-2 OT on ℓ bit strings, S holds two inputs x0 , x1 , each from {0, 1}ℓ and R holds a choice bit b. The output
to R is xb and no other party learns anything. We denote a 1-out-of-2 OTon ℓ bit strings as 21 -OTℓ . We
denote a 1-out-of-n OT on ℓ bit strings as n1 -OTℓ . Finally, we write n1 -OTm
ℓ to denote m instances of



m
n
2
2
1 -OTℓ . Similarly, 1 -OTℓ denotes m instances of 1 -OTℓ .

2.2 Walsh-Hadamard (WH) Codes

Walsh-Hadamard (WH) code is a linear code over a binary alphabet F2 that maps messages of length p to
codewords of length 2p . We use WH code that maps messages of length log κ to codewords of length κ. For
x ∈ {0, 1}log κ , WH(x) denotes the WH encoding of x defined as WH(x) := (x ⊗ a)a∈{0,1}log κ . It is the κ-bit
string consisting of inner products of each log κ-bit string a with x. For each κ, the WH code, denoted by
κ
κ is defined as the set {WH(x)}
CWH
x∈{0,1}log κ . Note that CWH contains κ codewords each of length κ bits. Our
OT extension protocol relies on the following well-known property of WH codes.
κ is
Theorem 2.1. The distance of CWH

κ
2

when κ is a power of 2.

2.3 Hash Function and Random Oracle Model
We use a hash function H : {0, 1}∗ → {0, 1}Poly(κ) which we model as a random oracle. Namely, we prove
the security of our protocol assuming that H implements a functionality FRAND which for different inputs
x, returns uniform random output values from the range of H(x).

3 An Attack on [KK13] Protocol
The KK13 OT extension protocol is known to provide the best communication complexity among the existing constructions when the input length of the sender is ‘short’. The protocol is proven to be secure against
a semi-honest receiver and a malicious sender. It was not known if the protocol is secure against malicious
receiver. We show that the protocol is insecure against a malicious receiver. We prove this by giving an
attack that can be mounted by a maliciously corrupt receiver to break the security of the sender. Our finding
sets the stage for a maliciously secure OT extension in KK13 style which is the concern of this paper. Below
we recall the KK13 OT extension protocol prior to presenting our attack. We also briefly recall its efficiency
analysis from [KK13].

3.1 KK13 OT Extension Protocol


The OT extension protocol constructs a n1 -OTm
relying on an instance of 21 -OTκκ . We recall the simpler
ℓ

2
κ
2
κ
version of the protocol that reduces n1 -OTm
ℓ to 1 -OTm . It is well-known that 1 -OTm can be constructed

2
κ
from 1 -OTκ with some additional cost.
Following the footstep of [IKNP03], KK13 OT extension allows the receiver to send an m × κ matrix
column-wise to the sender using an instance of 21 -OTκm where the sender acts as the receiver and vice
versa. In [IKNP03] OT extension, the ith row of the transferred matrix allows the sender to create two pads
for the two messages in the ith extended OT. One of the two pads is a function of the sender’s input bit vector
5


to 21 -OTκm and thus is unknown to the receiver. The other pad is completely known to the receiver. The
pad known to the receiver is used as the mask for the intended message of the receiver. The above allows
the receiver to unmask and learn its intended message for each extended OT but nothing more. Going along
the same line, KK13 OT extension allows the sender to create n pads for the n messages in the ith extended
OT using the ith row of the transferred matrix. Much like IKNP, the receiver knows exactly one pad out of
the n pads and the pad it knows is in fact the mask
for its intended message. All the remaining n − 1 pads
2
are function of the sender’s input bit vector to 1 -OTκm and thus are unknown to the receiver. The ability
to generate n masks instead of just 2 from each of the rows of the transferred matrix is achieved by cleverly
κ in each of the rows of the transferred m × κ matrix. The use of C κ
incorporating WH codewords from CWH
WH
restricts the value of n to be at most κ.
κ that consists of κ codewords each of length κ denoted as (c , · · · , c ).
The protocol uses WH code CWH
1
κ
The receiver R chooses two random m × κ matrices B and D such that ith row of matrix E = B ⊕ D is cri
where ri is the input of the receiver for the ith extended OT. On the
 other hand, the sender S picks a κ bit
length vector s uniformly at random. The parties then interact via 21 -OTκm reversing their roles. Namely, the
sender S acts as the receiver with input s and the receiver R acts as a sender with inputs {bj , dj }j∈[κ] . After

the execution of 21 -OTκm , the sender holds an m × κ matrix A such that the ith row of A is the ith row of
B xored with the bitwise AND of s and cri , i.e. ai = (bi ⊕ (s ⊙ cri )). With theith row ai of the matrix
 A,
the sender creates n pads for the n messages in the ith extended OT as follows: H i, ai ⊕ (s ⊙ cj ) j∈[n]
where H is a random oracle. The jth pad will be used to blind the jth message of the sender in the ith
extended OT. It is easy to note that the pad for the ri th message is H(i, bi ) (since ai = (bi ⊕ (s ⊙ cri )))
which the receiver can compute with the knowledge of B matrix. For the jth message where j is different
from ri , the pad turns out to be H i, bi ⊕ (s ⊙ (cri ⊕ cj )) where cri and cj are distinct codewords. Since
κ is κ/2, c and c are different at κ/2 positions implying that κ/2 bits of s
the distance of WH code CWH
j
ri
contribute to the input of the random oracle H. Since the vector s is unknown to the receiver (recall that the
sender picks s), it is hard for an PPT receiver
to retrieve the other pads making
the protocol secure for a
n
m
2
κ
sender. The protocol of KK13 that realizes 1 -OTℓ given ideal access to 1 -OTm appears in Fig. 1.
It is easy to verify that the protocol is correct (i.e., zi = xi,ri ) when both parties follow the protocol.

3.2 An Attack
At the heart of the attack lies a clever way of manipulating the E matrix (cf. Section 3.1) which should
contain WH codewords in its rows in an honest execution. Recall that the security of the sender lies in the
κ is κ/2. The pads for the messages that are not chosen as the output by
fact that the distance of WH code CWH
the receiver, are the random oracle outputs of an input consisting of κ/2 bits of s. Since the receiver R does
not know s, it cannot guess the pads too in polynomial time. So one way of breaking the privacy of the other
inputs of the sender is to find out the bits of the vector s. Our strategy allows the receiver to recover the ith
bit of s at the cost of two calls to the random oracle under the assumption that R has apriori knowledge of
its chosen input xi,ri for the ith extended OT. This is achieved by tweaking the rows of E matrix which are
κ in an honest execution. Specifically, the ith row of E, e is c in an honest execution.
codewords from CWH
i
ri
It is now tweaked to a κ-bit string that is same as cri in all the positions barring the ith position. Specifically,
κ is a κ-length bit vector (c , . . . , c ). We denote complement of
recall that a WH codeword ci from CWH
i,1
i,κ
a bit b by b. Then the ith row ei of E is set as (ci,1 , . . . , ci,i , . . . , ci,κ ). The matrix is tweaked as above for
every ith row as long as i ≤ κ. The rest of the rows in E starting from κ to m do not need to be tweaked.
The matrix E after tweaking is given below. We denote the tweaked matrix as E and the tweaked rows as
cri for i ≤ κ.

6

Figure 1: The KK13 OT Extension Protocol
Protocol for
–
–
–
–


-OTm
ℓ from

n
1


-OTκm

2
1


Input of S: m tuples (xi,1 , · · · , xi,n ) i∈[m] of ℓ bit strings.
Input of R: m selection integers (r1 , · · · , rm ) such that each ri ∈ [n].
κ
Common Inputs: A security parameter κ such that κ ≥ n, and Walsh-Hadamard code CWH
= (c1 , · ·· , cκ ).
κ
ℓ
Oracles and Cryptographic Primitives: A random oracle H : [m]×{0, 1} → {0, 1} . An ideal 21 -OTκm
primitive.
1. Seed OT Phase:
(a) S chooses s ← {0, 1}κ at random.
(b) R forms two m × κ matrices B and D in the following way:
– Choose bi , di ← {0, 1}κ at random such that bi ⊕ di = cri . Let E := B ⊕ D. Clearly ei = cri .

(c) S and R interact with 21 -OTκm in the following way.
– S acts as receiver with inputs.
– R acts as sender with input (bj , dj ) j∈[κ] .
– S receives output {aj }j∈[κ] and forms m × κ matrix A with the jth column of A as aj . Clearly

i. aj = bj ⊕ (sj ⊙ ei) and

ii. ai = bi ⊕ (s ⊙ ei ) = bi ⊕ (s ⊙ cri ) .

2. OT Extension Phase:


(a) For every i ∈ [m], S computes yi,j = xi,j ⊕ H i, ai ⊕ (s ⊙ cj ) and sends {yi,j }j∈[n] .

(b) For every i ∈ [m], R recovers zi = yi,ri ⊕ H(i, bi ).



cr1 ,1

cr1 ,2

...

...

...


 cr2 ,1

 ..
 .


 cri ,1

 .
E =  ..


crκ ,1

cr ,1
 κ
 .
 .
 .

cr2 ,2

...

...

...

..
.

..

..
.

..

cri ,2

...

cri ,i

...

..
.

..

..
.

..

crκ ,2
crκ ,2

...
...

...
...

..
.

crκ ,j
cr(κ+1) ,j

..

cm,2

...

cm,1

.
.

.

.
.

..
.

..

...

...

.

cr1 ,κ





cr1



 

cr2 ,κ   cr2 
 
..   .. 



. 
  . 
 

cri ,κ   cri 
 

 . 
.. 
=  .. 
. 
 

 

crκ ,κ   crκ 
 



cr(κ+1) ,κ 
 crκ+1 


..   .. 

.   . 
cm,κ

crm

When R uses E instead of E, the ith row of A for i ≤ κ will be ai = (bi ⊕ (s ⊙ cri )). The pad used to
mask the ri th message xi,ri in ith extended OT is:



H i, ai ⊕ (s ⊙ cri ) = H i, bi ⊕ s ⊙ (cri ⊕ cri )


= H i, bi ⊕ (s ⊙ 0i−1 10κ−i

= H i, bi ⊕ 0i−1 si 0κ−i
Now note that the malicious receiver has cleverly made the pad used for xi,ri a function of sole unknown
bit si . With the knowledge of its chosen input xi,ri and the padded message yi,ri that the receiver receives
7

in the OT extension protocol, the malicious receiver R recovers thevalue of the pad by finding yi,ri ⊕ xi,ri .
i−1 s 0κ−i . Now two calls to the random oracle H
It further knows
i
i ⊕ xi,ri is same as H i, bi ⊕ 0
 that yi,r
i−1
κ−i
with inputs (i, bi ⊕ 0 si 0 ) s ∈{0,1} is sufficient to find the value of si . In the similar way, it can find
i
entire input vector of the sender, s with 2κ number (polynomial in κ) of calls to the random oraclebreaking
the privacy of the sender completely. The attack works in the version of KK13 that reduces n1 -OTm
ℓ to
κ
2
1 -OTκ without any modification.

3.3 Efficiency of [KK13]

Since efficiency is the prime focus of this paper and we build an OT extension protocol in KK13 style secure against malicious adversaries, we recall the communication complexity
of KK13
from [KK13]. For

2
κ
complexity analysis we consider the version of KK13 that reduces n1 -OTm
to
-OT
in Apℓ
κ (presented
1
n
m
2
m
pendix D of [KK13]) and requires less communication than the one
 that reduces 1 -OTℓ to 1 -OTκ . The
communication complexity of KK13 OT extension producing n1 -OTm
ℓ is O(m(κ + nℓ)) bits.
has
The best known semi-honest OT extension protocol before KK13
[IKNP03] which
 is IKNP protocol
2
κ
n
m
a communication complexity of O(m(κ+ℓ)) bits for producing 21 -OTm
from
-OT
.
To
get
-OT
ℓ
κ
ℓ as
1
1
the output from IKNP
protocol, the efficient transformation of [NP05] is used.
The transformation generates
n
1
2
log n
2
log n
-OT
from
-OT
with
an
additional
(outside
the
execution
of
-OT
) communication cost of
ℓ
κ
κ
1
1
1

n
m
log n
O(ℓn) bits. This transformation can be repeated m times to reduce 1 -OTℓ to 21 -OTm
with an
κ
as
the
output
from
IKNP
protocol,
first
additional communication cost of O(ℓmn) bits. So to get n1 -OTm
ℓ



m log n
m
m log n
2
n
2
is produced via [IKNP03] and then the reduction from 1 -OTℓ to 1 -OTκ
is used
1 -OTκ
that requires an additional communication cost of O(ℓmn) bits. So the total communication turns out to be
O(m log n · (κ + κ) + ℓmn) = O(m(κ log n + nℓ)) bits. Now recall that n ≤ κ, a restriction that comes
κ contains κ codewords). Given this bound, as long as
from the KK13 OT extension (due to the fact that CWH
ℓ = Ω(log n), KK13 OT extension gives better communication complexity than IKNP protocol.

4 Actively Secure OT Extension for Short Secrets
We make the KK13 OT extension protocol secure against a malicious receiver by adding a consistency
check that relies on linearity of WH code and adds a communication of O(µ log κ) bits irrespective of the
number of extended OTs. We first discuss the properties of WH code relevant to us for the correctness of
the consistency check. We then discuss the check and our actively secure protocol. As we will see the check
involves an additional trick apart from the linearity of WH codes to achieve the claimed communication
complexity. We also describe the required ideal functionalities.

4.1 Randomized Linearity Testing
We focus on WH code that maps messages of length log κ to codewords of length κ. A WH codeword for a
log κ-bit input x can be viewed as a truth table of a linear function Lx : {0, 1}log κ → {0, 1} parametrised
with x where Lx (a) = x ⊗ a. The WH codeword for x can be defined as WH(x) := (Lx (a))a∈{0,1}log κ .
It is easy to note that Lx (a) = La (x) for any a ∈ {0, 1}log κ . So we can rewrite the WH codeword for
x as WH(x) := (La (x))a∈{0,1}log κ . It is also easy to note that La () is a linear function since La (x ⊕
y) = La (x) ⊕ La (y) for any x and y in {0, 1}log κ . This implies that given codewords, say cx and cy
corresponding to x and y respectively, the codeword for x ⊕ y can be obtained as cx ⊕ cy . In general,
any linear combination of a set of WH codewords will lead to a WH codeword. On the other hand XOR
of a codeword and a non-codeword will be a non-codeword. We note that the above statements are true for

8

κ ) for any I of size less than κ/2. The distance of PRN (C κ ) is κ/2 − |I| which is at
pruned code PRNI (CWH
I WH
least 1.
In our OT extension protocol, we need to verify whether a set strings are individually valid WH codewords or not. In particular the number of strings to be verified is proportional to the number of extended
OTs output by the OT extension protocol. In practice, it will be in the order of millions. Individual string
testing may inflate the computation and the communication cost many-fold. We take the following route to
bypass the efficiency loss. Given ν strings for validity verification, we compress them to one string via linear
combination taken using a uniform random vector of length ν and then check the compressed string only for
validity. We show that the compression process ensures that the output string will be a non-codeword with
probability at least 12 if the input set contains some non-codeword(s). Below we present the randomized
linearity test for ν strings in Fig 2 and its probability analysis in Theorem 4.1.

Figure 2: A Randomized Linearity Test for Many Strings
Randomized Linearity Test for ν Strings
– Input: ν κ-bit strings y1 , . . . , yν .
– Output: Accept or Reject indicating whether the strings y1 , . . . , yν passes the test or not.
1. Selection of Random Combiners: Choose ν bits b1 , . . . , bν uniformly at random.
L
2. The test: Compute y = νi=1 bi ⊙ yi . Output Accept if y is a valid WH codeword, output Reject
otherwise.

Theorem 4.1. Assume that some of the ν κ-bit strings y1 , . . . , yν are not WH codewords. The randomized
linearity test presented in Fig 2 outputs Reject with probability at least 12 .
Proof. Without loss of generality, let i1 , . . . , iη denote the indices of the input strings that are non-codewords.
That is, {i1 , . . . , iη } ⊆ {1, . . . , ν} and yi1 , . . . , yiη are exactly the non-codeword strings among the set of ν
input strings. It is easy to verify that any linear combination of the remaining strings that are codewords will
result in a codeword. So we concentrate on the linear combination that can result from the non-codewords
yi1 , . . . , yiη . Let the uniform random bits used to find the linear combination of the non-codewords be
bi1 , . . . , biη . There are 2η possibilities in total for these η bits which can be interpreted as numbers in the
set {0, . . . , 2η − 1}. We divide these 2η strings or numbers in two sets, say A and B. A and B consist
of all the strings that corresponds to even and odd numbers respectively from {0, . . . , 2η − 1}. Clearly
|A| = |B| = 2η−1 . We now show that at least 2η−1 strings lead to a non-codeword when they are used as
linear combiners for the set of non-codewords yi1 , . . . , yiη . We prove our claim by showing that for every
element in set A, there exists at least one unique string that when used for linear combination of the noncodewords will lead to a non-codeword. Consider a string w from set A. We have two cases to consider:
(i) w when used as the linear combiner for yi1 , . . . , yiη yields a non-codeword. In this case w itself is the
string and element in A that when used as the linear combiner for the non-codewords will lead to a noncodeword.
(ii) w when used as a linear combiner for yi1 , . . . , yiη yields a codeword. Note that w is a string that denotes
an even number, say p in {0, . . . , 2η − 1}. The least significant bit of w is a zero. The string corresponding
to p + 1 will belong to the set B and will have the same form as w except that the least significant bit will be
1. The linear combination of yi1 , . . . , yiη−1 with respect to w is a codeword. We exclude yiη from the list
since the least significant bit of w is zero. Whereas yiη is a non-codeword and will be included in the linear
combination with respect to the string corresponding to p + 1.
Clearly, the string corresponding to p + 1 will lead to a non-codeword as the linear combination of a
codeword and a non-codeword always gives a non-codeword. We have shown that for every w that leads to
a codeword, there is a unique string in B that leads to a non-codeword. The mapping is one-to-one.
9

We can now conclude that at least half the possibilities of bi1 , . . . , biη leads to a non-codeword when
used as a linear combiner. Since the linear combiners are chosen uniformly at random, the probability that
the linear combination that will result from the non-codewords yi1 , . . . , yiη is a non-codeword is at least 21 .
Recall that any linear combination of the remaining strings that are codewords will result in a codeword. So
the compressed string y resulted from the linear combination of all the ν strings will be a non-codeword
with at least 12 probability too.
κ ) for any I of size less than κ/2. So we
It is easy to note that the above theorem holds true for PRNI (CWH
get the following corollary.
Corollary 4.2. Let I ⊂ [κ] be a set of size less than κ/2. Assume that some of the ν κ − |I|-bit vectors
κ ) with probability at least 1 where y =
y1 , . . . , yν are not pruned WH codewords. Then y 6∈ PRNI (CWH
2
L
ν
i=1 bi ⊙ yi and the bits b1 , . . . , bν are uniform random.

4.2 Functionalities

We describe the ideal functionalities that we need. Below we present an OT functionality parameterized
using three parameters ℓ that denotes the string length of the sender’s inputs, n that refers to 1-out-of-n OTs
and m that denotes the number of instances of the OTs.

Figure 3: The Ideal Functionality for n1 -OTm
ℓ
(n,m,ℓ)

Functionality FOT
interacts with S, R and the adversary S and is parameterized by three parameters ℓ that denotes the
string length of the sender’s inputs, n that refers to 1-out-of-n OTs and m that denotes the number of instances
of the OTs.

• Upon receiving m tuples (xi,1 , · · · , xi,n ) i∈[m] of ℓ bit strings from S and m selection integers

(r1 , · · · , rm ) such that each ri ∈ [n] from R, the functionality sends xi,ri i∈[m] to R. Otherwise it
aborts.
(n,m,ℓ)
FOT

Next we present a functionality to generate uniformly random common coins.
Figure 4: The Ideal Functionality for generating random common coins
Functionality FCOIN
FCOIN interacts with S, R and the adversary S.
• Upon receiving (coin, ℓ) from both S and R, the functionality generates ℓ random bits, say w and sends
w to both S and R. Otherwise it aborts.

4.3 The Protocol

2
κ
We now describe the protocol that realizes n1 -OTm
ℓ given ideal access to 1 -OTκ . The protocol is similar
to the protocol of KK13 (cf. Fig. 1), except that our protocol includes a consistency check for preventing R
from behaving maliciously and using non-codewords in matrix E. The check makes use of the Randomized
Linearity Testing described in Section 4.1. It is trivial to see that Randomized Linearity Test alone doesn’t
suffice, since a malicious R can provide some vector for the check independent from what he had used in
the seed OTs. Thus we need a check to ensure that the vector provided by R for the check is consistent with
the vectors used in the seed OTs. We make use of the fact that if both S and R are honest, then we have
ai = bi ⊕ (ei ⊙ s). A closer analysis of this expression gives a simple verification mechanism for a corrupt
R. Namely, R sends to S a random linear combination of the rows of B and E, say b and e respectively,
10

for a commonly agreed random linear combiner generated using a coin tossing protocol. S then applies
the same random linear combiner on the rows of A to obtain a and checks if b and e are consistent with
s and a. Namely, whether a = b ⊕ (e ⊙ s) holds or not. While the above check is simple, it requires
communication of κ-bit vectors, namely b and e. The communication is brought down to O(log κ) using a
couple of tricks. First, a second level of compression function is applied on a, b and e ⊙ s via xor on the
bits of the individual vectors. This results in three bits a, b and p respectively from a, b and e ⊙ s. Then
the check is simply to verify if a = b ⊕ p. Notice that e ⊙ s can be perceived as the linear combination
of e for random combiner s. Since s is privy to S, R cannot compute the linear combination of e ⊙ s,
namely p. So R sends across the index of the codeword that matches with e and on receiving it S computes
κ consists of κ codewords. Thus our final
p after computing e ⊙ s. The index requires just log κ bits as CWH
consistency check needs communication of O(log κ) bits and a sequence of cheap xor operations. Lastly,
the above check is repeated µ times, where µ denotes the statistical security parameter. We show that either a
corrupt R tweaks few positions of the codewords allowing error-correction or it is caught. Either event takes
place with overwhelming probability. Looking ahead to the proof, the former event allows the simulator
to extract the inputs of corrupted R and thereby making the real and the ideal world indistinguishable with
high probability. Whereas, the protocol is aborted in both the real and ideal worlds when the latter event
happens. Our construction appears in Fig. 5.
4.3.1

Security

The correctness of our protocol follows from the correctness of the KK13 protocol and the correctness of
the consistency check. While the former is explained in Section 3, the latter is explained below. The linearly
combined vectors e(l) for l ∈ [µ] will be valid codewords follows directly from the linearity of WH code as
mentioned in Section 4.1. When R is honest we have ai = bi ⊕ (ei ⊙ s) and cα(l) = e(l) for l ∈ [µ]. Thus,
for every l ∈ [µ],
a(l) =

m+µ
M

(l)

wi ⊙ ai =

=

(l)
wi

#

⊙ bi ⊕

i=1
(l)

a(l)

(l)

wi ⊙ [bi ⊕ (ei ⊙ s)]

i=1

i=1

"m+µ
M

m+µ
M

"

m+µ
M
i=1

(l)
wi

⊙ ei

!

#

⊙s

= b ⊕ (e(l) ⊙ s)
κ
κ
M
M
(l)
(l)
(l)
(bi ⊕ (si ⊙ ei )) = b(l) ⊕ p(l)
ai =
=
i=1

i=1

Now it is easy to verify that the protocol is correct (i.e., zi = xi,ri ) when both the parties follow the protocol.
We now move on to the security argument for our protocol. The original OT extension of [KK13]
provides security against a malicious S. Since our consistency check involves message communication
from R to S, it does not offer any new scope for a malicious sender to cheat. However, the check may reveal
some information about R’s input. Recall that R’s input is encoded in the rows of matrix E and during the
check, a random linear combination of the rows of E (where the combiner is known to S) is presented to S
for verification. The check is repeated for µ times. To prevent information leakage on R’s input, E is padded
with µ extra rows consisting of random codewords. This ensures that the linear combination presented in an
instance of the check will look random and will bear no information about the m rows of E that encode R’s
input, unless the bits of the random combiner corresponding to the padded µ rows are zero. However, the
probability of that happening is only 21µ .
A corrupt R can cheat by not picking the rows of E as codewords. Our consistency check ensures an
overwhelming probability for catching such a misconduct when ‘large’ number of positions in the codewords
11

Figure 5: Actively Secure OT Extension Protocol
Protocol for
–
–
–
–


-OTm
ℓ from

n
1


-OTκκ

2
1


Input of S: m tuples (xi,1 , · · · , xi,n ) i∈[m] of ℓ bit strings.
Input of R: m selection integers (r1 , · · · , rm ) such that each ri ∈ [n].
κ
Common Inputs: A security parameter κ such that κ ≥ n, and Walsh-Hadamard code CWH
= (c1 , · · · , cκ ).
Oracles, Cryptographic Primitives and Functionalities: A random oracle H : [m] × {0, 1}κ → {0, 1}ℓ
(2,κ,κ)
and an
and a pseudorandom generator G : {0, 1}κ → {0, 1}m+µ. An ideal OT functionality FOT
ideal coin tossing functionality FCOIN .
1. Seed OT Phase:
(a) S chooses s ← {0, 1}κ at random.
(b) R chooses κ pairs of seeds (k0j , k1j ) each of length κ.
(2,κ,κ)

(c) S and R interact with FOT

in the following way.

– S acts as receiver with inputs.
– R acts as sender with input (k0i , k1i )
– S receives output {ksi i }i∈[κ] .

i∈[κ]

.

2. OT Extension Phase I:
(a) R forms three (m + µ) × κ matrices B, E and D in the following way and sends D to S:
– Set bj = G(k0j ).
κ
.
– Set ei = cri for i ∈ [m]. For i ∈ [m + 1, m + µ], set ei to a randomly picked codeword from CWH
j
j
1
j
– Set d = b ⊕ G(kj ) ⊕ e .

j
j
(b) On receiving D, S forms (m + µ) × κ matrix
A
with
the
jth
column
of
A
set
as
a
=
s
⊙
d
j
 ⊕


sj
j
j
j
G(kj ). Clearly, (i) a = b ⊕ (sj ⊙ e ) and (ii) ai = bi ⊕ (s ⊙ ei ) = bi ⊕ (s ⊙ cri ) .

3. Checking Phase:

(a) S and R invoke FCOIN with (coin, µ(m+µ)) and receives an µ (m+µ)-length random bit vectors
say w(1) , . . . , w(µ) . On receiving the vectors, the parties do the following for l ∈ [µ]:
– R computes b(l) =

m+µ
L
i=1

(l)

wi ⊙ bi , e(l) =

m+µ
L
i=1

(l)

wi ⊙ ei and b(l) =

κ
L

i=1

(l)

bi . It sends b(l) and α(l)

where e(l) = cα(l) to S.
m+µ
κ
κ
L
L
L (l)
(l)
(l)
pi . It aborts
ai , p(l) = s ⊙ cα(l) and p(l) =
wi ⊙ ai , a(l) =
– S computes a(l) =
i=1

i=1

i=1

the protocol if a(l) 6= b(l) ⊕ p(l) .

4. OT Extension Phase II:

(a) For every i ∈ [m], S computes yi,j = xi,j ⊕ H i, ai ⊕ (s ⊙ cj ) and sends {yi,j }j∈[n] .

(b) For every i ∈ [m], R recovers zi = yi,ri ⊕ H(i, bi ).

are tweaked. If few positions are tweaked, then we show that the tweaked codewords are error-correctable
with high probability allowing the simulator in the proof to extract input of the corrupt R. We now prove
security formally.
(n,m,ℓ)

Theorem 4.3. The protocol in Fig. 5 securely realizes FOT

(2,κ,κ)

in the (FOT

, FCOIN )-hybrid model.

Proof. Our proof is presented in Universal Composability (UC) framework recalled briefly in Appendix A.
12

To prove the security of our protocol, we describe two simulators. The simulator SS simulates the view of
a corrupt sender and appears in Fig. 6. On the other hand, the simulator SR simulates the view of a corrupt
receiver and is presented in Fig. 7.
Figure 6: Simulator SS for Malicious Sender
Simulator SS for S

The simulator plays the role of the honest R and simulates each step of the protocol n1 -OTm
ℓ as follows. The
communication of the Z with the adversary A who corrupts S is handled as follows: Every input value received
by the simulator from Z is written on A’s input tape. Likewise, every output value written by A on its output
tape is copied to the simulator’s output tape (to be read by the environment Z).
(2,κ,κ)

(2,κ,κ)

, SS receives s, the input of S to the functionality FOT
1. Seed OT Phase: On behalf of FOT

(2,κ,κ)
.
it picks κ PRG seeds ki each of length κ and sends ki i∈[κ] to S on behalf of FOT

. Next

2. OT Extension Phase I: SS picks a (m + µ) × κ matrix D uniformly at random and sendsto S. It then
computes matrix A using the PRG seeds sent to S, s and D. Namely, it sets aj = sj ⊙ dj ⊕ G(kj ).

3. Checking Phase: On receiving (coin, µ(m + µ)) from S on behalf of FCOIN , SS sends µ (m + µ)length random bit vectors say w(1) , . . . , w(µ) . For l ∈ [µ], it then computes a(l) and a(l) using w(l) and
A just as an honest S does. It chooses a random WH codeword, say e(l) , sets b(l) = a(l) ⊕ (s ⊙ e(l)) and
computes b(l) using b(l) . Finally, it sends α(l) , the index of e(l) and b(l) to S.

4. OT Extension Phase II: On receiving (yi,1 , · · · , yi,n ) i∈[m] from S, SS computes xi,j = yi,j ⊕


(n,m,ℓ)
on behalf
H i, ai ⊕ (s ⊙ cj ) for 1 ≤ i ≤ m and sends (xi,1 , · · · , xi,n ) i∈[m] to functionality FOT
of S.
c

(2,κ,κ)

≈ REAL(n)-OTm ,A,Z when A corrupts S. In (FOT , FCOIN )ℓ
1
OT
hybrid model, we note that the difference between the simulated and the real view lies in D matrix. In the
simulated world, the matrix D is a random matrix, whereas in the real world it is a pseudo-random matrix.
The indistinguishability can be proved via a reduction to PRG security.
c
Next, we prove that IDEAL F (n,m,ℓ) ,S ,Z ≈ REAL(n)-OTm ,A,Z when A corrupts R via a series of hyWe now prove that IDEAL F (n,m,ℓ) ,S

S ,Z

R

OT

1

ℓ

brids. The output of each hybrid is always just the output of the environment Z. Starting with HYB0 =
REAL (n)-OTm ,A,Z , we gradually make changes to define HYB1 and HYB 2 as follows:
1

ℓ

HYB 1 : Same as HYB 0 , except that in the Checking Phase, the protocol is aborted when the simulator SR
fails to extract the input of R.

HYB 2 : Same as HYB 1 , except that the default value 0ℓ is substituted for the inputs xi,j i∈[m]∧j6=r .
i

Clearly, HYB 2 = IDEAL F (n,m,ℓ) ,S
OT

R

. Our proof will conclude, as we show that every two consecutive
,Z

hybrids are computationally indistinguishable.
c

HYB 0 ≈ HYB 1 : The difference between HYB 0 and HYB 1 lies in the condition on aborting the protocol. In HYB 0 the protocol is aborted when a(l) 6= b(l) ⊕ p(l) for some l ∈ [µ] (cf. Fig. 5). Whereas, in
HYB 1 the protocol is aborted when either the condition for abortion in HYB 0 is true or the extraction fails.
κ ). Let PC
The latter implies that either |T | ≥ κ/2 or there exist an index i such that PRNT (ei ) 6∈ PRNT (CWH
denote the event of passing the consistency check for a corrupt R who commits a non-codeword matrix E
in the seed OT phase. Let FE denote the event of failed extraction of R’s input. Lastly, let D denote the
event that Z distinguishes between HYB 0 and HYB1 . Then, we have Pr[D | ¬PC] = 0 (since the execution

13

Figure 7: Simulator SR for Malicious Receiver
Simulator SR for R.

The simulator plays the role of the honest S and simulates each step of the protocol n1 -OTm
ℓ as follows. The
communication of the Z with the adversary A who corrupts R is handled as follows: Every input value received
by the simulator from Z is written on A’s input tape. Likewise, every output value written by A on its output
tape is copied to the simulator’s output tape (to be read by the environment Z).
(2,κ,κ)

1. 
Seed OT Phase: On behalf of FOT
(k0i , k1i ) i∈[κ] .

, SR receives the input of R to the functionality, namely

2. OT
Phase I: On receiving matrix D from R, SR computes E using the knowledge of
 0Extension
(ki , k1i ) i∈[κ] . That is, it computes E as ei = G(k0i ) ⊕ G(k1i ) ⊕ di , where i ∈ [κ].

3. Checking Phase: On receiving (coin, µ(m+µ)) from R on behalf of FCOIN , SR sends µ (m+µ)-length
random bit vectors say w(1) , . . . , w(µ) to R. Then l ∈ [µ], it receives b(l) and α(l) from R and performs
(n,m,ℓ)
on
the consistency check honestly like an honest S. If the check fails, then it sends Abort to FOT
m+µ
L
(l)
wi ⊙ ei using the rows of E
behalf of R and halts. If none of the check fails, SR computes e(l) =
(l)

and finds Ti = HDI(e , cα(l) ) for l ∈ [µ]. It then computes T =

µ
S

i=1

Tl . If |T | ≥ κ/2 or there exists an

l=1
(n,m,ℓ)

κ a
index i such that PRNT (ei ) 6∈ PRNT (CWH
) , then it sends Abort to FOT
ith input of R as ri where PRNT (ei ) = PRNT (cri ) for i ∈ [m].

. Otherwise, SR extracts the

4. OT Extension Phase II: SR sends the input of R, namely (r1 , · · · , rm ) (such that each ri ∈ [n]) to

(n,m,ℓ)
(n,m,ℓ)
, it receives xi,ri i∈[m] . It then runs the protocol
on behalf of R. From FOT
functionality FOT


with R using xi,ri i∈[m] and 0ℓ for the unknown inputs xi,j i∈[m]∧j6=ri .

κ
Note that PRNT (CWH
) consists of κ vectors with distance κ/2 − |T | which is at least one when |T | < κ/2. This follows
κ
from the fact that the distance of CWH
is κ/2.
a

aborts in both hybrids) and Pr[D | PC] = Pr[FE | PC]. So we have,
Pr[D] = Pr[D | PC] · Pr[PC] + Pr[D | ¬PC] · Pr[¬PC]

(1)

= Pr[FE | PC] · Pr[PC]
We now show that Pr[D] is negligible in κ and µ because either the probability of passing the check is
negligible or the probability of failure in extraction when check has passed is negligible. In other words, we
show that Pr[PC] ≤ negl(κ, µ) when |T | ≥ κ/2 and Pr[FE | PC] ≤ negl(κ, µ) otherwise. We capture the
above in the following two lemmas.
Lemma 4.4. Pr[D] ≤ max( 2|T1 | , 21µ ), when |T | ≥ κ/2.
Proof. When |T | ≥ κ/2, we note that Pr[FE | PC] = 1 as the extraction always fails. Plugging the equality
in Equation 1, we get Pr[D] = Pr[PC]. Next we conclude the proof by showing that Pr[PC] = max( 2|T1 | , 21µ )
which is negligible in κ and µ.
Consider lth iteration of the check in Checking Phase. Recall that a(l) at S’s end is computed as follows.
m+µ
m+µ

L (l)
L (l)
First a(l) is calculated as a(l) =
wi ⊙ai where ai = bi ⊕(s⊙ei ) . Denoting b(l) =
wi ⊙bi and

e(l)

=

m+µ
L
i=1

we have

i=1

(l)
wi

a(l)

=

⊙ ei , we have
κ
L

i=1

a(l)

=

i=1

b(l)

⊕ (s ⊙ e(l) ).

Lastly, denoting

b(l)

=

κ
L

i=1
(l)
ai

=

b(l)

⊕

p(l) .

Let a corrupt R sends the index
14

α(l) .

(l)
bi

Let

and p =

b̄(l)

κ
L

i=1

(l)

si ⊙ ei ,

denote the bit sent

along with α(l) and let p̄(l) =

κ
L

i=1

(l)

si ⊙ ci

(l)

(l)

where cα(l) = [c1 , . . . , cκ ]. Now the check passes when

b(l) ⊕ p(l) = b̄(l) ⊕ p̄(l) . The equation implies that
b(l) ⊕ b̄(l) = p(l) ⊕ p̄(l) =

κ
M
i=1

=

κ
M

(l)

(l)

si ⊙ ei

!

κ
M M
i=1

(l)

si ⊙ ci

!

(l)

si ⊙ (ei ⊕ ci )

i=1

Now note that the bits of s corresponding to the indices not in T do not have any impact on the value of
κ
L
(l)
(l)
si ⊙ (ei ⊕ ci ). So 2κ−|T | possibilities of the vector s will lead to passing the check. Since s is chosen
i=1

uniformly at random and is a κ-length bit vector, the probability that the chosen vector will hit one of the
κ−|T |
2κ−|T | possibilities is 2 2κ . The probability of passing the check is thus 2|T1 | . Another way of passing the
check is to hit the value of b̄(l) in all the µ instances of the check so that the equalities b(l) ⊕ p(l) = b̄(l) ⊕ p̄(l)
for l ∈ [µ] hold good. The probability of passing the check in this way thus turns out to be 21µ . This
concludes the proof.
Lemma 4.5. Pr[D] ≤

1
2µ ,

when |T | < κ/2.

Proof. From Equation 1, we get the inequality Pr[D] ≤ Pr[FE | PC]. We now show that Pr[FE | PC] ≤ 21µ .
We note that when |T | < κ/2, the reason for failure in extraction happens because some of the pruned
κ ). That is, there exists an index i such that
rows of E do not belong to the the pruned code PRNT (CWH
κ is κ/2 and the number of indices that are
κ
PRNT (ei ) 6∈ PRNT (CWH ). Now the fact that the distance of CWH
κ ) consists of κ vectors with distance κ/2 − |T | which
pruned are strictly less that κ/2 implies that PRNT (CWH
κ ),
is at least one. Now Corollary 4.2 implies that if some of the pruned rows of E do not belong to PRNT (CWH
(l)
(l)
κ
then PRNT (e ) belongs to PRNT (CWH ) with probability at most 1/2. Since e s are computed using independent and uniformly picked random linear combiners, at least one of PRNT (e(1) ), . . . , PRNT (e(µ) ) do not
κ ) with probability at least 1 − 1 . Recall that e(l) is computed using w(l) . But since
belong to PRNT (CWH
2µ
κ ) for all l ∈ [µ], it implies that PRN (ei ) for all
(l)
PRNT (e ) = PRNT (cα(l) ) and PRNT (cα(l) ) ∈ PRNT (CWH
T
κ
i ∈ [m + µ] belong to PRNT (CWH ) with probability at least 1 − 21µ . So we have Pr[¬FE | PC] ≥ 1 − 21µ
which implies Pr[FE | PC] ≤ 21µ

c
HYB 1 ≈ HYB 2 : The difference between HYB 1 and HYB 2 lies in the values for the inputs xi,j i∈[m]∧j6=r .
i
In HYB 1 these values are the real values of an honest S whereas in HYB2 these are the default value
0ℓ . The security in this case will follow from the random oracle assumption of H. We proceed in two
steps. First, assume that the distinguisher of HYB 1 and HYB2 does not make any query to H. We
show that the pads used to mask the unknown inputs of S will be uniformly random
 and independent
of each other due to random oracle assumption. Recall that the pads for masking xi,j i∈[m]∧j6=r are
i


κ is a WH code, the Hamming weight of each vector
H i, bi ⊕ (s ⊙ (cri ⊕ cj )) i∈[m]∧j6=r . Since CWH
i

in the set (cri ⊕ cj ) i∈[m]∧j6=r is at least κ/2. Since s is picked at random from {0, 1}κ , each of the
i

values in s ⊙ (cri ⊕ cj ) i∈[m]∧j6=r is uniformly distributed over a domain of size at least 2κ/2 . Now
i


random oracle assumption lets us conclude that the pads H i, bi ⊕ (s ⊙ (cri ⊕ cj )) i∈[m]∧j6=r are rani
dom
 and independent of each other and thus provide information-theoretic blinding guarantee to the values
xi,j i∈[m]∧j6=r .
i

15

Next, following the standard of proofs in the random oracle model we allow the distinguisher to make
polynomial(in κ) number of adaptive
 queries to H. Clearly, if a distinguisher makes a query to H on any of
the values i, bi ⊕ (s ⊙ (cri ⊕ cj ) i∈[m]∧j6=r that are used to mask the unknown inputs of S, then it can
i
distinguish between the hybrids. Such queries are denoted as offending queries. As long as no offending
query is made, each of these m(n − 1) offending queries is (individually) distributed uniformly at random
over a domain of size (at least) 2κ/2 and so the distinguisher’s probability of hitting upon an offending query
remains the same as in the case he does not make any query at all to H. So if the distinguisher makes q
queries, then it’s probability of distinguishing only increases by a polynomial factor over 2−κ/2 .
Our security proof relies on random oracle assumption of H. However, as mentioned in [KK13], the
random oracle assumption can be replaced with a generalized notion of correlation-robustness [IKNP03]
referred as C-correlation-robustness [KK13] in a straightforward way. For completeness, we recall the
definition of C-correlation-robust hash functions below.
Definition 4.6 ([KK13]). Let C = {c1 , . . . , cn } be a set of κ-bit strings such n = Poly(κ) and for any
j, k with j 6= k, the Hamming distance between cj and ck is Ω(κ). Then a hash function H : {0, 1}∗ →
{0, 1}ℓ(κ) is C-correlation-robust if for any polynomial m(κ) and any non-uniform PPT distinguisher A
provided with input C has negl(κ) probability of distinguishing the following distributions:
n
o

–
j, k, H(i, bi ⊕ ((cj ⊕ ck ) ⊙ s)) i∈[m],j,k∈[n],j6=k where each string in {bi }i∈[m] is a κ-bit and s
is a κ-bit string chosen uniformly at random and independent of {bi }i∈[m] .
– Um(n−1)ℓ ; Um(n−1)ℓ denotes uniform distribution over {0, 1}m(n−1)ℓ .
4.3.2

Efficiency

The actively secure protocol incurs a communication of O(κ2 ) bits in Seed OT Phase. In OT Extension
Phase I, R sends κ(m + µ) bits to S. In Checking Phase, S and R invokes FCOIN . We follow the
implementation of [KOS15] for FCOIN that generates µ(m + µ) bits at one go and uses a pseudorandom
function (PRF) and a PRG. Let Fk : {0, 1}2κ → {0, 1}κ be a keyed PRF with k ∈ {0, 1}κ be a uniform
random string and G : {0, 1}κ → {0, 1}µ(m+µ) be a PRG. Then FCOIN can be realized as follows:
1. R generates and sends random sR ← {0, 1}κ to S.
2. S generates and sends random sS ← {0, 1}κ to R.
3. Both parties compute s = Fk (sS , sR ) and output w1 ||w2 . . . ||wµ = G(s) where each wi ∈ {0, 1}(m+µ) .
With the above implementation of FCOIN , Checking Phase incurs a communication of O(µ log κ).
In OT Extension Phase II, S communicates mnℓ bits to R. So the total communication our protocol is
O(κ2 + κ(m + µ) + µ log κ + mnℓ) = O(m(κ + nℓ)) (assuming m is asymptotically bigger than κ and µ)
bits which is same as that of KK13 OT extension.
Computation-wise, Checking Phase constitutes the additional work that our protocol does over KK13
protocol. The additional work involves cheap xor and bit-wise multiplications.

5 Empirical Results
We compare our work with the existing protocols of KK13 [KK13], IKNP [IKNP03], ALSZ15 [ALSZ15]
and NNOB [NNOB12] in terms of communication and runtime in LAN and WAN settings. The implementation of KOS [KOS15] is not available in the platform that we consider for benchmarking. As per the claim
made in KOS, the runtime of their OT extension bears an overhead of 5% with respect to IKNP protocol
both in LAN and WAN. The communication complexity of KOS is at least the complexity of IKNP. These
results allow to get a clear idea on how KOS fares compared to our protocol.
16

In any practical scenario, the computation is not the prime bottleneck, as computing power has improved
a lot due to improvements in hardwares. The communication overhead is the main issue, and so most of
the aforementioned protocols are aimed at improving the communication complexity. Our empirical results
show that our proposed protocol performs
way better than even the passively secure IKNP in terms of

n
communication complexity when 1 -OTs with short input are expected outcomes. Since ALSZ15, NNOB
and KOS are built upon IKNP, they lag behind our protocol in performance too. Though our prime focus
is to improve the communication complexity, our protocol outperforms IKNP and the existing actively
secure protocols in runtime both in LAN and WAN setting. We now detail the software, hardware and
implementation specifications used in our empirical analysis before presenting our experimental findings.
Software Details. We build upon the OT extension code provided by the Encrypto group on github [OTC]. It
contains the OT extension implementations of KK13, NNOB and ALSZ15 in C++, using the Miracl library
for elliptic curve arithmetic. We build upon the KK13 code for our actively secure protocol. AES-128 has
been used for the PRG instantiation and the random oracle has been implemented by the SHA-256 hash
function.
Hardware Details. We have tested the code in a standard LAN network and a simulated WAN setting.
Our machine has 8 GB RAM and an Intel Core i5-4690 CPU with 3.5 GHz processor speed. For WAN
simulation, we used the tc tool of Linux, where we introduced a round trip delay of 100 milliseconds into
the network, with a limited bandwidth of 20 Mbps.
Implementation Details. We discuss our choice of m, n and ℓ denoting the number of extended output OTs,
the number of inputs of S in each extended OT
 and the bit length of S’s input respectively. In other words,
we refer to the parameters m, n and ℓ of n1 -OTm
ℓ . Recall that as long as the input length of S, namely
ℓ satisfies the relation ℓ = Ω(log n), theoretically KK13 OT extension (and our proposed OT extension)
gives better communication complexity for producing n1 -OTm
ℓ than IKNP protocol and its variants (cf.
Section 3.3). For benchmarking, we take two approaches. First, we fix n = 16 and ℓ = 4(= log 16) and
experiment on the following values of m: 1.25 × 105 , 2.5 × 105 , 5 × 105 and 1.25 × 106 . Next, we fix
m to a value and vary n from 8 to 256 in the powers of 2. The
 value of ℓ for each choice of n is set as
log n. Our protocol and KK13 directly generate OTs of type n1 -OTℓ whereas IKNP, ALSZ15 and NNOB

generate OTs of type 21 -OT1 . To compare with IKNP, ALSZ15 and NNOB, we convert the output OTs of


these protocols, namely 21 -OT1 to n1 -OTℓ using the efficient transformation of [NP05] (cf. Section 3.3).
To obtain a computational security guarantee of 2−128 , while KK13 and our protocol need 256 seed OTs,
IKNP, NNOB and ALSZ15 need 128, 342 and respectively 170 seed OTs. Among these, except IKNP and
KK13, the rest are maliciously secure. To obtain a statistical security guarantee of 2−40 against a malicious
receiver, ALSZ15 and NNOB need 380 checks whereas we need 96 checks.
We follow the approach of ALSZ15 implementation and perform the OT extension in batches of 216 in
sequential order. For each batch, the sender and the receiver perform the seed OTs, participate in a coin
tossing protocol, perform the checks and finally obtain the output. We use one thread in the sender as well
as in the receiver side in order to calculate the upper bound on the computation cost. However our code
is compatible with multiple threads where each thread can carry out a batch of OTs. Lastly, our seed OT
implementation relies on the protocol of [PVW08].

5.1 Performance Comparison
Since we build upon KK13 protocol, we first display in Table 3-4 the overhead (in %) of our protocol
compared to KK13. Notably, the communication overhead lies in the range 0.011%-0.028%. Table 3
shows that for large enough number of extended OTs, the runtime overhead of our protocol over KK13
ranges between 4-6% for both LAN and WAN. Table 4 demonstrates that the runtime overheads drop below
2% when in addition the number of inputs of the sender in the extended OTs is large enough.

17

Next, our empirical results are shown in Table 5-6 and Fig. 8-9. First, we discuss our results in Table 5
and Fig. 8 where we vary m. Next, we focus on the results displayed in Table 6 and Fig. 9 where we vary n.
In both the case studies, our protocol turns out to be the best choice among the actively secure OT extensions
and second best overall closely trailing KK13 which is the overall winner. Communication complexity wise,
our protocol is as good as KK13 and is way better than the rest. The empirical results are in concurrence
with the theoretical log n improvement of KK13 and our protocol over IKNP (and its variants).
Table 4: Runtime and Communication Overhead (in %) of
Our protocol over KK13 for producing

Table 3: Runtime and Communication Overhead
(in %) of

16
1

Our protocol over KK13 for producing
Runtime
m

LAN

WAN

1.25 × 105
2.5 × 105
5 × 105
1.25 × 106

6.48
6.33
5.88
3.78

9.27
8.76
7.09
5.72

-OTm
4 .

Runtime

Communication
0.012
0.012
0.012
0.028

n
1

6

-OT10
log n .

Communication

n

LAN

WAN

8
16
32
64
128
256

6.16
4.13
4.5
3.65
1.24
0.58

11.77
6.6
2.29
1.81
1.18
0.8

0.011
0.012
0.013
0.014
0.015
0.015

Performance Comparison for varied m values. The results in Table 5 reflects that KK13 is the best performer
in terms of communication as well as runtime in LAN and WAN. Our actively secure protocol is the second
best closely trailing KK13. Our protocol has communication overhead of 0.012-0.028% over KK13, while
IKNP, ALSZ15 and NNOB have overheads of 79.7-84%, 249% and 352% respectively. Noticeably, we
observe that the cost for generating 5 × 105 16
the cost of generating
1 -OT using our protocol is less than
16
16
5
6
1.25 × 10 1 -OT using NNOB. Similarly the cost of generating 1.25 × 10 1 -OT using our protocol

is 71.6% of the cost of generating 5 × 105 16
1 -OT using ALSZ15.
In LAN setting, the overheads over KK13 vary in the range of 3.78-6.48%, 11-17.60%, 14.4-22.7% and
14.5-20.8% respectively for our protocol, IKNP, ALSZ15 and NNOB. The similar figures in WAN setting
are 5.72-9.26%, 16-22.6%, 35.3-39% and 24.1-29.1% respectively for our protocol, IKNP, ALSZ15 and
NNOB. A pictorial representation is shown in Fig. 8.
Table 5: Performance Comparison of various OT extensions for producing
Runtime in LAN (in sec)

m

Runtime in WAN (in sec)

16
1


-OTm
4 .

Communication (in MB)

KK13 This paper IKNP ALSZ15 NNOB KK13 This paper IKNP ALSZ15 NNOB KK13 This paper IKNP ALSZ15 NNOB

1.25 × 105
2.5 × 105
5 × 105
1.25 × 106

02.16
04.23
08.50
21.68

02.30
04.50
09.00
22.50

02.54
04.88
09.78
24.07

02.65
05.26
10.04
24.81

02.61 13.38
05.05 24.32
10.10 47.39
24.84 115.34

14.62
26.45
50.75
121.94

16.40
29.26
56.9
133.81

18.10
33.80
65.00
158.60

16.90
31.40
60.40
143.20

04.77
09.54
19.08
47.69

04.77
09.54
19.08
47.70

08.66
17.15
34.79
87.74

16.67
33.33
66.62
166.54

21.60
43.21
86.39
215.95

Performance Comparison for varied n values. Here we set m = 5 × 104 and vary n from 8 to 256 in the
powers of 2. Similar to the previous case study, KK13 turns out the best performer here as well (cf. Table
6). Our protocol is the second best closely trailing KK13. Our protocol has communication overhead of
0.011-0.028% over KK13, while IKNP, ALSZ15 and NNOB have overheads of 74.5-384.6%, 239.5-549.4%
and 341.8-652.9% respectively. In LAN setting, the overheads over KK13 vary in the range of 3.5-8.8%,
12.2-263.8%, 22.2-282.7% and 20.5-267.5% respectively for our protocol, IKNP, ALSZ15 and NNOB. The
similar figures in WAN setting are 13.7-20.2%, 27.1-77.4%, 36.7-106.3% and 30.9-86.6% respectively for
our protocol, IKNP, ALSZ15 and NNOB. A pictorial representation is shown in Fig. 9.

18

16
1



Figure 8: Performance Comparison of various OT extensions for producing
(b) WAN Runtime

KK13
This paper
IKNP
ALSZ15
NNOB

20
15

KK13
This paper
IKNP
ALSZ15
NNOB

150

Runtime (s)

Runtime (s)

25

10

(c) Communication

100

Communication (MB)

(a) LAN Runtime

50

5

1.25
2.5
5
12.5
Number of OTs (of order 105)

150
100
50
0

1.25
2.5
5
12.5
Number of OTs (of order 105)

1.25
2.5
5
12.5
Number of OTs (of order 105)
n
1

Table 6: Performance Comparison of various OT extensions for producing
Runtime in LAN (in sec)

n

KK13
This paper
IKNP
ALSZ15
NNOB

200

0

0

-OTm
4 .

Runtime in WAN (in sec)


5×104
-OTlog
n .

Communication (in MB)

KK13 This paper IKNP ALSZ15 NNOB KK13 This paper IKNP ALSZ15 NNOB KK13 This paper IKNP ALSZ15 NNOB

8
16
32
64
128
256

0.70
0.96
1.22
1.33
1.50
1.75

0.73
1.01
1.28
1.45
1.63
1.89

0.79
1.15
1.48
2.26
3.61
6.37

0.86
1.23
1.64
2.37
3.94
6.70

0.85
1.17
1.58
2.36
3.71
6.43

5.06
6.70
7.46
8.88
9.56
10.96

6.08
7.72
8.53
10.31
11.05
12.46

7.38
8.52
9.10
11.29
14.84
19.43

7.67
9.15
10.2
12.97
16.63
22.6

7.41
8.77
9.86
12.64
15.16
20.45

1.43
1.91
2.39
2.86
3.34
3.82

1.43
1.91
2.39
2.86
3.34
3.82

n
1

Figure 9: Performance Comparison of various OT extensions for producing
(a) LAN Runtime

Runtime (s)

Runtime (s)

4

15

10

2
5
8

16

32

64

Value of n

128

256

6.34
8.65
11.29
14.68
19.8
28.75


5×104
-OTlog
n .

30

KK13
This paper
IKNP
ALSZ15
NNOB

20

4.87
6.69
8.81
11.7
16.36
24.8

(c) Communication

(b) WAN Runtime
Communication (MB)

KK13
This paper
IKNP
ALSZ15
NNOB

6

2.5
3.53
4.89
7.01
10.85
18.5

KK13
This paper
IKNP
ALSZ15
NNOB

20

10

0
8

16

32

64

Value of n

128

256

8

16

32

64

128

256

Value of n

6 Application to Private Set Intersection
In a private set intersection (PSI) protocol, a sender S and a receiver R hold sets X = {x1 , x2 , . . . xn1 }
and Y = {y1 , y2 , . . . yn2 } respectively. The goal of the protocol is to let the receiver know the intersection
X ∩ Y and nothing more. Put simply, a PSI protocol realizes the functionality FPSI (X, Y ) = (⊥, X ∩ Y ).
The set sizes are assumed to be public.
We set our focus on the PSI protocols that are OT-based so that we can employ our OT extension protocol
in them to improve
efficiency. [PSZ14] introduced an OT-based PSI protocol relying on black-box usage

of random n1 -OT. Subsequently, [PSSZ15] improved the communication overhead of [PSZ14]. Both the
protocols are semi-honestly secure. At the core of the protocols lies an important building block called set
inclusion that allows R to check whether its input, say y, is contained in X, owned by S, while preserving
the input privacy of both the parties. In the set inclusion protocol, the receiver breaks its σ-bit element, say y
into t blocks of η-bits. Similarly S breaks each of its σ-bit element xi into t blocks of η-bits. Next, a random

19

2η 
1 -OT

is used for kth block of receiver’s input for k = 1, . . . , t where the random OT does the following.
Denoting N = 2η , a random OT of above type generates N random masks and delivers them to S. R
receives from the OT the mask corresponding to its block which acts as its choice string.
 S then generates
a mask for each of its elements in X using the masks received from the t random N1 -OTs. Similarly, R
combines the masks it receives from the OTs to generate the mask corresponding to its input element y.
The verification whether y is included in X is then done by performing checks over the masks. Namely S
sends across the masks corresponding to all its elements in X. R verifies if the mask corresponding to y
matches with one of them or not. In a naive approach, PSI can be achieved by having the receiver run the
set inclusion protocol n2 times, once for each element in Y . [PSZ14] and subsequently [PSSZ15] improved
the complexity of the naive approach by reducing the number of OTs and improving the input length of S
in the OTs. Various hashing techniques such as Simple Hashing [PSZ14] and Cuckoo Hashing (with a stash
s [KMW09]), h-ary Cuckoo Hashing [FPSS03] and Feistel-like functions [ANS10] were used to achieve
the goal. However, as mentioned before, both [PSZ14] and [PSSZ15] works in semi-honest setting. Indeed,
Lambæk in his detailed analysis [Lam16] finds three vulnerabilities in [PSZ14, PSSZ15] when malicious
adversaries are considered. Details follow.
One of vulnerabilities corresponds to sender corruption. Fixing the problem remains an open question.
The remaining two vulnerabilities correspond to the receiver corruption. In more details, the first problem
comes from a malicious receiver who can learn whether some elements of its choice outside his set Y of size
n2 belong to S’s input X or not. The solution proposed in the thesis to thwart this attack uses Shamir secret
sharing (SS) paired with symmetric-key encryption (SKE). Recall that, S sends the masks corresponding
to its elements in X after the OT executions to help R identify the elements in the intersection. The idea
of the proposed solution of [Lam16] is to lock the masks using a key of SKE, secret share the key and
allow R to recover the key only when R uses less than or equal to n2 elements in the set inclusion protocols
(i.e. in the OT executions). The second vulnerability may result from any malicious behaviour of R in the
OT executions of set inclusion protocol. [Lam16] proposes to fix the problem by using maliciously secure
(against corrupt receiver) OT protocols. Using off-the-shelves maliciously secure OT extension protocols,
[Lam16] therefore obtains a PSI protocol that is maliciously secure against corrupt R but semi-honestly
secure against corrupt S. For complete details of the protocol of Lambæk, refer [Lam16].
We propose to use our maliciously secure OT extension protocol in the PSI protocol of [Lam16] to obtain
the most efficient PSI protocol that is maliciously secure against corrupt R but semi-honestly secure against
corrupt S. As evident from the theoretical and experimental results presented in this work, our maliciously
secure OT extension protocol is a better choice compared to the existing maliciously
secure extension pron
tocols [ALSZ15, NNOB12, KOS15] when the OTs required are of type 1 -OT. As PSI employs n1 -OT

(instead of 21 -OT), our extension protocol fits the bill. Lastly, we find a concrete vulnerability for the
malicious corrupt R case in Lambæk’s PSI protocol when semi-honest KK13 OT extension is used in it.
This confirms Lambæk’s concern of privacy breach of his PSI protocol that may result from privacy breach
of the underlying OT protocols and further confirms the necessity of maliciously secure OT extension in
Lambæk’s PSI protocol. The attack by the corrupt R goes as follows: Using the concrete attack discussed
in Section 3 for KK13 protocol, a corrupt R in the PSI protocol can recover the outputs to S in the OT
executions. The outputs to S are used to compute the masks for the elements of X. Therefore by violating
the privacy of semi-honest KK13, R can completely recover the masks for all the elements of X bypassing
the security of secret sharing technique coupled with SKE. This allows R to learn whether some elements
of its choice outside his set Y of size n2 belong to S’s input X or not.

20

Acknowledgements
We thank Peter Scholl and Emmanuela Orsini for pointing out a bug in the initial version of the paper. We
also thank Michael Zohner and Thomas Schneider for a useful discussion on the implementation part of the
work. This work is partially supported by INSPIRE Faculty Fellowship (DST/INSPIRE/04/2014/015727)
from Department of Science & Technology, India.

References
[ALSZ13] Gilad Asharov, Yehuda Lindell, Thomas Schneider, and Michael Zohner. More efficient oblivious transfer and extensions for faster secure computation. In 2013 ACM SIGSAC Conference on Computer and Communications Security,
CCS’13, Berlin, Germany, November 4-8, 2013, pages 535–548, 2013.
[ALSZ15] Gilad Asharov, Yehuda Lindell, Thomas Schneider, and Michael Zohner. More efficient oblivious transfer extensions
with security for malicious adversaries. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International
Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I, pages 673–701, 2015.
[ANS10]

Yuriy Arbitman, Moni Naor, and Gil Segev. Backyard cuckoo hashing: Constant worst-case operations with a succinct
representation. In 51th Annual IEEE Symposium on Foundations of Computer Science, FOCS 2010, October 23-26,
2010, Las Vegas, Nevada, USA, pages 787–796, 2010.

[BCR86]

Gilles Brassard, Claude Crépeau, and Jean-Marc Robert. All-or-nothing disclosure of secrets. In Advances in Cryptology - CRYPTO ’86, Santa Barbara, California, USA, 1986, Proceedings, pages 234–238, 1986.

[Bea96]

Donald Beaver. Correlated pseudorandomness and the complexity of private computations. In Proceedings of the
Twenty-Eighth Annual ACM Symposium on the Theory of Computing, Philadelphia, Pennsylvania, USA, May 22-24,
1996, pages 479–488, 1996.

[Can01]

Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. In 42nd Annual Symposium on Foundations of Computer Science, FOCS 2001, 14-17 October 2001, Las Vegas, Nevada, USA, pages
136–145, 2001.

[DCW13]

Changyu Dong, Liqun Chen, and Zikai Wen. When private set intersection meets big data: an efficient and scalable
protocol. In Proceedings of the 2013 ACM SIGSAC conference on Computer &#38; communications security, CCS
’13, pages 789–800, 2013.

[EGL85]

Shimon Even, Oded Goldreich, and Abraham Lempel. A randomized protocol for signing contracts. Commun. ACM,
28(6):637–647, 1985.

[FJN+ 13]

Tore Kasper Frederiksen, Thomas Pelle Jakobsen, Jesper Buus Nielsen, Peter Sebastian Nordholt, and Claudio Orlandi. Minilego: Efficient secure two-party computation from general assumptions. In Advances in Cryptology EUROCRYPT 2013, 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Athens, Greece, May 26-30, 2013. Proceedings, pages 537–556, 2013.

[FPSS03]

Dimitris Fotakis, Rasmus Pagh, Peter Sanders, and Paul G. Spirakis. Space efficient hash tables with worst case
constant access time. In STACS 2003, 20th Annual Symposium on Theoretical Aspects of Computer Science, Berlin,
Germany, February 27 - March 1, 2003, Proceedings, pages 271–282, 2003.

[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or A completeness theorem for
protocols with honest majority. In Proceedings of the 19th Annual ACM Symposium on Theory of Computing, 1987,
New York, New York, USA, pages 218–229, 1987.
[GV87]

Oded Goldreich and Ronen Vainish. How to solve any protocol problem - an efficiency improvement. In Advances
in Cryptology - CRYPTO ’87, A Conference on the Theory and Applications of Cryptographic Techniques, Santa
Barbara, California, USA, August 16-20, 1987, Proceedings, pages 73–86, 1987.

[HIKN08] Danny Harnik, Yuval Ishai, Eyal Kushilevitz, and Jesper Buus Nielsen. Ot-combiners via secure computation. In
Theory of Cryptography, Fifth Theory of Cryptography Conference, TCC 2008, New York, USA, March 19-21, 2008.,
pages 393–411, 2008.
[HKK+ 14] Yan Huang, Jonathan Katz, Vladimir Kolesnikov, Ranjit Kumaresan, and Alex J. Malozemoff. Amortizing garbled
circuits. In Advances in Cryptology - CRYPTO 2014 - 34th Annual Cryptology Conference, Santa Barbara, CA, USA,
August 17-21, 2014, Proceedings, Part II, pages 458–475, 2014.
[IKNP03]

Yuval Ishai, Joe Kilian, Kobbi Nissim, and Erez Petrank. Extending oblivious transfers efficiently. In Advances in
Cryptology - CRYPTO 2003, 23rd Annual International Cryptology Conference, Santa Barbara, California, USA,
August 17-21, 2003, Proceedings, pages 145–161, 2003.

21

[IR89]

Russell Impagliazzo and Steven Rudich. Limits on the provable consequences of one-way permutations. In Proceedings of the 21st Annual ACM Symposium on Theory of Computing, May 14-17, 1989, Seattle, Washigton, USA, pages
44–61, 1989.

[Kil88]

Joe Kilian. Founding cryptography on oblivious transfer. In Proceedings of the 20th Annual ACM Symposium on
Theory of Computing, May 2-4, 1988, Chicago, Illinois, USA, pages 20–31, 1988.

[KK13]

Vladimir Kolesnikov and Ranjit Kumaresan. Improved OT extension for transferring short secrets. In Advances in
Cryptology - CRYPTO 2013 - 33rd Annual Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2013.
Proceedings, Part II, pages 54–70, 2013.

[KMW09] Adam Kirsch, Michael Mitzenmacher, and Udi Wieder. More robust hashing: Cuckoo hashing with a stash. SIAM J.
Comput., 39(4):1543–1561, 2009.
[KOS15]

Marcel Keller, Emmanuela Orsini, and Peter Scholl. Actively secure OT extension with optimal overhead. In Advances
in Cryptology - CRYPTO 2015 - 35th Annual Cryptology Conference, Santa Barbara, CA, USA, August 16-20, 2015,
Proceedings, Part I, pages 724–741, 2015.

[Lam16]

Mikkel Lambk. Breaking and fixing private set intersection protocols. Cryptology ePrint Archive, Report 2016/665,
2016. http://eprint.iacr.org/2016/665.

[Lar14]

Enrique Larraia. Extending oblivious transfer efficiently - or - how to get active security with constant cryptographic
overhead. In Progress in Cryptology - LATINCRYPT 2014 - Third International Conference on Cryptology and Information Security in Latin America, Florianópolis, Brazil, September 17-19, 2014, Revised Selected Papers, pages
368–386, 2014.

[Lin16]

Yehuda Lindell. Fast cut-and-choose-based protocols for malicious and covert adversaries. J. Cryptology, 29(2):456–
490, 2016.

[LP15]

Yehuda Lindell and Benny Pinkas. An efficient protocol for secure two-party computation in the presence of malicious
adversaries. J. Cryptology, 28(2):312–350, 2015.

[LR15]

Yehuda Lindell and Ben Riva. Blazing fast 2pc in the offline/online setting with security for malicious adversaries.
In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, Denver, CO, USA,
October 12-6, 2015, pages 579–590, 2015.

[LZ13]

Yehuda Lindell and Hila Zarosim. On the feasibility of extending oblivious transfer. In TCC, pages 519–538, 2013.

[Nie07]

Jesper Buus Nielsen. Extending oblivious transfers efficiently - how to get robustness almost for free. IACR Cryptology
ePrint Archive, 2007:215, 2007.

[NNOB12] Jesper Buus Nielsen, Peter Sebastian Nordholt, Claudio Orlandi, and Sai Sheshank Burra. A new approach to practical active-secure two-party computation. In Advances in Cryptology - CRYPTO 2012 - 32nd Annual Cryptology
Conference, Santa Barbara, CA, USA, August 19-23, 2012. Proceedings, pages 681–700, 2012.
[NO09]

Jesper Buus Nielsen and Claudio Orlandi. LEGO for two-party secure computation. In Theory of Cryptography, 6th
Theory of Cryptography Conference, TCC 2009, San Francisco, CA, USA, March 15-17, 2009. Proceedings, pages
368–386, 2009.

[NP99]

Moni Naor and Benny Pinkas. Oblivious transfer and polynomial evaluation. In Proceedings of the Thirty-first Annual
ACM Symposium on Theory of Computing, STOC ’99, pages 245–254, 1999.

[NP05]

Moni Naor and Benny Pinkas. Computationally secure oblivious transfer. J. Cryptology, 18(1):1–35, 2005.

[OTC]

Encrypto group otextension code. https://github.com/encryptogroup/OTExtension.

[PSSZ15]

Benny Pinkas, Thomas Schneider, Gil Segev, and Michael Zohner. Phasing: Private set intersection using permutationbased hashing. In Proceedings of the 24th USENIX Conference on Security Symposium, SEC’15, 2015.

[PSZ14]

Benny Pinkas, Thomas Schneider, and Michael Zohner. Faster private set intersection based on ot extension. In
Proceedings of the 23rd USENIX Conference on Security Symposium, SEC’14, 2014.

[PVW08]

Chris Peikert, Vinod Vaikuntanathan, and Brent Waters. A framework for efficient and composable oblivious transfer.
In Advances in Cryptology - CRYPTO 2008, 28th Annual International Cryptology Conference, Santa Barbara, CA,
USA, August 17-21, 2008. Proceedings, pages 554–571, 2008.

[Rab81]

Michael O. Rabin. How to exchange secrets with oblivious transfer, 1981. Harvard University Technical Report 81
talr@watson.ibm.com 12955 received 21 Jun 2005.

[SS13]

Abhi Shelat and Chih-Hao Shen. Fast two-party secure computation with minimal assumptions. In 2013 ACM SIGSAC
Conference on Computer and Communications Security, CCS’13, Berlin, Germany, November 4-8, 2013, pages 523–
534, 2013.

22

[Yao82]

Andrew Chi-Chih Yao. Protocols for secure computations (extended abstract). In 23rd Annual Symposium on Foundations of Computer Science, Chicago, Illinois, USA, 3-5 November 1982, pages 160–164, 1982.

[Yao86]

Andrew Chi-Chih Yao. How to generate and exchange secrets (extended abstract). In 27th Annual Symposium on
Foundations of Computer Science, Toronto, Canada, 27-29 October 1986, pages 162–167, 1986.

A

The Universal Composability (UC) Security Model

We prove security of our protocol in the standard Universal Composability (UC) framework of Canetti [Can01],
with static corruption. The UC framework introduces a PPT environment Z that is invoked on the security
parameter κ and an auxiliary input z and oversees the execution of a protocol in one of the two worlds. The
“ideal” world execution involves dummy parties P0 and P1 , an ideal adversary S who may corrupt one of
the dummy parties, and a functionality F. The “real” world execution involves the PPT parties P0 and P1
and a real world adversary A who may corrupt one of the parties. The environment Z chooses the input of
the parties and may interact with the ideal/real adversary during the execution. At the end of the execution,
it has to decide upon and output whether a real or an ideal world execution has taken place.
We let IDEAL F ,S,Z (1κ , z) denote the random variable describing the output of the environment Z
after interacting with the ideal execution with adversary S, the functionality F, on the security parameter 1κ and z. Let IDEAL F ,S,Z denote the ensemble {IDEAL F ,S,Z (1κ , z)}κ∈N,z∈{0,1}∗ . Similarly let
REAL Π,A,Z (1κ , z) denote the random variable describing the output of the environment Z after interacting
in a real execution of a protocol Π with adversary A, the parties, on the security parameter 1κ and z. Let
REAL Π,A,Z denote the ensemble {REAL Π,A,Z (1κ , z)}κ∈N,z∈{0,1}∗ .
Definition A.1. For n ∈ N, let F be a functionality and let Π be an 2-party protocol. We say that Π securely
realizes F if for every PPT real world adversary A, there exists a PPT ideal world adversary S, corrupting
the same parties, such that the following two distributions are computationally indistinguishable:
c

IDEAL F ,S,Z ≈ REALΠ,A,Z .
The F-hybrid model. In order to construct some of our protocols, we will use secure two-party protocols
as subprotocols. The standard way of doing this is to work in a “hybrid model” where both the parties
interact with each other (as in the real model) in the outer protocol and use ideal functionality calls (as in the
ideal model) for the subprotocols. Specifically, when constructing a protocol Π that uses a subprotocol for
securely computing some functionality F, the parties run Π and use “ideal calls” to F (instead of running
the subprotocols implementing F). The execution of Π that invokes F every time it requires to execute
the subprotocol implementing F is called the F-hybrid execution of Π and is denoted as ΠF . The hybrid
ensemble HYBΠF ,A,Z (1κ , z) describes Z’s output after interacting with A and the parties P0 , P1 running
protocol ΠF . By UC definition, the hybrid ensemble should be indistinguishable from the real ensemble
with respect to protocol Π where the calls to F are instantiated with a realization of F.

23

