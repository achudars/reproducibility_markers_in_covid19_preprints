Adaptive Algorithm for Finding Connected Dominating Sets
in Uncertain Graphs∗

arXiv:1912.12665v1 [cs.DS] 29 Dec 2019

Takuro Fukunaga†

Abstract
The problem of finding a minimum-weight connected dominating set (CDS) of a given undirected
graph has been studied actively, motivated by operations of wireless ad hoc networks. In this paper, we
formulate a new stochastic variant of the problem. In this problem, each node in the graph has a hidden
random state, which represents whether the node is active or inactive, and we seek a CDS of the graph
that consists of the active nodes. We consider an adaptive algorithm for this problem, which repeat
choosing nodes and observing the states of the nodes around the chosen nodes until a CDS is found. Our
algorithms have a theoretical performance guarantee that the sum of the weights of the nodes chosen by
the algorithm is at most O(α log(1/δ)) times that of any adaptive algorithm in expectation, where α is
an approximation factor for the node-weighted polymatroid Steiner tree problem and δ is the minimum
probability of possible scenarios on the node states.

1

Introduction

Background For an undirected graph G with the node set V , a subset U of V is called a dominating set
if, for each v ∈ V , v itself or a neighbor of v is included in U . If a dominating set induces a connected
subgraph, then it is called a connected dominating set (CDS). The CDS problem is the problem of finding a
minimum-cardinality/weight CDS in a given graph, where the nodes in the graph are weighted in the weight
minimization case. This problem is being actively studied, one motivation being operations of wireless ad
hoc networks. For avoiding flooding of messages in a wireless ad hoc network, a popular approach is to
construct a virtual backbone. Requirements on the virtual backbone are the connectivity and accessibility
from outside the virtual backbone. Since these requirements are naturally formulated as constraints on
CDSs, it is widely accepted to use a CDS as the virtual backbone of a wireless ad hoc network.
In wireless ad hoc networks, nodes are mobile wireless devices, which often join or leave the network.
This instability is inevitable because wireless ad hoc networks are expected to be used in an environment
for which traditional networks are hard to use, such as disaster areas. To cope with the instability, it is
desirable that an algorithm for computing a virtual backbone have robustness against node absence.
One approach for constructing a robust virtual backbone is to strengthen the requirements on CDSs. In
this context, the notion of a k-connected m-dominating set ((k, m)-CDS) was proposed by Dai and Wu [1].
A node set U is called a (k, m)-CDS if it induces a k-connected subgraph and each node in V \ U has m
neighbors in U . There are many previous studies on algorithms for finding a minimum-cardinality/weight
(k, m)-CDS (e.g., [2–5]). A disadvantage of this approach is that the (k, m)-CDS tends to be large if k and m
are large. To make a (k, m)-CDS tolerant against clustered node failures (e.g., caused by an earthquake), we
have to set k and m extremely large. However, this is infeasible in many cases due to the size disadvantage
of (k, m)-CDSs.
Our contributions Another approach for the above-stated issue is to reconstruct CDSs periodically.
However, this requires computing CDSs without knowing which nodes remain in the network. To cope
with this technical challenge, we consider the adaptive optimization approach, which is recently regarded as
∗ This

is the accepted version of a paper to be published by IEEE/ACM Transactions on Networking.
author is with Chuo University, Japan, JST, PRESTO, Japan, and RIKEN Center for Adcanced Intelligence Project,
Japan. Email: fukunaga.07s@g.chuo-u.ac.jp. This study was supported by JST PRESTO Grant Number JPMJPR1759.
† The

1

a strong paradigm for presenting robust algorithms against uncertainty (see Section 2.3). Specifically, we
formulate a robust optimization version of the CDS problem, that we call the robust CDS problem. In this
problem, each node in the given graph has a hidden state, which represents whether the node is active or
inactive. The problem seeks a CDS in the graph that consists of the active nodes. For this purpose, we
consider adaptive policies for finding a CDS. An adaptive policy chooses nodes sequentially. Immediately
after a node is chosen, the policy receives feedback about the states of nodes around the chosen node.
Depending on this feedback, the policy decides which nodes to choose in the subsequent iterations. The
objective is to minimize the weights of nodes chosen until the solution set becomes a CDS.
We emphasize that an adaptive policy for the robust CDS problem does not know which nodes are active
when it is invoked. The only information available to the policy is the probability distribution on the states
of the nodes. During the process, it observes them partially through feedback. We consider two feedback
models—the full feedback model and the local feedback model. In the full feedback model, the states of the
neighbors of the chosen node are revealed, whereas only the state of the chosen node is revealed in the local
feedback model.
We present an algorithm that computes adaptive policies for the robust CDS problem with both of the
feedback models. We provide a theoretical performance guarantee for this algorithm. This performance
guarantee compares the expected weights of the nodes chosen by a policy with those chosen by an optimal
adaptive policy. We prove that their ratio is at most O(α log(1/δ)), where α is the approximation factor of an
algorithm for the node-weighted polymatroid Steiner tree problem (which will be defined in Section 3) and
δ is the minimum probability of possible scenarios on the node states. If the given graph is a unit disk graph
with n nodes, then we can assume that α is polylogarithmic on n and the fractionality of the probabilities
on the node states (see Section 3). Note that unit disk graphs are popular as a model of wireless networks,
and many previous studies on CDSs assume that the graph is a unit disk graph. In addition to present the
performance guarantee, we investigate the empirical performance of this algorithm through simulations.
Summing up, the contributions given in this paper are (i) formulation of the robust CDS problem, (ii)
an algorithm with a theoretical O(α log(1/δ))-factor performance guarantee, and (iii) comparison of the
algorithms through computational simulations.
Organization The rest of this paper is organized as follows. Section 2 surveys the related studies. Section 3
formulates the robust CDS problem and introduces other preliminary concepts. Section 4 presents our
O(α log(1/δ))-approximation algorithm. Section 5 defines two heuristic algorithms, with which we compare
our algorithm in the simulations. Section 6 reports the simulation results. Section 7 concludes the paper.

2
2.1

Related studies
CDS problem with full information

Guha and Khuller [6] presented two O(H(∆))-approximation algorithms for cardinality minimization of the
CDS problem, and a 2.613 ln n-approximation algorithm for weight minimization, where ∆ is the maximum
degree of the given graph, H(∆) is the ∆-th harmonic number, and n is the number of nodes of the graph.
They also showed that no polynomial-time algorithm for the cardinality minimization achieves approximation
factor (1 − )H(∆) for any fixed  ∈ (0, 1) unless NP ⊆ DTIME[nO(log log n) ]. The approximation factor for
weight minimization was improved by Guha and Khuller [7] to (1.35 + ) ln n.
Besides general graphs, the CDS problem has been considered extensively for unit disk graphs. The
problem is NP-hard even when the objective is cardinality minimization and the graph is a unit disk graph [8].
Simultaneously, a polynomial-time approximation scheme (PTAS) was given by Cheng et al. [9] for cardinality
minimization in a unit disk graph; note that the existence of a PTAS means that for any fixed constant  > 0,
there exists a (1 + )-approximation algorithm that runs in polynomial time. As for weight minimization,
the current best approximation factor is 6.475 + , obtained by combining Willson et al. [10], Zou et al. [11],
and Byrka et al. [12].

2

2.2

CDS problem with limited information

One of the algorithms presented by Guha and Khuller [6] for the cardinality minimization is so-called a local
greedy algorithm, that repeats selecting one or two nodes greedily from the 2-hop neighborhood of the nodes
chosen in the preceding iterations. Other local greedy algorithms are also considered by Borgs et al. [13] and
Khuller and Yang [14]. Since these local greedy algorithms do not require information on the whole graph,
they work for our setting with a suitable feedback model. However, the theoretical performance guarantee
of these algorithms holds only for the cardinality minimization, and it seems difficult to extend them to the
weight minimization.
For the cardinality minimization in unit disk graphs, distributed algorithms are also studied actively.
The current best approximation ratio of distributed algorithms is 6.91 due to Funke et al. [15]. Distributed
algorithms do not require global information on the graph, and thus their purpose is similar to our study.
However, the distributed algorithms assume that each node in the graph does some computation and communication, which is different from our study. In addition, only simple algorithms can be implemented as
distributed algorithms. Indeed, no distributed algorithm is known to the weight minimization.
Shi et al. [16] considers an adaptive algorithm for finding CDSs in energy-harvest sensor networks. The
main purpose of this study is to manage energy of sensors, and the problem setting considered there is totally
different from ours.

2.3

Adaptive optimization

We are aware of no previous study on the stochastic version of the CDS problem, but there are many studies
on adaptive algorithms for stochastic optimization problems. One of the previous studies most closely related
to our work in this literature is that by Lim, Hsu, and Lee [17] for the Bayesian Canadian traveler problem.
The Bayesian Canadian traveler problem is a stochastic variant of the shortest path problem. It seeks
adaptive policies to find a path from the source to the sink in the situation where each edge takes the active
or inactive state. The essential idea in [17] is to consider the exploration path and the exploitation path in
the graph given by the most-likely scenario repeatedly. The exploration path is given by an algorithm for the
edge-weighted polymatroid Steiner tree problem, and the exploitation path is given by an algorithm for the
shortest path problem. The algorithm of [17] compares the weights of the exploration and the exploitation
paths, and visits nodes along the path that achieves the smaller weight until the sink is visited or the
probability of the scenarios consistent with the observations decreases by a factor of 1/2. Similar ideas can
be also found in the studies on a stochastic submodular covering problem with a path constraint [18], and
the stochastic traveling salesperson problem [19].

3
3.1

Problem formulation
Notations

R+ and Z+ denote the sets of nonnegative real numbers and nonnegative integers, respectively. For a positive
integer i, let [i] denote {1, . . . , i}. Let G = (V, E) denote an undirected graph with the node set V and the
edge set E. Throughout the paper, we denote |V | by n. An edge joining two nodes u and v is denoted by
uv. We say that an edge uv is induced by a node set U ⊆ V if u, v ∈ U , and a subgraph is induced by a
node set U if its node set is U and its edge set consists of the edges induced by U . We denote the subgraph
of G induced by U by G[U ] and its edge set by E[U ]. We say that a subset U of V dominates a node v if
v ∈ U or if there exists a node u ∈ U such that uv ∈ E. For a node v ∈ V , N [v] denotes the set of neighbors
of v and v itself. For U ⊆ V , N [U ] is the set of nodes dominated by U .

3.2

CDS problem

We introduce a formal definition of the CDS problem. For the connection with the robust CDS problem
introduced below, we present the formulation in which the root node is specified. This formulation is slightly
different from the most well-studied setting of the CDS problem, in which the root node is not specified.

3

Table
Ψ
Aψ
Ψ∗
supp(φ)
U (π, ψ)
w(π, ψ)
wavg (π)
δ
M

1: List of notations introduced in Section 3.3
set of full realizations
{v ∈ V : ψ(v) = 1} for ψ ∈ Ψ
set of realizations
{v ∈ V : φ(v) 6= ∗} for φ ∈ Ψ∗
set of nodes chosen by a policy π for ψ ∈ Ψ
w(U (π, ψ)) for a policy π and ψ ∈ Ψ
expectation of w(π, ψ) for a policy π and ψ ∈ Ψ
min{p(ψ) : ψ ∈ Ψ, p(ψ) > 0}
minimum number s.t. M p(ψ) ∈ Z+ for ∀ψ ∈ Ψ

However, the setting without the root can be reduced to the setting with the root, and hence the formulation
given in this paper is more general.
Suppose that we are given a connected undirected graph G = (V, E) and the weights w : V → R+ of the
nodes. Moreover, a node in V is specified as the root node and denoted by r. A subset U of V is called the
connected dominating set (CDS) if U includes the root r, induces a connected
P subgraph of G, and each node
in the graph is dominated by U . The weight of U is defined as w(U ) := v∈U w(v). The objective of the
problem is to find a minimum-weight CDS.

3.3

Robust CDS problem

In the robust version of the CDS problem, several nodes are inactive (absent from the network). We seek a
CDS in the graph consisting of active nodes for the case that we do not know which nodes are active. When
the graph of the active nodes is not connected, there are two natural formulations; one formulation demands
outputting the message that the graph is not connected, and the other demands outputting a CDS of the
connected component including the root. We focus on the latter formulation in this paper, but our results
can be easily applied to the former formulation with a slight modification.
Let us formulate the problem more precisely. The notations introduced in this section is listed in Table 1.
We let a vector ψ ∈ {0, 1}V represent which nodes are active or not; ψ(v) = 1 (resp., ψ(v) = 0) indicates
that the node v is active (resp., inactive). We assume that the root is always active (i.e., ψ(r) = 1). We call
such a vector ψ a full realization, and let Ψ denote the set of all full realizations. The states of nodes are
decided randomly (possibly correlated), and p(ψ) ∈ [0, 1] is the probability that the states of all nodes are
represented by ψ ∈ Ψ.
For a full realization ψ, let Aψ = {v ∈ V : ψ(v) = 1}. The task of the robust CDS problem is to find a
CDS of the graph G[Aψ ]. If G[Aψ ] is not connected, then we seek a CDS of the component including the
root.
For this problem, we consider adaptive policies for choosing nodes sequentially. Immediately after the
policy chooses a node, it receives feedback about the states of nodes around the chosen node. We consider
two feedback models.
• full feedback : if the chosen node v is active, then the states of v and neighbors of v are revealed, while
only the state of v is revealed when v is inactive.
• local feedback : if a node v is chosen, then only the state of v is revealed.
If the chosen node is active, then it must be added to the solution set irrevocably, whereas it is discarded
otherwise. We demand that the solution set always induce a connected subgraph. Namely, if U is the set
of nodes chosen by the policy up to a certain iteration, then the policy has to choose a node dominated by
U ∩ Aψ in this iteration. The policy repeats this process until it can be determined that the solution set
is a CDS of the component including the root in G[Aψ ]. We assume that the root node has already been
included in the solution set when the first iteration of the policy begins.
We represent the observations made during the algorithm by a vector φ ∈ {0, 1, ∗}V ; φ(v) = 1 (resp.,
φ(v) = 0) indicates that the state of a node v is observed and found to be active (inactive), and φ(v) = ∗
indicates that the state of v has not been yet observed by the policy. It is assumed that φ(r) = 1. Moreover,
4

in the full feedback model, φ(v) = 1 for each neighbor v of r without loss of generality because the full
feedback model revealed the states of all neighbors of r and the inactive neighbors of r can be safely removed
from the graph. We call such a vector φ a realization, and let Ψ∗ denote the set of all realizations. We let
supp(φ) = {v ∈ V : φ(v) 6= ∗}. We say that a realization ψ extends another realization φ and write ψ  φ
if ψ(v) = φ(v) for all v ∈ supp(φ). For realizations ψ, φ ∈ Ψ∗ with ψ  φ, p(ψ | φ) denotes the probability
that the state of each node v ∈ supp(ψ) \ supp(φ) is represented as ψ(v) conditioned on that the states of
nodes in supp(φ) are represented as φ.
Let π be a policy, and let U (π, ψ) be the set of nodes (possibly including inactive nodes) chosen by π
when the states of all nodes are represented as ψ ∈ Ψ. We note that if the observation kept by π is φ when
π terminates and the full realization is ψ, then U (π, ψ) ⊆ supp(φ) holds and U (π, ψ) ∩ Aψ is a dominating
set of G[supp(φ)]. Moreover, the CDS output by π for a full realization ψ is U (π, ψ) ∩ Aψ . Particularly
U (π, ψ) = supp(φ) holds in the local feedback model. In the full feedback model, all nodes in U (π, ψ) are
active because a policy knows the state of a node when it is chosen and it is unnecessary to choose inactive
nodes.
We denote
P w(U (π, ψ)) by w(π, ψ) for conciseness. Let wavg (π) denote the expectation of w(π, ψ) (i.e.,
wavg (π) = ψ∈Ψ w(π, ψ)p(ψ)). We evaluate the performance of a policy π by wavg (π). We say that a policy
π achieves the approximation factor α ≥ 1 if wavg (π) ≤ αwavg (π 0 ) for any policies π 0 .
As a parameter, we let δ = min{p(ψ) : ψ ∈ Ψ, p(ψ) > 0} and M denote the minimum number such that
M p(ψ) is an integer for any ψ ∈ Ψ. We present an adaptive policy that achieves an approximation factor
depending on δ (and the approximation factor for the node-weighted polymatroid Steiner tree problem given
below). As δ becomes smaller, the factor becomes larger.
We would like to emphasize that a policy does not know which nodes are active in advance. The
information available to the policy when it is invoked is only the probability distribution p : Ψ → [0, 1] on
the full realizations. During the process, the policy decides its behavior from the probability that each node
is active and the one that each node is connected to the root in the graph on the active nodes, conditioned
on the observations obtained up to that point. If the behavior is independent from the observations, then
the policy is called nonadaptive.

3.4

Polymatroid Steiner tree problem

A set-function f : 2V → Z+ on a finite set V is called polymatroid if it is monotone (i.e., f (X) ≤ f (Y ) for
any X ⊆ Y ⊆ V ), submodular (i.e., f (X ∪ {v}) − f (X) ≥ f (Y ∪ {v}) − f (Y ) for any X ⊆ Y ⊆ V and
v ∈ V \ Y ), and is proper (i.e., f (φ) = 0).
In the polymatroid Steiner tree problem, we are given an undirected graph G = (V, E), a root node
r ∈ V , and a polymatroid f : 2V → R+ . A feasible solution is a tree in G such that the root node r is
spanned by it, and the node set U spanned by the tree satisfies f (U ) = f (V ). The objective of the problem
is to find such a tree of minimum weight.
In the literature, it is usual to assume that each edge is associated with a nonnegative weight and the
weight of a tree is defined as the sum of the weights of edges in the tree. Călinescu and Zelikovsky [20]
gave an O(  log1log n log2+ n log f (V ))-approximation algorithm for this case, where  > 0 is any constant. In
our algorithms for the robust CDS problem, we solve the node-weighted polymatroid Steiner tree problem,
where each node is associated with a nonnegative weight, and the weight of a tree is defined as the sum of
the weights of the nodes spanned by the tree. We let α denote the approximation factor of an algorithm for
solving the node-weighted polymatroid Steiner tree problem. For general graphs, we know no algorithm that
achieves a nontrivial approximation factor for the node-weighted problem. In the following theorem, we show
that, if the graph is a unit disk graph, then the node-weighted problem can be reduced to the edge-weighted
problem, and hence the approximation factor α is identical to the one achieved by [20]. In unit disk graphs,
nodes are located on the Euclidean plane, and any two nodes are joined by an edge whenever their distance
is at most a unit distance. From this definition, it is accepted to model wireless networks as unit disk graphs.
Theorem 1. If the graph is a unit disk graph, then the node-weighted polymatroid Steiner tree admits an
O(  log1log n log2+ n log f (V ))-approximation algorithm for any constant  > 0.
Proof. Let w : V → R+ be the node weights given in the node-weighted problem. Let β be the approximation
factor for the edge-weighted polymatroid Steiner tree problem. From w, we define edge weights w0 : E → R+
5

by w0 (uv) = w(u) + w(v) for each uv ∈ E. Apply the β-approximation algorithm for the edge-weighted
problem with w0 . Then we obtain a tree T feasible for both the node-weighted and the edge-weighted
problems. We show that T achieves an approximation factor O(β) also for the node-weighted problem.
Let T ∗ be an optimal solution for the node-weighted problem. It is widely known that, for any tree
∗
T in a unit disk graph, there is a tree T 0 (possibly the same as T ∗ ) of maximum degree 5 that spans the
same node set as T ∗ (see e.g., [2]). Let w(T 0 ) and w0 (T 0 ) denote the node weight and the edge weight of
the tree T 0 . We use the same notation also for T ∗ and T . Since the maximum degree of T 0 is at most 5,
w0 (T 0 ) ≤ 5w(T 0 ) = 5w(T ∗ ). Because T achieves an approximation factor β for the edge-weighted problem,
we have w0 (T ) ≤ βw0 (T 0 ). By the definition of w0 , w(T ) ≤ w0 (T ). Combining these relationships shows that
w(T ) ≤ 5βw(T ∗ ).
As described above, the polymatroid Steiner tree problem is defined from a polymatroid. In our algorithms discussed below, we sometimes consider the problem with a function f which is not proper but
monotone submodular. In this case, we can construct a polymatroid f 0 from f by f 0 (X) = f (X) − f (φ) for
each X ⊆ V . Indeed, the function f 0 constructed this way is monotone submodular since the this property
is maintained by the subtraction of a constant, and is proper by f 0 (φ) = f (φ) − f (φ) = 0. Moreover, the
problem with f 0 is equivalent to the one with f since a node set U satisfies f (U ) = f (V ) if and only if
f 0 (U ) = f 0 (V ).
In instances of the polymatroid Steiner tree problem solved in our algorithms, f (V ) is a polynomial on
n and M . Thus, Q
we can assume that α is polylogarithmic on n and M when the graph is a unit disk graph.
Note that M ≤ ψ∈Ψ:p(ψ)>0 1/p(ψ). Thus log M is proportional to the bit-size of the inputs. The above
upper bound on M is at most (1/δ)1/δ because |{ψ ∈ Ψ : p(ψ) > 0}| ≤ 1/δ. However, we have better bounds
in special cases. For example, when p(ψ) ∈ {0, 1/δ} for all ψ ∈ Ψ, M = 1/δ.

4

Algorithms with performance guarantee

In this section, we present our algorithms to compute an adaptive policy that has a performance guarantee
for the robust CDS problem. We first present the algorithm and its analysis for the full feedback model. We
then present those for the local feedback model.
Since the algorithm and its analysis for the local feedback model are almost the same as those for the
full feedback model, we omit a detailed explanation on the local feedback model and only highlight their
differences.

4.1

Algorithm for the full feedback model

The algorithm runs in rounds. We explain the behavior of the algorithm in a round. Suppose that φ ∈ Ψ∗
represents the observations made and U ⊆ supp(φ) comprises the nodes chosen in the preceding rounds. We
explain which nodes are chosen by the policy in the current round.
In the algorithm, we safely remove a node in V \ U from the graph if it is inactive for all full realizations
of Ψφ := {ψ ∈ Ψ : ψ  φ, p(ψ) > 0}. Moreover, if a node is disconnected from the root (because of the
removal of inactive nodes), then this node is not included in and is not dominated by any CDS. Hence, we
also remove such nodes from the graph. Because of these removals, in the rest of this section, we suppose
that each node in supp(φ) is active, each node in V \ supp(φ) is active for some full realization of Ψφ , and
the graph G is always connected.
If U dominates all nodes in the graph (i.e., supp(φ) = V ), then U is already a CDS. In such a case, the
policy terminates before entering this round. In the following, we suppose that V \ supp(φ) 6= ∅.
Most-likely observations We define H as the set of nodes in V \ U which isP
active with probability more
than a half conditioned on that φ is realized. In other words, H = {v ∈ V \ U :
ψ∈Ψφ :v∈Aψ p(ψ | φ) > 1/2}.
Note that all nodes in supp(φ) \ U belong to H because those nodes are removed from the graph if they are
inactive. Let R be the set of nodes in the connected component of the graph G[U ∪ H] including r; see also
Figure 1 for the definition of R.

6

∈U
∈ supp(φ) \ U

r

inactive
∈ H \ supp(φ)
∈V \H

R

Figure 1: An example of the state after a round of the algorithm (this figure also illustrates the inactive
nodes removed from the graph)
For each v ∈ R ∩ H, we define the most-likely observation vector ξv ∈ {0, 1, ∗}V as follows:


∗ u ∈ V \ N [v],
ξv (u) = 1 u ∈ H ∩ N [v],


0 u ∈ N [v] \ H
Our algorithm computes two subsets Hplt and Hplr of R ∩ H from solutions to two instances of the
node-weighted polymatroid Steiner tree problem. In both of these instances, the given graph is G[R], the
root node is r, and the node weights w0 : R → R+ are defined by
(
0
v ∈ U,
0
w (v) =
w(v) v ∈ H \ U
for each v ∈ R. The polymatroids are different in these instances. Below, we give the definitions of these
polymatroids used for computing Hplt and Hplr .
For an intuition, the polymatroid in the instance for Hplt is designed so that choosing nodes in Hplt gives
a small-weight solution for the robust CDS problem, assuming that the feedbacks given by choosing nodes in
Hplt are represented as their most-likely observation vectors. The polymatroid for Hplr is designed so that
choosing nodes in Hplr decreases the uncertainty in the node states by at least a half. Thus, Hplt aims at
the exploitation, and Hplr aims at the exploration.
Definition of Hplt A set-function fplt : 2R → R+ used for computing Hplt is defined as follows. Let
H 0 ⊆ R ∩ H. The residual hypothesis denoted by ΨH 0 is defined as the set of full realizations ψ ∈ Ψφ such
that ψ  ξv for all v ∈ H 0 . If two nodes u and v are active and belong to the same connected component of
G[Aψ ] in a full realization ψ ∈ Ψ, then we write u ∼ψ v.
Now, we define fplt by
fplt (X) = |(V \ supp(φ)) ∩ N [X]}|




+

X
v∈(V \supp(φ))\N [X]

1 −

X

p(ψ)

ψ∈ΨX∩H :v∼ψ r

for each X ⊆ R. Thus, if a node v ∈ V \ supp(φ) is dominated by X, then it contributes one unit to fplt (X).
If v is not dominated by X, then its contribution to fplt (X) is the probability that v is not active or is not
included in the same component as the root when most-likely observations are given as feedback by choosing
the nodes in X ∩ H. Note that the value of fplt (X) depends only on X ∩ H.
We will show below that fplt is monotone submodular.
Theorem 2. Function fplt is monotone submodular.

7

Proof. Let X ⊆ Y ⊆ R ∩ H. If a node is dominated by X, then it is also dominated by Y . Moreover, if a
full realization ψ ∈ Ψ satisfies ψ ∈ ΨY , then also does ψ ∈ ΨX . These imply that fplt (X) ≤ fplt (Y ), which
shows that fplt is monotone.
To see the submodularity
of fplt , let u ∈ (R ∩ H) \ Y and v ∈ V \ supp(φ). v contributes
to fplt (X ∪
P
P
{u}) − fplt (X) by ψ∈ΨX \ΨX∪{u} :v∼ψ r p(ψ) if v is not dominated by X ∪ {u}, and by ψ∈ΨX :v∼ψ r p(ψ) if v
is not dominated by X but is dominated by u. Otherwise, v does not contribute to fplt (X ∪ {u}) − fplt (X).
The value of this contribution is monotone non-increasing on X because ΨX is monotone non-increasing
on X. Thus, fplt (Y ∪ {u}) − fplt (Y ) ≤ fplt (X ∪ {u}) − fplt (X) follows for any X ⊆ Y . Therefore, fplt is
submodular.
Function fplt is not a polymatroid since it is not proper (i.e., fplt (∅) 6= 0) and fplt may not return an
integer. fplt can be transformed into a proper function by shifting the function values as mentioned in
0
Section 3. As for the integrality of the function values, it suffices to multiply fplt by M . Let fplt
be the
polymatroid obtained by applying these two operations to fplt .
In our algorithm, we solve the instance of the polymatroid Steiner tree problem with G[R], w0 , and
0
fplt , and define Hplt as the set of nodes in H spanned by the computed tree. Note that fplt (R) = |V \
0
supp(φ)| holds. Hence, fplt (Hplt ∪ U ) = |V \ supp(φ)| also holds. Moreover, fplt
(R) ≤ nM , and hence the
approximation factor α for solving this instance is polylogarithmic on n and M .
Definition of Hplr

We define a set function fplr : 2R → R+ by



1
X
,1 −
p(ψ | φ)
fplr (X) = min

2
ψ∈ΨX∩H

for each X ⊆ R. Again, the value of fplr (X) depends only on X ∩ H. The second term in the minimum of
this definition represents the probability that the states of the nodes are inconsistent with the most-likely
vectors of nodes in X, conditioned on that the full realization is consistent with φ.
Theorem 3. Function fplr is monotone, submodular, and proper.
Proof. The monotonicity
P of fplr follows from
P the fact that ΨX∩H is monotone non-increasing on X. Moreover,
fplr (∅) = 0 because ψ∈ΨX∩H p(ψ | φ) = ψ∈Ψφ p(ψ | φ) = 1 holds if X = ∅.
?
To see the submodularity
of fplr , it suffices to see the submodularity of fplr
: 2R∩H → R+ defined by
P
?
fplr (X) = 1 − ψ∈ΨX p(ψ | φ) for each X ⊆ R ∩ H. This is because fplr (X) depends only on X ∩ H
for any X ⊆ R, and any function g that returns the minimum of a constant and the value of a function
?
g ? is submodular P
if g ? is submodular. Let X ⊆ Y ⊆ R ∩ H and v ∈ (R ∩ H) \ Y . Then, fplr
(X ∪
?
{v}) − fplr (X) = ψ∈ΨX \ΨX∪{v} p(ψ | φ). Notice that a full realization is included in ΨX \ ΨX∪{v} when
it is consistent with the most-likely vectors of all nodes in X but inconsistent P
with that of v. Thus, we
?
?
have ΨX \ ΨX∪{v} ⊇ ΨY \ ΨY ∪{v} , which implies fplr
(X ∪ {v}) − fplr
(X) = ψ∈ΨX \ΨX∪{v} p(ψ | φ) ≥
P
?
?
?
ψ∈ΨY \ΨY ∪{v} p(ψ | φ) = fplr (Y ∪ {v}) − fplr (Y ). Therefore, fplr is submodular.
0
Function fplr does not return an integer value. We can define a polymatroid fplr
by multiplying fplr by
2M p(φ).
If fplr (R) < 1/2, then we define Hplr as H. Otherwise, we solve the instance of the polymatroid Steiner
0
tree problem with G[R], w0 , and fplr
, and define Hplr as the set of nodes in H spanned by the computed
tree.
From the definition of the polymatroid Steiner trees, fplr (Hplt ∪ U ) = 1/2 holds when fplr (R) = 1/2.
Note that fplr (Hplt ∪ U ) = 1/2 indicates that the probability (conditioned on φ) of the full realizations
consistent with the most-likely observations of the nodes in Hplt is at most a half. Hence in this case, by
choosing the nodes in Hplt and by observing the states of their neighbors, we can decrease the probability
of the remaining full realizations by a factor of at least a half.

8

Algorithm 1: Full feedback model
Input : undirected graph G = (V, E), node weights w : V → R+ , full realizations Ψ, probability
distribution p : Ψ → [0, 1], and root node r ∈ V (ψ(r) = 1 for all ψ ∈ Ψ)
Output: U ⊆ V
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18

U ←− {r};
foreach v ∈ V do
if v ∈ N [r] and v is active then φ(v) ←− 1;
else if v ∈ N [r] then remove v from G;
else φ(v) ←− ∗;

while U does not dominate
P V do
H ←− {v ∈ V \ U :
ψ∈Ψφ :v∈Aψ p(ψ | φ) > 1/2};
R ←− connected component including r in G[H ∪ U ];
compute Hplt , Hplr ⊆ R ∩ H;
H ∗ ←− argminH 0 ∈{Hplt ,Hplr } w(H 0 );
while H ∗ 6⊆ U do
choose a node v ∈ (H ∗ \ U ) ∩ N [U ];
U ←− U ∪ {v};
foreach u ∈ N [v] \ supp(φ) do φ(u) ←− the state of u ;
if φ(u) 6= ξv (u) for ∃u ∈ N [v] then break;
remove u ∈ V from G if ψ(u) = 0 for ∀ψ ∈ Ψφ ;
remove the connected components not including r from G

output U

r

a

a0

b

b0

c

0

d

c

Figure 2: An example for illustrating behavior of Algorithm 1
Adaptive policy After computing Hplt and Hplr , we compare their weights and let H ∗ be the one of
smaller weight. Recall that Hplr = H if fplr (H ∪ U ) < 1/2. Hence, H ∗ = Hplt in this case.
In the adaptive policy, we repeat choosing nodes in H ∗ in an arbitrary order such that the chosen nodes
and U form a connected subgraph of G. If the observation given by choosing a node v is inconsistent with
ξv , then the policy stops choosing nodes and proceeds to the next round. Otherwise, the policy continues
choosing nodes in H ∗ unless all nodes have already been chosen. The pseudo-code of our algorithm for
computing this policy is given in Algorithm 1.
Example Let us illustrate how Algorithm 1 computes a solution for an example. Let the given graph G be
the one illustrated in Fig. 2. The root node is r, and exactly one of nodes a0 , b0 , c0 is active with probability
1/3. (for example, with probability 1/3, a is active and b, c are inactive). All of the other nodes are active
with probability 1. The weights of a, b, c are defined so that w(a) < w(b) < w(c). The weights of the other
nodes are all 0. We explain behavior of Algorithm 1 for this instance.
Initially, U = {r}, and the algorithm knows that r, a, b, c, d are active. Since none of a0 , b0 , c0 is active with
probability at least 1/2, H = {a, b, c, d} and R = {r, a, b, c}. In the polymatroid Steiner tree problem with
fplt , the constraint demands that the node set spanned by the solution dominates all the nodes whose states
are not revealed (i.e., a0 , b0 , c0 ). Thus, Hplt = R. The constraint of the problem with fplr demands that at
least two of a0 , b0 , c0 are dominated by the node set spanned by the solution. Hence, Hplr = {r, a, b} if we solve
9

the polymatroid Steiner tree problem optimally (here, we assume that an exact algorithm for the polymatroid
Steiner tree problem is used). Then, the algorithm set H ∗ to Hplr , and the policy chooses a and b sequentially.
Suppose that a is chosen first. If a0 is revealed to be active, the policy terminates the first iteration. Then,
it chooses a0 in the next iteration and outputs {r, a, a0 } as a solution in this case. If a0 is inactive, then the
policy chooses b and observes the state of b0 . If b0 is active, then the policy chooses b0 in the second iteration
and outputs {r, a, b, b0 } as a solution. If b0 is inactive, then the policy chooses c, c0 in the second iteration,
and outputs {r, a, b, c, c0 } as a solution. This policy π achieves wavg (π) = w(a) + 2/3 · w(b) + 1/3 · w(c).

4.2

Performance guarantee for the full feedback model

Let π denote the adaptive policy given by Algorithm 1. In this section, we prove the following performance
guarantee on π.
Theorem 4. Let π denote the policy given by Algorithm 1, and let α be the approximation factor for the
node-weighted polymatroid Steiner tree problem. Then, π achieves the approximation factor 2α(1 + lg(1/δ)).
Let U ⊆ V and φ ∈ Ψ∗ such that supp(φ) = U ∪ N [U ]. We consider a residual instance of the robust
CDS problem after choosing nodes in U and the obtained observations are represented by φ. That is, when
a policy for this instance is invoked, the nodes in U have been already chosen and the states of those nodes
and their neighbors are given as φ. Let π ∗ (U, φ) be an optimal policy for this residual instance. Note that
wavg (π ∗ (U, φ)) does not count the weights of nodes in U .
Lemma 1. Let U and φ be those at the beginning of some round of π, and let H ∗ denote the one computed
in this round. Then, w(H ∗ ) ≤ 2αwavg (π ∗ (U, φ)).

Proof. In this proof, we simply denote π ∗ (U, φ) by π ∗ . Let (v1 , . . . , vl ) be the sequence of nodes chosen by
π ∗ when it always receives feedback of the highest probability, and for each i ∈ [l], let φi ∈ Ψ∗ represent the
realization maintained after choosing
Pvi and observing the states of the neighbors of vi . The assumption on
feedback means that φi maximizes ψ∈Ψφ p(ψ | φi−1 ) over possible realizations, where, by convention, φ0
i
P
denotes φ. Let j be the maximum index such that ψ∈Ψφ p(ψ | φ) > 1/2. The maximality of j implies
j
P
p(ψ | φ) ≤ 1/2 if j < l. We let Vi denote the node set {v1 , . . . , vi } for each i ∈ [l].
ψ∈Ψφ
j+1

Firstly we show that vi ∈ H for each i ∈ [j + 1]. Recall that any policy in the full feedback model
always chooses a node which is known to be active. Hence, φi−1 (vi ) = 1. This indicates
P that any ψ ∈ Ψφi−1
satisfies vi ∈ Aψ . Moreover, Ψφj ⊆ Ψφi−1 ⊆ Ψφ because φj  φi−1  φ. Therefore, ψ∈Ψφ :vi ∈Aψ p(ψ | φ) ≥
P
P
p(ψ | φ) ≥ ψ∈Ψφ p(ψ | φ) > 1/2, which means that vi ∈ H.
ψ∈Ψφ
j

i−1

Secondly, we prove that the observations given by choosing vi are consistent with ξvi if i ∈ [j]. For this,
let x ∈ {0, 1, ∗}V represent the states of the neighbors of vi observed at the choice of vi (x(u) = ∗ if u 6∈ N [vi ],
x(u) = 1 if u ∈ N [vi ] and u is active, and x(u) = 0 otherwise)
and suppose that P
x(u) 6= ξvi (u) for some
P
u ∈ N [vi ]. From the definitions of ξvi and H, we have ψ∈Ψφ :ψ(u)=x(u) p(ψ | φ) = ψ∈Ψφ :ψ(u)6=ξv (u) p(ψ |
i
P
P
φ) ≤ 1/2, from which ψ∈Ψφ :ψx p(ψ | φ) ≤ 1/2 follows. However, this means that ψ∈Ψφ p(ψ | φ) ≤ 1/2
i
P
P
holds because
ψ∈Ψφi p(ψ | φ) ≤
ψ∈Ψφ :ψx p(ψ | φ). This contradicts the definition of j, and hence
x = ξ vi .
Thirdly, we show that w(H ∗ ) ≤ αw(Vj ) holds when j = l. For this, we suppose j = l for a moment.
The union of U and Vl = {v1 , . . . , vl } is a feasible solution for the instance of the polymatroid Steiner tree
problem solved for computing Hplt . Indeed, Vl ∪ U induces a connected subgraph of G[R]. Moreover, when
π ∗ terminates, each node in V \ supp(φ) is dominated by Vl ∪ U , is revealed to be inactive, or is disconnected
from the root in any graphs consistent with the observations. This means that fplt (Vl ∪ U ) = |V \ supp(φ)| =
fplt (R), and thus Vl ∪ U is feasible for the instance. Therefore, αw(Vl ) ≥ w(Hplt ) ≥ w(H ∗ ) in this case.
Next, we prove that w(H ∗ ) ≤ αw(Vj+1 ) holds when
j < l. If the observations given
Pj < l. Suppose that P
at the choice of vj+1 are consistent with ξvj+1 , then ψ∈ΨV p(ψ | φ) = ψ∈Ψφ p(ψ | φ). Otherwise,
j+1
j+1
P
P
P
ψ∈ΨVj+1 p(ψ | φ) ≤
ψ∈Ψφj+1 p(ψ | φ) from the definition of φj+1 . In either of the cases,
ψ∈ΨVj+1 p(ψ |
P
φ) ≤ ψ∈Ψφ p(ψ | φ), and the right-hand side of this inequality is at most 1/2 because of the definition
j+1

of j. This means that fplr (Vj+1 ∪ U ) = 1/2 = fplr (R), and Vj+1 ∪ U is feasible for the instance of the
polymatroid Steiner tree problem solved for computing Hplr . This implies αw(Vj+1 ) ≥ w(Hplr ) ≥ w(H ∗ ).
10

Now, to prove the lemma, it suffices to show w(Vl ) ≤ 2wavg (π ∗ ) if j = l, and w(Vj+1 ) ≤ 2wavg (π ∗ )
otherwise. From the definition of j, φi appears with probability at least 1/2 in the execution of π ∗ for each
i ∈ [j]. Hence, with probability at least 1/2, policy π ∗ chooses the nodes in Vj , and vj+1 when j < l.
Therefore, the required inequalities hold.
Lemma 2. The number of rounds executed in π is at most 1 + lg(1/δ).
Proof. Let φ and φ0 be the realizations at the beginning and the end of a round. We prove that p(φ)/2 ≥ p(φ0 )
holds unless it is the last round. This indicates that the number of rounds is 1 + lg(1/δ).
First, let us consider the case where an observation
given at the choice of a node v ∈ H ∗ is inconsistent
P
with ξv in this round. By the definition of ξv , ψΨφ : ψ6ξv p(ψ | φ) ≤ 1/2 holds. Since φ0 is a realization
in Ψφ such that φ0 6 ξv in this case, we have p(φ0 ) ≤ p(φ)/2.
In the following, suppose that the observation given at the choice of each node v ∈ H ∗ is consistent with
ξv . Thus, all nodes in H ∗ are chosen in this round. If H ∗ = Hplt , then choosing all nodes in Hplt indicates
that the set of nodes chosen up to the end of this round dominates the connected component of active nodes
including the root, and hence this round is the last. Otherwise (i.e., H ∗ = Hplr ), p(φ0 | φ) ≤ 1/2 because φ0
is consistent with ξv for all v ∈ Hplr and fplr (Hplr ∪ U ) = 1/2.
P
Lemma 3. Let {Φ1 , . . . , Φk } be a partition of Ψ. For each i ∈ [k], let pi = ψ∈Φi p(ψ), consider an instance
such that each ψ ∈ Φi appears with probability p(ψ)/pi , and let πi∗ be an
P optimal policy for this instance.
Moreover, π ∗ denotes an optimal policy for the original instance. Then, i∈[k] pi wavg (πi∗ ) ≤ wavg (π ∗ ).
Proof. Recall that U (π ∗ , ψ) is the output of π ∗ for a full realization ψ. Define πi as the policy for the instance
with
(π ∗ , ψ) for each ψ ∈P
Φi . By
of πi∗ , wavg (πi∗ ) ≤ wavg (πi ) =
P Φi such that U (πi , ψ) = UP
P the optimality
∗
∗
U
(π
,
ψ)p(ψ)/p
.
Hence,
p
w
(π
)
≤
U
(π
,
ψ)p(ψ)
= wavg (π ∗ ).
i
i
ψ∈Φi
i∈[k] i avg i
i∈[k]
ψ∈Φi
Proof of Theorem 4. We show that the approximation factor of π is 2αk if the number of rounds in π is k.
Since k ≤ 1 + lg(1/δ) by Lemma 2, this suffices to prove the theorem.
Let π ∗ be an optimal policy for the given instance. The weights of nodes chosen in the first round of
π are at most 2αwavg (π ∗ ) by Lemma 1. Let (U1 , φ1 ), . . . , (Ul , φl ) be the pairs of possible solutions and the
observations at the end of the first round. Then, Ψφ1 , . . . , Ψφl form a partition of Ψ. The number of rounds
of π in the residual instance with (Ui , φi ) is at most k − 1 for each i ∈ [l]. Hence, under the condition that
the full realization extends φi , the expected objective value achieved by π in this residual instance is at most
2α(k − 1)wavg (π ∗ (Ui , φi )). This means that
wavg (π)
≤ 2αwavg (π ∗ ) + 2α(k − 1)

l
X

p(φi )wavg (π ∗ (Ui , φi ))

(1)

i=1

Note that wavg (π ∗ (Ui , φi )) is at most the expected objective value achieved by an optimal policy πi∗ for the
instances with the full realizations in Ψφi . Thus, the second term in the right-hand side of (1) is bounded
by
2α(k − 1)

l
X

p(φi )wavg (π ∗ (Ui , φi ))

i=1

≤ 2α(k − 1)

l
X
i=1

p(φi )wavg (πi∗ ) ≤ 2α(k − 1)wavg (π ∗ ),

where the second inequality follows from Lemma 3. Therefore, we have wavg (π) ≤ 2αkwavg (π ∗ ).

4.3

Algorithm and analysis for the local feedback model

Our algorithm and its analysis for the local feedback model are almost the same as those for the full feedback
model. In this subsection, we only highlight the differences between the algorithms.
11

As in Section 4.1, let U and φ be the set of chosen nodes and the realization kept at the beginning of
some round. In the local feedback model, choosing a node v reveals only the state of v. Because of this, we
possibly choose inactive nodes in this model. Due to this difference, we define the most-likely observation
vector ξv for all nodes v ∈ N [R] \ U by


1 u = v ∈ H,
ξv (u) = 0 u = v 6∈ H,


∗ u 6= v.
In each round, we solve two instances of the polymatroid Steiner tree problem to compute Hplt and Hplr .
The graphs in these instances are G[N [R]]. The ranges of the functions fplt and fplr are also changed to
2N [R] . The reason for these changes is that an optimal policy may choose inactive nodes even in the case
that the set of active nodes is exactly H. The definition of fplt is changed to
fplt (X) =|(V \ supp(φ)) ∩ N [X ∩ R]}|

X
X
1 −
+
v∈V \N [R]


p(ψ)

ψ∈ΨX\U :v∼ψ r

for each X ⊆ N [R]. Notice that the first term in the right-hand side depends only on X ∩ R, but the second
term depends on the whole of X. This is because inactive nodes are not used to dominate other nodes,
but the information on the states of those nodes indicates that the full realizations inconsistent with that
information are not realized. The definition of fplr is changed to



1
X
,1 −
p(ψ | φ)
fplr (X) = min

2
ψ∈ΨX\U

for each X ⊆ N [R].
The other inputs in these instances are the same as those in the full feedback model. Hplt and Hplr are
defined as the sets of nodes in N [R] \ U that are spanned by the computed trees. Then, the policy repeats
nodes in H ∗ = argminH 0 ∈{Hplt ,Hplr } w(H 0 ). If the revealed state of a chosen node v is different from the
expectation given by H (i.e., v is active and v 6∈ H, or v is inactive and v ∈ H), then the policy stops
choosing the nodes in this round and proceeds to the next round. The full details of this algorithm are
shown in Algorithm 2.
The performance guarantee on Algorithm 2 is given in the following theorem. Its proof is the same as
that for Theorem 4 except several minor details, and hence we omit it from this paper.
Theorem 5. Let π denote the policy given by Algorithm 2, and let α be the approximation factor for the
node-weighted polymatroid Steiner tree problem. Then, π achieves the approximation factor 2α(1 + lg(1/δ)).

5

Heuristic algorithms

In this section, we introduce two heuristic algorithms, one of which is a greedy algorithm and the other of
which is based on an algorithm for the CDS problem. These algorithms are regarded as baselines in the
simulation reported in the subsequent section.

5.1

Greedy algorithms

In the greedy algorithms, we repeat choosing a node for which the expected number of nodes dominated by
it is largest. We first explain the algorithm for the full feedback model.
Let U be the set of chosen nodes and φ be the realization that represents the observed states of nodes
up
to
the beginning of an iteration. For each v ∈ supp(φ) \ U such that φ(v) = 1, we define its score χ(v) as
P
u∈N [v]\supp(φ) Pr[ψ(u) = 1 | ψ  φ]. Hence, χ(v) represents the expected number of active nodes that are
12

Algorithm 2: O(α log 1/δ)-approximation algorithm for the local feedback model
Input : undirected graph G = (V, E), node weights w : V → R+ , full realizations Ψ, probability
distribution p : Ψ → [0, 1], and root node r ∈ V (ψ(r) = 1 for all ψ ∈ Ψ)
Output: U ⊆ V
1
2
3
4
5
6
7
8
9
10
11
12
13

U ←− {r}, φ(v) ←− 1;
foreach v ∈ V \ {r} do φ(v) ←− ∗;
while U does not dominate
P V do
H ←− {v ∈ V \ U :
ψ∈Ψφ :v∈Aψ p(ψ | φ) > 1/2};
R ←− connected component including r in G[H ∪ U ];
compute Hplt , Hplr ⊆ N [R] \ U , and set H ∗ ←− argminH 0 ∈{Hplt ,Hplr } w(H 0 );
while H ∗ 6⊆ U do
choose a node v ∈ H ∗ \ U dominated by U ;
U ←− U ∪ {v}, φ(v) ←− the state of v;
if φ(v) = 1 and v ∈ H, or φ(v) = 0 and v 6∈ H then break;
remove all nodes u with ψ(u) = 0 for all ψ ∈ Ψφ from G;
remove the connected components not including r from G

output U

U

x
u0

v

u

u1

u2

v

r

r
(a) greedy algorithm

uk

···

(b) CDS-based algorithm

Figure 3: Bad instances for the greedy and the CDS-based algorithms
not dominated by U but by v. In this iteration, the policy chooses the node v that maximizes χ(v)/w(v)
among all nodes in supp(φ) \ U .
Recall that U = supp(φ) in the local feedback model. For the local feedback model, we choose a node
that P
is dominated by an active node in U . We define the score of such a node v as Pr[ψ(v) = 1 | ψ 
φ] × u∈N [v]\N [U ] Pr[ψ(u) = 1 | ψ  φ, ψ(v) = 1]. Namely, it is the expected number of active nodes that
are not dominated by U but by v, multiplied by the probability that v is active.
The full algorithm is shown in Algorithm 3.
Bad instance The performance guarantee of Algorithm 3 can be arbitrarily bad even for the (deterministic) CDS problem. Let G = (V, E) be the graph defined as follows (see also Figure 3(a)). The node set V
consists of nodes r, v, u, u0 , and the other n0 nodes. We let U = V \{r, v, u, u0 }. The edge set E contains edges
rv, ru, uu0 . In addition, each of v and u0 is joined with all nodes in U . We can see that G is a unit disk graph
by defining the positions of the nodes appropriately. The node weights w are defined by w(r) = 0, w(v) = n0 ,
w(u) = 1 +  for a small  > 0, w(u0 ) = 0, and w(x) = 0 for each node x ∈ U . The minimum-weight CDS for
this instance is {r, u, u0 }, and its weight is 1 + . However, Algorithm 3 outputs another CDS that consists
of r, v, and a node of U . The weight of this CDS is n0 . The factor of the CDS output by Algorithm 3 to the
optimal one is n0 /(1 + ), which can be arbitrarily large by setting  to a value near to 0 and by increasing
n0 .
13

Algorithm 3: Greedy algorithm
Input : undirected graph G = (V, E), node weights w : V → R+ , full realizations Ψ, probability
distribution p : Ψ → [0, 1], and root node r ∈ V (ψ(r) = 1 for all ψ ∈ Ψ)
Output: U ⊆ V
1
2
3
4
5

U ←− {r} and φ(r) ←− 1;
foreach v ∈ V do
if the model is the full feedback model, v ∈ N [r], and v is active then φ(v) ←− 1;
else if the model is the full feedback model, v ∈ N [r] (v is inactive) then φ(v) ←− 0;
else φ(v) ←− ∗;

13

while U does not dominate V do
D ←− {v ∈ supp(φ) \ U : φ(v) = 1} in the full feedback model;
D ←− {v ∈ V \ U : ∃u ∈ U, φ(u) = 1, uv ∈ E} in the local feedback model;
foreach v ∈ D do compute χ(v);
v ←− argmaxv∈D χ(v)/w(v) and U ←− U ∪ {v};
update φ(v) in the full feedback model, and φ(u) for ∀u ∈ N [v] \ U in the local feedback model;
remove all nodes u with ψ(u) = 0 for all ψ ∈ Ψφ from G;
remove the connected components not including r from G

14

output U

6
7
8
9
10
11
12

5.2

CDS-based algorithms

In the other algorithm, we use a β-approximation algorithm for the CDS problem. In this algorithm, we
first compute a CDS D for the graph G and the node weights w by the β-approximation algorithm. Then,
we repeat choosing nodes in D such that the chosen nodes always induce connected subgraphs. During this
process, if a node in D turns out to be inactive, then we stop choosing nodes in D. We remove the nodes
that are revealed to be inactive from G and recompute a CDS for the updated graph, where the weights of
the nodes that have been chosen up to that moment are defined to be 0. These operations are repeated until
the chosen nodes form a solution. The pseudo-code of this algorithm is given in Algorithm 4.
Bad instance Algorithm 4 does not perform well for some instances because its behavior does not depend on the probability distribution on the node states. We see this fact by presenting a bad instance for
Algorithm 4. For ease of discussion, we suppose that a minimum-weight CDS can be computed in Step 8 of
Algorithm 4, and consider the local feedback model.
Let  and δ be small positive constants. Let G = (V, E) be the graph illustrated in Figure 3(b).
Namely, the node set V of a graph G comprises nodes r, v, u1 , . . . , uk , x, and the edge set E consists of
edges rv, ru1 , . . . , ruk , xv, xu1 , . . . , xuk . The node weights of u1 , . . . , uk are 1, and that of v is 1 + , and
those of r and x are 0. We assume that nodes r, x, and v are always active. For a full realization ψ ∈ Ψ,
p(ψ) = δ if exactly one of u1 , . . . , uk is active, and p(ψ) = 1 − kδ if all of u1 , . . . , uk are inactive.
If δ is small enough, the average objective value achieved by a policy is almost equal to the one for
the case where all of u1 , . . . , uk are inactive. In this case, the best policy chooses only v, which results in
the objective value 1 + . However, Algorithm 4 chooses all of u1 , . . . , uk and then chooses v. Thus the
approximation factor of Algorithm 4 is nearly k/(1 + ). This factor can be arbitrarily large by increasing k
and setting  to a constant.
Notice that the above discussion holds even when there are edges induced by {v, u1 , . . . , uk }. Thus we
can find such a bad instance even if the graph is restricted to unit disk graphs. Moreover, we obtain a bad
example in the full feedback model by modifying the above instance slightly as follows. For each i ∈ [k],
subdivide the edge rui by inserting a new node u0i (i.e., edge rui is replaced by ru0i and u0i ui ), where we let
u0i be always active. The weights of u01 , . . . , u0k are defined as 1, and those of u1 , . . . , uk are changed to 0.
Then, similar to the above instance for the local feedback model, Algorithm 4 chooses all of u01 , . . . , u0k and
v, achieving the objective k + 1 +  while the optimal policy chooses v and x, achieving the objective 1 + .

14

Algorithm 4: CDS-based algorithm
Input : undirected graph G = (V, E), node weights w : V → R+ , full realizations Ψ, probability
distribution p : Ψ → [0, 1], and root node r ∈ V (ψ(r) = 1 for all ψ ∈ Ψ)
Output: U ⊆ V
1
2
3
4
5
6
7
8
9
10
11
12

U ←− {r} and φ(r) ←− 1;
foreach v ∈ V do
if the model is the full feedback model, v ∈ N [r], and v is active then φ(v) ←− 1;
else if the model is the full feedback model, v ∈ N [r] (v is inactive) then φ(v) ←− 0;
else φ(v) ←− ∗;

while U does not dominate V do
update w(u) ←− 0 for ∀u ∈ U ;
compute a minimum-weight CDS D of (G, w);
while (D ∩ N [U ]) \ U 6= ∅ do
choose v ∈ (D ∩ N [U ]) \ U and U ←− U ∪ {v};
update φ(v) in the full feedback model, and φ(u) for ∀u ∈ N [v] \ U in the local feedback model;
if φ(u) = 0 for some node u then break;
remove all nodes u with ψ(u) = 0 for all ψ ∈ Ψφ from G;
remove the connected components not including r from G

13
14
15

output U

6

Simulation results

In this section, we report our simulation results to evaluate the empirical performance of the proposed
algorithm.

6.1

Setting

Throughout this section, we call the algorithm given in Section 4 the polymatroid-based algorithm, and the
heuristic algorithms given in Section 5 the greedy and the CDS-based algorithms. In the implementations
of the polymatroid-based and the CDS-based algorithms, we use the CBC integer programming solver
(https://projects.coin-or.org/Cbc) to solve the polymatroid Steiner tree and the CDS problems. The
solver solves these problems to optimality in all of the simulations that we report here. Thus, the polymatroidbased algorithm achieves an approximation factor within 1 + lg(1/δ) here.
In addition to these algorithms, we implemented the local algorithm given by Borgs et al. [13]. The
reason to choose this algorithm is that this algorithm requires the most limited information among the
known local algorithms; The other local algorithms [6, 14] require the information on the 3-hop neighbors of
the previously chosen nodes while the algorithm of Borgs et al. requires only the information on the 2-hop
neighbors. Note that even in the full feedback models, our algorithms cannot observe the 2-hop neighbors,
and thus the algorithm of Borgs et al. uses more information on neighbors than our algorithms. To be fair,
our algorithms use the probability distributions on realizations instead.
The algorithm of Borgs et al. is defined only for the cardinality minimization. To apply it to the weight
minimization, we slightly modified the algorithm. Let us explain this modification briefly. The algorithm of
Borgs et al. maintains a solution set U in the course of its execution, and proceeds in iterations. In each
iteration, it first chooses a node v from N [U ] that maximizes |N [v] \ N [U ]|, and add v to U . Then, it also
chooses a node from N [v] \ N [U ] uniform randomly, and adds it to U if it dominates a node not dominated
by U . In our implementation, we define v as a node in N [U ] that maximizes |N [v] \ N [U ]|/w(v) instead of
|N [v] \ N [U ]|. The other part of the algorithm is the same as the original.
For the simulations, we prepared the following three types of instances:
Unit disk graph In this type of instances, the graph is a unit disk graph, where each node has a random
position distributed uniformly on a 2-dimensional square region of a unit side length, and two nodes are

15

√
joined by an edge if their distance is at most 1/ n. We intend to make the density of the graph uniform
when n changes by this definition of edges. The weight of a node is sampled uniformly at random from
[0, 1]. As for the probability distribution on the full realizations, we construct M full realizations as follows:
for each full realization, we randomly pick seven points on the square region with thresholds sampled from
[0, 1/3], and a node except the root and its neighbors is defined to be inactive if and only if its distance
from one of the seven points is at most its threshold. The root and its neighbors are always active. The
distribution on the full realizations is defined so that one of these M full realizations appears uniformly at
random. Therefore, δ = 1/M in these instances.
Bidirectional disk graph In graphs of these instances, each node has a random position on the a 2dimensional square region of a unit side length, and has a radius sampled uniform randomly from [0, 1/3].
We consider these graphs as a model of wireless networks; the radius of a node represents a coverage length
of a wireless device, and an edge indicates that the devices corresponding to its end nodes can send signals
each other. Two nodes are joined by an edge whenever their distance is at most the minimum of their
radiuses. The other settings are defined in the same way as the unit disk graph instances.
Erdős-Rényi random graph In this type of instances, the graph is an Erdős-Rényi random graph, which
includes an edge joining each pair of nodes with probability 0.1 independently. The node weights are defined
in the same way as the unit disk graph instances. To define the full realizations, we define the location of
each node on a 2-dimensional square region of a unit side length randomly, and construct M full realizations
and a distribution on them as in the unit disk graph instances. The thresholds associated with the seven
points picked for defining the full realizations are sampled from [0, 0.25] since the the sampling from [0, 1/3]
makes the graphs on the active nodes too small.

6.2

Results

Comparison of the adaptive algorithms As we noted in Section 5, the approximation factors of the
heuristic algorithms are unbounded for the carefully constructed instances. However, these algorithms possibly perform well for other instances. A purpose of this simulation is to compare their performances and
that of the polymatroid-based algorithm.
In Figure 4, we compare the average objective values achieved by the algorithms. Each point in the
figure corresponds to an instance of the problem, and its x-coordinate (resp., y-coordinate) is the ratio of
the average objective value achieved by the polymatroid-based algorithm to that achieved by the greedy
algorithm (resp., the CDS-based algorithm). Thus, if the x-coordinate (resp., y-coordinate) of the point is
smaller than 1, then the polymatroid-based algorithm performs better than the CDS-based algorithm (resp.,
the greedy algorithm) in the corresponding instance. If the point is below the line representing x = y, then
this indicates that the CDS-based algorithm is better than the greedy algorithm. In the construction of the
instances, parameters are set to M = 30 and n = 40, 60, 80, 100. For each instance type and each parameter
setting, we constructed 5 instances.
We can observe that all of the three algorithms achieve the best in some instances, and thus we can
find no algorithm that is superior or is inferior to the other algorithms completely. In the full feedback
model, the polymatroid-based and the CDS-based algorithms are superior to the greedy algorithm in many
of the instances. Comparing the polymatroid-based and the CDS-based algorithms, the polymatroid-based
algorithm is slightly better than the CDS-based algorithm, but their difference is small. In the local feedback
model, the difference is clear; the polymatroid-based algorithm performs better than the other two algorithms
in unit disk and the Erdos-Renyi graphs. For bidirected disk graphs with the local feedback model, the CDSbased algorithm is superior to the others.
Although the merit of the greedy algorithm may not be clear when the objective values are compared,
it is superior to the other algorithms in running time. For example, the greedy algorithm is 10000 times
faster than the other two algorithms for the unit disk graph instances with n = 100 in our simulations. Our
implementations of the polymatroid-based and the CDS-based algorithms have to solve the integer programs,
and the time for this part is dominant in their computations. The running times of these algorithms can
be improved by more sophisticated integer programming solvers or by implementing other algorithms for
the polymatroid Steiner tree and the CDS problems at the sacrifices of their optimization performances.
16

unit disk

bidirectional disk

1.4

Erdos-Renyi

1.4

1.2

polymatroid / greedy

polymatroid / greedy

1.3

1.1
1.0
0.9
0.8

1.2

1.0

0.8

0.7
0.6
0.6

0.8

1.0
1.2
polymatroid / CDS

0.6
0.6

1.4

full feedback

0.8

1.0
1.2
polymatroid / CDS

1.4

local feedback

Figure 4: Simulation results to compare the three proposed algorithms
However, it is unlikely that they are superior to the greedy algorithm because of their definitions. Thus the
greedy algorithm is a good option when a fast algorithm is required (e.g., when the network is frequently
updated). On the other hand, it is often the case that receiving feedback from the environment is timeconsuming. In such a situation, the running time of an algorithm is not an important factor, and the
polymatroid-based and the CDS-based algorithms are also useful.
Comparison of the adaptive algorithms and the local algorithm We also apply the implementation
of the local algorithm of Borgs et al. [13] to the instances used in the simulation reported above. In all of
the instances, the local algorithm was clearly inferior to our three algorithms. In Table 2, we report the
maximum and minimum ratios of the objective values achieved by the local algorithm to that achieved by
the polymatroid-based algorithm for each graph class.
Change of performances for varying M The approximation factor of the polymatroid-based algorithm
depends on 1/δ (= M ) in our theoretical guarantee; as 1/δ increases, the approximation factor gets worse.
To evaluate the influence of 1/δ on the performance of the algorithms, we did the simulations with varying
M.
Figure 5 indicates how performances of the algorithms change when M changes. We used the unit disk
graph instances with n = 70. For each M , we prepared 5 instances, and report the averages of the objective
values achieved by the algorithms for those 5 instances. The right figure in Figure 5 also gives the average
weights of active nodes in the solutions output by the algorithms. Recall that a solution includes both active
and inactive nodes in the local feedback model while a solution consists of only active nodes in the full
feedback model. Although the objective in the local feedback models is not to minimize the weights of the
active nodes in a solution, it is meaningful to see how large they are since the active nodes in the solution
forms a CDS.
The figure shows that the polymatroid-based algorithm is superior to the other algorithms for all values of
M . We cannot observe any influence from increasing M on the performance in the full feedback model. In the
local feedback model, the average weights are increased as M increases, but this is a common phenomenon in
all algorithms. Hence, at least in this setting, increasing M does not give a large influence on the performance
of the polymatroid-based algorithm.
From the right figure of Figure 5, we can see that the weights of the solutions output by the CDS-based
algorithm is larger than those of the greedy algorithm in the local feedback model. However, the weights
of the active nodes in the solutions output by the CDS-based algorithm is smaller than those of the greedy
algorithm. This is an interesting feature of the CDS-based algorithm.

17

Table 2: Ratios of objective values achieved by Borgs et al. [13] to the polymatroid-based algorithm
unit disk bidirectional disk Erdos-Renyi
maximum
1.588
1.494
2.357
minimum
1.359
1.300
1.483

polymatroid

greedy

CDS

polymatroid active
greedy active
CDS active
4.75
4.50
2.90
4.25
2.85
4.00
2.80
3.75
3.50
2.75
3.25
2.70
3.00
2.65
2.75
10 20 30 40 50 60 70 80 90 100
10 20 30 40 50 60 70 80 90 100
M
M
average weights

average weights

2.95

full feedback

local feedback

Figure 5: Average objective value as a function of M in the unit disk graph instances

7

Conclusion

In this paper, we formulate the robust CDS problem, which is a new stochastic optimization variant of
the CDS problem. We also present three algorithms. One of them has a theoretical performance guarantee of factor O(α log 1/δ). Through computational simulation, we compare their empirical performances.
Considering the instability of wireless ad hoc networks, we believe that these algorithms are useful for the
construction of the virtual backbone of a network.

References
[1] F. Dai and J. Wu, “On constructing k-connected k-dominating set in wireless ad hoc and sensor networks,” J. Parall. Distri. Comp., vol. 66, no. 7, pp. 947–958, 2006.
[2] W. Shang, F. Yao, P. Wan, and X. Hu, “On minimum m-connected k-dominating set problem in unit
disc graphs,” J. Comb. Optim., vol. 16, no. 2, pp. 99–106, 2008.
[3] Y. Shi, Z. Zhang, Y. Mo, and D. Du, “Approximation algorithm for minimum weight fault-tolerant
virtual backbone in unit disk graphs,” IEEE/ACM Trans. Netw., vol. 25, no. 2, pp. 925–933, 2017.
[4] W. Wang, B. Liu, D. Kim, D. Li, J. Wang, and Y. Jiang, “A better constant approximation for
minimum 3-connected m-dominating set problem in unit disk graph using Tutte decomposition,” in
IEEE INFOCOM, 2015, pp. 1796–1804.
[5] Z. Zhang, J. Zhou, Y. Mo, and D. Du, “Performance-guaranteed approximation algorithm for
fault-tolerant connected dominating set in wireless networks,” in IEEE INFOCOM, 2016, pp. 1–8.
[6] S. Guha and S. Khuller, “Approximation algorithms for connected dominating sets,” Algorithmica,
vol. 20, no. 4, pp. 374–387, 1998.
[7] ——, “Improved methods for approximating node weighted Steiner trees and connected dominating
sets,” Inf. Comput., vol. 150, no. 1, pp. 57–74, 1999.
[8] B. N. Clark, C. J. Colbourn, and D. S. Johnson, “Unit disk graphs,” Disc. Math., vol. 86, no. 1-3, pp.
165–177, 1990.
18

[9] X. Cheng, X. Huang, D. Li, W. Wu, and D. Du, “A polynomial-time approximation scheme for
the minimum-connected dominating set in ad hoc wireless networks,” Networks, vol. 42, no. 4, pp.
202–208, 2003.
[10] J. Willson, Z. Zhang, W. Wu, and D. Du, “Fault-tolerant coverage with maximum lifetime in wireless
sensor networks,” in Proceedings of IEEE International Conference on Computer Communication,
INFOCOM, 2015, pp. 1364–1372.
[11] F. Zou, X. Li, S. Gao, and W. Wu, “Node-weighted Steiner tree approximation in unit disk graphs,” J.
Comb. Optim., vol. 18, no. 4, pp. 342–349, 2009.
[12] J. Byrka, F. Grandoni, T. Rothvoß, and L. Sanità, “Steiner tree approximation via iterative
randomized rounding,” J. ACM, vol. 60, no. 1, pp. 6:1–6:33, 2013.
[13] C. Borgs, M. Brautbar, J. T. Chayes, S. Khanna, and B. Lucier, “The power of local information in
social networks,” in Proceedings of 8th International Workshop on Internet and Network Economics,
WINE, 2012, pp. 406–419.
[14] S. Khuller and S. Yang, “Revisiting connected dominating sets: An optimal local algorithm?”
in Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques,
APPROX/RANDOM, LIPIcs 60, 2016, pp. 11:1–11:12.
[15] S. Funke, A. Kesselman, U. Meyer, and M. Segal, “A simple improved distributed algorithm for
minimum CDS in unit disk graphs,” ACM Transactions on Sensor Networks, vol. 2, no. 3, pp. 444–453,
2006.
[16] T. Shi, S. Cheng, Z. Cai, and J. Li, “Adaptive connected dominating set discovering algorithm
in energy-harvest sensor networks,” in Proceedings of IEEE International Conference on Computer
Communications, INFOCOM, 2016, pp. 1–9.
[17] Z. W. Lim, D. Hsu, and W. S. Lee, “Shortest path under uncertainty: Exploration versus exploitation,”
in Proceedings of Conference on Uncertainty in Artificial Intelligence, UAI, 2017.
[18] ——, “Adaptive stochastic optimization: From sets to paths,” in Proceedings of 29th Conference on
Neural Information Processing Systems, NIPS, 2015, pp. 1585–1593.
[19] A. Gupta, V. Nagarajan, and R. Ravi, “Approximation algorithms for optimal decision trees and
adaptive TSP problems,” Math. Oper. Res., vol. 42, no. 3, pp. 876–896, 2017.
[20] G. Călinescu and A. Zelikovsky, “The polymatroid Steiner problems,” J. Comb. Optim., vol. 9, no. 3,
pp. 281–294, 2005.

19

