Making a Sieve Random: Improved Semi-Streaming Algorithm for
Submodular Maximization under a Cardinality Constraint
Naor Alaluf∗

Moran Feldman†

arXiv:1906.11237v1 [cs.DS] 26 Jun 2019

June 27, 2019

Abstract
In this paper we consider the problem of maximizing a non-negative submodular function
subject to a cardinality constraint in the data stream model. Previously, the best known algorithm for this problem was a 5.828-approximation semi-streaming algorithm based on a local search technique (Feldman et al., 2018). For the special case of this problem in which
the objective function is also monotone, the state-of-the-art semi-streaming algorithm is an
algorithm known as Sieve-Streaming, which is based on a different technique (Badanidiyuru,
2014). Adapting the technique of Sieve-Streaming to non-monotone objective functions has
turned out to be a challenging task, which has so far prevented an improvement over the local
search based 5.828-approximation. In this work, we overcome the above challenge, and manage
to adapt Sieve-Streaming to non-monotone objective functions by introducing a “just right”
amount of randomness into it. Consequently, we get a semi-streaming polynomial time 4.282approximation algorithm for non-monotone objectives. Moreover, if one allows our algorithm
to run in super-polynomial time, then its approximation ratio can be further improved to 3 + ε.

∗
†

Department of Mathematics and Computer Science, Open University of Israel. E-mail: naoralaluf@gmail.com
Department of Mathematics and Computer Science, Open University of Israel. E-mail: moranfe@openu.ac.il

1

Introduction

Submodular functions are a wide class of functions capturing the intuitive notion of diminishing
returns. As diminishing returns occurs naturally in many scenarios, the optimization of submodular functions subject to combinatorial constraints has found many applications in diverse fields,
including machine learning [16, 24, 32], social networks [25, 27] and algorithmic game theory [17, 33].
In the context of many of the above applications, it is desirable for the submodular optimization algorithm to be a (semi-)streaming algorithm because the input is either very large (e.g., the
friendships graph of a social network) or naturally occurs at the form of a long stream (e.g., summarizations of the frames generated by a surveillance camera). In response to this need, Badanidiyuru
et al. [2] and Chakrabarti and Kale [10] developed two semi-streaming algorithms for the maximization of non-negative submodular functions that are also monotone. A set function f : 2N → R
over a ground set N is submodular if for every two sets A ⊆ B ⊆ N and element u ∈ N \ B it
holds that
f (A ∪ {u}) − f (A) ≥ f (B ∪ {u}) − f (B) ,
and it is monotone if f (A) ≤ f (B) for every two sets A ⊆ B ⊆ N . The algorithm of Badanidiyuru
et al. [2] maximizes non-negative monotone submodular functions subject to a cardinality constraint
up to an approximation ratio of 2; and the algorithm of Chakrabarti and Kale [10] achieves a 4approximation for the maximization of the same kind of functions subject to a more general class
of constraints known as matroid constraints.
Note again that the two above algorithms work only for monotone submodular functions. To
handle non-monotone submodular functions, it is usually necessary to use randomness.1 The algorithm of Chakrabarti and Kale [10] is local-search based, and easily integrates with randomness,
which has lead to multiple works adapting it to non-monotone
√ functions [13, 20, 29]. The best
of these adaptations achieves an approximation ratio of 3 + 2 2 ≈ 5.828 for maximizing a nonnegative (not necessarily monotone) submodular function subject to a matroid constraint [20]. In
contrast, the algorithm of Badanidiyuru et al. [2] for cardinality constrains, which is known as SieveStreaming, is based on a thresholding technique. In a nutshell, the algorithm picks a threshold and
then selects every element whose marginal contribution to the current solution of the algorithm
exceeds this threshold, until the solution gets to the maximum cardinality allowed. The analysis of
Sieve-Streaming then handles in two very different ways the case in which the solution grew all the
way to the maximum cardinality allowed and the case in which this did not happen. Unfortunately,
most natural ways to add randomness to Sieve-Streaming result in input instances for which both
these cases might happen with a non-zero, which makes the analysis break down. Due to this
hurdle, prior to this work, no random adaptation of Sieve-Streaming managed to improve over
the 5.828-approximation of [20] despite the significant advantage of Sieve-Streaming over the local
search approach of Chakrabarti and Kale [10] in the context of monotone submodular functions.2
In this paper, we present a novel way to introduce randomness into the thresholding technique
of Sieve-Streaming. Our basic idea is to base the decisions of the algorithm on the values of expectations over appropriately chosen distributions. On the one hand, this allows our algorithm
to include the necessary random component, and on the other hand, since expectations have deterministic values, the algorithm we get is deterministic enough to allow us to consider at every
1

Some works use alternative techniques involving the maintenance of multiple solutions. However, it is often
natural to view these solutions as the support of a distribution of solutions. See [3] for an explicit example of this
point of view.
2
Chekuri et al. [13] claimed an improved approximation ratio of 4.718 for cardinality constraints based on such an
adaptation of Sieve-Streaming, but an error was later found in the proof of this improved ratio [12]. See Appendix A
for more detail.

1

given time only one of the cases from the analysis of Sieve-Streaming. Using this idea, we get the
following theorem. In this theorem, and in the rest of the paper, we denote by k the maximum
number of elements allowed by the cardinality constraint in a solution. We also remind the reader
that a semi-streaming algorithm is an algorithm that gets its input in the form of a data stream
and uses a memory whose size is bounded by the maximum size of a feasible solution up to a
poly-logarithmic factor, which in our context means O(k · polylog(k, |N |)) space.
Theorem 1.1. For every constant ε ∈ (0, 1], there exists a semi-streaming (3 + ε)-approximation
algorithm for maximizing a non-negative submodular function subject to cardinality constraint. The
algorithm stores at most O(kε−2 log k) elements.
The time complexity of the algorithm whose existence is guaranteed by Theorem 1.1 is of the
form h(k, ε) · poly(|N |) for some non-polynomial function h, which makes this algorithm useful in
practice only when k and ε−1 are small enough. For larger values of k and ε−1 , the guarantee of
Theorem 1.1 is interesting only from an information theoretic point of view. To counteract this,
the following theorem describes a different version of our algorithm that is more appropriate for
practical uses. This version achieves a polynomial time complexity at the cost of guaranteeing a
weaker approximation ratio.
Theorem 1.2. There exists a polynomial time semi-streaming 4.282-approximation algorithm for
maximizing a non-negative submodular function subject to cardinality constraint. This algorithm
stores at most O(k log k) elements.
The algorithm guaranteed by Theorem 1.2 uses as a black box an offline algorithm for the
problem of maximizing a non-negative submodular function subject to cardinality constraint, and
naturally, its approximation ratio depends on the approximation ratio of this offline algorithm.
The approximation ratio given by Theorem 1.2 was calculated based on the guarantee of the offline
algorithm suggested by [7], and will improve if better offline algorithms are found for the problem.
However, even based on the existing offline algorithm, Theorem 1.2 significantly improves over the
state-of-the-art 5.828-approximation.
It is also worth mentioning that a simple adaptation of a result due to Buchbinder et al. [8]
shows that no data stream algorithm can achieve (2 − ε)-approximation (for any positive ε) for the
problem we consider, unless it uses Ω(|N |) memory. Moreover, this is true even if the algorithm
is allowed to use unbounded computational power. For completeness, we include the proof of this
result in Appendix B.

1.1

Additional Related Work

The problem of maximizing a non-negative monotone submodular function subject to a cardinality
or a matroid constraint was studied (in the offline model) already in the 1970’s. In 1978, Nemhauser
et al. [31] and Fisher et al. [22] showed that a natural greedy algorithm achieves an approximation ratio of e/e−1 ≈ 1.58 for this problem when the constraint is a cardinality constraint and an
approximation ratio of 2 for matroid constraints. The e/e−1 approximation ratio for cardinality
constraints was shown to be optimal already on the same year by Nemhauser and Wolsey [30],
but the best possible approximation ratio for matroid constraints was open for a long time. Only
a decade ago, Calinescu et al. [9] managed to show that a more involved algorithm, known as
“continuous greedy”, can achieve e/e−1-approximation for this type of constraints, which is tight
since matroid constriants generalize cardinality constraints. Unlike the natural greedy algorithm,
continuous greedy is a randomized algorithm, which raised an interesting question regarding the
best possible approximation ratio for matroid constraints that can be achieved by a deterministic
2

algorithm. Very recently, Buchbinder et al. [5] made a slight step towards answering this question. Specifically, they described a deterministic algorithm for maximizing a monotone submodular
function subject to a matroid constraint whose approximation ratio is 1.997. This algorithm shows
that the 2 approximation of the greedy algorithm is not the right answer for the above mentioned
question.
Many works have studied also the offline problem of maximizing a non-negative (not necessarily
monotone) submodular function subject to a cardinality or a matroid constraint [4, 7, 15, 18, 19, 21].
The most recent of these works achieves an approximation ratio of 2.598 for both cardinality
and matroid constraints [4]. In contrast, it is known that no polynomial time algorithm can
achieve an approximation ratio of 2.037 for cardinality constraints or 2.093 for matroid constraints,
respectively [23].
The study of data stream algorithms for submodular maximization problems is related to the
study of online algorithms for such problems. A partial list of works on algorithms of the last kind
includes [1, 6, 8, 11, 26, 28].

2

Preliminaries

In this section we introduce two standard extensions of submodular functions. The first of these
extensions is known as the multilinear extension. To define this extension, we first need to define
the random set R(x). For every vector x ∈ [0, 1]N , R(x) is defined as a random subset of N that
includes every element u ∈ N with probability xu , independently. The multilinear extension F of
f is now defined for every vector x ∈ [0, 1]N by
!
X
X
Y
Y


F (x) = E f R(x) =
f (A) · Pr[R(x) = A] =
f (A) ·
xu ·
(1 − xu ) .
A⊆N

A⊆N

u∈A

u∈A
/

One can observe from the definition that F is indeed a multilinear function of the coordinates of
x, as suggested by its name.
In the analysis of our algorithm we need an upper bound on the possible increase in the value
of F (x) when some of the indices of x are zeroed. Corollary 2.2 provides such an upper bound. To
prove it, we first need the following known lemma by Buchbinder et al. [7].

Lemma 2.1 (Lemma 2.2 from [7]). Let f : 2N → R≥0 be a non-negative submodular function.
Denote by A(p) a random subset of A where each element appears with probability at most p (not
necessarily independently). Then, E[f (A(p))] ≥ (1 − p) · f (∅).

In the statement of Corollary 2.2, and in the rest of the paper, we denote by supp(x) the support
of vector x, i.e., the set {u ∈ N | xu > 0}.
Corollary 2.2. Let f : 2N → R≥0 be a non-negative submodular function whose multilinear extension is F , let p be a number in the range [0, 1] and let x, y ∈ [0, 1]N be two vectors such that
• supp(x) ∩ supp(y) = ∅,
• and yu ≤ p for every u ∈ N .
Then, F (x + y) ≥ (1 − p) · F (x).

Proof. Let us define the function Gx (S) = E[f (R(x) ∪ S)]. It is not difficult to verify that Gx is
non-negative and submodular, and that Gx (∅) = F (x). Additionally, since supp(x) ∩ supp(y) = ∅,
R(x + y) has the same distribution as R(x) ∪ R(y), and therefore,




F (x + y) = E f R(x + y)) = E f R(x) ∪ R(y)
= E[Gx (R(y))] ≥ (1 − p) · Gx (∅) = (1 − p) · F (x) ,
3

where the inequality follows from Lemma 2.1.
The other standard extension of submodular functions that we need is the Lovász extension.
The Lovász extension fˆ of f is defined for every vector x ∈ [0, 1]N by
fˆ(x) =

Z

1

f (Tλ (x)) dλ ,

0

where Tλ (x) = {u ∈ N | xu ≥ λ} is the subset of N containing every element u ∈ N whose corresponding coordinate xu in the vector x is at least λ. In this paper we use the Lovász extension
only to lower bound values of the multilinear extension via the following known lemma.
Lemma 2.3 (Lemma A.4 from [34]). Let F and fˆ be the multilinear and Lovász extensions of a
submodular function f : 2N → R, respectively. Then, F (x) ≥ fˆ(x) for every vector x ∈ [0, 1]N .
We conclude this section by describing some additional notation that we use in the rest of the
paper. Given a set A ⊆ N and element u ∈ N , we denote by 1A and 1u the characteristic vectors
of A and {u}, respectively. Additionally, given two vectors x, y ∈ [0, 1]N , we use x ∨ y and x ∧ y to
denote the coordinate-wise maximum and minimum of x and y, respectively (i.e., for every element
u ∈ N , (x ∨ y)u = max{xu , yu } and (x ∧ y)u = min{xu , yu }). We also use the shorthand ∂u F (x) for
(x)
the first partial derivative ∂F
∂xu of the multilinear extension F . Note that, since F is multilinear,
∂u F (x) = F (x ∨ 1u ) − F x ∧ 1N \{u}



.

Finally, we denote by OP T an arbitrary optimal solution for our problem, i.e., a subset of N of
size at most k maximizing f among all such subsets.

3

Our Algorithm

In this section, we introduce a simplified version of the algorithm we use to prove Theorems 1.1
and 1.2. This simplified version (given as Algorithm 1) captures our main new ideas, but avoids
some technical issues that can be solved using standard techniques. In particular, Algorithm 1
assumes access to an estimate τ of f (OP T ) obeying (1 − O(ε)) · f (OP T ) ≤ τ ≤ f (OP T ). Such
an estimate can be produced, at the cost of increasing the space complexity of the algorithm by a
factor of O(ε−1 log k), using a technique introduced by [2], and we defer the details to Appendix C.
Algorithm 1 gets two constant parameters p ∈ (0, 1) and c > 0. The algorithm maintains
a fractional solution x ∈ [0, 1]N . This fractional solution starts empty, and the algorithm adds
to it fractions of elements as they arrive. Specifically, when an element u arrives, the algorithm
considers its marginal contribution with respect to the current fractional solution x. If this marginal
contribution exceeds the threshold of cτ /k, then the algorithms tries to add to x a p-fraction of u,
but might end up adding a smaller fraction of u if adding a full p-fraction of u to x will make x an
infeasible solution, i.e., make kxk1 > k (note that kxk1 is the sum of the coordinates of x).
After viewing all the elements, Algorithm 1 uses the fractional solution x to generate two sets
S1 and S2 that are feasible (integral) solutions. The set S1 is generated by rounding the fractional
solution x. Two rounding procedures, named Pipage Rounding and Swap Rounding, were suggested
for this task in the literature [9, 14]. Both procedures run in polynomial time and guarantee that
the output set S1 of the rounding is always feasible, and that its expected value with respect to f
is at least the value F (x) of the fractional solution x. The set S2 is generated by finding a subset
of the support of the vector x that (approximately) maximizes f among all such subsets of size
4

at most k. One can observe that to get S2 one must (approximately) solve the offline version of
the problem of maximizing a non-negative submodular function subject to a cardinality constraint.
In the pseudocode of Algorithm 1 we denote by α the inverse of the approximation ratio of the
algorithm used to solve this problem and produce S2 . The value that we can assume for α depends
on whether we want Algorithm 1 to run in polynomial time. If that is not required, then α can be
assumed to be 1 because the offline problem can be optimally solved using a brute force search. In
contrast, α must have a smaller value if Algorithm 1 should run in polynomial time, and we discuss
at a later point the value that can be assumed for α in this case. After computing the two feasible
solutions S1 and S2 , Algorithm 1 simply returns the better one of them.
Algorithm 1: Multilinear Threshold (p, c)
1
2
3
4
5
6

x ← 1∅ .
for each arriving element u do
if ∂u F (x) ≥ cτ
k then x ← x + min{p, k − kxk1 } · 1u .

Round the vector x to yield a feasible solution S1 such that E[f (S1 )] ≥ F (x).
Find a feasible solution S2 ⊆ supp(x) such that E[f (S2 )] ≥ α · arg maxS⊆supp(x),|S|≤k f (S).
return the better solution among S1 and S2 .

Let us denote by x̂ the final value of the fractional solution x (i.e., its value when the stream
ends). We begin the analysis of Algorithm 1 with the following useful observation.
Observation 3.1. If kx̂k1 < k, then x̂u = p for every u ∈ supp(x̂). Otherwise, this is still true for
every element u ∈ supp(x̂) except for maybe a single element.
Proof. For every element u added to the support of x by Algorithm 1, the algorithm sets xu to p
unless this will make kxk1 exceed k, in which case the algorithm set xu to be the value that will
make kxk1 equal to k. Thus, after a single coordinate of x is set to a value other than p (or the
initial 0), kxk1 becomes k and the Algorithm 1 stops changing x.
Using the last observation we can now bound the space complexity of Algorithm 1, and show
(in particular) that it is a semi-streaming algorithm for a constant p.
Observation 3.2. Assuming it takes O(1) space to store an element of N and a value returned
by F , Algorithm 1 can be implemented so that it stores at most O(k/p) elements and its space
complexity is Õ(k/p), excluding the space complexity required by the algorithm for computing S2 .
Proof. To calculate the sets S1 and S2 , Algorithm 1 needs access only to the elements of N that
appear in the support of x. Thus, the number of elements it needs to store is O(| supp(x)|) = O(k/p),
where the equality follows from Observation 3.1.
Since each one of the sets S1 and S2 contains at most k elements, they require O(k) space.
In addition, Algorithm 1 needs to store the vector x. It is possible to store the coordinates of x
taking the value of p by storing their indices, which requires O(log |N |) space for each coordinate
and O(| supp(x)|) · O(log |N |) = Õ(k/p) space in total. In addition to these coordinates, the vector
x might include a single non-zero coordinate taking the value of k − p⌊k/p⌋, storing the index and
value of this coordinate require O(log |N | + log k) = Õ(1) space.
We now divert our attention to analyzing the approximation ratio of Algorithm 1. The first
step in this analysis is lower bounding the value of F (x), which we do by considering two cases,
one when kx̂k1 = k, and the other when kx̂k1 < k. The following lemma bounds the value of F (x̂)
in the first of these cases.
5

Lemma 3.3. If kx̂k1 = k, then F (x̂) ≥ cτ .
Proof. Denote by u1 , u2 , . . . , uℓ the elements that Algorithm 1 selects, in the order of their arrival.
Using this notation, the value of F (x̂) can be written as follows.
ℓ 
X


F x̂ ∧ 1{u1 ,u2 ,...,ui } − F x̂ ∧ 1{u1 ,u2 ,...,ui−1 }
F (x̂) = F (1∅ ) +

= F (1∅ ) +

i=1
ℓ 
X
i=1

≥ F (1∅ ) +

x̂ui · ∂ui F x̂ ∧ 1{u1 ,u2 ,...,ui−1 }



ℓ
cτ X
cτ
x̂ui = F (1∅ ) +
·
· kx̂k1 ≥ cτ ,
k
k
i=1

where the second equality follows from the multilinearity of F , and the first inequality holds since
Algorithm 1 selects an element ui only when ∂ui F x̂ ∧ 1{u1 ,u2 ,...,ui−1 } ≥ cτ
k . The last inequality
holds since f (and thus, also F ) is non-negative and kxk1 = k by the assumption of the lemma.
We now consider the case in which kx̂k1 < k. Recall that our objective is to lower bound F (x̂)
in this case as well. Towards this goal, we bound the expression F (x̂ + 1OP T \supp(x̂) ) from below
and above in the next two lemmata.


Lemma3.4. If kx̂k1 < k, then F x̂ + 1OP T \supp(x̂) ≥ (1 − p) · p · f (OP T ) + (1 − p) · f OP T \
supp(x̂) .

Proof. Since kx̂k1 < k, Observation 3.1 guarantees that xu = p for every u ∈ supp(x̂), Thus
x̂ = p · 1OP T ∩supp(x̂) + p · 1supp(x̂)\OP T , and therefore,


F x̂ + 1OP T \supp(x̂) = F p · 1OP T ∩supp(x̂) + p · 1supp(x̂)\OP T + 1OP T \supp(x̂)

≥ (1 − p) · F p · 1OP T ∩supp(x̂) + 1OP T \supp(x̂)

≥ (1 − p) · fˆ p · 1OP T ∩supp(x̂) + 1OP T \supp(x̂)
h
i
= (1 − p) · p · f (OP T ) + (1 − p) · f OP T \ supp(x̂) ,

where the first inequality follows from Corollary 2.2, the second inequality hold since the Lovász
extension lower bounds the multilinear extension (Lemma 2.3), and the last equality follows from
the definition of the Lovász extension.

Lemma 3.5. If kx̂k1 < k, then F x̂ + 1OP T \supp(x̂) ≤ F (x̂) + cτ .

Proof. The elements in OP T \ supp(x̂) were rejected by Algorithm 1, which means that their
marginal contribution with respect to the fractional solution x at the time of their arrival was smaller
than cτ /k. Since the fractional solution x only increases during the execution of the algorithm, the
submodularity of f guarantees that this is true also with respect to x̂. More formally, we get
∂u F (x̂) <

cτ
k

∀ u ∈ OP T \ supp(x̂) .

Using the submodularity of f again, this implies
X

cτ
∂u F (x̂) ≤ F (x̂) + |OP T \ supp(x̂)| ·
≤ F (x̂) + cτ .
F x̂ + 1OP T \supp(x̂) ≤ F (x̂) +
k
u∈OP T \supp(x̂)

6

Combining the last two lemmata immediately yields the promised lower bound on F (x̂).
h
i
Corollary 3.6. If kx̂k1 < k, then F (x̂) ≥ (1 − p) · p · f (OP T ) + (1 − p) · f OP T \ supp(x̂) − cτ .

Now that we have lower bounds on F (x̂) for both cases, we can use them to get an expression
for the approximation ratio of Algorithm 1.
o
n
α(1−p−c)
. In particular,
Lemma 3.7. If τ ≤ f (OP T ), then E[max{f (S1 ), f (S2 )}] ≥ τ · min c, α+(1−p)
2
for c =

α(1−p)
2α+(1−p)2

we get E[max{f (S1 ), f (S2 )}] ≥

ατ (1−p)
2α+(1−p)2

α(1−p)
Proof. To see why the second part of the lemma follows from the first part, note that c = 2α+(1−p)
2
implies
h
h
i
i
2α+(1−p)2
α
α
α(1
−
p)
1
−
α(1
−
p)
−
α(1 − p − c)
α(1 − p)
2α+(1−p)2
α+(1−p)2
α+(1−p)2
=
=
=
.
2
2
2
α + (1 − p)
α + (1 − p)
2α + (1 − p)
2α + (1 − p)2

Given the above, we concentrate in the rest of the proof on proving the first part of the lemma.
If kx̂k = k, then by the definition of S1 and Lemma 3.3
E[max{f (S1 ), f (S2 )}] ≥ E[f (S1 )] ≥ F (x̂) ≥ cτ .
Consider now the case in which kx̂k1 < k. Note that OP T ∩ supp(x̂) is a subset of the support of
x̂ of size at most k, and thus, by the definition of S2 , E[f (S2 )] ≥ α · f (OP T ∩ supp(x̂)). Combining
this with the lower bound given by Corollary 3.6 for E[f (S1 )] when kxk1 < k, we get
E[max{f (S1 ), f (S2 )}] ≥ max{E[f (S1 )], E[f (S2 )]}



≥ max (1 − p) · p · f (OP T ) + (1 − p) · f (OP T \ supp(x̂)) − cτ, α · f (OP T ∩ supp(x̂))
α
≥
· [(1 − p) · [p · f (OP T ) + (1 − p) · f (OP T \ supp(x̂))] − cτ ]
α + (1 − p)2
(1 − p)2
+
· α · f (OP T ∩ supp(x̂)) ,
α + (1 − p)2
where the last inequality holds since a maximum over two expressions is lower bounded by any convex combination of the two expressions in it. Rearranging the rightmost side of the last inequality
yields
i α[p(1 − p) · f (OP T ) − cτ ]
α(1 − p)2 h
·
f
(OP
T
∩
supp(x̂))
+
f
(OP
T
\
supp(x̂))
+
.
α + (1 − p)2
α + (1 − p)2
By assumption, f (OP T ) ≥ τ . Additionally, by the submodularity and non-negativity of f ,
f (OP T ∩ supp(x̂)) + f (OP T \ supp(x̂)) ≥ f (OP T ) ≥ τ . Combining all the above, we get
E[max{f (S1 ), f (S2 )}] ≥

α[p(1 − p) · τ − cτ ]
α(1 − p − c)
α(1 − p)2
·τ +
=τ·
,
2
2
α + (1 − p)
α + (1 − p)
α + (1 − p)2

which completes the proof for the case of kx̂k1 < k.
The following proposition summarizes the results we have proved so far.

7

Proposition 3.8. As long as the algorithm used to compute S2 runs in poly(ε) · Õ(k) space,
Algorithm 1 is a semi-streaming algorithm storing O (k/p) elements. Moreover, for an appropriate
choice of the parameter c, the output set produced by Algorithm 1 has an expected value of at least
ατ (1−p)
whenever τ ≤ f (OP T ).
2α+(1−p)2
One consequence of Proposition 3.8 is the following theorem. This theorem is similar to Theorem 1.1, but it still assumes access to an estimate τ of f (OP T ). In Appendix C we show how to
remove this assumption, using the technique of [2], which yields Theorem 1.1.
Theorem 3.9. For every constant ε ∈ (0, 1], there exists a semi-streaming algorithm that assumes
access to an estimate τ of f (OP T ) obeying (1 − ε/8) · f (OP T ) ≤ τ ≤ f (OP T ) and provides
(3 + ε)-approximation for the problem of maximizing a non-negative submodular function subject to
cardinality constraint. This algorithm stores at most O(kε−1 ) elements.
Proof. In the theorem that we want to prove there is no restriction on the time complexity of the
algorithm. Without such a restriction, Algorithm 1 can be implemented with α = 1 (as discussed
above). Consider the algorithm obtained from Algorithm 1 by setting α = 1, p = ε/8 and c as
necessary to make Proposition 3.8 hold. We show that this algorithm obeys all the requirements
of the theorem. First, by Proposition 3.8, it stores at most O(k/p) = O(kε−1 ) elements, and it is
a semi-streaming algorithm since the algorithm for calculating S2 simply iterates over all subsets
of the stored elements of size at most k, which requires no more than O(kε−1 ) space. Second, the
expected value of the output set of this algorithm is at least
(1 − ε/8) · f (OP T ) · (1 − ε/8)
(1 − ε/4) · f (OP T )
f (OP T )
ατ (1 − p)
≥
≥
≥
.
2
2
2α + (1 − p)
2 + (1 − ε/8)
3
3+ε
Our next objective is to use Proposition 3.8 to get also a guarantee for a polynomial time
algorithm. To get a polynomial time implementation of Algorithm 1, one has to handle two issues.
The first issue is that one must use a polynomial time algorithm for calculating S2 , which leads to
α < 1. The second issue is related to the way the algorithm access the objective function. It is
standard in the literature about submodular maximization to assume that algorithms have access
to the objective function f through a value oracle, which is an oracle that given a set S ⊆ N
returns f (S). For non-polynomial time algorithms, one can use this oracle to evaluate F because
the value of F with respect to any given vector can be calculated using an exponential number of
value oracle queries to f . However, for polynomial time algorithms there is no known way to do
that. Thus, it is not clear how to implement Algorithm 1 using only value oracle access to f . We
note, however, that it is easy to implement Algorithm 1 using a value oracle access to F .3
Keeping the two above issues in mind, we get the following theorem. This theorem is similar
to Theorem 1.2, but assumes access to an estimate τ of f (OP T ) and value oracle access to F . In
Appendix C we explain how to remove the need to access τ , and in Appendix D we explain how the
value oracle access to F can be replaced with a value oracle access to f using standard sampling
techniques, which completes the proof of Theorem 1.2.
Theorem 3.10. There exists a semi-streaming 4.2819-approximation algorithm for maximizing a
non-negative submodular function f subject to cardinality constraint that assumes
• value oracle access to the multilinear extension F of f , and
9999
· f (OP T ) ≤ τ ≤ f (OP T ).
• access to an estimate τ of f (OP T ) such that 10000
The algorithm stores at most O(k) elements.
3
Observe that an algorithm that has value oracle access to F can also evaluate derivatives of F via the equality
∂u F (x) = F (x ∨ 1u ) − F (x ∧ 1N \{u} ), which holds for every vector x ∈ [0, 1]N and element u ∈ N .

8

Proof. We begin the proof by determining the value of α that we may assume in a polynomial time
implementation of Algorithm 1. In general, the state-of-the-art algorithm for the offline problem of
maximizing a non-negative submodular function subject to a cardinality constraint is an algorithm
of [4] achieving 2.598-approximation for the problem. However, the instance of this problem that
Algorithm 1 solves has additional structure. Specifically, the size of the ground set of this instance
is | supp(x)| ≤ ⌈k/p⌉. Furthermore, by guessing a single element of this ground set that does not
belong to the optimal solution, we can assume that the algorithm needs to solve an offline instance
in which the size of the ground set is upper bounded by k/p. For such instances, Buchbinder et
al. [7] described an algorithm that for every constant ε ∈ (0, 1] achieves in polynomial time an
approximation ratio of
{size of ground set of offline instance}
+ε ,
1+ p
2 ({size of ground set of offline instance} − k) k

when the size of the ground set of the offline instance is at least 2k and an approximation ratio of
2 otherwise (this is not the way the approximation ratio of Buchbinder et al. [7] is stated in the
original paper, but it follows from their proof). Plugging into this approximation ratio the upper
bound we have on the size of the ground set of the offline instance, we get that for p ≤ 1/2 the
algorithm of [7] achieves an approximation ratio of at most
)
(
)
(
1
k/p
1
+ ε, 2 = 1 + p
+ε .
max 1 + p
+ ε, 2 = max 1 + p
2 (k/p − k)k
2 p − p2
2 p − p2

Thus, for p ≤
p 1/2 we may assume in a polynomial time implementation of Algorithm 1 that
α = [1 + 1/(2 p − p2 )]−1 + ε for any constant ε ∈ (0, 1].
p = 0.24 and c
Consider now the algorithm obtained from Algorithm 1 by setting α = 0.460675,
p
2
as necessary to make Proposition 3.8 hold. One can verify that α > [1+ 1/(2 p − p )]−1 , and thus,
the algorithm obtained in this way can be implemented in polynomial time according to the above
discussion (assuming value oracle access to F ). We also would like to show that the algorithm we
obtained obeys the other requirements of the theorem we want to prove. First, by Proposition 3.8,
it stores at most O(k/p) = O(k) elements, and it is a semi-streaming algorithm since the algorithm
of Buchbinder et al. [4] can be implemented to use only poly(ε−1 ) · Õ(k/p) space when run on a
ground set of size ⌈k/p⌉. Second, the expected value of the output set of this algorithm is at least
0.460675 · 0.9999 · f (OP T ) · (1 − 0.24)
ατ (1 − p)
≥
2α + (1 − p)2
2 · 0.460675 + (1 − 0.24)2
0.35007 · f (OP T )
≥
≥ 0.233543 · f (OP T ) .
1.49895
The theorem now follows since 1/0.233543 ≤ 4.2819.

References
[1] Yossi Azar, Iftah Gamzu, and Ran Roth. Submodular max-sat. In ESA, pages 323–334, 2011.
[2] Ashwinkumar Badanidiyuru, Baharan Mirzasoleiman, Amin Karbasi, and Andreas Krause.
Streaming submodular maximization: massive data summarization on the fly. In KDD, pages
671–680, 2014.

9

[3] Niv Buchbinder and Moran Feldman. Deterministic algorithms for submodular maximization
problems. ACM Trans. Algorithms, 14(3):32:1–32:20, 2018.
[4] Niv Buchbinder and Moran Feldman. Constrained submodular maximization via a nonsymmetric technique, 2019. To appear in Mathematics of Operations Research.
[5] Niv Buchbinder, Moran Feldman, and Mohit Garg. Deterministic (1/2 + ε)-approximation for
submodular maximization over a matroid. In SODA, pages 241–254, 2019.
[6] Niv Buchbinder, Moran Feldman, and Mohit Garg. Online submodular maximization: Beating
1/2 made simple, 2019. To appear in IPCO.
[7] Niv Buchbinder, Moran Feldman, Joseph Naor, and Roy Schwartz. Submodular maximization
with cardinality constraints. In SODA, pages 1433–1452, 2014.
[8] Niv Buchbinder, Moran Feldman, and Roy Schwartz. Online submodular maximization with
preemption, 2019. To appear in ACM Transactions on Algorithms.
[9] Gruia Călinescu, Chandra Chekuri, Martin Pál, and Jan Vondrák. Maximizing a monotone
submodular function subject to a matroid constraint. SIAM J. Comput., 40(6):1740–1766,
2011.
[10] Amit Chakrabarti and Sagar Kale. Submodular maximization meets streaming: matchings,
matroids, and more. Math. Program., 154(1-2):225–247, 2015.
[11] T.-H. Hubert Chan, Zhiyi Huang, Shaofeng H.-C. Jiang, Ning Kang, and Zhihao Gavin Tang.
Online submodular maximization with free disposal. ACM Trans. Algorithms, 14(4):56:1–
56:29, 2018.
[12] Chandra Chekuri. Personal communication, 2018.
[13] Chandra Chekuri, Shalmoli Gupta, and Kent Quanrud. Streaming algorithms for submodular
function maximization. In ICALP, pages 318–330, 2015.
[14] Chandra Chekuri, Jan Vondrák, and Rico Zenklusen. Dependent randomized rounding via
exchange properties of combinatorial structures. In FOCS, pages 575–584, 2010.
[15] Chandra Chekuri, Jan Vondrák, and Rico Zenklusen. Submodular function maximization via
the multilinear relaxation and contention resolution schemes. SIAM J. Comput., 43(6):1831–
1879, 2014.
[16] Abhimanyu Das and David Kempe. Submodular meets spectral: Greedy algorithms for subset
selection, sparse approximation and dictionary selection. In ICML, pages 1057–1064, 2011.
[17] Shaddin Dughmi, Tim Roughgarden, and Mukund Sundararajan. Revenue submodularity.
Theory of Computing, 8(1):95–119, 2012.
[18] Alina Ene and Huy L. Nguyen. Constrained submodular maximization: Beyond 1/e. In FOCS,
pages 248–257, 2016.
[19] Moran Feldman. Maximizing symmetric submodular functions. ACM Trans. Algorithms,
13(3):39:1–39:36, 2017.

10

[20] Moran Feldman, Amin Karbasi, and Ehsan Kazemi. Do less, get more: Streaming submodular
maximization with subsampling. In NeurIPS, pages 730–740, 2018.
[21] Moran Feldman, Joseph Naor, and Roy Schwartz. A unified continuous greedy algorithm for
submodular maximization. In FOCS, pages 570–579, 2011.
[22] Marshall L. Fisher, George L. Nemhauser, and Laurence A. Wolsey. An analysis of approximations for maximizing submodular set functions—II, pages 73–87. Springer Berlin Heidelberg,
Berlin, Heidelberg, 1978.
[23] Shayan Oveis Gharan and Jan Vondrák. Submodular maximization by simulated annealing.
In SODA, pages 1098–1116, 2011.
[24] Daniel Golovin and Andreas Krause. Adaptive submodularity: Theory and applications in
active learning and stochastic optimization. J. Artif. Intell. Res., 42:427–486, 2011.
[25] Jason D. Hartline, Vahab S. Mirrokni, and Mukund Sundararajan. Optimal marketing strategies over social networks. In WWW, pages 189–198, 2008.
[26] Michael Kapralov, Ian Post, and Jan Vondrák. Online submodular welfare maximization:
Greedy is optimal. In SODA, pages 1216–1225, 2013.
[27] David Kempe, Jon M. Kleinberg, and Éva Tardos. Maximizing the spread of influence through
a social network. Theory of Computing, 11:105–147, 2015.
[28] Nitish Korula, Vahab S. Mirrokni, and Morteza Zadimoghaddam. Online submodular welfare
maximization: Greedy beats 1/2 in random order. SIAM J. Comput., 47(3):1056–1086, 2018.
[29] Baharan Mirzasoleiman, Stefanie Jegelka, and Andreas Krause. Streaming non-monotone
submodular maximization: Personalized video summarization on the fly. In AAAI, pages
1379–1386, 2018.
[30] George L. Nemhauser and Laurence A. Wolsey. Best algorithms for approximating the maximum of a submodular set function. Math. Oper. Res., 3(3):177–188, 1978.
[31] George L. Nemhauser, Laurence A. Wolsey, and Marshall L. Fisher. An analysis of approximations for maximizing submodular set functions—I. Math. Program., 14(1):265–294, 1978.
[32] Mehraveh Salehi, Amin Karbasi, Dustin Scheinost, and R. Todd Constable. A submodular
approach to create individualized parcellations of the human brain. In Medical Image Computing and Computer Assisted Intervention - MICCAI 2017 - 20th International Conference,
Quebec City, QC, Canada, September 11-13, 2017, Proceedings, Part I, pages 478–485, 2017.
[33] Andreas S. Schulz and Nelson A. Uhan. Approximating the least core value and least core of
cooperative games with supermodular costs. Discrete Optimization, 10(2):163–180, 2013.
[34] Jan Vondrák. Symmetry and approximability of submodular maximization problems. SIAM
J. Comput., 42(1):265–304, 2013.

11

A

Details about the Error in a Previous Work

As mentioned above, Chekuri et al. [13] described a semi-streaming algorithm for the problem of
maximizing a non-negative (not necessarily monotone) submodular function subject to a cardinality
constraint, and claimed an approximation ratio of 4.718 for this algorithm. However, an error was
later found in the proof of this result [12] (the error does not affect the other results of [13]). For
completeness, we briefly describe in this appendix the error found.
In the proof presented by Chekuri et al. [13], the output set of their algorithm is denoted by S̃.
As is standard in the analysis of algorithms based on Sieve-Streaming, the analysis distinguishes
between two cases: one case in which S̃ = k, and a second case in which S̃ < k. To argue about
the second case, the analysis then implicitly uses the inequality
h
i
E f (S̃ ∪ OP T ) | |S| < k ≥ (1 − max Pr[u ∈ S̃]) · f (OP T ) .
(1)
u∈N

It is claimed by [13] that this inequality follows from a lemma due to [7]. However, the lemma of [7]
can yield only the inequalities
h
i
E f (S̃ ∪ OP T ) ≥ (1 − max Pr[u ∈ S̃]) · f (OP T )
u∈N

and

h
i
E f (S̃ ∪ OP T ) | |S| < k ≥ (1 − max Pr[u ∈ S̃ | |S| < k]) · f (OP T ) ,
u∈N

which are similar to (1), but do not imply it.

B

Inapproximability

In this appendix, we prove an inapproximability result for the problem of maximizing a non-negative
submodular function subject to cardinality constraint in the data stream model. This result is given
by the next theorem. The proof of the theorem is an adaptation of a proof given by Buchbinder et
al. [8] for a similar result applying to an online variant of the same problem.
Theorem B.1. For every constant ε > 0, no data stream algorithm for maximizing a non-negative
submodular function subject to cardinality constraint is (2 − ε)-competitive, unless it uses Ω(|N |)
memory.
Proof. Let k ≥ 1 and h ≥ 1 be two integers to be chosen later, and consider the non-negative
k−1
submodular function f : 2N → R+ , where N = {ui }i=1
∪ {vi }hi=1 ∪ {w}, defined as follows.
(
|S|
if w ∈
/S ,
f (S) =
k−1
k + S ∩ {ui }i=1
if w ∈ S .
It is clear that f is non-negative. One can also verify that the marginal value of each element in
N is non-increasing, and hence, f is submodular.
Let ALG be an arbitrary data stream algorithm for the problem of maximizing a non-negative
submodular function subject to a cardinality constraint, and let us consider what happens when we
give this algorithm the above function f as input, the last element of N to arrive is the element w
and we ask the algorithm to pick a set of size at most k. One can observe that, before the arrival of
w, ALG has no way to distinguish between the other elements of N . Thus, if we denote by M the
set of elements stored by ALG immediately before the arrival of w and assume that the elements
12

of N \ {w} arrive at a random order, then every element of N \ {w} belongs to M with the same
probability of E[|M |]/|N \ {w}|. Hence, there must exist some arrival order for the elements of
N \ {w} guaranteeing that
h

E |M ∩

i

k−1
{ui }i=1
|

=

k−1
X
i=1

Pr[ui ∈ M ] ≤

k · E[|M |]
.
|N \ {w}|

Note now that the above implies that the expected value of the output set produced by ALG
given the above arrival order is at most
k+

k · E[|M |]
.
|N \ {w}|

k−1
In contrast, the optimal solution is the set {ui }i=1
∪ {w}, whose value is 2k − 1. Therefore, the
competitive ratio of ALG is at least

2k − 1
2 − 1/k
1
2 · E[|M |]
=
≥2− −
.
k + k · E[|M |]/|N \ {w}|
1 + E[|M |]/|N \ {w}|
k |N \ {w}|
To prove the theorem we need to show that, when the memory used by ALG is o(|N |), we can choose
large enough values for k and h that will guarantee that the rightmost side of the last inequality
is at least 2 − ε. We do so by showing that the two terms 1/k and 2 · E[|M |]/|N \ {w}| can both
be upper bounded by ε/2 when the integers k and h are large enough, respectively. For the term
1/k this is clearly the case when k is larger than 2/ε. For the term 2 · E[|M |]/|N \ {w}| this is true
because increasing h can make N as large as want, and thus, can make the ratio E[|M |]/|N \ {w}|
as small as necessary due to our assumption that the memory used by ALG (which includes M ) is
o(|N |).

C

Estimating the Optimal Value

In this appendix, we explain how one can drop the assumption from Section 3 that the algorithm
has access to an estimate τ of f (OP T ). This leads to versions of Theorems 3.9 and 3.10 without
this assumption. Specifically, we prove the following two theorems. The first of these theorems is
one of the results of this paper. In Appendix D we explain how the proof of the second of these
theorems can be modified to derive the other result of the paper (Theorem 1.2).
Theorem 1.1. For every constant ε ∈ (0, 1], there exists a semi-streaming (3 + ε)-approximation
algorithm for maximizing a non-negative submodular function subject to cardinality constraint. The
algorithm stores at most O(kε−2 log k) elements.
Theorem C.1. There exists a polynomial time semi-streaming algorithm for maximizing a nonnegative submodular function f subject to cardinality constraint that assumes value oracle access to
the multilinear extension F of f and has an approximation ratio of at most 4.2819. This algorithm
stores at most O(k log k) elements.
The algorithm we use to prove Theorems 1.1 and C.1 is Algorithm 2. It gets the same two
parameters p and c as Algorithm 1 plus an additional parameter ε′ ∈ (0, 1) controlling the quality
guarantee of the output. The algorithm is based on a technique originally due to Badanidiyuru et
al. [2]. Throughout its execution, Algorithm 2 tracks in m the maximum value of any singleton
seen so far (or the value of the empty set if it is larger). The algorithm also maintains a set
13


T = (1 + ε′ )i | m/(1 + ε′ ) ≤ (1 + ε′ )i ≤ mk/c of values that are either possible estimates for
OP T at the current point or might become such estimates in the future (of course, T includes only
a subset of the possible estimates). For every estimate τ in T , the algorithm maintains a fractional
solution xτ . We note that the set of fractional solutions maintained is updated every time that T
is updated (which happens after every update of m). Specifically, whenever a new value τ is added
to T , the algorithm instantiate a new vector xτ , and whenever a value τ is dropped from T , the
algorithm deletes xτ .
While a value τ remains in T , Algorithm 2 maintains the fractional solution xτ in exactly the
same way that Algorithm 1 maintains its fractional solution given the value τ as an estimate for
f (OP T ). Moreover, we show below that if τ remains in T when the algorithm terminates, then the
value of xτ when the algorithm terminates is equal to the value of the vector x when Algorithm 1
terminates after executing with τ as the estimate for f (OP T ). Thus, one can view Algorithm 2 as
parallel execution of Algorithm 1 for many estimates of f (OP T ) at the same time. After viewing
the last element, Algorithm 2 calculates for every τ ∈ T an output set Ŝτ based on the fractional
solution x̂τ in the same way Algorithm 1 does that, and then outputs the best output set computed
for any τ ∈ T .
Algorithm 2: Multilinear Threshold with No Access to τ (p, c, ε′ )

1 Let m ← f (∅) and T ← (1 + ε′ )h | m/(1 + ε′ ) ≤ (1 + ε′ )h ≤ mk/c .
2 for each arriving element u do
3
if m < f ({u}) then

4
Update m ← f ({u}) and T ← (1 + ε′ )h | m/(1 + ε′ ) ≤ (1 + ε′ )h ≤ mk/c .
5
Delete xτ for every value τ removed from T in Line 4.
6
Initialize xτ ← 1∅ for every value τ added to T in Line 4.
7
8
9
10
11

12
13

for every τ ∈ T do
if ∂u F (xτ ) ≥ cτ
k then xτ ← xτ + min{p, k − kxτ k1 } · 1u .

for every τ ∈ T do
Round the vector xτ to yield a feasible solution S1τ such that E[f (S1τ )] ≥ F (xτ ).
Find a feasible solution S2τ ⊆ supp(xτ ) such that
E[f (S2τ )] ≥ α · arg maxS⊆supp(xτ ),|S|≤k f (S).
Let Ŝτ be the better solution among S1τ and S2τ .
return the best solution among {Ŝτ }τ ∈T , or the empty set if T = ∅.

We begin the analysis of Algorithm 2 by bounding its space complexity.
Observation C.2. Assuming it takes O(1) space to store an element of N and a value returned
by F , Algorithm 2 can be implemented so that it stores at most O(kp−1 (ε′ )−1 (ln k − ln c)) elements
and its space complexity is Õ(kp−1 (ε′ )−1 (− ln c)), excluding the space complexity of the algorithm
used to find the sets S2τ .
Proof. The number of estimates in T is upper bounded at all times by


1 + ln k − ln c
1 + ln k − ln c
km/c
≤1+
= O((ε′ )−1 (ln k − ln c)) .
=1+
1 + log1+ε′
m/(1 + ε′ )
ln(1 + ε′ )
2ε′ /3
Algorithm 2 maintains for every τ ∈ T the same information maintained by Algorithm 1, which
requires O(k/p) elements and Õ(k/p) space for every τ ∈ T , or equivalently, O(kp−1 (ε′ )−1 (ln k −
14

ln c)) elements and Õ(kp−1 (ε′ )−1 (− ln c)) space for all the values in T together. In addition to this
information, the algorithm also has to store m, which requires constant space. We note that there
is no need to explicitly store T because the estimates added to it or removed from it in every update
of m can be easily determined using the old and new values of m.
Our next objective is to show that the approximation guarantee of Algorithm 1 extends to
Algorithm 2. Let m̂ and T̂ be the final values of m and T , respectively. We assume in this section
α(1−p)
that c is set to the value given in Lemma 3.7—the value 2α+(1−p)
2 . Recall that this is the value
required to make Proposition 3.8 hold. Using this choice of c allows us to easily handle the rare
case in which T̂ is empty.
Observation C.3. c ∈ (0, 1/2], and thus, T̂ is not empty unless m̂ = 0.
Proof. Since α ∈ (0, 1] and p ∈ (0, 1),
c=

 αi
α(1 − p)
= (0, 1/2] .
∈
0,
2α + (1 − p)2
2α

The last observation immediately implies that when T̂ is empty, all the singletons have zero
values. Thus, both OP T and the empty set have zero values, which makes the output of Algorithm 2
optimal in this case. Hence, we can assume from now on that T̂ 6= ∅. The following lemma shows
that T̂ contains a good estimate for f (OP T ) in this case.
Lemma C.4. The set T̂ contains a value τ̂ such that (1 − ε′ ) · f (OP T ) ≤ τ̂ ≤ f (OP T ).



. Thus, by the submodularity of f ,
Proof. Observe that m̂ = max f (∅), maxu∈N f {u}
(
)
X
X

km̂
.
f (OP T ) ≤ f (∅) +
[f ({u}) − f (∅)] ≤ max f (∅),
f {u}
≤ km̂ ≤
c
u∈OP T

u∈OP T

In contrast, by the definition of OP T ,




f (OP T ) ≥ max f (∅), max f {u}
= m̂ .
u∈N

Since T̂ contains all the values of the form (1 + ε′ )i in the range [m̂/(1 + ε′ ), k m̂/c], the above
inequalities imply that it contains in particular the largest value of this form that is still not larger
than f (OP T ). Let us denote this value by τ̂ . By definition, τ̂ ≤ f (OP T ). Additionally,
τ̂ · (1 + ε′ ) ≥ f (OP T ) ⇒ τ̂ ≥

f (OP T )
≥ (1 − ε′ ) · f (OP T ) .
1 + ε′

Let us now concentrate on the value τ̂ whose existence is guaranteed by Lemma C.4, and let
x̄ denote the fractional solution maintained by Algorithm 1 when it gets τ̂ as the estimate for
f (OP T ). Additionally, let us denote by u1 , u2 , . . . , un the elements of N in the order of their
arrival, and let uj be the element whose arrival caused the addition of τ̂ to T , i.e., uj is the first
element satisfying τ̂ ≤ (k/c) · f ({uj }) (if τ̂ ∈ T from the very beginning, then we define j = 0).
The following lemma shows that, prior to the arrival of uj , the fractional solution x̄ of Algorithm 1
was empty.

Lemma C.5. For every integer 1 ≤ t ≤ j − 1, ∂ut F x̄ ∧ 1{u1 ,u2 ,...,ut−1 } < cτ̂
k , and thus, no fraction
of ut was added to x̄.
15

Proof. If j = 0, then the lemma is trivial. Otherwise, by the definition of uj as the first element
obeying τ̂ ≤ (k/c) · f ({uj }),

cτ̂
> f ({ut }) ≥ f ({ut }) − f (∅) = ∂ut F (1∅ ) ≥ ∂ut F x̄ ∧ 1{u1 ,u2 ,...,ut−1 } ,
k

where the second inequality follows from the non-negativity of f and the last from its submodularity.
According to the above discussion, from the moment τ̂ gets into T , Algorithm 2 updates the
fractional solution xτ̂ in the same way that Algorithm 1 updates x̄ (note that, once τ̂ gets into T ,
it remains there for good since τ̂ ∈ T̂ ). Together with the previous lemma which shows that x̄ is
empty just like xτ̂ at the moment τ̂ gets into T —which is also the moment of the arrival of uj ,
this implies that the final value of xτ̂ is equal to the final value of x̄. Since the set Ŝτ̂ is computed
based on the final value of xτ̂ in the same way that the output of Algorithm 1 is computed based
on the final value of x̄, we get the following corollary.
Corollary C.6. If it is guaranteed that the approximation ratio of Algorithm 1 is at least β when
(1 − ε′ ) · f (OP T ) ≤ τ ≤ f (OP T ) for some choice of the parameters p and c, then the approximation
ratio of Algorithm 2 is at most β as well for this choice of p and c.
We are now ready to prove Theorems 1.1 and C.1.
Proof of Theorem 1.1. The proof of Theorem 3.9 shows that Algorithm 1 achieves an approximation
ratio of 3 + ε when it has access to a value τ obeying (1 − ε/8) · f (OP T ) ≤ τ ≤ f (OP T ) and its
α(1−p)
parameters are set to α = 1, p = ε/8 and c = 2α+(1−p)
2 . According to Corollary C.6, this implies
that setting the parameters α, p and c of Algorithm 2 in the same way and setting ε′ to ε/8, we get
an algorithm whose approximation ratio is at most 3 + ε and does not assume access to an estimate
of f (OP T ).
It remains to bound the space requirements of the algorithm obtained in this way. Observe that
c=

1 − ε/8
1/2
1
α(1 − p)
=
≥
= .
2α + (1 − p)2
2 + (1 − ε/8)2
3
6

Plugging this bound and the equality p = ε/8 into the guarantee of Observation C.2, we get that
the algorithm we obtained stores at most O(kε−2 log k) elements, and uses Õ(kε−2 ) space (since
the algorithm for calculating S2 uses only O(kε−1 ) space as explained in the proof of Theorem 3.9),
which implies that it is a semi-streaming algorithm.
Proof of Theorem C.1. The proof of Theorem 3.10 shows that Algorithm 1 runs in polynomial time
and achieves an approximation ratio of 4.2819 when it has access to a value τ obeying (1 − 10−4 ) ·
f (OP T ) ≤ τ ≤ f (OP T ), it has value oracle access to F and its parameters are set to α = 0.460675,
α(1−p)
p = 0.24 and c = 2α+(1−p)
2 . Since Algorithm 2 requires only a polynomial amount of time on top
of the time required by |T | instances of Algorithm 1, this implies that Algorithm 2 can also be
implemented to run in polynomial time (given value oracle access to F ) when the parameters p, c
and α are set as above and ε′ is set to 10−4 . Moreover, Corollary C.6 guarantees that, after setting
the parameters in this way, the approximation ratio of Algorithm 2 is at most 4.2819.
It remains to bound the space required by Algorithm 2 when the parameters are set as above.
Observe that
c=

0.460675 · (1 − 0.24)
0.3501092
α(1 − p)
=
=
≥ 0.233 .
2
2
2α + (1 − p)
2 · 0.460675 + (1 − 0.24)
1.49895
16

Plugging this bound and the equalities p = 0.24 and ε′ = 10−4 into the guarantee of Observation C.2, we get that Algorithm 2 with the above parameter values stores at most O(k log k)
elements, and uses Õ(k) space in addition to the poly(1/ε′ ) · Õ(k) space used by the algorithm for
calculating S2τ (as explained in the proof of Theorem 3.10), which implies that it is a semi-streaming
algorithm.

D

Approximating the Multilinear Extension

In this appendix we prove Theorem 1.2 by presenting a polynomial time variant of Algorithm 2,
given below as Algorithm 3. We observe that the only difference between Algorithms 2 and 3
is that the latter algorithm uses estimates for the partial derivatives of F instead of the actual
values of these derivatives (which are difficult to compute in polynomial time). These estimates
are calculated in Line 8 of the algorithm.
Algorithm 3: Multilinear Threshold with No Oracle Access to F (p, c, ε′ )

1 Let m ← f (∅) and T ← (1 + ε′ )h | m/(1 + ε′ ) ≤ (1 + ε′ )h ≤ mk/c .
2 for each arriving element ui do
3
if m < f ({ui }) then

4
Update m ← f ({ui }) and T ← (1 + ε′ )h | m/(1 + ε′ ) ≤ (1 + ε′ )h ≤ mk/c .
5
Delete xτ for every value τ removed from T in Line 4.
6
Initialize xτ ← 1∅ for every value τ added to T in Line 4.
7
8

for every τ ∈ T do
Let ∂¯uτ i F (xτ ) be an approximation of




∂ui F (xτ ) = F (xτ ∨ 1ui ) − F (xτ ∧ 1N \ui ) = E f R (xτ ) ∪ {ui } − f R(xτ )

9
10

11
12
13

14
15

obtained by averaging ℓ =
if ∂¯τ F (xτ ) ≥ cτ then
ui

k

l

4800(p−1 +1)2 k 2
[ε′ (1−ε′ )]2

xτ ← xτ + min{p, k − kxτ k1 } · 1ui .

· ln 80i2 (ε′ )−1

m

samples.

for every τ ∈ T do
Round the vector xτ to yield a feasible solution S1τ such that E[f (S1τ )] ≥ F (xτ ).
Find a feasible solution S2τ ⊆ supp(xτ ) such that
E[f (S2τ )] ≥ α · arg maxS⊆supp(xτ ),|S|≤k f (S).
Let Ŝτ be the better solution among S1τ and S2τ .
return the best solution among {Ŝτ }τ ∈T , or the empty set if T = ∅.

We begin the analysis of Algorithm 3 by bounding its space complexity.
Lemma D.1. Assuming it takes O(1) space to store an element of N and a value returned by f ,
Algorithm 3 can be implemented so that it stores at most O(kp−1 (ε′ )−1 (ln k − ln c)) elements and
its space complexity is Õ(kp−1 (ε′ )−1 (− ln c) + log ε−1 + log(1 − ε)−1 + log p−1 ), excluding the space
complexity of the algorithm used to find the sets S2τ .
Proof. Observe that apart from the space used to calculate the estimates of the derivatives, Algorithms 2 and 3 share the same space complexity. Thus, in this proof we only bound the space
required for computing the estimates.
17

To calculate each estimate, Algorithm 3 has to store the sum of ℓ samples. Since we assume
that each sample can be stored in constant space, storing this sum requires
 l

−2
m
O(log ℓ) = O log 4800 ε′ (1 − ε′ )pk−1
ln 80i2 (ε′ )−1

= O log k + log ε−1 + log(1 − ε)−1 + log p−1 + log log(i2 /ε′ )
= Õ(log ε−1 + log(1 − ε)−1 + log p−1 ) ,

where the last equality holds since i is upper bounded by n and the Õ notation suppresses terms
that are poly-logarithmic in n and k. Since Algorithm 3 need to store only one estimate at each
time point, its space complexity exceeds the space complexity of Algorithm 2 only by the above
expression.
Our next objective is to analyze the approximation guarantee of Algorithm 3. We note that
the proofs of Observation C.3 and Lemmata C.4 and C.5 apply also to Algorithm 3 without any
change. Thus, we know that Algorithm 3 outputs an optimal solution if the final set T is empty
(so we assume from now that it is not), and that there exists a value τ̂ and integer 1 ≤ j ≤ n such
that
• τ̂ enters T when uj arrives (unless τ̂ belongs to T from the very beginning of the algorithm,
in which case we define j = 1),
• once τ̂ enters into T , it remains there until the algorithm terminates,
• for every 1 ≤ t < j, ∂ut F (x̃∧1u1 ,u2 ,...,ut−1 ) < cτ̂ /k, where x̃ denotes the final value of fractional
solution xτ̂ ,
• and (1 − ε′ ) · f (OP T ) ≤ τ̂ ≤ f (OP T ).
It is important to observe also that the value of xτ̂ when the element ui arrives is x̃ ∧ 1{u1 ,u2 ,...,ui−1 } .

Let us denote now by E the event that the estimate ∂¯uτ̂ i F x̃ ∧ 1{u1 ,u2 ,...,ui−1 } that is calculated by

′
′)
· f (OP T ) for every j ≤ i ≤ n
Algorithm 3 differs from ∂ui F x̃ ∧ 1{u1 ,u2 ,...,ui−1 } by at most ε (1−ε
20k


′ (1−ε′ )
ε
(i.e., ∂¯uτ̂ i F x̃ ∧ 1{u1 ,u2 ,...,ui−1 } − ∂ui F x̃ ∧ 1{u1 ,u2 ,...,ui−1 } ≤ 20k · f (OP T ) for every 1 ≤ i ≤
n). Intuitively, E is the event that all the estimates done by Algorithm 3 with respect to τ̂ are
quite accurate. In the next few claims we show that E is a high probability event. We first need
the following known Chernoff-like lemma.
Lemma D.2 (Lemma B.3 from [8]).PLet X1 , X2 , . . . , Xℓ be independent random variables such that
for each i, Xi ∈ [−1, 1]. Let X = 1ℓ ℓi=1 Xi and µ = E[X]. Then
Pr[X > µ + α] ≤ e−

α2 ℓ
12

and

Pr[X < µ − α] ≤ e−

α2 ℓ
8

for every α > 0.
In the next lemma we show that each estimate that Algorithm 3 calculates is not likely to be
too far away from the actual value of the derivative.
h


Lemma D.3. For every j ≤ i ≤ n, Pr ∂¯uτ̂ i F x̃ ∧ 1{u1 ,u2 ,...,ui−1 } − ∂ui F x̃ ∧ 1{u1 ,u2 ,...,ui−1 } >
i
ε′ (1−ε′ )
ε′
·
f
(OP
T
)
≤ 40i
2.
20k


¯τ̂ F x̃ ∧ 1{u ,u ,...,u } by averaging ℓ samples of
Proof. The algorithm calculates
the
estimate
∂
u
1
2
i−1
i


f R(x̃ ∧ 1{u1 ,u2 ,...,ui−1 } ) ∪ {ui } − f R(x̃ ∧ 1{u1 ,u2 ,...,ui−1 } ) . Let Yt be the t-th such
 sample. Note that
the expected value of Yt for every 1 ≤ t ≤ ℓ is exactly ∂ui F x̃ ∧ 1{u1 ,u2 ,...,ui−1 } . Later in this proof,
18



we will show that the value of Yt always fall within the range −(p−1 + 1) · f (OP T ), f (OP T ) .
However, before doing so, let us prove that the lemma holds under this assumption.
Consider the random variables Y1 /[(p−1 + 1) · f (OP T )], Y2 /[(p−1 + 1) · f (OP T )], . . . , Yℓ /[(p−1 +
1) · f (OP T )]. Due to the above assumption, the values of these random variables always fall within
the range [−1, 1], therefore, by Lemma D.2,




ε′ (1 − ε′ )
τ̂
¯
Pr ∂ui F x̃ ∧ 1{u1 ,u2 ,...,ui−1 } − ∂ui F x̃ ∧ 1{u1 ,u2 ,...,ui−1 } >
· f (OP T )
20k
"
#
"
#
ℓ
ℓ
1 X
ε′ (1 − ε′ )
1 X
= Pr
Yt − E
Yt >
·
·
· f (OP T )
ℓ
ℓ
20k
t=1
t=1
#
#
"
"
ℓ
ℓ
X
Yt
Yt
ε′ (1 − ε′ )
1 X
1
>
·
−E
·
= Pr
ℓ t=1 (p−1 + 1) · f (OP T )
ℓ t=1 (p−1 + 1)f (OP T )
20k(p−1 + 1)
ℓ

≤ 2e−



ε′ (1−ε′ )
20k(p−1 +1)
12

2

ε′

≤ 2eln 80i2 =

ε′
.
40i2

It only remains to prove that
 for every 1 ≤ t ≤ ℓ, the sample Yt is contained within the range
−(p−1 + 1) · f (OP T ), f (OP T ) . Since f is submodular and f (OP T ) upper bounds the value of
every set of k elements with respect to f , every set S of at most ⌈p−1 k⌉ ≤ (p−1 + 1)k elements
obeys f (S) ≤ (p−1 + 1) · f (OP T ). Therefore,

Yt ≥ − f R x̃ ∧ 1{u1 ,u2 ,...,ui−1 } ≥ − (p−1 + 1) · f (OP T )



because x̃ contains at most ⌈p−1 k⌉ non-zero entries. In contrast, the submodularity of f also implies



Yt = f R x̃ ∧ 1{u1 ,u2 ,...,ui−1 } ∪ {ui } − f R x̃ ∧ 1{u1 ,u2 ,...,ui−1 } ≤ f ({ui }) − f (∅)
≤ f ({ui }) ≤ f (OP T ) .

Lemma D.3 implies the following corollary.
Corollary D.4. Pr[E] ≥ 1 − ε′ /20.
Proof. By Lemma D.3 and the union bound,
 
Z
n
n
X
ε′
ε′ X 1
ε′
ε′ n 1
ε′
ε′ 1 n
ε′
ε′
ε′
ε′
=
=
≤
+
dx
=
−
−
+
≤
.
1 − Pr[E] ≤
40i2
40
i2
40 40 1 x2
40 40 x 1
40 40n 40
20
i=j

i=j

In the next few lemmata we show that, given that the event E happens, the approximation
ratio of Algorithm 3 is good. We first consider the case in which kx̃k1 = k. The following lemma
corresponds to Lemma 3.3 and bounds the value of F (x̃) from below in this case.
Lemma D.5. Assuming E holds, if kx̃k1 = k, then F (x̃) ≥ τ̂ · (c − ε′ /20).
Proof. Note that since x̃ contains a zero fraction of every element that arrived before uj , the value
of F (x̃) can also be written as
F (x̃) = F (1∅ ) +
= F (1∅ ) +

n 
X


F x̃ ∧ 1{u1 ,u2 ,...,ui } − F x̃ ∧ 1{u1 ,u2 ,...,ui−1 }

i=j
n 
X
i=j

x̃ui · ∂ui F x̃ ∧ 1{u1 ,u2 ,...,ui−1 }
19



,

where the second equality follows from the multilinearity of F . Since we assume that the event E
happened, for every j ≤ i ≤ n it holds that
ε′ (1 − ε′ )
· f (OP T )
∂¯uτ̂ i (x̃ ∧ 1{u1 ,u2 ,...,ui−1 } ) ≤ ∂ui (x̃ ∧ 1{u1 ,u2 ,...,ui−1 } ) +
20k
ε′
≤ ∂ui (x̃ ∧ 1{u1 ,u2 ,...,ui−1 } ) + τ̂ ·
,
20k

where the second inequality follows since (1−ε′ )·f (OP T ) ≤ τ̂ . Combining this with the observation
that Algorithm 3 selects ui only if ∂¯uτ̂ i F x̃ ∧ 1{u1 ,u2 ,...,ui−1 } ≥ cτ̂ /k, we get
n 
X



ε′
τ̂
¯
x̃ui · ∂ui F x̃ ∧ 1{u1 ,u2 ,...,ui−1 } − τ̂ ·
F (x̃) ≥ F (1∅ ) +
20k
i=j


 X



n
c
c
ε′
ε′
ε′
x̃ui = F (1∅ ) + τ̂ ·
−
−
≥ F (1∅ ) + τ̂ ·
·
· kx̃k1 ≥ τ̂ · c −
,
k 20k
k 20k
20


i=j

where the last equality holds since x̃ contains a zero fraction of every element arriving before uj
by the definition of j, and the last inequality follows since F is non-negative and we assumed that
kx̃k1 = k.
Next, we bound in the following lemma the value of F (x̃) when kx̃k1 < k. To prove this lemma
we use the same steps used above to derive Corollary 3.6. Note that the bound we get here on
F (x̃) is equal up to a small error term to the bound in this corollary.
h
Lemma D.6. Assuming E holds, if kx̃k1 < k, then F (x̃) ≥ (1 − p) · p · f (OP T ) + (1 − p) · f OP T \
i
supp(x̃) − τ̂ · (c + ε′ /20).
Proof. As done in the proofs of Lemmata 3.4 and 3.5 (which were used to prove Corollary 3.6), we
find lower and upper bounds for F (x̃ + 1OP T \supp(x̃) ). Since Algorithms 1 and 3 both handle the
scenario of an arriving element getting past the threshold for acceptance similarly, Observation 3.1
and Lemma 3.4 apply to x̃. Thus,



F x̃ + 1OP T \supp(x̃) ≥ (1 − p) · p · f (OP T ) + (1 − p) · f OP T \ supp(x̃) .
(2)

Moreover, for every element ui ∈ OP T \ supp(x̃) it holds that, if i < j, then ∂ui F (x̃) ≤ ∂ui F (x̃ ∧
1u1 ,u2 ,...,ui−1 ) < cτ̂ /k by the definition of j, and if i ≥ j, then
∂ui F (x̃) − τ̂ ·

ε′
ε′ (1 − ε′ )
cτ̂
≤ ∂ui F (x̃) −
· f (OP T ) ≤ ∂¯uτ̂ i F (x̃) <
,
20k
20k
k

where the first inequality follows from the definition of τ̂ , the second inequality follows from the
assumption that the event E happens, and the last inequality follows since the elements in OP T \
supp(x̃) were rejected by Algorithm 3 and f is submodular. The submodularity of f also implies


X

c
ε′
F x̃ + 1OP T \supp(x̃) ≤ F (x̃) +
+
∂u F (x̃) ≤ F (x̃) + |OP T \ supp(x̃)| · τ̂ ·
k 20k
u∈OP T \supp(x̃)


ε′
≤ F (x̃) + τ̂ · c +
,
(3)
20
where the last inequality follows since OP T is a feasible solution, and thus, contains at most k
elements. The lemma now follows by combining Inequalities (2) and (3).
20

The following lemma is obtained by combining the results of the previous two. This lemma
corresponds to Lemma 3.7 from the analysis of Algorithm 1.
h
n
o
i



α(1−p−c)
ε′
Lemma D.7. Assuming E holds, E max f (S1τ̂ ), f (S2τ̂ ) ≥ τ̂ · min c, α+(1−p)
− 20
. In par2
i
h



′
α(1−p)
α(1−p)
ε
.
ticular, for c = 2α+(1−p)2 we get E max f (S1τ̂ ), f (S2τ̂ ) ≥ τ̂ · 2α+(1−p)2 − 20

Proof. If kx̃k1 = k, then by the definition of S1τ̂
h

E max

n

oi

f (S1τ̂ ), f (S2τ̂ )

≥E

h

i

f (S1τ̂ )

ε′
≥ F (x̃) ≥ τ̂ · c −
20




,

(4)

kx̃k1 < k, note that
where the last inequality follows from Lemma D.5. To address the case

 in which
OP T ∩supp(x̃) is a feasible solution within the support of x̃. Thus, E f (S2τ̂ ) ≥ α·f (OP T ∩supp(x̃))
by the definition of S2τ̂ . Therefore, since no convex combination of two values is higher than their
maximum, Lemma D.6 yields
E[max{f (S1 ), f (S2 )}] ≥ max{E[f (S1 )], E[f (S2 )]}





ε′
≥ max (1 − p) · p · f (OP T ) + (1 − p) · f (OP T \ supp(x̃)) − τ̂ c +
,
20

α · f (OP T ∩ supp(x̃))



ε′
α
· (1 − p) · [p · f (OP T ) + (1 − p) · f (OP T \ supp(x̃))] − τ̂ c +
≥
α + (1 − p)2
20
2
(1 − p)
+
· α · f (OP T ∩ supp(x̃)) .
α + (1 − p)2
Observe that the rightmost side in the above inequality is equal to
h

2
α
p(1
−
p)
·
f
(OP
T
)
−
τ̂
c+
α(1 − p)
·
[f
(OP
T
∩
supp(x̃))
+
f
(OP
T
\
supp(x̃))]
+
α + (1 − p)2
α + (1 − p)2

ε′
20

i

.

Moreover, since f is submodular and non-negative, it holds that f (OP T ∩ supp(x̃)) + f (OP T \
supp(x̃)) ≥ f (OP T ) ≥ τ̂ . Therefore, by combining all the above, we get
 i
h

ε′
α
p(1
−
p)
·
τ̂
−
c
+
2
20 τ̂
α(1 − p)
·
τ̂
+
E[max{f (S1 ), f (S2 )}] ≥
α + (1 − p)2
α + (1 − p)2


′
ε


α 1 − p − c − 20
α(1 − p − c)
ε′
= τ̂ ·
≥ τ̂ ·
−
.
(5)
α + (1 − p)2
α + (1 − p)2 20
The first part of the lemma now follows from Inequalities (4) and (5). To prove the second part,
α(1−p−c)
α(1−p)
note that in the proof of Lemma 3.7 we have shown that setting c = 2α+(1−p)
2 in α+(1−p)2 yields
c=

α(1−p−c)
.
α+(1−p)2

Hence, when the parameter c is set as above,
c−

α(1 − p − c)
α(1 − p)
ε′
ε′
ε′
=
=
.
−
−
20
α + (1 − p)2 20
2α + (1 − p)2 20

We are now ready to prove Theorem 1.2.
21

Proof of Theorem 1.2. In the proof of Theorem 3.10, we have discussed an algorithm by Buchbinder
et al. [7] for the offline version of our problem, and described the approximation ratio of this
algorithm for instances in which the size of the ground set is upper bounded by ⌈k/p⌉. In particular,
we showed that for p = 0.24 this algorithm can find a solution whose expected value is at least
a 0.460675 fraction of the optimal value. Thus, it is possible to implement Algorithm 3 with
α(1−p)
′
−4 . By Lemma D.7, conditioned on the event E,
α = 0.460675, p = 0.24, c = 2α+(1−p)
2 and ε = 10
the expected value of the output set T of such an implementation is at least




0.460675 · (1 − 0.24)
ε′
α(1 − p)
−
− 0.000005
≥ 0.9999 · f (OP T ) ·
E[f (T )] ≥ τ̂ ·
2α + (1 − p)2 20
2 · 0.460675 + (1 − 0.24)2


0.350113
≥ f (OP T ) ·
− 0.000005 ≥ 0.233567 · f (OP T ) .
1.49895
Using the low of total expectation, we now get


E[f (T )] = Pr[E] · E[f (T ) | E] + Pr[Ē] · E f (T ) | Ē ≥ Pr[E] · E[f (T ) | E]


ε′
f (OP T )
≥ 1−
,
· E[f (T ) | E] ≥ 0.999995 · 0.233567 · f (OP T ) ≥
20
4.282
where the first inequality holds by the non-negativity of f and the second inequality follows from
Corollary D.4. This shows that the above mentioned implementation of Algorithm 3 achieves the
approximation guarantee of Theorem 1.2.
To complete the proof of the theorem, it remains to observe that, for the above specified values
for the parameters p, ε′ and c, Lemma D.1 shows that Algorithm 3 obeys the space complexity
guarantees of Theorem 1.2 because the algorithm for calculating S2τ requires only poly(1/ε′ ) · Õ(k)
space (as explained in the proof of Theorem 3.10).

22

