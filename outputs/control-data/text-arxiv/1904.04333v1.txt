Polynomial Invariant Theory and Shape Enumerator of Self-Dual Codes
in the NRT-Metric
Welington Santos ∗ Marcelo Muniz Silva Alves †

arXiv:1904.04333v1 [cs.IT] 8 Apr 2019

Abstract
In this paper we consider self-dual NRT-codes, that is, self-dual codes in the metric space endowed with the
Niederreiter-Rosenbloom-Tsfasman (NRT-metric). We use polynomial invariant theory to describe the shape
enumerator [13] of a binary self-dual, doubly even self-dual, and doubly-doubly even self dual NRT-code C ⊆
Mn,2 (F2 ). Motivated by these results we describe the number of invariant polinomials that we must find to
describe the shape enumerator of a self-dual NRT-code of Mn,s (F2 ). We define the ordered flip of a matrix
A ∈ Mk,ns (Fq ) and present some constructions of self-dual NRT-codes over Fq . We further give an application
of ordered flip to the classification of bidimensional self-dual NRT-codes.

1

Introduction

In classical coding theory, an [n, k]-linear code C is a subspace of the metric space Fsq , endowed with the Hamming
metric, which is defined by dH (u, v) := |{i such that ui 6= vi }| for u, v ∈ C ⊆ Fsq . An important tool in this
setting is the dual code C ⊥ of a linear code C ⊆ Fsq with respect to usual (euclidean) inner product on Fsq .
One of the most important theorems in coding theory is MacWilliams’ Theorem (1962), which is known as the
“MacWilliams Identities”, which relates the weight enumerator of a linear code and its dual code. A remarkable
theorem that is due to Gleason [17] shows that the weight enumerator of a binary doubly-even self-dual code is
a polynomial in others two polynomials, to name, the weight enumerator of the Hamming code of length 8 and
the Golay code of length 24. During the past few years Sloane et al. presented some generalizations of Gleason’s
Theorem to other families of codes [8, 18, 20, 21]. A technique that can be used to derive those generalizations is
the polynomial invariant theory, and in special the well-known Molien’s series of a finite group of matrices [7].
Coding theory has also been developed with respect to alternative metrics. One of the most studied of those
metrics is the NRT-metric, which was introduced to study array codes that are subspaces of the linear space of all
n × s matrices Mn,s (Fq ) with entries from a finite field. The NRT-metric space was introduced by Rosenbloom
and Tsfasman in [27] by considering a generalization of Reed-Solomon codes on the space of all n × s matrices
Mn,s (Fq ); in this same paper the authors pointed out that this metric models transmission over a set of parallel
channels subject to fading. Since then several coding-theoretic questions with respect to this metric have been
investigated, such as MacWilliams Identities [9] and MDS codes [9, 11, 28]. Independently, Niederreiter [10]
worked with a maximization problem in finite vector spaces which turned out to be equivalent to coding theory
problems in NRT spaces, as was shown by Brualdi, Graves and Lawrence [6].
Dougherty and Skriganov showed in [9] that the weight enumerators of mutually NRT-dual codes may not
be related by any sort of MacWilliams Identities, in general, since there are examples of nonequivalent codes
which have the same weight enumerators but whose duals have distinct weight enumerators. However, in the same
paper they considered orbits of linear groups preserving the NRT-weight and showed that the weight enumerator
∗
W. Santos is with the Programa de Pós-Graduação em Matemática, Universidade Federal do Paraná, Caixa Postal 19081, 81531990, Curitiba-PR Brazil. His study was financed in part by the Coordenação de Aperfeiçoamento de Pessoal de Nível Superior- Brasil
(CAPES)-Finance Code 001. Email: wsantos.math@gmail.com
†
Marcelo Muniz S. Alves is with the Departamento de Matemática, Universidade Federal do Paraná, Caixa Postal 19081, 81531-990,
Curitiba-PR Brazil. This work was partially supported by CNPq-Conselho Nacional de Desenvolvimento Científico e Tecnológico, research
project number 306583/2016-0. Email: marcelomsa@ufpr.br

1

associated with such orbits (called H-enumerator) satisfies a MacWilliams type identity for mutually NRT-dual
codes.
Recently, Barg et al. [2, 4, 12, 13] introduced the definition of shapes of codewords and a shape enumerator
for NRT-codes. The shape enumerator coincides with the H-enumerator. Park and Barg in [13] obtained the
same MacWilliams Identity of [9] with a new proof based on a multivariate Tutte polynomial of a NRT-code and
centered in the concept of shape of a codeword.
In this contribution, we consider binary self-dual codes of Mn,s (F2 ), and we use polynomial invariant theory
and the MacWilliams Identity of [9, 13] to describe the shape enumerator of those codes. In particular, for binary
self-dual codes of Mn,2 (F2 ) we completely describe their shape enumerator; the same is done for binary doublyeven self-dual codes, and for binary doubly-doubly-even self dual codes of Mn,2 (F2 ). We describe the number of
invariant polinomials that we must find to describe the shape enumerator of a self-dual NRT-code of Mn,2 (F2 ). We
define the concept of ordered flip of a matrix A ∈ Mk,ns (Fq ) and present some constructions of self-dual codes
of Mn,s (Fq ) extending results for M1,s (Fq ) of [22]. Finally, we present an application of the ordered flip to the
classification of bidimensional self-dual codes.
This work is strutured as follows. In Sect. 2, we recall NRT-codes, the shape enumerator and the MacWilliams
Identity of [9, 13]. In Sect. 3, we recall polynomial invariant theory and Molien’s Theorem [19, 23, 30]. In Sect.
4, we describe the shape enumerator of binary self-dual, doubly even self-dual, and doubly-doubly even self dual
NRT-codes of Mn,2 (F2 ). In Sect. 5, we describe the Molien’s series of the invariant group of binary self-dual
NRT-codes of Mn,s (Fq ). In Sect. 6, we give some constructions of self-dual NRT-codes of Mn,s (Fq ) and an
application of the flip concept.

2

Codes and Niederreiter-Rosenbloom-Tsfasman Metric

Let Mn,s (Fq ) be the Fq -vector space of n × s matrices with entries in Fq . Given an n × s matrix v,


v11 v12 · · · v1s
 v21 v22 · · · v2s 


v= .
..  ,
..
..
 ..
.
. 
.
vn1 vn2 · · ·

vns

its i-th row will be denoted by vi and we will write v = [v1 ; v2 ; · · · ; vn ]. Via this notation the NiederreiterRosenbloom-Tsfasman weight or, for short, the NRT-weigth of v is defined by the following formula:
ρ(v) :=

n
X

ρ(vi )

i=1

where ρ(vi ) := max {0 ≤ j ≤ s ; vij 6= 0}.
The canonical metric associated to the NRT- weight, dρ (u, v) = ρ(u − v), is called the NRT-metric.
Now let v = [v1 ; v2 ; · · · ; vn ] and u = [u1 ; u2 ; · · · ; un ] be two elements of Mn,s (Fq ). We define the inner
product h, iN on the space Mn,s (Fq ) endowed with the NRT-metric by
hv, uiN = hu, viN :=

n
X

hvi , ui iN

i=1

with
hvi , ui iN = hui , vi iN := vi1 uis + vi2 uis−1 + . . . + vs−12 ui2 + vis ui1 =

s
X

vij uis+1−j .

j=1

The space (Mns (Fq ), ρ) is called NRT-space and an [ns, k]-linear NRT-code is a linear subspace C ⊆ (Mns (Fq ), ρ)
of dimension k.

2

Definition 1. The dual code of an k-dimensional linear NRT-code C ⊆ Mn,s (Fq ) is defined to be the k⊥ dimensional linear NRT-code C ⊥ ⊆ Mn,s (Fq ) given by
C ⊥ := {u ∈ Mn,s (Fq ) : hu, viN = 0 for all v ∈ C}.
A NRT-code C is said to be a self-orthogonal NRT-code if C ⊆ C ⊥ and self dual NRT-code if C = C ⊥ . Moreover,
the dimensions of the codes C and C ⊥ are related by the following equation: if k = dim(C) and k⊥ = dim(C ⊥ )
then
k + k⊥ = ns.
(2.1)

2.1

The Geometry of NRT-metric

Two NRT linear codes C and C ′ in Mn,s (Fq ) are equivalent if there is a linear isometry φ of Mn,s (Fq ) such that
φ(C) = C ′ . The group GL (Mn,s (Fq )) of linear isometries of an NRT space Mn,s (Fq ) was described in [3] (also
independently in [9]) and is isomorphic to the semidirect product of (Ts )n and Sn , where Ts is the group of all upper triangular matrices of Ms,s (Fq ) with non-zero diagonal elements, (Ts )n denotes the direct product of n copies
of Ts , and Sn is the symmetric group of order n. An element of Sn acts on v = [v1 ; v2 ; · · · ; vn ] by permuting
rows, and an element (M1 , M2 , . . . , Mn ) of Tsn sends v = [v1 ; v2 ; · · · ; vn ] to [v1 M1T ; v2 MnT ; · · · ; vn MnT ].
It is clear that if v = [v1 ; v2 ; · · · ; vn ] and u = [u1 ; u2 ; · · · ; un ] are two elements of Mn,s (Fq ) that lie in the
same GL (Mn,s (Fq ))-orbit then these matrices have the same NRT-weight. The converse will not hold in general,
since GL(Mn,s (Fq )) is not transitive on spheres. In order to parametrize the GL(Mn,s (Fq ))-orbits, which were
already studied in [9], Barg and Purkayastha [2] define a new parameter of the matrix v = [v1 ; v2 ; · · · ; vn ] ∈
Mn,s (Fq ) which is called the shape of v.
Definition 2. Let v ∈ Mn,s (Fq ) be a matrix written as v = [v1 ; v2 ; · · · ; vn ], where vi = (vi1 , . . . , vis ) for
i = 1, . . . , n. The shape of v with respect to the NRT-weight is an s-vector e = (e1 , . . . , es ), where
ej = |{i such that 1 6 i 6 n and ρ(vi ) = j}|.
P
Also define e0 := n − |e|, where |e| := sj=1 ej .

The action of GL(Mn,s (Fq )) on matrices of a fixed shape is transitive, and then the shape is an invariant for
this action. The NRT- weight can be also defined in terms of shapes: if e = (e1 , . . . , es ) is the shape of the matrix
v = [v1 ; v2 ; · · · ; vn ] ∈ Mn,s (Fq ) then
ρ(v) :=

s
X

jej .

j=1

2.2

The shape enumerator and a MacWilliams Identity

The NRT weight is a special case of poset weight as introduced by Brualdi, Graves and Lawrence in [6]. There is
a notion of dual code for every poset code but only in rare cases does the weight enumerator of the code determine
the enumerator of its dual; precisely, this is the case if and only if the poset is hierarchical [16], and an NRT weight
is associated to a hierarchical poset only when n = 1 or s = 1 (which corresponds to the Hamming weight).
Nevertheless, analogues of those identities do hold when one considers other kinds of enumerator polynomials. In
[9], Dougherty and Skriganov defined a generalized weight enumerator for a NRT-linear code, the H-enumerator,
which counts the number of codewords in each GL(Mn,s (Fq ))-orbit. In the same paper it was shown that the Henumerator of mutually dual codes satisfies a MacWilliams-type identity, which we will state next in the version
presented in [13], using the concept of shape vector.
A shape vector e defines a partition of n into a sum of s + 1 parts. We will denote by ∆s,n := {e ∈ Ns :
e0 + e1 + e2 + . . . + es 6 n} such partitions (recall that e0 = n − |e|). In the language of shapes, the description
of GL(Mn,s (Fq ))-orbits is as follows
Proposition 3. ([9], Proposition 2.2 (ii)) The GL(Mn,s (Fq ))-orbits of a nonzero matrix u ∈ Mn,s (Fq ) is the set
of all vectors v ∈ Mn,s (Fq ) which have the same shape as u.
3

Definition 4. Let C ⊆ Mn,s (Fq ) be a NRT-linear code. The shape enumerator of C is the polynomial of
C[z0 , z1 , . . . , zs ] defined by
X
(2.2)
Ae z0e0 z1e2 . . . zses ,
HC (z0 , z1 , . . . , zs ) =
e∈∆s,n

where Ae = |{v ∈ C such that shape(v) = e}|.
The shape enumerator of a NRT-code C is a homogeneous polynomial HC (Z) with s + 1 variables which
coincides with the H-enumerator introduced in [9]. In order to state the MacWilliams identity shown in [9] we
need to introduce new notation.
The group GL(s + 1, C) of invertible (s + 1) × (s + 1) matrices acts on the ring C[z0 , z1 , . . . , zs ] by


s
s
X
X
as,j zj  .
A · f (z0 , z1 , . . . , zs ) = f 
a0,j zj , . . . ,
(2.3)
j=0

j=0

We may describe the action in a more concise manner. Consider the “vector of variables” Z = (z0 , z1 , . . . , zs )t .
The previous equation may be rewritten as
A · f (Z) = f (AZ).
Using this notation, the next result presents the MacWilliams identity for the shape enumerator.
Theorem 5. [13] The shape enumerator of mutually dual NRT-linear codes C and C ⊥ ⊆ Mn,s (Fq ) are related
by
1
HC (Θs Z),
HC ⊥ (Z) =
|C|
where Θs = (θlk ) ∈ Ms+1,s+1 (Fq ) , 0 6 l, k 6 s, has the following entries

1
if l = 0,


 l−1
q (q − 1) if 0 < l 6 s − k,
.
θlk =
−q l−1
if l + k = s + 1,



0
if l + k > s + 1.

3

3.1

Polynomial Invariant Theory

Invariant Homogeneous Polynomial Basis

Let G be a finite subgroup of GL(n, C) and consider its action on the polynomial ring C[x1 , . . . , xn ] defined as in
(2.3).
We recall that f (x1 , . . . , xn ) is called an invariant of G, or a G-invariant, if for every A ∈ G
A · f (x1 , . . . , xn ) = f (x1 , . . . , xn ).
Clearly if f , g are invariants of G so are f + g and f g, it means that the set of invariants form a ring which
will be denoted by J (G).
It is well-known that every invariant polynomial can be written as a sum of homogeneous invariant polynomials. So given a finite group G < Mn,n (C) it is enought to characterize all homogeneous polynomials that are
invariant over G to describe the invariant ring J (G) of G.
However, a convenient description of J (G) is a set of homogeneous invariants B = {f1 , . . . , fl } such that
every polynomial in J (G) is a polynomial in f1 , . . . , fl . Then in this case B = {f1 , . . . , fl } is called a polynomial
basis for J (G). If l > n there will be equations, which are called syzygies, relating f1 , . . . , fl .
A finite polynomial basis of J (G) always exists when G is finite, this was shown by E. Noether’s Theorem
[18, 29, 30]. Find invariant polynomials is fairly easy using the following theorem.
4

Theorem 6. (Reynolds operator) Let f ∈ C[x1 , . . . , xn ] be a polynomial and G < GL(n, C) a finite group. Then
X
h(x1 , . . . , xn ) =
A · f (x1 , . . . , xn )
A∈G

is an invariant of G, that is, h ∈ J (G).
Definition 7. Given a finite group G < GL(n, C), a good polynomial basis for J (G) consists of homogeneous
invariants f1 , . . . , fl (l ≥ n) such that f1 , . . . fn are algebraically independent and
J (G) = C[f1 , . . . , fn ]

if

l = n,

or, if l > n,
J (G) = C[f1 , . . . , fn ] ⊕ fn+1 C[f1 , . . . , fn ] ⊕ · · · ⊕ fl C[f1 , . . . , fn ].
This means that when l = n any G-invariant can be written as a polynomial in f1 , . . . , fn and, if l > n, as such
a polynomial plus fn+1 times another such polynomial and so on. The polynomials f1 , . . . , fn are called primary
invariants and fn+1 , . . . , fl are secondary invariants.
Theorem 8. (Hochster and Eagon [23]) A good polynomial basis exists for the invariants of any finite group of
complex n × n matrices.
There are some criteria in literature that help to find out when a set of polynomials is algebraically independent.
In this work we use a useful tool that is know as the Jacobian criterion.
Theorem 9. (Jacobian criterion [14, 15]) f1 , . . . , fl ∈ C[x1 , . . . , xn ] are algebraically independent if only if the
Jacobian matrix is full rank. In particular, if m = n, f1 , . . . , fl are algebraically dependent if only if the Jacobian
determinant det(J(f1 , . . . , fl )) 6= 0.

3.2

Molien’s Theorem

A fundamental problem is to know, or at least estimate, how many algebraically independent invariants are required
to form a polynomial basis of J (G). The next two theorems tell us how many linearly independent homogeneous
invariants exist for each degree t.
Theorem 10. (Molien [7]) Given a finite group G < GL(n, C) the number of linearly independent invariants
over G of the first degree is
1 X
trace(A).
|G|
A∈G

Theorem 11. (Molien [7]) Let G < GL(n, C) be a finite group. Then, the number of linearly independent
invariants of G of degree t is the coefficient of λt in the expansion of
1
1 X
.
ΦG (λ) =
|G|
det(I − λA)
A∈G

ΦG (λ) is called the Molien series of G.
The Molien series of a finite group G < GL(n, C) can be written as
ΦG (λ) =

det(A)
1 X
.
|G|
det(A − λI)
A∈G

Another important fact about the Molien series of a finite group G < GL(n, C) is that it can be written down
by inspection from the degrees of a good polynomial basis, that is, if B = {f1 , . . . , fl } is a good polynomial basis
of J (G) such that d1 = deg f1 , . . . , dl = deg fl then the Molien series of G can be written as
1
,
di
1 (1 − λ )

ΦG (λ) = Qn

5

if

l = n,

(3.1)

or
1+
ΦG (λ) = Qn

Pn

i=1

dj
j=l+1 λ
(1 − λdi )

if

l > n.

(3.2)

On the other hand, the converse is not true. It is not always true when the Molien series has been put into the
forms (3.1) or (3.2) then a good polynomial basis for J (G) can be found with degrees matching the powers of λ
in Φ(λ). This was shown by an example, due to Stanley [30, Ex 3.8].

4

Invariant Theory and the shape enumerator

In this section, we investigate the shape enumerator HC of binary self-dual NRT-code C ⊆ Mn,s (F2 ).

4.1

Invariant Ring for Self-dual NRT-Codes of Mn,2 (F2 )

We know from Theorem 5 that the shape enumerators of mutually dual linear codes C and C ⊥ ⊆ Mn,2 (Fq ) are
related by the equation
1
(4.1)
HC ⊥ (Z) = d HC (Θ2 Z),
2
where


1
1
2
Θ2 =  1
1 −2  .
1 −1
0

If we assume that C is a linear self-dual NRT-code of dimension k, that is, C = C ⊥ and k = k⊥ , then we
conclude that k = n, so Equation (4.1) can be rewritten as
HC (Z) =

1
HC (Θ2 Z).
2n

Since by definition HC (Z) is a homogeneous polynomial of degree n, the last expression for HC (Z) may be
rewritten as


Θ2
Z ,
HC (Z) = HC
2
2
which means that the polynomial HC is invariant by T = Θ22 . Moreover, as T 2 = Θ22
= I3 , the shape
enumerator HC is an element of J (G1 ) where G1 is the finite group of order 2 generated by T , G1 = hT i =
{I, T }. We will try construct a good polynomial basis for J (G1 ).
From Molien’s Theorem the number of algebraically independent invariants of degree t over the group G1 is
equal to the coefficient of λt in
ΦG1 (λ) =

det(A)
1 X
.
2
det(A − λI3 )
A∈G1

Let’s calculate ΦG1 (λ). First note that
T :=
So the Molien’s series of G1 is given by
ΦG1 (λ) =



Θ2 
=
2

1
2
1
2
1
2

1
2
1
2
− 21


1
−1  .
0

(4.2)

1 X
det(A)
1
=
.
2
2
det(A − λI3 )
(1 − λ) (1 − λ2 )
A∈G1

It means that to find a good polynomial basis for G1 we should look for one invariant of degree two and two
invariants of degree one.
6

Since the shape enumerator of any NRT-code C ⊆ Mn,2 (F2 ) has degree n, we will start looking for shape
enumerators of self-dual NRT-codes in M1,2 (F2 ) = {(0, 0), (1, 0), (0, 1), (1, 1)}. In M1,2 (F2 ) there exist just five
linear codes, namely: The trivial codes C0 := {(0, 0)}, C4 := M1,2 (F2 ) and the non-trivial codes:
C1,1 := {(0, 0), (0, 1)};
C1,2 := {(0, 0), (1, 0)};
C1,3 := {(0, 0), (1, 1)};
It is clear that all except the trivial codes are self-dual codes, and their shape enumerators are
HC1,1 (z0 , z1 , z2 ) = z0 + z2 ;
HC1,2 (z0 , z1 , z2 ) = z0 + z1 ;
HC1,3 (z0 , z1 , z2 ) = z0 + z2 .
Note that HC1,2 (z0 , z1 , z2 ) = HC1,3 (z0 , z1 , z2 ) and this was already expected once that there exists a linear
isometry between C1,2 and C1,3 . We choose φ1 (z0 , z1 , z2 ) = z0 + z2 and φ2 (z0 , z1 , z2 ) = z0 + z1 ; it is obvious
that φ1 , φ2 are algebraically independent and invariant under G1 .
Now to find an invariant polynomial of degree two we will consider a self-dual NRT-code in M2,2 (F2 ) and
compute its shape enumerator. Let

 
 
 

0 0
1 0
0 1
1 1
C2,1 :=
,
,
,
.
0 0
1 0
0 1
1 1
C2,1 is a self-dual code and its shape enumerator is HC2,1 (z0 , z1 , z2 ) = z02 + z12 + 2z22 . Define φ3 (z0 , z1 , z3 ) =
z02 + z12 + 2z22 , so φ3 (z0 , z1 , z3 ) is invariant under G1 . Moreover, applying Theorem 9, we can check that the set
{φ1 , φ2 , φ3 } is algebraically independent. In short, we just proved the following theorem.
Theorem 12. Let C ⊆ Mn,2 (F2 ) be a self-dual NRT-code. Then, the shape enumerator of C is an invariant
polynomial under the action of G1 = hT i where T is the matrix given in (4.2). Moreover, the invariant ring of
the group G1 is C[φ1 , φ2 , φ3 ] where φ1 (z0 , z1 , z2 ) = z0 + z2 , φ2 (z0 , z1 , z2 ) = z0 + z1 , and φ3 (z0 , z1 , z2 ) =
z02 + z12 + 2z22 .
In words, Theorem 12 means that the shape enumerator of any linear self-dual NRT-code C ⊆ M atn,2 (F2 ) is a
polynomial in φ1 , φ2 and φ3 .

4.2

Invariant Ring for Doubly-Even Self-Dual NRT-Codes of Mn,2 (F2 )

Let now C ⊆ Mn,2 (F2 ) be a doubly-even self-dual NRT-code, i.e., a self-dual NRT-code C whose every codeword
has even weight. From the definition of shape enumerator of C it follows that HC (z0 , z1 , z2 ) ∈ C[z0 , z1 , z2 ] is
such that z1 has always even degree. So in this case
HC (z0 , z1 , z2 ) = HC (z0 , −z1 , z2 ).
Thats is, the polynomial HC is invariant by



1
0 0
A :=  0 −1 0  .
0
0 1

Since C is a self-dual NRT-code, we already know that HC is invariant by the matrix T given in (4.2). Finally,
the shape enumerator of C is invariant under the group G2 := hT, Ai. It is possible to check that
G2 = {I, A, T, AT, T A, T AT }
7

(4.3)

and the order of G2 is g = 6. The Molien’s series of G2 is given by
Φ(λ) =

det(A)
1
1 X
=
.
6
det(A − λI3 )
(1 − λ)(1 − λ2 )(1 − λ3 )
A∈G2

It suggests that we should search for one invariant of degree one, one invariant of degree two and one invariant
of degree three in order to determine a polynomial basis of invariants. The code C1,1 = {(0, 0), (0, 1)} is such that
C1,1 is a self-dual NRT-code and all its codewords has even weight. Moreover, HC1,1 (z0 , z1 , z2 ) = z0 + z2 is a
G2 -invariant. Now consider C2,2 ⊆ M2,2 (F2 ) given by

 
 
 

0 0
1 0
0 1
1 1
C2,2 =
,
,
,
.
0 0
1 0
0 1
1 1

C2,2 is a self-dual NRT-code and all its codewords have even weight. Furthermore, the shape enumerator of C2,2
is the polynomial HC2 (z0 , z1 , z2 ) = z02 + z12 + 2z22 which is, of course, an invariant polynomial of the group
G2 . Putting p1 and p2 as p1 (z0 , z1 , z2 ) = z0 + z2 and p2 (z0 , z1 , z2 ) = z02 + z12 + 2z22 we have an algebraically
independent set {p1 , p2 }. So, we just need do find another polynomial p3 (z0 , z1 , z2 ) such that p3 is algebraically
independent of p1 and p2 .
Define C3,3 ⊆ M3,2 (F2 ) by

 
 
 
 
 
 
 

0 0
1 1
1 0
1 1
0 1
1 0
0 1 
 0 0
C3,3 :=  0 0  ,  1 0  ,  1 1  ,  0 0  ,  0 1  ,  1 1  ,  1 0  ,  0 1 


0 0
1 0
0 1
1 0
1 1
1 1
0 0
0 1

C3,3 is a self-dual NRT-code and all its codewords has even weight. Moreover, the shape enumerator of C3,3
is the polynomial HC3,3 (z0 , z1 , z2 ) = z03 + 4z23 + 3z12 z0 that is invariant under G2 . Defining p3 (z0 , z1 , z2 ) =
HC3,3 (z0 , z1 , z2 ) the {p1 , p2 , p3 } is algebraically independent by Theorem 9.
Summing up, we have just proved the following.

Theorem 13. Let C ⊆ Mn,2 (F2 ) be a self-dual NRT-code such that all its codewords has even weight. Then, the
shape enumerator of C is an invariant polynomial for the group G2 given in (4.3). Moreover, the invariant ring
of G2 is C[p1 , p2 , p3 ] where the polynomials p1 , p2 and p3 are given by p1 (z0 , z1 , z2 ) = z0 + z2 , p2 (z0 , z1 , z2 ) =
z02 + z12 + 2z22 , and p3 (z0 , z1 , z2 ) = z03 + 4z23 + 3z12 z0 .
In other words, if C ⊆ Mn,2 (F2 ) is a self-dual NRT-code whose codewords has even weight then its shape
enumerator is a polynomial in p1 , p2 and p3 .

4.3

Invariant Ring for Doubly-Doubly-Even Self-Dual NRT-Codes of Mn,2 (F2 )

Let C ⊆ Mn,2 (F2 ) be a self-dual NRT-code whose every codeword has an even number of rows with weight one
and an even number of rows with weight two. In this case, by definition of shape enumerator, HC (z0 , z1 , z2 ) is
such that z1 and z2 are always of degree even, therefore, it is true that HC (z0 , z1 , z2 ) = HC (z0 , −z1 , −z2 ). This
implies that HC (z0 , z1 , z2 ) the shape enumerator of C is invariant under the action of the matrix


1
0
0
B :=  0 −1
0 .
0
0 −1
Since C is a self-dual NRT-code it follows also that HC is invariant by the matrix T defined in (4.2), and therefore
the polynomial HC is invariant under the action of the group
G3 := hT, Bi.
We can check that G3 = {I, B, T, BT, T B, T BT, BT B, (BT )2 , (T B)2 , (T B)3 , B(T B)2 , (T B)2 T } and
1 X
trace(Ai ) = 0.
|G3 |
Ai ∈G3

8

(4.4)

Therefore, Theorem 10 assure us that there are no G3 -invariants of degree one. We can write the Molien’s series
of G3 as


12 + 12λ4
1
ΦG3 (λ) =
12 (1 − λ2 )2 (1 − λ6 )
1
λ4
=
+
,
(1 − λ2 )2 (1 − λ6 ) (1 − λ2 )2 (1 − λ6 )
which suggests that in order obtain a good polynomial basis for J (G3 ) we should search for three primary invariants φ1 , φ2 and φ3 of degree 2, 2, 6 respectively and one secondary invariant φ4 of degree 4.
Unfortunately, there exists only one linear code C ⊆ M2,2 (F2 ) such that the required properties are satisfied,
namely C2,2 of the previous section, so we can take φ1 as φ1 (z0 , z1 , z2 ) = z02 + z12 + 2z22 . By averaging z02 under
the group G3 , using the Theorem 6, we obtain the invariant φ2 (z0 , z1 , z2 ) = 5z02 − 2z0 z1 + z12 + 8z22 + 8z2 z1 .
Now, we will work to find an invariant of degree six. Averaging z1 z2 over the group G3 , using Theorem 6,
we obtain an homogeneous invariant φ⋆3 of degree two, namely φ⋆3 (z0 , z1 , z2 ) = 2z02 − 2z12 + 8z1 z2 . The set
{φ1 , φ2 , φ⋆3 } is algebraically independent. Let φ3 ∈ C[z0 , z1 , z2 ] be the polynomial given by φ3 = (φ⋆3 )3 , so
deg φ3 = 6 and {φ1 , φ2 , φ3 } is algebraically independent since {φ1 , φ2 , φ⋆3 } is algebraically independent. We can
use Magma Computer Algebra program [31] to find the secondary invariant φ4 .
Theorem 14. Let C ⊆ Mn,2 (F2 ) be a self-dual NRT-code such that all its codewords has an even number of rows
with weight one, and an even number of rows with weight two. Then, the shape enumerator of C is an invariant
polynomial for the group G3 given in (4.4). Moreover, the invariant ring of G3 is C[φ1 , φ2 , φ3 ] ⊕ φ4 C[φ1 , φ2 , φ3 ]
where the polynomials φ1 , φ2 and φ3 are φ1 (z0 , z1 , z2 ) = z02 + z12 + 2z22 , φ2 (z0 , z1 , z2 ) = 5z02 − 2z0 z1 + z12 +
2
8z22 + 8z2 z1 , φ3 (z0 , z1 , z2 ) = 2z02 − 2z12 + 8z1 z2 .

5

The General case of Self-dual NRT-Codes of Mn,s (F2)

For the purpose of studying the shape enumerator of a self dual NRT-code C ⊆ Mn,s (F2 ) we will first look closely
at the matrix Θs given in Theorem 5.
Theorem 15. The matrix Θs given by Θs = (θl,k )l,k=0,...,s

1 if



2k−1 if
θl,k :=
−2k−1 if



0 if

where
k = 0,
0 < k 6 s − l,
l + k = s + 1,
l + k > s + 1,

satisfies the following properties:

a) Θ2s = 2s Is+1 ;
 s
2 2 if s is even
b) trace(Θs ) =
;
0
if s is odd
(
s+1 s(s+1)
if s is
(−1) 2 2 2
c) det(Θs ) :=
s s(s+1)
(−1) 2 2 2
if s is

odd

;

even

Proof. Item a) is immediate and also is a fact already noticed in [9]. So we will prove items b) and c).
b) By the definition of Θ we have that trace(Θs ) =

s
X

θii where

i=0






1 if
if
θii :=
i−1 if
−2



0 if
2i−1

9

i=0
0<i6s−i
.
2i = s + 1
2i > s + 1

So for an even s the trace of Θs becomes
s
X

trace(Θs ) =

s

θii = 1 +

2
X

2i−1 + 0

i=1

i=0
s
2

= 2 .

On the other hand, for a odd s the trace of Θs will be
trace(Θs ) =

s
X

s−1

θii = 1 +

i=0

= 1 + (2

2
X

θii + θ s+1 , s+1 +
2

i=1

s−1
2

− 1) − 2

s−1
2

2

s
X

θii

i= s+1
+1
2

+0

= 0,
and we have just proved that
trace(Θs ) =



s

if s
if s

22
0

is even,
is odd.

c) Setting Θ0 = 1 and applying Laplace expansion along the last column of Θs we find that
det(Θs ) = 2s−1 (−1)s det(Θs−1 ) − 2s−1 (−1)s+1 det(Θs−1 ) = 2s (−1)s det(Θs−1 ).

(5.1)

for every s ≥ 1.
This equation yields the two equalities below:
det(Θ2t+2 ) = 22t+2 det(Θ2t+1 ),
2t+1

det(Θ2t+1 ) = −2

det(Θ2t )

(5.2)
(5.3)

for every t ≥ 0. Using (5.2) and (5.3), and taking s = 2t we obtain, by induction on t, that the equality
s

det(Θs ) = (−1) 2 2

s(s+1)
2

(5.4)

holds for any even number s. Now it follows from the previous equation and from (5.3) that
det(Θs ) = (−1)

s+1
2

2

s(s+1)
2

(5.5)

for any odd number s, concluding the proof of c).

Theorem 16. Let mΘs and and PΘs be the minimal and characteristic polynomials respectively of the matrix Θs
s
s
given in Theorem 15. Then mΘs and PΘs are given by mΘs (λ) = (λ − 2 2 )(λ + 2 2 ) and
(
s s+2
s s
(λ − 2 2 ) 2 (λ + 2 2 ) 2
if s is even
pΘs (λ) =
s s+1
s s+1
2
2
2
2
(λ − 2 ) (λ + 2 )
if s is odd
Proof. Item a) of Theorem 15 says that
s

s

0 = Θ2s − 2s Is+1 = (Θs − 2 2 Is+1 )(Θs + 2 2 Is+1 )
s

s

and it follows that mΘs (λ) = (λ−2 2 )(λ+2 2 ) is the minimal polynomial of Θs , since mΘs is a monic polynomial
of degree two such that mΘs (Θs ) = 0 and obviously no polynomial of degree one vanishes on Θs . Therefore the
characteristic polynomial of Θs decomposes as a product
s

s

pΘs (λ) = (λ − 2 2 )r1 (λ + 2 2 )r2 ,
10

(5.6)

s

s

where r1 and r2 are the multiplicities of the eigenvalues β1 = 2 2 and β2 = −2 2 and, in particular, r1 + r2 = s + 1.
From (5.6) it follows that
s
s
(5.7)
trace(Θs ) = r1 (2 2 ) + r2 (−2 2 ),
and therefore for every s ≥ 1 we have the system of equations

 r1 + r2 =
s+1
trace(Θs )
 r1 − r2 =
s
22
If s is an odd number then trace(Θs ) = 0 by item b) of Theorem 15 and, in this case, the above system has
r1 = r2 = s+1
2 as unique solution. Therefore in the case of an odd s the characteristic polynomial of Θs is
s

pΘs (λ) = (λ − 2 2 )

s+1
2

s

(λ + 2 2 )

s+1
2

.

s
2

If s is even then trace(Θs ) = 2 and the corresponding system has solution r1 =
the characteristic polynomial of Θs is
s

We have just proved that pΘs (λ) =

5.1

(

pΘs (λ) = (λ − 2 2 )
s

s+2

s+2
2

s

s

s+2
2 , r2

= 2s . In this case

s

(λ + 2 2 ) 2 .

s

(λ − 2 2 ) 2 (λ + 2 2 ) 2
s s+1
s s+1
(λ − 2 2 ) 2 (λ + 2 2 ) 2

if s
if s

is even
is odd

Self-dual NRT-Codes in Mn,s (F2 ) with odd s

The main purpose of this subsection is to use the properties of the shape enumerator of a self-dual NRT-code
C ⊆ Mn,s (F2 ) and the properties of the matrix Θs to understand how the shape enumerator behaves.
We recall that Theorem 5 says that for a self-dual NRT-code C ⊆ Mn,s (F2 ) its H-enumerator HC satisfies the
equation


Θs
HC (z0 , . . . , zs ) = HC
.
s (z0 , . . . , zs )
22
In polynomial invariant theory language, this is equivalent to saying that HC is invariant by
Θs
s .
22
So HC will be invariant under the group G = hT i. Note also that by item a) of Theorem 15
 2
Θs
Θ2
2
T =
= ss = Is+1 ,
s
2
22
T =

(5.8)

and the group G is given by G = hT i = {Is+1 , T }.
Let us calculate the Molien’s series of G which tells us what kind of invariants we should look for. We can use
the properties c) of Theorem 15 and Theorem 16, since s is odd the Molien’s series of G can be written as
ΦG (λ) =
=
=

=

det(A)
1 X
2
det(A − λIs+1 )
A∈G
"
#
s+1
1
1
(−1) 2
s+1
s+1 +
2 (−1) s+1
(1 − λ)s+1
2 (1 − λ) 2 (1 + λ) 2
(1 − λ)

s+1
2

+ (1 + λ)

s+1
2

s+1

2(1 + λ) 2 (1 − λ)s+1
s+1
s+1
2  s+1 
2  s+1 
X
X
k
2
2
λ +
(−λ)k
k
k
k=0

k=0

2(1 − λ)

s+1
2

(1 − λ2 )
11

s+1
2

.

Consider the subcase of

s+1
2

even, that is,

s+1
2

= 2t for some t ≥ 0. The Molien’s series of G can be rewritten as
2t  
X
2t

2t  
X
2t
λ +
(−λ)k
k
k

k=0

ΦG (λ) =

k

k=0

2(1 − λ)2t (1 − λ2 )2t
t  
X
2t 2l
2
λ
2l
l=0
.
2(1 − λ)2t (1 − λ2 )2t

=
hence in this case

ΦG (λ) =

t  
X
2t
l=0

2l

λ2l

(1 − λ)2t (1 − λ2 )2t

.

(5.9)

Note that the term (1−λ)2t in the denominator indicates that to form a good basis we should look for s+1
2 invariants
of degree one, but by Theorem 10 and item b) of Theorem 15 there are no invariant polynomial under G of degree
one. So we are not using all the information about the shape enumerator of C.
Since the dimension of C is k = ns
2 and s is an odd number we must have n even, which implies that HC will
be invariant by −I, so HC is invariant under the action of the group
G1 := {−I, I, −T, T }.
It is easy to see that the Molien series of G1 can be written as
ΦG1 (λ) =

1
(ΦG (λ) + ΦG (−λ))
2

and, so

ΦG1 (λ) =

=

=



t  
X
2t

t  
X
2t





λ2l
λ2l


2l
2l
1

l=0
l=0
+


2  (1 − λ)2t (1 − λ2 )2t
(1 + λ)2t (1 − λ2 )2t 



" t   #
t  
X
2t 2l X 2t 2l
λ 2
λ
2l
2l
1
l=0

2
"

l=0

(1 − λ2 )4t
#2
t  
X
2t 2l
λ
2l
l=0
.
(1 − λ2 )4t

s+1
Now, if we consider the subcase where s+1
2 is odd, 2 = 2t + 1, for some t ≥ 0, then proceeding in the same
way as in the even case one obtains the following expression for the Molien’s series:

ΦG1 (λ) =

"


t 
X
2t + 1
l=0

2l

λ

(1 − λ2 )4t+2

In short, we have proved the following result:

12

2l

#2

.

Theorem 17. Let C ⊆ Mn,s (F2 ) be a self-dual NRT-code and suppose that s is an odd number. The shape
enumerator of C will be an invariant polynomial under the group G1 := {I, −I, T, −T } where T is given by (5.8)
and the Molien’s series of G1 is
 
2
t  

X

2t

2l

 
λ 



2l


l=0

if s+1
2 = 2t, t = 0, 1, . . .
(1−λ2 )4t

.

ΦG1 (λ) =
2


t

X 2t + 1


2l



λ 



2l
 l=0


if s+1
2 = 2t + 1, t = 0, 1, . . .
(1−λ2 )4t+2
Thus, Theorem 17 gives us an expectation of how many algebraically independent invariants we must find to form
a base of invariants for J (G1 ).
Note that in the case s = 1 we have s+1
2 = 1 = 2(0) + 1 and so the Molien’s series of G1 is given by
" 0   #
X 1
λ2l
2l
1
=
,
ΦG1 (λ) = l=0
2
2
(1 − λ )
(1 − λ2 )2

which agrees with [18], where it was shown by MacWilliams et al. that the Hamming weight enumerator of a
binary self-dual code is a polynomial in two polynomials p1 (x, y) and p2 (x, y) where deg p1 = deg p2 = 2. This
fact was expected since the Hamming metric coincides with the NRT-metric in the case where s = 1 and the shape
enumerator is the Hamming weight enumerator.

5.2

Self-dual NRT-Codes in Mn,s (F2 ) with even s

Following the same steps as in the previous subsection we can prove an analogous result for the case of an s even.
Theorem 18. Let C ⊆ Mn,s (F2 ) be a self-dual NRT-code, such that s is an even number. The shape enumerator
of C will be an invariant polynomial under the group G := {I, T } where T is given by (5.8) and the Molien’s
series of G1 is

t  
X

2t 2l


λ



2l

 l=0
if 2s = 2t, t = 1, . . .
(1−λ2 )2t (1−λ)2t+1
ΦG (λ) =
.

t 
X

2t
+
1

2l

λ



2l

 l=0
if s = 2t + 1, t = 0, 1, . . .
(1−λ2 )2t+1 (1−λ)2t+2

2

Theorem 18 gives us an expectation of how many algebraically independent invariants we must find to form a base
of invariants for J (G).
Note that for s = 2 we have 2s = 1 = 2(0) + 1 and, so the Molien’s series of G is given by

ΦG (λ) =

0  
X
1 2l
λ
2l
l=0

(1

− λ2 )(1

−

λ)2

=

1
(1 −

λ2 )(1

− λ)2

,

which matches the result that we found in Section 3.1.

6

Construction of Self-Dual Codes in the NRT-Metric

In this last section we present some constructions of self-dual codes in NRT spaces. The first one utilizes a self-dual
code in Hamming space as its starting point.
13

6.1

Self-Dual Codes in NRT Spaces from Self-Dual codes in Hamming Spaces

Definition 19. Given a vector v = (v1 , . . . , vs−1 , vs ) ∈ Fsq the flip of v, denoted by flip(v), is the vector flip(v) =
(vs , vs−1 , . . . , v1 ) ∈ Fsq .
Remark 20. Let flip : Fsq −→ Fsq be the function taking v ∈ Fsq to its flip. Then
a) For any s ∈ N, flip : Fsq −→ Fsq is a linear operator.
b) If s = 1 then flip ≡ I where I denotes the identity operator.
c) If h, iH is the standard inner product on Fsq and v, u ∈ Fsq , then hflip(v), flip(u)iH = hv, uiH .
In the next theorem we present a construction of a self-orthogonal NRT-code that is derived from a code
C ⊆ Fsq over the Hamming space with the standard inner product h, iH .
Theorem 21. Let C ⊆ Fsq be an [s, k]-linear code over the Hamming space and let C ⊥ its dual code with respect
to the standard inner product. Then, the code Co ⊆ M1,2s (Fq ) given by
Co := {(v, flip(u)) such that v ∈ C and u ∈ C ⊥ }
is a [2s, k + k⊥ ]-self orthogonal code with respect to the NRT-metric where k⊥ = dim(C ⊥ ).
Proof. Indeed, let (v1 , flip(u1 )) , (v2 , flip(u2 )) ∈ Co where v1 , v2 ∈ C and u1 , u2 ∈ C ⊥ . Then
h(v1 , flip(u1 )) , (v2 , flip(u2 ))iN

= hv1 , u2 iH + hflip(u1 ), flip(v2 )iH
= hv1 , u2 iH + hu1 , v2 iH
= 0,

which means that Co ⊆ (Co )⊥ . It’s easy to check that dim Co = k + k⊥ .
Example 22. Let C ⊆ F22 be the [2, 1]-linear code given by C := {(0, 0), (1, 0)} than its dual code C ⊥ is given
by C ⊥ = {(0, 0), (0, 1)} and, the code Co ⊆ M1,4 (F2 ) of Theorem 21 is the following [4, 2]-self orthogonal
NRT-code
Co := {(0, 0, 0, 0), (0, 0, 1, 0), (1, 0, 0, 0), (1, 0, 1, 0)}.
Note that if we consider Co as an [4, 2]-code over the Hamming space F42 , Co is not a self-orthogonal code since
(1, 0, 0, 0) ∈ Co but (1, 0, 0, 0) ∈
/ Co . Note also that Co is not a self-dual NRT-code since (0, 1, 0, 1) ∈
/ Co but
(0, 1, 0, 1) ∈ Co⊥ .
Theorem 23. Let C ⊆ Fsq be an [s, k]-self orthogonal code over the Hamming space. Then, the code
Cort := {(v, flip(v)) ∈ M1,2s (Fq ) such that v ∈ C}
is an [2s, k]-self orthogonal code with respect to the NRT-metric.
Proof. Let v = (v, flip(v)), u = (u, flip(u)) ∈ Cort with v, u ∈ C. Then
hv, uiN = h(v, flip(v)), (u, flip(u))iN = 2hv, uiH = 0
since v, u ∈ C and C is a self-orthogonal code over the Hamming space. Clearly, dim Cort = k, so Cort is an
[2s, k]-self orthogonal NRT-code.
Example 24. Let C be the [3, 1]-self orthogonal code given by C = {(0, 0, 0), (1, 1, 0)} over the Hamming space
F32 and, so the code Cort ⊆ M1,6 (F2 ) of Theorem 23 is the following [6, 1]-self orthogonal NRT-code
Cort = {(0, 0, 0, 0, 0, 0), (1, 1, 0, 0, 1, 1)}.

14

Theorem 25. Let C ⊆ Fsq be an [s, k]-self dual code over the Hamming space. Then, the code CN ⊆ M1,2s (Fq )
given by
CN := {(v, flip(v ′ )) such that v, v ′ ∈ C}
is an [2s, 2k]-self dual with respect to the NRT-metric.
Proof. Let v = (v1 , flip(v1′ )), u = (u1 , flip(u′1 )) ∈ CN with v1 , v1′ , u1 , u′1 ∈ C. Then,
hv, uiN = h(v1 , flip(v1′ )), (u1 , flip(u′1 ))iN = hv1 , u1 iH + hv1′ , u′1 iH = 0
since v1 , v1′ , u1 , u′1 ∈ C and C is a self-dual code over the Hamming space. So CN is a self orthogonal NRT-code.
CN will be a self-dual NRT-code if dim(CN ) = 2k. Let β := {v1 , . . . vk } be a basis of C. Since flip : Fsq −→ Fsq
is a linear isomorphism the set f lip(β) := {flip(v1 ), . . . , flip(vk )} is a basis of f lip(C). Define
βN := {(v1 , 0), . . . , (vk , 0), (0, flip(v1 )), . . . , (0, flip(vk ))}
where 0 denotes the vector (0, . . . , 0) ∈ Fsq . This is a basis for CN which has 2k elements, and it follows that CN
is a [2s, 2k]-NRT self dual code.
Example 26. Let C be the [2, 1]-self dual code given by C := {(0, 0), (1, 1)} over the Hamming space F22 the
code CN ⊆ M1,4 (F2 ) of Theorem 25 will be the following [4, 2]-self dual NRT code
CN = {(0, 0, 0, 0), (0, 0, 1, 1), (1, 1, 0, 0), (1, 1, 1, 1)}.
Example 27. Consider the [8, 4]-Extended Hamming code Ĥ3 . It is well knowm that Ĥ3 is a self-dual code over the
Hamming space F82 and thus the construction of Theorem 25 applied to Ĥ3 will give us an code CN ⊆ M1,16 (F2 ),
which is an [16, 8]- self dual NRT code.

6.2

Constructions of NRT self-dual codes via generator matrices

In this subsection we will present some constructions of self-dual NRT-codes starting from other self-dual NRTcodes. These constructions are inspired by the those introduced by Marka et al. in [22], where some constructions
of self-dual NRT-codes for n = 1 are given. In order to describe NRT codes by generator matrices we will order
lexicographically the entries of an element v ∈ Mn,s (Fq ), identifying the matrix v = [v1 ; v2 ; · · · ; vn ] ∈ Mn,s (Fq )
with a row vector (v1 | v2 | . . . | vn ) ∈ M1,ns (Fq ).
Definition 28. A generator matrix for an [ns, k]-linear code C ⊆ Mn,s (Fq ) in the N RT -space is a matrix
G ∈ Mk,ns (Fq ) whose rows form a basis of C. A generator matrix G ∈ Mk,ns (Fq ) of an [ns, k]- linear NRT-code
C ⊆ Mn,s (Fq ) can be written as


G = G1 G2 · · · Gn−1 Gn

where each Gi is an k × s matrix for i = 1, . . . , n.

The main point in the constructions given in [22] is the definition of a flip of a matrix A ∈ Mn,s (Fq ), which is
given by
Definition 29. Let A = (ai,j ) ∈ Mn,s (Fq ). Then, the flip of A denoted by Flip(A) is defined by
Flip(A) = (aik ),
where k = s − j + 1 for 1 6 i 6 n and 1 6 j 6 s. We denote the transpose of Flip(A) as Ao .
Example 30. Let A ∈ Mn,s (Fq ) given by

a1,1
a1,2
 a2,1
a2,2


..
.
..
A=
.

 an−1,1 an−1,2
an,1
an,2

···
···
..
.
···
···
15

a1,s−1
a2,s−1
..
.

a1,s
a2,s
..
.

an−1,s−1 an−1,s
an,s−1
an,s






.



Then, Flip(A) and Ao are given respectively by

a1,s
a1,s−1 · · ·
a1,2
a1,1
 a2,s
a
·
·
·
a
a
2,s−1
2,2
2,1


..
..
..
..
..
F lip(A) = 
.
.
.
.
.

 an−1,s an−1,s−1 · · · an−1,2 an−1,1
an,s
an,s−1 · · ·
an,2
an,1











o
,
A
=







a1,s
a2,s
a1,s−1 a2,s−1
..
..
.
.
a1,2
a2,2
a1,1
a2,1

···
···
..
.
···
···

an−1,s
an,s
an−1,s−1 an,s−1
..
..
.
.
an−1,2
an,2
an−1,1
an,1






.



Note that by the definition of the NRT-metric, in the case n = 1, a code C ⊆ M1,s (Fq ) is an [ns, k]-self
orthogonal NRT-code if and only if GGo = 0 where G is any generator matrix of the code C.
In order to define self-dual NRT-codes by generator matrices, we introduce the ordered flip of a matrix A ∈
Mk,ns (Fq ).


Definition 31. Let A = A1 A2 · · · An−1 An be an k × nsmatrix. The ordered flip of A is the matrix
OFlip(A) := Flip(A1 ) Flip(A2 ) · · · Flip(An−1 ) Flip(An ) . We denote the transpose of OFlip(A) by
Aod . Note that


Ao1
 Ao 
2 

 .. 
od
T
A = [OFlip(A)] =  .  .
 o

 An−1 
Aon
The definition of ordered flip and NRT-metric implies the following remark.

Remark 32. Let C ⊆ Mn,s (Fq ) be an [ns, k]-linear NRT-code. Then, C is a self orthogonal NRT-code if and only
if GGod = 0 where G is a generator matrix of C.
(i)

(i)

Theorem 33. Let Ci be an [ns, ki ]-self orthogonal NRT-code for i = 1, 2 and G(i) = [G1 | . . . |Gn ] be a
generator matrix of Ci . Then, the matrix G ∈ Mk1 +k2 ,2ns (Fq ) defined by
#
"
(1)
(1)
0
· · · Gn
0
G1
G=
(2)
(2)
0
G1
···
0
Gn
is a generator matrix of an [2ns, k1 + k2 ]-self orthogonal NRT-code C N .
Proof. We will prove that GGod = 0. Indeed, by definition of ordered flip we have

OF lip(G) =

"

(1)

F lip(G1 )
0
···
(2)
F lip(G1 ) · · ·
0

(1)

F lip(Gn )
0
(2)
0
F lip(Gn )

and therefore
(1)

(1)

(2)

#



, God






=





(1)

(G1 )o
0
(2) o
0
(G1 )
(1) o
(G2 )
0
..
..
.
.
(1) o
(Gn )
0
(2) o
0
(Gn )













(2)

(1) o
o
(2)
(2) o
GGod = G1 (G1 )o + . . . + G(1)
n (Gn ) + [G1 (G1 ) + . . . + Gn (Gn ) ]
od
= G1 God
1 + G2 G2 = 0,

given that C1 and C2 are self-dual NRT-codes. Now it follows from Remark 32 that C N is a self orthogonal
NRT-code. It is easy to see that the rows of G form a basis of C N , so dim C N = k1 + k2 and hence C N is an
[2ns, k1 + k2 ]-self orthogonal NRT-code.

16



(i) = [G(i) | . . . |G(i) ] be a generator
Corollary 34. Let Ci be an ns, ns
n
1
2 -self dual NRT-code for i = 1, 2 and G
matrix of Ci . Then, the matrix G ∈ Mns,2ns (Fq ) defined by
#
"
(1)
(1)
0
· · · Gn
0
G1
G=
(2)
(2)
0
G1
···
0
Gn
is a generator matrix of an [2ns, ns]-self dual NRT-code C N .
Example 35. In Example 26, given the Hamming self-dual code C = {(0, 0), (1, 1)}, we obtain the self-dual
NRT-code CN ⊆ M1,4 (F2 ) which a generator matrix given by


1 1 0 0
(1)
G =
.
0 0 1 1
Applying the construction of Theorem 33 we obtain the [8, 4]-self-dual
generator matrix

1 1 0 0 0 0 0
 0 0 1 1 0 0 0
G := 
 0 0 0 0 1 1 0
0 0 0 0 0 0 1

NRT-code C N1 ⊆ M2,4 (F2 ) defined by the

0
0 
.
0 
1

Example 36. Applying again the construction to the linear self dual NRT-code C N1 ⊆ M2,4 (F2 ) of Example 35
we obtain the [16, 8]-self dual NRT-code C N2 given by the generator matrix


1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 


 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 


 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 

G := 
 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 .


 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 


 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1

Theorem 37. Let Ci ∈ Mni si (Fq ) be an [ni si , ki ]-self orthogonal NRT-code for 1 6 i 6 t such that k =
(i)
(i)
k1 + . . . + kt 6 n̄s̄, where n̄ := max{ni } and s̄ := max{si }. Let also G(i) = [G1 | . . . |Gni ] be a generator
matrix of Ci . Then the matrix G ∈ Mk,s̄(n1 +...+nt ) (Fq ) defined by

 (1)
e(1) . . . G
e(1)
e
G
0
0
.
.
.
0
.
.
.
0
0
.
.
.
0
G
n
1
2

 1
e(2) G
e(2) . . . G
e(2)
 0
G
0
...
0
...
0
0
...
0 
n2
1
2
G=
..
..
..
..
..
..
..
..
..
..
..
.. 

 ..
.
.
.
.
.
.
.
.
.
.
.
. 
 .
0

0

...

0

0

0

...

0

e(t) G
e(t) . . . G
e(t)
... G
nt
1
2

e(i) ∈ Mk s̄ (Fq ),
is a generator matrix of an [s̄(n1 +. . .+nt), k]-self orthogonal NRT-code C⋆ , where the matrices G
i
ji
(i)
(i)
(i)
(i)
e
e
1 6 i 6 t and 1 6 ji 6 ni are given by Gji = [Gji ] if si = s̄ or Gji = [Gji | 0] if si < s̄, where
0 ∈ Mki s̄−si (Fq ) is the null matrix.

Corollary 38. Let Ci be an [ns, ki ]-self orthogonal NRT-code for 1 6 i 6 t such that k = k1 + . . . + kt 6 ns
(i)
(i)
and G(i) = [G1 | . . . |Gn ] be a generator matrix of Ci . Then the matrix G ∈ Mk,tns (Fq ) defined by

 (1)
(1)
(1)
G2
. . . Gn
0
0
...
0
...
0
0
...
0
G1


(2)
(2)
(2)
 0
0
...
0
G1
G2
. . . Gn . . .
0
0
...
0 
G=
..
..
..
..
..
..
..
..
..
..
..
.. 

 ..
.
.
.
.
.
.
.
.
.
.
.
. 
 .
0

0

...

0

0

0

...

is a generator matrix of a [tns, k]-self orthogonal NRT-code C⋆ .
17

0

(t)

. . . G1

(t)

G2

(t)

. . . Gn

In particular, we can apply the preceding Corollary to construct a self-dual NRT-code C⋆ equivalent to the code
C N obtined by the constructions in Theorem 33 is the folowing


(1) = [G(1) | . . . |G(1) ] be a generator
Corollary 39. Let C1 , C2 be two ns, ns
n
1
2 -self dual NRT-codes and let G
(2)

(2)

matrix of C1 , and G(2) = [G1 | . . . |Gn ] be a generator matrix of C2 . Then, the matrix G ∈ Mns,2ns (Fq ) defined
by
#
"
(1)
(1)
. . . Gn
0
...
0
G1
G=
(2)
(2)
0
...
0
G1
. . . Gn

is a generator matrix for an [2ns, ns]-self dual NRT-code C⋆ .
Example 40. Let C N1 be the [8, 4]-Self dual NRT-code of Example 35. Then, by the construction of Theorem 39
the following matrix


1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 


 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 


 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 


G := 

0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0


 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 


 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1
is a generator matrix for a [16, 8]-self dual NRT-code C⋆ that is equivalent to the code C N2 of Example 36.

6.3

An application of the ordered flip concept

In [1], Alves gave an analogue for NRT-codes of the well-known standard form of generator matrices for codes in
spaces with the Hamming space. In particular, for bidimensional codes it was shown the following result.
Theorem 41. Let C ⊆ Mn,s (Fq ) be an [ns, 2]-linear NRT-code. Then, C has a generator matrix of the form
G = [G1 |G2 | . . . |Gn ]
where each Gi is an 2 × s matrix of one of the following types: Null matrix,
where ei ∈ Fsq denotes the i-th canonical vector, 1 6 i 6 j and λ 6= 0.



ei
0

 
 

 
ei
ei + λej
0
,
,
,
ei
ej
ej

The definition of ordered flip and Theorem 41 can be used to find all possible generator matrices of a bidimensional self-dual NRT-code. In fact, if C ⊆ Mn,s (Fq ) is an [ns, k]-self dual bidimensional NRT-code then
2 = dim(C) = ns
2 and so ns = 4, which implies that one of the following cases holds.
i) n = 1, s = 4 and an [4, 2]-Self dual NRT-code C ⊆ M1,4 (Fq ) has as a generator matrix one of the matrices

 
 
 

1 0 0 0
1 0 0 0
0 1 0 0
0 0 1 0
,
,
,
,
0 1 0 0
0 0 1 0
0 0 0 1
0 0 0 1

 
 
 

1 0 λ 0
1 λ 0 0
0 1 0 λ
0 0 1 λ
,
,
,
.
0 0 1 0
0 1 0 0
0 0 0 1
0 0 0 1
ii) n = 2, s = 2 and an [4, 2]-Self dual NRT-code C ⊆ M2,2 (Fq ) has as a generator matrix one of the matrices
 
1
,
0

 
0
0 1 1 0
,
0 0 1 0
0
 

0 1
0 1 1+λ 0
,
1
0
0 0
0 0


1 0 0 0
0 0 1 0

 
0
,
0
 
0 1
1
,
0
0 1
 
1
1+λ
,
1
0

 
0 1
,
0 0
 
1 0
1 0
,
0 0
1 0
 
1
1+λ 0
,
1
0
0

0 0 0
0 0 1

1 0 0
0 1 0

0 0
0 1

1
0

0
0

0 1
0 1

0
0

18

0
0




,
,

0 0 1+λ
1
0 0



.

iii) n = 4, s = 1 and in this case the NRT-metric and the Hamming metric are equivalent. The classification of
self-dual codes in this case is given by Pless in [25].

References
A standard form for generator matrices with respect to the
[1] M. M. S. Alves,
Niederreiter-Rosenbloom-Tsfasman metric, IEEE Information Theory Workshop, Vol.1, pp. 486-489,
2011.
[2] A. Barg, P. Purkayastha, Bounds on ordered codes and orthogonal arrays, Moscow Mathematical Journal,
vol. 9, pp. 211-243, 2009.
[3] K. Lee, The automorphism group of a linear space with the Rosenbloom-Tsfasman metric, European Journa
of Combinatories, vol. 24, pp. 607-6017, 2003.
[4] W. Park, A. Barg, Linear ordered codes, shape enumarators and parallel channels, Forty-Eighth Annual
Allerton Conference, pp. 361-368, 2010.
[5] M. Beecken, J. Mittmann, and N. Saxena, Algebraic independence and blackbox identity testing, Information
and Computation, vol. 222, pp. 137-148, 2011.
[6] R. A. Brualdi, J. S. Graves and K. M. Lawrence, Codes with a poset metric, Discrete Mathematics, vol. 147,
pp. 57-72, 1995.
[7] T. Molien, Ueber die invarianten der linear substitutions gruppe, Sitzungaber Kï¿ 12 ning, Akad. Wiss, pp.
1152-1156, 1857.
[8] E. M. Rains, N. J. A. Slone, Self-dual codes, In: Handbook of coding theory, North Holland, 1995.
[9] S. T. Dougherty, M. M. Skriganov, MacWilliams duality and the Rosenbloom-Tsfasman metric, Moscow
Mathematical Journal, vol. 2, pp. 81-97, 2002.
[10] H. Niederreiter, A combinatorial problem for vectors spaces over finite fields, Discrete Math, vol. 96, pp.
221-228, 1991.
[11] S. Dougherty and K. Shiromoto, Maximum distance codes in M atN,S (Z(K)) with a Non-Hamming metric
and uniform distributions, Designs Codes Cryptography, vol. 33, pp. 45-61, 2004.
[12] A. Barg, M. Firer, Translation association schemes, poset metric, and the shape enumerator of codes, IEEE
International Symposium on Information Theory Proceedings, pp. 101-105, 2012.
[13] A. Barg, W. Park, On linear ordered codes, Moscow Mathematical Journal, vol. 15, pp. 679-702, 2015.
[14] S. Lefschetz, Algebraic Geometry, Princeton University Press, Princeton, N. J., 1953, 2nd edn., 1964.
[15] R. Ehrenborg, G. C. Rota, Apolarity and canonical forms for homogeneous polynomials, European Journal
of Combinatorics, vol.12, pp. 157-181, 1993.
[16] H. K. Kim and D. Y. Oh, A classification of posets admitting the MacWilliams identity, IEEE Transactions
on Information Theory, vol. 51, pp. 1424-1431, 2005.
[17] A. M. Gleason, Weight polynomials of self-dual codes and the MacWilliams identities , in: Actes, Proceeding
of the congrï¿ 12 s international de mathï¿ 21 matiques, Nice, vol. 3, pp. 211-215, 1971
[18] F. J. MacWilliams, C. L. Mallows and N. J. A. Sloane, Generalizations of Gleason’s Theorem on weight
enumerators of self-dual codes IEEE Transactions on Information Theory, vol. 18, pp. 796-805, 1972.
[19] N. J. A. Sloane, The classical groups, Princeton University Press, Pinceton, N. J., 1946.
19

[20] G. Nebe, E. M. Rains, and N. J. A. Sloane, The invariants of the Cifford groups, Designs, Codes and Cryptography, vol. 24, pp 99-121, 2001.
[21] G. Nebe, E. M. Rains, N. J. A. Sloane, Codes and invariant theory, Mathematische Nachrichten, vol. 274-275,
pp. 104-116, 2004.
[22] V. Marka, R. S. Selvaraj and I. Gnanasudha, Self-dual codes in the Rosenbloom-Tsfasman metric, Mathematical Communications, vol. 22, pp. 75-87, 2017.
[23] M. Hochater and J.A. Eagon, Cohen-Macaulay rings, invariant theory, and the generic perfection of
determinantal loci, American Journal of Mathematics, vol. 93, pp. 1020-1058, 1971.
[24] W. J. Martin and D. R. Stinson, Association schemes for ordered orthogonal arrays and (T,M,S)-nets, Canadian Journal of Mathematics, vol 51, pp 326-346, 1999.
[25] V. Pless, A Classification of self-orthogonal codes over GF (2), Discrete Mathematics, vol. 3, pp. 209-246,
1972.
[26] E. Noether, Der endlichkeitssatz der invarianten endlicher gruppen, Mathematische Annalen, vol. 77, pp.
89-92, 1916.
[27] M. Yu. Rosenbloom, M. A. Tsfasman, Codes for the m-metric, Problemy Peredachi Informatsii, vol. 33,
pp. 55-63 (Russian), 1997. MR 98c:94023. English translation in Problems Inform. Transmission, vol. 33,
pp.45-52, 1997.
[28] M. M. Skriganov, Coding theory and uniform distributions, St. Petersburg Mathematical Journal, vol. 13, pp.
310-337, 2002.
[29] R. P. Stanley, Invariants of finite groups and their applications to combinatorics , American Mathematical
Society, vol. 1, pp. 475-511 , 1979.
[30] R. P. Stanley, Hilbert function of graded algebras, Advances in Math, vol. 28, pp. 57-83, 1978.
[31] W. Bosma, J. Cannon, and C. Playoust, The Magma algebra system. I. The user language, Journal of Symbolic Computation, vol. 24, pp. 235-265, 1997.

20

