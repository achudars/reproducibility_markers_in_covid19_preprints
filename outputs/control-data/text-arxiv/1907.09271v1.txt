Succinct Representation for (Non)Deterministic
Finite Automata
Sankardeep Chakraborty1 , Roberto Grossi2 , Kunihiko Sadakane3 ,
and Srinivasa Rao Satti4
1
2
3

arXiv:1907.09271v1 [cs.DS] 22 Jul 2019

4

RIKEN Center for Advanced Intelligence Project, Japan
sankar.chakraborty@riken.jp
Dipartimento di Informatica, Universit√† di Pisa, Italy
grossi@di.unipi.it
The University of Tokyo, Japan
sada@mist.i.u-tokyo.ac.jp
Seoul National University, South Korea
ssrao@cse.snu.ac.kr

Abstract
Deterministic finite automata are one of the simplest and most practical models of computation
studied in automata theory. Their conceptual extension is the non-deterministic finite automata
which also have plenty of applications. In this article, we study these models through the lens of
succinct data structures where our ultimate goal is to encode these mathematical objects using
information theoretically optimal number of bits along with supporting queries on them efficiently.
Towards this goal, we first design a succinct data structure for representing any deterministic
finite automaton D having n states over a œÉ-letter alphabet Œ£ using (œÉ‚àí1)n log n+O(n log œÉ) bits
of space, which can determine, given an input string x over Œ£, whether D accepts x in O(|x| log œÉ)
time, using constant words of working space. When the input deterministic finite automaton is
acyclic, not only we can improve the above space bound significantly to (œÉ ‚àí 1)(n ‚àí 1) log n +
3n + O(log2 œÉ) + o(n) bits, we also obtain optimal query time for string acceptance checking.
More specifically, using our succinct representation, we can check if a given input string x can
be accepted by the acyclic deterministic finite automaton using time proportional to the length
of x, hence, the optimal query time. We also exhibit a succinct data structure for representing a
non-deterministic finite automaton N having n states over a œÉ-letter alphabet Œ£ using œÉn2 + n
bits of space, such that given an input string x, we can decide whether N accepts x efficiently in
O(n2 |x|) time. Finally, we also provide time and space efficient algorithms for performing several
standard operations such as union, intersection and complement on the languages accepted by
deterministic finite automata.
1998 ACM Subject Classification Dummy classification ‚Äì please refer to http://www.acm.org/
about/class/ccs98-html
Keywords and phrases Succinct Data Structures, Encoding Schemes, Finite Automata
Digital Object Identifier 10.4230/LIPIcs.CVIT.2016.23

1

Introduction

Automata theory is a branch of theoretical computer science that deals exclusively with the
definitions, properties and applications of different mathematical models of computation.
These models play a major role in multiple applied areas of computer science. One of the
most basic and fundamental models that is studied in automata theory since long time
back is called the finite automata. It primarily comes in two different types, deterministic
¬© Chakraborty, Grossi, Sadakane and Satti;
licensed under Creative Commons License CC-BY
42nd Conference on Very Important Topics (CVIT 2016).
Editors: John Q. Open and Joan R. Acces; Article No. 23; pp. 23:1‚Äì23:17
Leibniz International Proceedings in Informatics
Schloss Dagstuhl ‚Äì Leibniz-Zentrum f√ºr Informatik, Dagstuhl Publishing, Germany

23:2

Succinct Representation for (Non)Deterministic Finite Automata

finite automata (henceforth DFA) and non-deterministic finite automata (henceforth NFA)
among others. There exists more complex and sophisticated models as well, for example,
Context-free grammar, Turing machines etc. In what follows, let us formally define DFA and
NFA in a nutshell as these are our primary subjects of study in this article. A DFA D is a
quintuple D = (Œ£, Q, q0 , Œ¥, F ) where:
Œ£ is an alphabet; a finite set of letters,
Q is the finite set of states,
q0 ‚àà Q is the initial state,
Œ¥ : Q √ó Œ£ ‚Üí Q is the transition function and
F ‚äÜ Q is the set of final states.
We often extend the transition function to Œ¥ : Q √ó Œ£‚àó ‚Üí Q which is defined recursively as
follows: Œ¥(q, ) = q for all q ‚àà Q, where  is the empty string; and Œ¥(q, aw) = Œ¥(Œ¥(q, a), w) for
all q ‚àà Q, a ‚àà Œ£, and w ‚àà Œ£‚àó . Given the above definition, we say that the DFA accepts a
string x over the alphabet Œ£ if and only if Œ¥(q, x) ‚àà F . The language L accepted by a DFA
D is defined as the set of all strings accepted by the DFA D, and is denoted by L(D). See
Figure 1 for a simple example. In the rest of this paper, we assume that the alphabet Œ£ is
{1, 2, . . . , œÉ}, and the state set Q is {q0 , q1 , . . . , qn‚àí1 }.

1

0
‚Ä´›ç‚Ä¨‡¨¥

‚Ä´›ç‚Ä¨‡¨µ

1

0
Figure 1 The state transition diagram for a DFA D where D = (Œ£, Q, q0 , Œ¥, F ) such that (i)
Œ£ = {0, 1}, (ii) Q = {q0 , q1 }, (iii) q0 = q0 (marked with an incoming arrow coming from nowhere),
(iv) F = {q0 }, and (v) the transition function is defined as the following set, {Œ¥(q0 , 1) = q0 , Œ¥(q0 , 0) =
q1 , Œ¥(q1 , 1) = q1 , Œ¥(q1 , 0) = q0 }. Precisely the DFA D accepts all the strings containing an even
number of zeros over the binary alphabet.

A deterministic automaton A is called acyclic [16] if it has a unique recurrent state
where a state q is defined as recurrent if there exists a non-empty string x over Œ£ such that
Œ¥(q, x) = q. Non-recurrent states are typically called transient, and the unique recurrent
state (denoted by q 00 ‚àà Q) is classically called the dead state as Œ¥(q 00 , œÉ) = q 00 for all œÉ ‚àà Œ£.
An NFA is a conceptual extension of DFAs where the definition of the transition function
is mainly extended. More specifically, for DFA, the transition function is defined as Œ¥:
Q √ó Œ£ ‚Üí Q whereas for NFA, the same is defined as Œ¥: Q √ó Œ£ ‚Üí P(Q) where P(Q) denotes
the power set of Q. Another extension, which is sometimes used in the literature, is to simply
allow more than one initial state in an NFA, and in this case, the third item in the tuple
becomes I denoting the set of initial states, instead of singleton {q0 }. The rest of above
quintuple definition remains as it is for NFA. Thus, in the case of NFA N , the language L(N )
is defined as {x | ‚àÉq‚ààI ‚àÉq0 ‚ààF [q 0 ‚àà Œ¥(q, x)]}. We refer the readers to the classic texts of [14, 23]
for a thorough discussions on these mathematical models and automata theory in general.
Even if a DFA is defined as an abstract mathematical concept, still it has got myriad
of practical applications. More specifically, it is used in text processing, compilers, and
hardware design [23]. Quite often it is implemented in small hardware and software tools
for solving various specific tasks. For example, a DFA can model a software that can figure

Chakraborty, Grossi, Sadakane and Satti

23:3

out whether or not online user input such as email addresses are valid. DFAs/NFAs are also
used for network packet filtering. In some of these applications, the alphabet is large and
there is a failure/exit state so that only a subset of transitions go to non-failure states; so we
call the latter ones non-failure transitions.
Despite having so many applications in practically motivated problems, we are not aware
of, to the best of our knowledge, any study of DFAs and NFAs from the point of view of
succinct data structures where the goal is to store an arbitrary element from a set Z of
objects using the information theoretic minimum log(|Z|) + o(log(|Z|)) bits of space while
still being able to support the relevant set of queries efficiently, which is what we focus on in
this paper. We also assume the usual model of computation, namely a Œò(log n)-bit word
RAM model where n is the size of the input.

1.1

Related Work

The field of succinct data structures originally started with the work of Jacobson [15], and by
now it is a relatively mature field in terms of breadth of problems considered. To illustrate
this further, there already exists a large body of work on representing various combinatorial
objects succinctly. A partial list of such combinatorial objects would be trees [18, 21],
various special graph classes like planar graphs [2], chordal graphs [19], partial k-trees [11],
interval graphs [1] along with arbitrary general graphs [12], permutations [17], functions [17],
bitvectors [22] among many others. We refer the reader to the recent book by Navarro [20] for
a comprehensive treatment of this field. The study of succinct data structures is motivated
by both theoretical curiosity and also by the practical needs as these combinatorial structures
do arise quite often in various applications.
For DFA and NFA, other than the basic structure that is mentioned in the introduction,
there exists many extensions/variations in the literature, for example, two-way finite automata,
B√ºchi automata and many more. Researchers generally study the properties, limitations and
applications of these mathematical structures. One such line of study that is particularly
relevant to us for this paper is the research on counting DFAs and NFAs. Since the fifties
there are plenty of attempts in exactly counting the number of DFAs and NFAs with n
states over the alphabet Œ£, and the state-of-the-art result is due to [3] for DFAs and [10]
for NFAs respectively. We refer the readers to the survery (and the references therein) of
Domaratzki [9] for more details. Basically, from these results, we can deduce the information
theoretic lower bounds on the number of bits required to represent any DFA or NFA. Then
we augment these lower bounds by designing data structures whose size matches the lower
bounds, hence consuming optimal space, along with capable of executing algorithms efficiently
using this succinct representation, and this is the main contribution of this paper.

1.2

DFA and NFA Enumeration

After a number of efforts by several authors, finally Bassino and Nicaud [3] found a matching
upper and lower bound on the number of non-isomorphic initially-connected1 (i.e., all the
states are reachable from the initial state) DFA‚Äôs with n (including a fixed initial and one or
possibly more final) states over an alphabet Œ£ (where |Œ£| = œÉ) is Œò(n22n S2 (œÉn, n)) where
S2 (n, m) denotes the Stirling numbers of the second kind2 . Using the approximation of the

1
2

Note that this assumption always implies that the language accepted by the DFA is non-empty.
It is defined recursively as S2 (0, 0) = 1, S2 (n, 0) = 0 for all n ‚â• 1 and for all n, m ‚â• 1, S2 (n, m) =
mS2 (n ‚àí 1, m) + S2 (n ‚àí 1, m ‚àí 1).

CVIT 2016

23:4

Succinct Representation for (Non)Deterministic Finite Automata
n

Stirling numbers of the second kind [13], which states that S2 (n, m) ‚âà m
m! , we can obtain
the information theoretic lower bound for representing any DFA having n states and œÉ-sized
alphabet is given by lg(n22n S2 (œÉn, n)) = (œÉ ‚àí 1)n lg n + O(n) bits. On the other hand,
2
Domaratzki et al. [10] showed that there are asymptotically 2œÉn +n initially connected NFAs
on n states over a œÉ-letter alphabet with a fixed initial state and one or more final states.
Thus, information theoretically, we need at least œÉn2 + n bits to represent any NFA. In
what follows later, we show that we can represent any given DFA/NFA using asymptotically
optimal number of bits as mentioned here. Throughout this paper, we assume that the input
DFAs/NFAs that we want to encode succinctly are initially connected.

1.3

Our Main Results and Paper Organization

The classical representation of DFAs/NFAs consists of explicitly writing the transition
function Œ¥ in a two dimensional array J[0..n ‚àí 1][1..œÉ] having n rows corresponding to the n
states of the DFA/NFA and œÉ (where |Œ£| = œÉ) columns corresponding to the alphabet Œ£
such that J[i][j] = Œ¥(qi , j) where qi ‚àà Q, j ‚àà Œ£. For DFA, the entry in J[i][j] is a singleton
set whereas for NFA it could possibly contain a set having more than one state. Thus, the
space requirement for representing any given DFA (NFA respectively) is given by O(nœÉ log n)
(O(n2 œÉ log n) respectively) bits. These space bounds are clearly not optimal ‚Äì for the DFAs,
it is off by an additive n log n term from the information theoretic minimum, while for the
NFAs, it is off by a multiplicative factor of log n from the optimal bound. We alleviate this
discrepancy in the space bounds by designing optimal succinct data structures for these
objects.
Towards this goal, we start by listing all the preliminary data structures and graph
theoretic terminologies that will be required in our paper in Section 2. Then, in Section 3.1
we first discuss the relevant prior work from [3], and show that, by using suitable data
structures, their work already gives a succinct encoding of DFA. But the major drawback of
this encoding is that it is not capable of handling the problem of checking whether a string
is accepted by the DFA extremely efficiently. In Section 3.2, we overcome this problem by
designing a succinct data structure for DFA, which can also check the string acceptance
almost optimally. We summarize our main result in the following theorem.
I Theorem 1. Given an initially-connected deterministic finite automata D having n states
and working over an alphabet Œ£ of size œÉ, there exists a succinct encoding for D taking
(œÉ ‚àí 1)n log n + O(n log œÉ) bits of space, which can determine, given an input string x over
Œ£, whether D accepts x in O(|x| log œÉ) time, using constant words of working space. If the
DFA has only N < œÉn non-failure transitions, then the space can be further reduced to
(N ‚àí n) log n + O(N log œÉ) bits.
The upper bounds in Theorem 1 save roughly n log n bits with respect to the immediate
representation of the DFA. The former upper bound is optimal as it matches the informationtheoretical lower bound in Section 1.2, up to lower order terms. As for the latter upper
bound, we do not know
its optimality but it is smaller than the information-theoretical
2
lower bound of dlog nN e + Œò(N log œÉ) bits derived for edge-labeled deterministic directed
graphs [12]. Indeed, DFAs can be seen as a special case of these graphs where n is the
number of nodes, N ‚â• n ‚àí 1 is the number of arcs, and œÉ is the maximum node degree.3

3

A directed graph with labelson its arcs is deterministic if no two out-neighbor arcs have the same
2
label. Since there are dlog nN e directed graphs [12] with n nodes and N arcs, each deterministic graph

Chakraborty, Grossi, Sadakane and Satti

23:5

We can improve the above space bound significantly if the given DFA is acyclic along with
obtaining optimal query time for string acceptance checking. More specifically, in Section 3.3,
we obtain the following result in this case.
I Theorem 2. Given an initially-connected acyclic deterministic finite automata A having
n ‚àí 1 transient states, a unique dead state and working over an alphabet Œ£ of size œÉ, there
exists a succinct encoding for A taking (œÉ ‚àí 1)(n ‚àí 1) log n + 3n + O(log2 œÉ) + o(n) bits of
space, which can optimally determine, given an input string x over Œ£, whether A accepts x
in time proportional to the length of x, using constant words of working space.
This is followed by the succinct data structure for NFA in Section 3.4 where we prove the
following result.
I Theorem 3. Given an initially-connected non-deterministic finite automata N having
n states and working over an alphabet Œ£ of size œÉ, there exists a succinct encoding for N
taking œÉn2 + n bits of space, which can determine, given an input string x over Œ£, whether
N accepts x in O(n2 |x|) time, using 2n bits of working space.
Next we move on to discuss how one can support several standard operations such as union
and intersection of two languages accepted by the deterministic finite automata. Classically
it is done via the product automaton construction [14, 23], and here we provide a time and
space efficient algorithm for performing this construction. More specifically, we show the
following theorem (proof and other details are provided in Appendix A.1),
I Theorem 4. Suppose we are given the succinct representations for two DFAs D1 (having
n states) and D2 (having n0 states) respectively such that both are working over the same
alphabet Œ£. Also suppose that the product automata (denoted by P) has n00 states where
n00 ‚â§ nn0 . Then, using O(n00 ) expected time and O(n00 log n00 ) bits of working space, we can
directly construct a succinct representation for P. Moreover, P can be represented optimally
using (œÉ ‚àí 1)n00 log n00 + O(n00 log œÉ) bits overall, and by suitably defining the final states of
P, we can make P accept either L(D1 ) ‚à™ L(D2 ) or L(D1 ) ‚à© L(D2 ). Finally, given an input
string x over Œ£, we can decide whether x ‚àà L(P) in O(|x| log œÉ) time using constant words
of working space.
Finally, we conclude in Section 4 with some concluding remarks.

2

Preliminaries

In this section we collect all the previous theorems and definitions that will be used throughout
this paper.

2.1

Graph Terminology and Graph Algorithms

We will assume the knowledge of basic graph theoretic terminology (like trees, paths etc)
as given in [6] and basic graph algorithms (mostly the depth first search (henceforth DFS)
traversal of a graph and its related concepts) as given in [5]. Perhaps at this point it may
seem slightly unusual that we are talking about graphs here when the focus of this paper is
DFA/NFA and their succinct representations. Essentially in this paper we view DFA/NFA,

Q

G = (V, E) can have L = u‚ààV du ! label assignments for its arcs, where du s the out-degree of node u
P
and N =
d . Note that log L = Œò(N log œÉ) when labels are from Œ£ and thus du ‚â§ œÉ.
u‚ààV u

CVIT 2016

23:6

Succinct Representation for (Non)Deterministic Finite Automata

more specifically their graphical representation i.e., state transition diagram, as a special case
of an edge labeled directed graph G having n nodes corresponding to the n = |Q| states of
DFA/NFA, m = œÉn edges where |Œ£| = œÉ as each node has exactly œÉ outgoing edges, and
each edge is labeled with some elements from Œ£. It is with this point of view, we will design
our succinct data structures for DFA/NFA in this paper.

2.2

Succinct Data Structures

Rank-Select. For a bit vector B and any a ‚àà {0, 1}, the rank and select operations are
defined as follows :
ranka (B, i) = the number of occurrences of a in B[1, i], for 1 ‚â§ i ‚â§ n;
partial_rank1 (B, i) = rank1 (B, i) if B[i] = 1, and ‚àí1 otherwise; and
selecta (B, i) = the position in B of the i-th occurrence of a, for 1 ‚â§ i ‚â§ n.
We make use of the following theorems:
I Theorem 5. [4] We can store a bitstring B of length n with additional o(n) bits such
that rank and select operations can be supported in O(1) time. Such a structure can also be
constructed from the given bitstring in O(n) time and space.

n
I Theorem 6. [22] We can store a bitstring B of length n with m ones using log m
+
o(m) + O(log log n) bits such that partial_rank1 operations can be supported in O(1) time.
Such a structure can also be constructed from the given bitstring in O(n) time and space.
Succinct tree representation. We use following result from [18].
I Theorem 7. [18] Given a rooted ordered tree œÑ on n nodes, it can be succinctly represented
as a sequence of balanced parenthesis of length 2n bits, such that given a node v, we can
support subtree size and various navigational queries (such as parent and i-th child) on v in
O(1) time using an additional o(n) bits. Such a structure can also be constructed in O(n)
time and space.
Compact representation of increasing sequence.
from [24].

We use the following theorem

I Theorem 8. [24] Given an increasing integer sequence a[¬∑] of length n such that 0 ‚â§
a[1] ‚â§ a[2] ‚â§ ¬∑ ¬∑ ¬∑ ‚â§ a[n] < u, there exists a data structure to represent a[¬∑] in compressed
form using O(min{ 1 n u1‚àí , 1 u n1‚àí }) bits of space, where  > 0 is any parameter, such that
any entry a[i] and the value a[i] = |{j | a[j] < i, 1 ‚â§ j ‚â§ n}| can be retrieved in O(1/) time.
We denote the above data structure by D(n, u, ). If B denotes the characteristic vector for
the sequence a, then computing a[i] and a[i] correspond to computing select and rank on B.
Representation of a vector. We also make use of the following theorem from [8].
I Theorem 9. [8] There exists a data structure that can represent a vector A[1..n] of
elements from a finite alphabet Œ£ using n log |Œ£| + O(log2 n) bits, such that any element of
the vector can be read or written in constant time.

3

Succinct Representations for DFA and NFA

In this section, we provide all the upper bound results of our paper dealing with DFA/NFA.
Throughout this section, whenever we mention DFA (NFA resp.), it should refer to an
initially-connected deterministic (non-deterministic resp.) finite automata having n states
and working over an alphabet Œ£ of size œÉ. With this notation in mind, we start with the
succinct encoding of DFA first.

Chakraborty, Grossi, Sadakane and Satti

3.1

23:7

Succinct Encoding of DFA

Bassino and Nicaud [3] proved a beautiful bijection between the state transition diagram of
any DFA and pairs of integer sequences which can be represented by boxed diagrams (will
be defined shortly) along with providing an efficient algorithm to perform this construction.
We will refer the readers to [3] for complete details regarding the bijection, counting and
many other details that we choose to not repeat here. However, we still need to provide
some details/definitions (which basically follow their exposition) that are relevant to our own
work and will also help to understand the results from their paper smoothly. Following [3],
a diagram of width m and height n is defined as a sequence (x1 , . . . , xm ) of non-decreasing
non-negative integers such that xm = n, represented as a diagram of boxes. See Figure 2 for
better visual description and understanding. A boxed diagram can be defined as a pair of
sequences ((x1 , . . . , xm ), (y1 , . . . , ym )) where (x1 , . . . , xm ) is a diagram and for all i (such that
1 ‚â§ i ‚â§ m), the yi -th box of the column i of the diagram is marked. Note that 1 ‚â§ yi ‚â§ xi .
Qm
Thus, a diagram can lead to i=1 xi boxed diagrams. A k-Dyck diagram of size n is defined
as a diagram of width m := (k ‚àí 1)n + 1 and height n such that xi ‚â• di/(k ‚àí 1)e for all
i ‚â§ m ‚àí 1. Finally, a k-Dyck boxed diagram of size n is boxed diagram where the first
coordinate (x1 , . . . , x(k‚àí1)n+1 ) is a k-Dyck diagram of size n. Given these definitions, Bassino
and Nicaud [3] proved the following theorem.

(1, 1, 2, 2, 4)

(1, 1, 2, 2, 4)
(1, 1, 2, 2, 3)

(1, 2, 3, 4, 4)

(1, 2, 3, 4, 4)
(1, 1, 2, 2, 4)

Figure 2 A diagram of width m = 5 and height n = 4, a boxed diagram, a k-Dyck diagram and
a k-Dyck boxed diagram with k = 2.

I Theorem 10. [3] The set Dn containing DFAs having n states and working over a œÉ-letter
alphabet is in bijection with the set Bn of œÉ-Dyck boxed diagrams of size n. Moreover, the
construction involving going from transition diagram of the DFA to k-Dyck boxed diagram
and vice versa runs in linear time and space.
Thus, by applying the above theorem, from any given DFA with n states and œÉ-letter
alphabet, [3] produces a œÉ-Dyck boxed diagrams of size n, which can be in turn represented by
two integer arrays Max[1..m] and Boxed[1..m] of length m := (œÉ ‚àí 1)n + 1 each. Furthermore,
from these two arrays, it is possible to entirely reconstruct the DFA using the algorithm
of Theorem 10. Thus, it is sufficient to store just these two arrays in order to encode any
given DFA. For more details, readers are referred to [3]. For an example, see Figure 3 which
will also serve as the working example for this part of our paper. In particular, the DFA of
Figure 3 can be entirely encoded by the Max[1..15] = {3, 4, 4, 4, 4, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7} and
Boxed[1..15] = {1, 2, 3, 1, 4, 3, 4, 2, 3, 1, 4, 4, 5, 3, 6} arrays of length (œÉ ‚àí 1)n + 1 = 15, and
these can be computed using the algorithms of [3].
First, we observe that, by construction, the arrays satisfy 1 ‚â§ Max[1] ‚â§ Max[2] ‚â§
¬∑ ¬∑ ¬∑ ‚â§ Max[m] ‚â§ n and 1 ‚â§ Boxed[i] ‚â§ Max[i] for each i = 1, 2, . . . , m. This happens
precisely because the translation is obtained by following a DFS on the DFA using the

CVIT 2016

23:8

Succinct Representation for (Non)Deterministic Finite Automata

c
a
a
Œ¥
1
2
3
4
5
6
7

a
2
3
1
2
3
4
4

b
7
5
4
3
6
2
5

c
6
4
4
1
1
3
3

b

1

b

b
7
c

c

5

b

c

c
c

b

b

3

a

b
c

a

a

2

c
4

a

6
a

Figure 3 Three ways to define the same DFA. This DFA will serve as the working example for our
discussion. By using the techniques of [3], this DFA can be entirely represented by the Max[1..15] =
{3, 4, 4, 4, 4, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7} and Boxed[1..15] = {1, 2, 3, 1, 4, 3, 4, 2, 3, 1, 4, 4, 5, 3, 6} arrays of
length (œÉ ‚àí 1)n + 1 = 15 each.

lexicographic order of words, and on each backtracking edge adding to the first vector
the number of states scanned so far, and to the second vector the state reached. This
also explains why each entry of these two arrays are upper bounded by n, the number of
states of the given DFA. Now we consider the number of bits needed to encode the array
Max[1..m]. As it is an increasing integer sequence of length m and the range of the values is
[1, n], by using data structure D(n, m, ) of Theorem 8, this array can be represented using
O( 1 m n1‚àí ) = O( 1 {(œÉ ‚àí 1)n + 1} n1‚àí ) bits of space. By letting  = 1/ log(œÉ ‚àí 1), the size
is O(n log œÉ) bits if œÉ > 2. If œÉ = 2, the space is obviously O(n) = O(n log œÉ) bits. Next
we consider the number of bits required for array Boxed[1..m]. Because each entry of this
array is an integer from 1 to n, we can use Theorem 9 to represent the Boxed[1..m] array
using (œÉ ‚àí 1)n log n + O(log2 m) (recall m = (œÉ ‚àí 1)n + 1) bits. Thus, in total, the size of
the representation using two integer arrays is (œÉ ‚àí 1)n log n + O(n log œÉ) bits. Because the
information theoretic lower bound is (œÉ ‚àí 1)n log n + O(n) bits for the representation of DFA,
this representation is succinct.
We consider a special case when there is a failure/exit state labeled 0 and only N transitions
among all the œÉn transitions go to non-failure states. Note that Boxed has N ‚àí n + 1 non-zero
values. In this case we can reduce the space for Boxed[1..m] by using a new bitvector Z[1..m]
which has N ‚àín+1 ones. We use a new array Boxed 0 [1..N ‚àín+1] which stores non-zero values
of Boxed[1..m]. Then Boxed[i] is computed as follows. If Z[i] = 0, Boxed[i] = 0 (transition
to the failure state). If Z[i] = 1, Boxed[i] = Boxed 0 [partial_rank1 (Z, i)]. If we use the data
structure of Theorem 5, Z is represented in œÉn + o(œÉn) bits, which is asymptotically smaller
than the space lower bound of (œÉ ‚àí 1)n log n + O(n). But, by using the data structure
of Theorem 6, the bitvector Z can be represented in log œÉn
N + o(N ) + O(log log(œÉn)) =
N log œÉn
+
O(N
)
bits
to
support
partial_rank
queries
in
O(1)
time. The space for Boxed 0
N

Chakraborty, Grossi, Sadakane and Satti

23:9

is (N ‚àí n + 1) log n bits. Therefore the total space for representing a DFA with N non-failure
transitions is (N ‚àí n) log n + O(N log œÉ) bits.
Even though this representation is optimal from the point of view of space occupancy, one
major drawback of this representation is that, given a string x over Œ£, it takes linear time (in
the size of the DFA, i.e., O(œÉn) time where n is number of states of the DFA and œÉn is total
number of transitions or edges in state transition diagram of the DFA) to decide whether the
DFA accepts the string x, which is clearly not optimal as ideally it should be performed in
time O(|x|). This happens because the algorithm of Theorem 10 actually unravels the DFA
from these two arrays Max[1..m] and Boxed[1..m], and then checks whether the input string
can be accepted or not. Thus, from the point of view of string acceptance, this encoding of
DFA is not optimal whereas space requirement point of view, this is optimal. This motivates
the need of a succinct encoding of a given DFA, where the problem of string acceptance can
be performed in almost optimal time (i.e., almost in time proportional to the string length).
In what follows, we provide such an encoding.

3.2

Succinct Data Structure for DFA

Data structure: To design a succinct data structure for DFA, we need the following three
bitvectors F , P and T in addition to an integer array NewBoxed[1..m] (that can be obtained
from the Boxed[1..m] array of the previous section, as described later), which are defined as
follows.
P is a balanced parentheses sequence of length 2n obtained from the lexicographic depthfirst search (DFS) tree of the given input automaton D. More specifically, given any DFA
D, we first perform the lexicographic DFS on D to generate the lexicographic DFS tree
R of D, i.e., while looking for a new edge to traverse during DFS, the algorithm always
searches in lexicographic order of edge labels. For example, in Figure 3, from any vertex,
lexicographic DFS first tries to traverse the edge labeled a, followed by b and finally c. The
tree R is represented as a balanced parenthesis sequence P together with auxiliary structures
to support the navigational queries on R, as mentioned in Theorem 7, using 2n + o(n) bits.
The bitvector F is used to mark all the final states of the input DFA, hence it takes n bits.
Before explaining the other bitvector, T , required for our succinct encoding, we want
to explain the contents of Figure 4. The tree depicted in the figure is what we call an
extended lexicographic DFS tree or extended lex-DFS tree (denoted by S) in short. If we delete
the squared nodes and their incident edges (originating from the circled nodes), we obtain
the lexicographic DFS tree of the automaton D. Actually these edges represent the back
edges/cross edges/forward edges [5] (i.e., non-tree edges) in the DFS tree of the automaton
D. Traditionally the vertices in the square are not drawn (as in our case of Figure 4), rather
the edges point to the nodes in the circle only (hence all the nodes appear only once). We
have chosen to draw and define the extended lex-DFS tree this way as it helps us to design
and explain our succinct data structure well. Also note that, edges originating from a circled
node and going to another circled node represents tree edges whereas edges from circled to
squared nodes represent non-tree edges.
Now given the extended lex-DFS tree S, we visit the nodes of S in DFS order and append
a bit string of length œÉ for each vertex v of S marking which of its children are attached to v
via tree edges (marked with 1) and which are attached to v via non-tree edges (marked with
0) in the lexicographic order of the edge labels. The string obtained this way is referred to
as T . Thus, T is a bit-vector of length œÉn which captures the information about the tree
and non-tree edges of S. More specifically, it has exactly n ‚àí 1 ones, which have one-to-one
correspondence with the tree edges of the lexicographic DFS tree of DFA D, and has exactly

CVIT 2016

23:10

Succinct Representation for (Non)Deterministic Finite Automata

1

a
2

a

b
4

1

a
2

P

5

3

a

1 2 3 4

3

a

b

4

3

6

b

4
7

(((())(()))())

2

T

a

b

4

5

6

c
3

c

a

1
5 6

4

c

c

b

7

c

b

c

b

1

1

c
3
2

3

4

5

6

7

110 110 010 000 010 000 000

abc abc abc abc abc abc abc
NewBoxed [1..15] = [
6
4 1 4 2 3 1 3 1 4 2 3 4 5 3]

Figure 4 The extended lex-DFS tree S of the automaton of Figure 3 along with the corresponding
bitvectors P , T , and the NewBoxed[1..15] array (the elements of this array are drawn exactly below
the corresponding 0s with which they share one to one correspondence with). Note that, for the
same automaton Boxed[1..15] array is given as Boxed[1..15] = {1, 2, 3, 1, 4, 3, 4, 2, 3, 1, 4, 4, 5, 3, 6}.

(œÉ ‚àí 1)n + 1 zeros, which correspond to non-tree edges of the lexicographic DFS tree of DFA
D. See Figure 4 for an example. We relabel all the states of D such that the i-th vertex
(state) in R in preorder has label i, and also modify the transition function accordingly. Now
it is easy to see that, for the state with label i (1 ‚â§ i ‚â§ n), the corresponding node in the
lexicographic DFS tree has exactly œÉ outgoing edges, and we encode the tree edges among
them using the bits in the range T [œÉ(i ‚àí 1) + 1..œÉi]. More specifically, T [œÉ(i ‚àí 1) + c] = 1 if
and only if the outgoing edge labeled c is a tree edge (1 ‚â§ c ‚â§ œÉ). Similarly, we can also find
the j-th outgoing tree edge from the state i by select1 (T, j + rank1 (T, œÉ(i ‚àí 1))). Finally, we
compress T by observing that the positions of 1s in the T array form an increasing sequence,
hence by using the data structure D(n ‚àí 1, œÉn, ) of Theorem 8, access, rank and select
operations can be supported in constant time. By setting  = 1/ log(œÉ ‚àí 1), T can be encoded
in O(n log œÉ) bits.
Now let us define the new integer array NewBoxed[1..m]. First, observe that elements of
the array Boxed[1..m] are nothing but the leaves (i.e., node labels in the squared nodes) of
the extended lex-DFS tree S in the left to right order. More specifically, they are the node
labels of the destinations of the non-tree edges emanating from the nodes of the lexicographic
DFS tree of the automaton D in their preorder. Instead of this specific ordering (followed
in the Boxed[1..m] array), NewBoxed[1..m] lists the same node labels in the order of their
appearance in the T bitvector (from left to right). Note that, as mentioned previously, these
node are marked by 0s in T and they are in one-to-one correspondence with all the non-tree
edges of the lexicographic DFS tree of the automaton D. Thus, the NewBoxed[1..m] array
contains the same node labels as the Boxed[1..m] array, but in a different order. See Figure 4
for an example. This completes the description of our succinct data structure for DFA. Note
that Max is no longer used in our data structure.
We now analyze the space complexity of our data structure. The array NewBoxed[1..m]

Chakraborty, Grossi, Sadakane and Satti

23:11

takes (œÉ ‚àí 1)n log n + O(log2 m) bits (by similar analysis as before for the Boxed[1..m] array).
As mentioned previously, we store T using Theorem 8, hence it takes O(n log œÉ) bits. The
bitvector F consumes n bits. Finally, the bitvector P is stored using Theorem 7, hence it occupies 2n + o(n) bits in total. Thus, overall our data structure uses (œÉ ‚àí 1)n log n + O(n log œÉ)
bits. Hence, the data structure is succinct. It is easy to further reduce the size if the DFA has
only N < œÉn non-failure transitions. Using the bitvector Z[1..m] for indicating non-failure
transitions, the array NewBoxed[1..m] is compressed to N ‚àí n + 1 non-zero values, and
the total space is (N ‚àí n) log n + O(N log œÉ) bits. In what follows, we describe the string
acceptance query algorithm using our data structures.
Query algorithm. Suppose we are given an input string x of length y over Œ£, and we need
to decide if the DFA D accepts x or not. We start the following procedure from the initial
state (stored explicitly using O(log n) bits) and repeat until the end of the input string x.
At any generic step, to figure out the transition function Œ¥(q, c) := q 0 where 1 ‚â§ q, q 0 ‚â§ n
are the states, we first look at the bit T [œÉ(q ‚àí 1) + c]. If it is 1, the outgoing edge labeled c
from state q is a tree edge. Let j := rank1 (T, œÉ(q ‚àí 1) + c) ‚àí rank1 (T, œÉ(q ‚àí 1)). Then the
outgoing edge is the j-th tree edge of node q in the lex DFS tree. Therefore q 0 = child(q, j)
(supported using the Theorem 7). If the bit is 0, the outgoing edge labeled c from state
q is a non-tree edge. Let j := rank0 (T, œÉ(q ‚àí 1) + c). Then the edge is the j-th non-tree
edge in the DFA, and q 0 is obtained by q 0 := NewBoxed[j]. Hence, when we reach the end
of x, and if we are at an accepting/final states (can be figured out from the bitvector F ),
we say that the DFA D accepts x. The rank operations on T take O(log œÉ) time while all
other operations, at each step, take O(1) time. Thus the overall run time for checking the
membership of an input string x is O(|x| log œÉ). This completes the proof of Theorem 1.
Remark: In the light of the above discussion, consider the following. Suppose we are
given as input a succinct representation for a DFA D whose language is L(D), and our goal
is to construct the succinct representation for the DFA (say D0 ) which accepts complement
of L(D) i.e., L(D0 ) = Œ£‚àó ‚àí L(D). In order to construct the succinct representation for D0 ,
we start with the succinct representation for D (that is given in terms of three bit vectors
F, P, T and the integer array NewBoxed[1..m]), and simply convert (in the F array) each
final state in D into a non-final state in D0 and convert each non-final state in D into a final
state in D0 without changing any other data structures. As a consequence, it is easy to see
that, we will end up with what we desired.

3.3

Succinct Data Structures for Acyclic DFA

As mentioned previously, an acyclic DFA A with total n states always has a unique dead
state and n ‚àí 1 transient (i.e., non dead) states. Another way to visualize A is to see that
the state transition diagram of A does not have any cycles except at the unique dead state.
Given such a setting, one can always use the succinct encoding (of the previous section) of an
arbitrary DFA to represent them. In that case, we end up using (œÉ ‚àí 1)n log n + O(n log œÉ)
bits of space. In what follows, we show that by exploiting the acyclic property, one can
obtain improved space bound for representing A.
We basically view the state transition diagram of A as a directed acyclic graph with a
single source (i.e., the initial state), and a single sink i.e., the dead state (call it d). Given
this, we first construct a spanning tree W = (V, E) of A where V = Q (i.e., the set of states
of A) and E = {(qu , qv ) | Œ¥(qv , œÉ) = qu where qv 6= d} by making the dead state d as the
root of this tree. It is easy to see that such a spanning tree can always be constructed.
By applying Theorem 7, we encode the structure of W using 2n + o(n) bits to support

CVIT 2016

23:12

Succinct Representation for (Non)Deterministic Finite Automata

the navigational queries on W (in particular, the parent query) in O(1) time. As done
previously in Section 3.2 while constructing the succinct data structures for DFA, here also
we relabel all the states of A such that the i-th vertex (state) in W in preorder has label
i, and modify the transition function accordingly. Note that the dead state d is labeled
with label 0 in this ordering, and we do not need to store the transition function for the
dead state. We also mark in a bitvector of size n all the final states of A, and we store the
label of the start state. We then store a two dimensional array L[1..n ‚àí 1][1..œÉ ‚àí 1] such
that L[q][i] = Œ¥(q, i) using data structure of Theorem 9. Thus, the overall space usage is
(œÉ ‚àí 1)(n ‚àí 1) log n + 3n + O(log2 œÉ) + o(n) bits.
In what follows, we explain how to check if A accepts any given string x over Œ£. At any
generic step, to compute Œ¥(q, i), we simply output L[q][i] if i ‚àà {1, 2, . . . , œÉ ‚àí 1}; otherwise
(i.e., if i = œÉ) the value of Œ¥(q, œÉ) is given by the parent of q in W i.e., Œ¥(q, i) = parent(q).
Thus Œ¥(q, i) can be computed in constant time, and hence we can optimally decide if A
accepts x in time proportional to the length of x. This completes the proof of Theorem 2.

3.4

Succinct Encoding for NFA

As mentioned previously in Section 1.2, to encode an initially connected NFA on n states
over a œÉ-letter alphabet Œ£ with a fixed initial state and one or more final states, we need at
least œÉn2 + n bits. In what follows, we show a very simple scheme achieving this bound.
We store a table H having n rows (corresponding to the n states of the input NFA)
and œÉ columns (corresponding to each letter of the alphabet Œ£). The entry H[i][j] (where
0 ‚â§ i ‚â§ n ‚àí 1 and 1 ‚â§ j ‚â§ œÉ) basically stores the corresponding transition function of the
NFA i.e., H[i][j] = Œ¥(qi , j) where qi ‚àà Q and j ‚àà Œ£. Now for an NFA, Œ¥(i, j) is a subset of Q.
If we store this subset explicitly, it might take O(n log n) bits in the worst case per transition
of the NFA, leading to overall œÉn2 log n bits which is O(log n) multiplicative factor off from
the optimal space requirement. Instead we simply store the charecteristic vector L of the
subset (of length n, marking the corresponding states from the subset as 1, and rest of the
bits in L are 0) where the state labeled i of the NFA moves to after reading the letter j ‚àà Œ£.
Thus, the overall size of H is exactly œÉn2 bits. Finally, we also mark in a separate bitvector
(of length n) all the final states of the input NFA. Thus, in total the size of our encoding is
given by œÉn2 + n bits, which matches the lower bound. Hence, our encoding is succinct and
optimal.
Now using our encoding, we can simply implement the classical algorithm (given in the
texts of [14, 23]) for checking if the NFA accepts a given input string or not, and this runs in
O(n2 |x|) time where x is the input string and |x| denotes its length. Note that we also need
two bitvectors of length n each (hence overall 2n bits) as working space to mark two sets
of intermediate states between successive transitions while executing the string acceptance
checking algorithm. Hence, we obtain the result mentioned in Theorem 3.

4

Concluding Remarks

We considered the problem of succinctly encoding any given DFA D, acyclic DFA A or NFA
N so as to check efficiently if they accept a given input string. To this end, we successfully
designed succinct data structures for them that also support the string acceptance query
efficiently for DFAs, acyclic DFAs, and NFAs. To the best of our knowledge, our work is the
first attempt to encode any mathematical models from the world of automata theory using
the lens of succinct data structures, and we believe that our work will spur further interest
in other similar problems in future.

Chakraborty, Grossi, Sadakane and Satti

23:13

References
1
2
3
4
5
6
7

8
9
10

11
12
13
14
15
16
17
18
19
20
21
22
23
24

H. Acan, S. Chakraborty, S. Jo, and S. R. Satti. Succinct data structures for families of
interval graphs. In WADS, 2019.
L. C. Aleardi, O. Devillers, and G. Schaeffer. Succinct representations of planar maps.
Theor. Comput. Sci., 408(2-3):174‚Äì187, 2008.
F. Bassino and C. Nicaud. Enumeration and random generation of accessible automata.
Theor. Comput. Sci., 381(1-3):86‚Äì104, 2007.
D. R. Clark. Compact Pat Trees. PhD thesis. University of Waterloo, Canada, 1996.
T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein. Introduction to Algorithms (3.
ed.). MIT Press, 2009.
R. Diestel. Graph Theory, 4th Edition, volume 173 of Graduate texts in mathematics.
Springer, 2012.
M. Dietzfelbinger, A. R. Karlin, K. Mehlhorn, F. Meyer auf der Heide, H. Rohnert, and
R. E. Tarjan. Dynamic perfect hashing: Upper and lower bounds. SIAM J. Comput.,
23(4):738‚Äì761, 1994.
Y. Dodis, M. Patrascu, and M. Thorup. Changing base without losing space. In STOC,
pages 593‚Äì602, 2010.
M. Domaratzki. Enumeration of formal languages. Bulletin of the EATCS, 89:117‚Äì133,
2006.
M. Domaratzki, D. Kisman, and J. Shallit. On the number of distinct languages accepted
by finite automata with n states. Journal of Automata, Languages and Combinatorics,
7(4):469‚Äì486, 2002.
A. Farzan and S. Kamali. Compact navigation and distance oracles for graphs with small
treewidth. Algorithmica, 69(1):92‚Äì116, 2014.
A. Farzan and J. I. Munro. Succinct encoding of arbitrary graphs. Theor. Comput. Sci.,
513:38‚Äì52, 2013.
P. Flajolet and R. Sedgewick. Analytic Combinatorics. Cambridge University Press, 2009.
J. E. Hopcroft, R. Motwani, and J. D. Ullman. Introduction to automata theory, languages,
and computation - international edition (2. ed). Addison-Wesley, 2003.
G. J. Jacobson. Succinct static data structures. PhD thesis. Carnegie Mellon University,
1998.
V. A. Liskovets. Exact enumeration of acyclic deterministic automata. Discrete Applied
Mathematics, 154(3):537‚Äì551, 2006.
J. I. Munro, R. Raman, V. Raman, and S. S. Rao. Succinct representations of permutations
and functions. Theor. Comput. Sci., 438:74‚Äì88, 2012.
J. I. Munro and V. Raman. Succinct representation of balanced parentheses and static
trees. SIAM J. Comput., 31(3):762‚Äì776, 2001.
J. I. Munro and K. Wu. Succinct data structures for chordal graphs. In ISAAC, pages
67:1‚Äì67:12, 2018.
G. Navarro. Compact Data Structures - A Practical Approach. Cambridge University Press,
2016.
G. Navarro and K. Sadakane. Fully functional static and dynamic succinct trees. ACM
Transactions on Algorithms, 10(3):16, 2014.
R. Raman, V. Raman, and S. R. Satti. Succinct indexable dictionaries with applications
to encoding k-ary trees, prefix sums and multisets. ACM Trans. Algorithms, 3(4):43, 2007.
M. Sipser. Introduction to the theory of computation. PWS Publishing Company, 1997.
K. Sumigawa and K. Sadakane. An efficient representation of partitions of integers. In
IWOCA, pages 361‚Äì373, 2018.

CVIT 2016

23:14

Succinct Representation for (Non)Deterministic Finite Automata

A
A.1

Appendix
Supporting More Operations (Union and Intersection)

In what follows we show how to support some standard operations on DFAs space efficiently.
We start with the classical example of product automaton construction. More specifically,
given the succinct representation of two DFAs, we want to construct a succinct representation
of the product automaton accepting the language which is the union/intersection of the
two input DFA‚Äôs language. Before providing our construction, let us formally define the
product automaton construction. Suppose, we are given two DFAs D1 = (Œ£, Q, q0 , Œ¥, F ) and
D2 = (Œ£, Q0 , q00 , Œ¥ 0 , F 0 ) represented succinctly (as described in Section 3.2) and both working
over the same alphabet Œ£. Then a product automaton (denoted by P) of D1 and D2 is defined
as follows, P = (Œ£, Q, (q0 , q00 ), Œ¥p , Fp ) where Q = Q √ó Q0 , and Œ¥p : Q √ó Œ£ ‚Üí Q. Moreover, for
any q ‚àà Q, q 0 ‚àà Q0 and c ‚àà Œ£, Œ¥p ((q, q 0 ), c) := (Œ¥(q, c), Œ¥ 0 (q 0 , c)). The start state of P is the
pair (q0 , q00 ) whereas the final state can be defined in multiple ways. More specifically, if we
set Fp = F √ó F 0 , then L(P) = L(D1 ) ‚à© L(D2 ). Similarly, if we set Fp = (F √ó Q0 ) ‚à™ (Q √ó F 0 ),
then L(P) = L(D1 ) ‚à™ L(D2 ). Now we show how one can directly construct a succinct
representation of P given the succinct representations of D1 and D2 as input, and note that,
to do so we just need to describe how one can create the three bitvectors F, P, T and the
integer array NewBoxed[1..m] corresponding to P from the succinct representations of D1
and D2 directly. See Figure 5 and Figure 6 for a visual description of our product automaton
construction algorithm.
For constructing the product automaton P, our high level idea is to create the states
and transitions of P by generating the states of P in the lexicographic DFS order using two
passes. In the first pass, we generate the P and T arrays (both initialized with empty string),
and this is followed by the construction of the NewBoxed[1..m] array in the second pass.
More specifically, we start by creating the initial state i.e., (q0 , q00 ) as the first circled node
i.e., root in the extended lex-DFS tree corresponding to P, store an entry corresponding to
this node in the hash table along with storing its preorder number (which is 1 in the case of
(q0 , q00 )) as a satellite data in the hash table. Also we append œÉ zero bits to T corresponding
to the root. In general, at any point of time during the execution of this algorithm, the hash
table stores an entry corresponding to each of the circled nodes generated upto that point
along with storing its preorder number and its parent node as satellite data. Note that for
the root, we don‚Äôt need to store any parent information. Now to figure out the transitions
out of any state, note that, if we use the method described in the query algorithm for DFA
(as described in Section 3.2) we need to pay O(log œÉ) time per symbol of the alphabet Œ£.
Instead, in what follows, we show how one can find each transition in O(1) time per symbol
out of any state using all the information that is already stored in the input i.e., succinct
representations for D1 and D2 . Assume for now that we can do so and also suppose that
at some point of the algorithm, we created a new circled node (i, i0 ). Then we proceed as
follows. First we append œÉ zero bits to the bit string T corresponding to the node (i, i0 ).
This is followed by the expansion of the state (i, i0 ) by generating the transitions Œ¥p ((i, i0 ), c)
in the lexicographic ordering of the alphabet characters c ‚àà Œ£, as follows. Let j = Œ¥(i, c) and
j 0 = Œ¥ 0 (i0 , c), then we check in the hash table if the state (j, j 0 ) has already been created
before (by checking membership in the hash table). If yes, we create a squared node (j, j 0 )
as a child node of (i, i0 ) (which is a circled node) and don‚Äôt make any changes to the P
array, mark the c-th bit corresponding to the node (i, i0 ) in T as zero; and continue with the
expansion of (i, i0 ) with the next character in Œ£. If not, we create a circled node (j, j 0 ) as a
child of (i, i0 ), append an open parenthesis to the P array constructed so far, mark the c-th

Chakraborty, Grossi, Sadakane and Satti

b,c

a,c

a

q0

q1

b,c

23:15

a

b

q‚Äô0

q‚Äô1

b

a,c

Figure 5 The state transition diagram for a DFA D1 (on the left) where D1 = (Œ£, Q, q0 , Œ¥, F )
such that (i) Œ£ = {a, b, c}, (ii) Q = {q0 , q1 }, (iii) q0 = q0 (marked with an incoming arrow coming
from nowhere), (iv) F = {q1 }, and (v) the transition function is defined as the following set,
{Œ¥(q0 , a) = q1 , Œ¥(q0 , b) = q0 , Œ¥(q0 , c) = q0 , Œ¥(q1 , a) = q1 , Œ¥(q1 , b) = q0 , Œ¥(q1 , c) = q0 }. Precisely the
DFA D1 accepts all the strings that end with an a over Œ£. Similarly the state transition diagram for
a DFA D2 (on the right) where D2 = (Œ£, Q0 , q00 , Œ¥ 0 , F 0 ) such that (i) Œ£ = {a, b, c}, (ii) Q = {q00 , q10 },
(iii) q00 = q00 (marked with an incoming arrow coming from nowhere), (iv) F = {q10 }, and (v) the
transition function is defined as the following set, {Œ¥(q00 , a) = q00 , Œ¥(q00 , b) = q10 , Œ¥(q00 , c) = q00 , Œ¥(q10 , a) =
q00 , Œ¥(q10 , b) = q10 , Œ¥(q10 , c) = q00 }. Precisely the DFA D2 accepts all the strings that end with a b over
Œ£. These two DFAs will serve as the working example for our discussion of the product automaton
construction.

bit corresponding to the node (i, i0 ) in T as one, and finally insert (j, j 0 ) into the hash table
along with inserting (i, i0 ) as its parent and its preorder number as its satellite data; and
continue with the expansion of (j, j 0 ). Finally, when we exhaust checking all the characters
c ‚àà Œ£ out of (i, i0 ), we backtrack to the parent of (i, i0 ) in the extended lex-DFS tree (using
the parent information stored as a satellite data with the entry for the node (i, i0 )), and in
this case, we simply append a close parenthesis to the P array constructed so far. It is clear
that using this procedure repeatedly we can successfully create P and T arrays corresponding
to the product automaton P. Finally, we create the all the auxiliary structures (mentioned
in Section 2.2) on top of the arrays P and T (similar to the succinct data structure for DFA
as described in Section 3.2) for supporting various navigational queries on the extended
lex-DFS tree. Intuitively the P array stores the topology of the extended lex-DFS tree of the
state transition diagram of the product automaton P and the T array stores the parent-child
relationship between the nodes of the extended lex-DFS tree in a compact manner. Now
let‚Äôs discuss how to find out the transitions efficiently. Note that it suffices to describe how
one can find j = Œ¥(i, c) in D1 (j 0 = Œ¥ 0 (i0 , c) in D2 can be found similarly). We consider
the two cases: when the edge (i, j) is a (i) non-tree edge, or a (ii) tree edge. In case (i),
j = NewBoxed[rank0 (T, œÉ(i ‚àí 1) + c)]. In case (ii), j = child(i, t) (can be supported using
the Theorem 7 on the P array) where t = rank1 (T, œÉ(i ‚àí 1) + c) ‚àí rank1 (T, œÉ(i ‚àí 1)).
In what follows, we describe how one can fill up the integer array NewBoxed[1..m] with m
(we discuss about fixing m later) entries which are initialized with all one. Note that, similar
to the succinct DFA construction, this array should contain the preorder number of the node
labels in the squared nodes of the extended lex-DFS tree in the order of their appearance
in the T bitvector (from left to right). Moreover, these node are marked by 0s in T and
they are in one-to-one correspondence with all the non-tree edges of the extended lex-DFS
tree of the product automaton P. To fill up NewBoxed[1..m] array, we follow essentially the
same lexicographic DFS traversal procedure as we did in the first pass except the following.

CVIT 2016

23:16

Succinct Representation for (Non)Deterministic Finite Automata

c

a

q0,q‚Äô0

b

c

q1,q‚Äô0

c
b

a

q0,q‚Äô1

q0,q‚Äô0

a

q1,q‚Äô0 q0,q‚Äô1

c

Node
pair

q0,q‚Äô0

Preorder
number

q0,q‚Äô1 q0,q‚Äô0

q1,q‚Äô0 q0,q‚Äô0

2

c

q0,q‚Äô1 q1,q‚Äô0

3

b

q0,q‚Äô1

q0,q‚Äô0
1

1

Parent
node

1

c

b

a

q1,q‚Äô0

b

q0,q‚Äô0 Null

a

q1,q‚Äô0

b

a

2 3

P ( ( ( ) ) )

T

2

3

100 010 000

NewBoxed[1..7]= {

a b

c

3

1

a

2

b c

a

b c

1

2

3 1}

Figure 6 The state transition diagram on the top depicts the product automaton P accepting
the language L(D1 ) ‚à™ L(D2 ) (DFA D1 and D2 are defined in Figure 5). The diagram on the bottom
left depicts the extended lex-DFS tree of the product automaton P (defined above) whereas the rest
of diagram contains the description of the other data structures i.e., the bitvectors P, T , the integer
array NewBoxed[1..7], and finally the hash table. Note that the elements of the NewBoxed[1..7]
array are drawn exactly below the corresponding 0s with which they share one to one correspondence
with.

Chakraborty, Grossi, Sadakane and Satti

23:17

More specifically, we start the second pass of the extended lex-DFS tree and whenever we
encounter a non-tree edge, we retrieve the preorder number corresponding to the node label
in the squared node (i.e., the other end point of that non-tree edge) from the hash table,
and insert this number at the suitable position in the NewBoxed array. In detail, suppose
we are at a circled node (i, i0 ) (with preorder number, say, k) and currently exploring the
transition with the letter c ‚àà Œ£ out of (i, i0 ). Also assume that Œ¥p ((i, i0 ), c) = (j, j 0 ) and
(j, j 0 ) is a squared node (i.e., ((i, i0 ), (j, j 0 )) is a non-tree edge) such that the preorder number
associated with the node label (j, j 0 ) is d in the hash table. Then, we assign NewBoxed[`] = d
where ` = rank0 (T, œÉ(k ‚àí 1) + c). Finally, depending on union or intersection operation, we
also mark in another bitvector F (according to the definition given above) all the final states
of the product automaton P. Observe that once we have all the constituent data structures
(including all the auxiliary data structures that we build on top of F, P, T arrays and the
integer array NewBoxed[1..m]) for the succinct representation for P ready, we can essentially
use the same query algorithm for string acceptance checking as we described for DFA in
Section 3.2.
Let‚Äôs analyze the resource requirements for our algorithm. Suppose |Q| = n and |Q0 | = n0 ,
then the product automaton P can have nn0 states at the worst case, but in general it
could be much less as well. Let us suppose that P has n00 states, then n00 ‚â§ nn0 , and in
what follows, we write our space requirement as a function of n00 . If we implement the
hash table using the data structure of [7], then it consumes O(n00 log n00 ) bits in total. Also
note that this is the dominating term for the working space bound as other auxiliary data
structures consume negligible space with respect to the space consumption for the hash table.
Moreover, our algorithm runs in linear (in n00 ) expected time overall. The randomized nature
of our algorithm is due to the fact of using the hashing data structure of [7] whereas all
the other parts of our algorithm is deterministic. As a result of our algorithm, we generate
a representation for P and this is given by the following arrays. The bitvectors P and F
consume 2n00 + o(n00 ), n00 bits respectively. For the T array, we compress it by observing
that the positions of 1s in the T array form an increasing sequence, hence by using the
data structure D(n00 ‚àí 1, œÉn00 , ) of Theorem 8, access, rank and select operations can be
supported in constant time, and by setting  = 1/ log(œÉ ‚àí 1), T can also be encoded in
O(n00 log œÉ) bits. Finally, the NewBoxed array has m entries where m = (œÉ ‚àí 1)n00 + 1 and
each entry could be upto n00 . Thus, using the data structure of Theorem 9, NewBoxed[1..m]
can be encoded using (œÉ ‚àí 1)n00 log n00 + O(log2 m) bits. Thus, our algorithm produces a
representation of the product automaton P using (œÉ ‚àí 1)n00 log n00 + O(n00 log œÉ) bits overall,
and this is succinct. This completes the description of the product automaton construction
algorithm as stated in Theorem 4.

CVIT 2016

