arXiv:1909.06997v2 [cs.DB] 31 Jan 2020

MVDLite: A Light-weight Model View Definition
Representation with Fast Validation for Building
Information Model
Han Liua , Ge Gaoa , Hehua Zhanga , Yu-Shen Liua , Yan Songb , Ming Gua
a
School of Software, Tsinghua University, Beijing, China
Beijing National Research Center for Information Science and Technology (BNRist)
Key Laboratory for Information System Security, Ministry of Education (KLISS), China
b
Wanda Commercial Planning and Research Institute CO., LTD. Beijing, China

Abstract
Model View Definition (MVD) is the standard methodology to define the
exchange requirements and data constraints for Building Information Model
(BIM). In this paper, MVDLite is proposed as a novel light-weight representation for MVD. Compared with mvdXML, MVDLite is more concise and
could be used in more flexible scenarios. MVDLite introduces a “rule chain”
structure to combine the subgraph templates and value constants, based on
which a fast MVD validation algorithm is proposed. It is also compatible
with the current mvdXML format, and supports bi-directional conversion
with mvdXML. A case study is provided to show the workflow for developing an enterprise-level MVD based on MVDLite, and its applications in
MVD validation and partial model extraction. The outperforming experimental results show that our method is much faster than the state-of-the-art
methods on large real-world models.
Keywords:
Model View Definition (MVD); Industry Fundamental Classes (IFC);
Building Information Model (BIM)
1. Introduction
Industry Foundation Classes (IFC) is a standard open data schema for
Building Information Model (BIM). IFC is widely used as an information
exchange format in the architectural, engineering and construction (AEC)
Preprint submitted to Automation In Construction

February 3, 2020

field. For supporting the exchange of various building information from various software platforms, IFC defines a general-purpose data schema with
coarse-grained entity types (such as “IfcWindow” and “IfcDoor”), various
geometry representations (such as “IfcExtrudedAreaSolid” and “IfcFacetedBrep”), relationships (such as “ConnectedTo” and “IsDecomposedBy”), and
the data structure for properties (such as “IfcPropertySet” and “IfcPropertySingleValue” ). However, since IFC has strong compatibility for various
contents, different software platforms may have various implementations in
the importing and exporting of data. Without sufficient constraints for the
entities, geometry representations, relationships, and property definitions,
the data exchange process between different software platforms will suffer
from information loss or inapplicability.
In order to ensure the interoperability of IFC in specific data exchange
use cases, the Information Delivery Manual (IDM) - Model View Definition
(MVD) method [1, 2, 3] is proposed as a recommended standard methodology
to support specific data exchange requirements. IDM describes the working
process and exchange requirements in the use cases. MVD defines the subsets
of a specific IFC Schema, with constraints on entities, attributes, geometry
representations and so on.
The mvdXML [4] is the formal representation format for MVDs recommended by buildingSMART. There are two major parts of contents in
mvdXML: the natural language descriptions of domain concepts and exchange requirements, and the rules for data templates, attributes, and values. The mvdXML rules can be parsed by computers, which can be used
for supporting software implementation in IFC-based data exchange, and for
supporting automatic MVD validation on IFC models [5, 6].
Currently, the developers of MVDs are primarily academic institutions
and standardization organizations, such as buildingSMART and National
Institute of Building Sciences (NIBS). The MVDs developed by these organizations are mainly focused on the use cases of a certain discipline (such
as walls, water systems, and HVAC systems), or the information exchange
requirement of a certain application (such as quantity take-off and energy
simulation).
In mvdXML, the data templates are represented separately from the rule
statements. The data templates are in XML tags and the rules are written in
“mvdXML Rule Grammar” statements, so that the templates can be reused
in multiple rule statements. Generally, professional tools like ifcDoc [7] are
needed to generate mvdXML rulesets. Some other enterprise-standard tools
2

like BIMQ [8] can not fully utilize the expressiveness of MVD, i.e. it is not
supported to create arbitrary mvdXML rules (such as the constraints about
geometry representations, colors, or various relationships). The mvdXML
files are not concise enough to be edited in text editors or embedded in the
forms in such applications. Besides, It could take hours to validate a largescale model against an enterprise-level mvdXML, which makes it hard to be
adopted in real projects. As a result, the application of mvdXML in flexible
scenarios is still limited.
In this paper, MVDLite is proposed as a novel light-weight MVD language. MVDLite is more concise and has a more flexible rule structure, and
also compatible with the current mvdXML format. It is suitable for editing in sentences in text editors or embedding in a table. It also supports
faster MVD validation on large-scale models and rulesets. In addition, the
MVDLite rulesets are easier switching between different IFC schema versions
like IFC2X3 and IFC4.
Our main contributions are listed as follows.
• A novel MVD rule grammar is proposed with a new combined structure for the data templates, attribute values, and logical operators (see
Section 3).
• A new MVD validation algorithm is proposed based on the novel rule
structure of MVDLite, which is much faster than the mvdXML-based
MVD validation algorithm (see Section 4).
• A case study is provided to show the MVDLite-based workflow for
customizing an enterprise-level MVD, and the applications in MVD
validation and partial model extraction on large real-world models (see
Section 5).
2. Related Work
2.1. Methods for MVD Representation and Development
In the IDM-MVD method, IDM is mainly about the definition of data
delivery process, exchange requirements, and functional parts, and MVD is
about the technical solution of IDM in the IFC data format. MVD binds the
domain entities in the exchange requirements to the IFC entities and constrains the required information for geometry, attributes and relationships.

3

The definitions and constraints in MVD intend to support meaningful IFC
implementations for software developers [3].
There have been several studies on MVD representation and development
from different aspects. The Extended Process to Product Modeling (xPPM)
[9] is based on the formal definition of IDM, and provides a tool for mapping the IDM functional parts to MVD. The Semantic Exchange Modules
framework (SEM) [10] is based on the object-oriented definition of domain
concepts in ontologies. SEM provides a mapping between the domain entity
concepts and the data structure concepts in specific data forms. The Generalised Model Subset Definition (GMSD) [11] is based on the specification
of rules for selecting a subset of entities from the IFC model. In summary,
xPPM focuses on the process of mapping IDM to MVD, SEM focuses on the
definition of domain concepts, and GMSD focuses on the rule constraints for
partial models.
Based on the previous researches about MVD, an integrated IDM-MVD
process for IFC data exchange is proposed and recommended by buildingSMART [2], which combines the strengths of the previous researches. The
mvdXML format [4] is used for this integrated IDM-MVD process, which involves abundant information about exchange requirements, domain concepts,
and rule constraints. The recommended IDM-MVD process mainly include:
• Defining the domain concepts (entities, properties, and geometries),
relationships and rule constraints in an Exchange Requirements Model
(ERM) as forms and diagrams.
• Binding the concept definitions in the ERM into a specific IFC Release
(such as IFC4).
• Writing the relationships and rule constraints into a specific IFC Release as MVD Implementation Guidance forms and diagrams.
• Implement the mvdXML according to the concept bindings, forms, and
diagrams.
The mvdXML format has been widely accepted and is supported by the
newer versions of xPPM and SEM.
In addition to MVD, there are some other studies on the definition of
IFC partial models, mainly based on domain ontologies [12, 13, 14, 15] or
domain-specific query languages [16, 17, 18, 19, 20, 21, 22, 23]. MVD is
4

currently accepted by the mainstream because it can integrate the exchange
requirements and the data constraints required in software implementation.
2.2. The mvdXML Format
Currently, the most widely used version of mvdXML is V1.1 [4]. In this
paper, all the analyses and experimental comparisons are based on mvdXML
V1.1. An example ruleset in mvdXML format is shown in Figure 2 (b).
The mvdXML format involves natural language definitions (exchange requirements and entity types) and rules (subgraph structures and value constraints). Subgraph structures are defined in the ConceptTemplate tags at
the beginning of the file, and the other contents are included in ModelView
tags at the body part.
• A subgraph structure is defined as a ConceptTemplate, which represents
the subgraph pattern, attributes, and entity types are defined in a
nested XML structure. Each ConceptTemplate is with a GUID and
each attribute is assigned with a RuleID. One ConceptTemplate can
also be referred to in another ConceptTemplate as a subtemplate.
• A exchange requirement is defined as a ExchangeRequirement tag in a
ModelView tag. Each ExchangeRequirement is with a GUID.
• An entity type is defined as a ConceptRoot tag, which corresponds to
a subset of entities of an IFC entity type (i.e. the “applicableRootEntity”). An Applicability rule is used to distinguish this subset of entities
from all root entities.
• A value constraint rule is defined as a Concept tag inside a ConceptRoot. Each Applicability rule and Concept rule should refer to a ConceptTemplate with GUID, and the rules are written in “mvdXML Rule
Grammar”. One Concept can also refer to several ExchangeRequirements with GUID.
One important feature of the representation of rules in mvdXML is the
separation of templates and rule statements. The templates of IFC subgraph
structures are defined in ConceptTemplate tags, and each rule statement
should refer to a ConceptTemplate with GUID, so that the RuleIDs defined
in the template can be used to compose the rule statement. The benefit of this
separation is that the templates can be reused in multiple rule statements.
5

While as a result, the “mvdXML Rule Grammar” must rely on the complete
XML structure. It can not be used independently as a query language or
rule language since it needs the ConceptTemplates defined in XML.
The separation of templates and rule statements leads to two corresponding different logical operators in mvdXML: the logical operators inside one
statement are represented as keywords (AND, OR, XOR, NOT), while the logical operators between different statements are represented in the XML structure, such as “<TemplateRules operator=“or”> ... </TemplateRules>”.
The two types of logical operators are not equivalent, and usually, they can
not replace each other. The detailed difference between them is explained in
Section 2.4.
2.3. The Process of Developing MVDs
In the buildingSMART document about integrated IDM-MVD process
[2], the authors acknowledge that “MVD development is much more technical work that requires expertise in software, the IFC Schema, construction
industry, and data modeling ... It requires in-depth knowledge of the information model(s) for which bindings will be defined, as well as a good
understanding of the requirements (and industry process) described in the
IDM.”
The MVD development process is a collaboration between domain engineers and MVD experts. The domain engineers are the originators of exchange requirements. They inform the MVD expert with the understandings
of element types, properties and exchange requirements in natural language.
An MVD expert requires both domain knowledge (about domain concepts
and exchange requirements) and data knowledge (about IFC data structure
and mvdXML format). The tasks of an MVD expert mainly include: understanding exchange requirements, mapping domain concepts into IFC, drawing diagrams, editing ConceptTemplates, and writing rules. The tasks are
usually done in tools such as ifcDoc. Due to the knowledge threshold and
workload of developing MVDs, currently, most MVDs are developed by academic institutions and standardization organizations.
Some studies consider using ontology-based process [24, 25, 26, 27, 28] to
assist the creation of MVD. Such methods formalize the exchange requirements, domain concepts and constraints described in IDM-MVD as domain
ontologies, and then generates mvdXML by means of automatic conversion.
Ontology-based MVD creation is modularized and reusable. When sufficient domain concepts are represented in ontology, the efficiency of building
6

mvdXML can be significantly improved. In addition, the rule constraints can
be formally represented using rule languages such as SPARQL and SWRL.
However, since the ontology-based process requires additional knowledge
about ontology and ontology editing tools like Protégé [29], it is mainly used
in academic institutions.
2.4. Automated MVD Validation
In order to realize the practical application of MVD, an important supporting application is to automatically verify the conformity of the model
with MVD. Chi Zhang et al. summarized a three-step framework for automated model view checking [5], including the development of model view rulesets, check execution, and report generation. Currently, automatic model
view validation applications have been implemented on several software platforms, including Solibri Model Checker (SMC) [30], xBIM [31, 31], BIMserver
[32, 5], and Simplebim [33].
The mvdXML validation algorithm is formulated according to the way
rules are organized in mvdXML, so the current MVD validation tools all have
similar implementations. In mvdXML, one “rule” (in Applicability or in Concept) is composed of a root entity set, a ConceptTemplate, several “mvdXML
Rule Grammar” statements, and the logical combination of the statements.
Since templates and statements are separated, the validation process follows
“first matching the template and then checking the statements”. The steps
of getting the Boolean result of one root entity is as follow:
1. For one root entity, there are usually multiple subgraphs that can match
the same template. For example, if one root entity has 5 properties
and each property is an “IfcProperty” node, then for this root entity,
there are 5 subgraphs that can match the template for this rule about
properties.
2. For each statement, the Boolean result of one root entity is obtained
according to whether there exists a subgraph that satisfies the rule
statement.
3. The final Boolean result of one root entity is the logical combination
of the Boolean results obtained from each statement.
In this validation process, two different types of logical operators are
used. The logical operators inside each statement are used in step 2, which
are calculated by one statement on one subgraph. While the logical operators
7

in XML tags are used in step 3, which is the combination of Boolean results
from all subgraphs and all statements. There is a common misunderstanding
that “the two types of logical operators are equivalent”. While according to
the mvdXML documentation and the implementation of mvdXML validation
algorithms, they are not equivalent, and usually they can not replace each
other.
Usually, the IFC model of a real project typically exceeds millions of
nodes, with hundreds of megabytes of data. Although different strategies
like caching and pruning are applied in different software implementations,
the efficiency of mvdXML validation on large scale models is still a challenge.
Some other researches focused on modularized MVD validation methods.
The mvdXML developer team categorized the mvdXML-based automated
validation tasks [34], including the existence of attributes, the size of collections, the uniqueness of values, etc. Yong-Cheol Lee et al. also similarly
categorized the rules in MVD [35, 36, 37]. Such modularized MVD validation
methods implement program modules for the commonly-used MVD validation tasks (such as the value of attributes or the existence of relationships),
but can not support the validation for arbitrary mvdXML rules.
3. The MVDLite Language
Currently, although mvdXML has been widely accepted by the academic
community, not many companies have the ability to customize MVDs according to their own domain concept definitions and exchange requirements.
For domain engineers, there is a demand to read and understand MVD rules,
so that they can give feedback to the MVD experts, and edit the rules themselves if needed. However, the domain engineers may have never used XML,
so it is hard for them to read mvdXML rules without the help of tools like
ifcDoc [7]. In addition, for MVD experts, it is also difficult to write or edit
mvdXML correctly without the help of such tools due to the strict XML
format and UUID references. As a result, the application of mvdXML in
flexible scenarios is limited.
In this paper, MVDLite is proposed as a novel representation of MVD
rules. The main features of MVDLite are:
• Light-weight: the data size of an MVDLite ruleset is smaller than its
equivalent mvdXML ruleset.

8

• Flexibility: compared with the “mvdXML Rule Grammar”, MVDLite is
a stand-alone MVD rule language that combines both subgraph structures and value constraints, which is suitable to be flexibly edited without relying on the ifcDoc tool.
• Faster validation: the validation algorithm based on the rule structure
of MVDLite runs faster on large real-world models.
By mapping the rule segments (about IFC data structures and value
constraints) into natural language terms, MVDLite is with good readability
for common domain engineers. Besides, the natural language mapping makes
MVDLite ruleset easier to be switched between different IFC schema versions
(such as IFC2X3 and IFC4).
3.1. The Grammar of MVDLite
The grammar of MVDLite is designed based on three basic ideas:
• Combining the data templates, attribute values, and logical operators
in one consistent and concise grammar.
• Mapping the data structure rule segments into natural language terms,
and organize the rules with such natural language terms.
• Keeping MVDLite compatible with mvdXML, and supporting bi-directional
conversion with mvdXML rules.
There are three types of expressions in MVDLite grammar, the rule expression, concept expression, and abbreviation expression. The rule
expression is the core of MVDLite, which represents the data templates, attribute values, and logic operators. The other two are used for replacing data
structure definitions with natural language terms, which makes MVDLite
easier to use. An example ruleset in MVDLite is shown in Figure 1. The
full definition of the MVDLite grammar is included in the Appendix (see
Figure A.12 and Figure A.13).
3.1.1. Rule Expression
The basic grammar structure of an MVDLite rule expression is the “rule
chain”. A rule segment is the representation of a rule as a mapping from
input nodeset to output nodeset. There are three types of rule segments
(attribute segment, metric segment, and compound segment). A rule chain
9

instancePset as (IfcObject)->IsDefinedBy->RelatingPropertyDefinition:IfcPropertySet
typePset as (IfcObject)->IsTypedBy->RelatingType->HasPropertySets:IfcPropertySet
prop as (IfcPropertySet)->HasProperties:IfcPropertySingleValue
propValue as (IfcPropertySingleValue)->NominalValue
externalWall extends IfcWall
definition
externalWall->typePset('Pset_WallCommon')->prop('IsExternal')->propValue = TRUE
OR
externalWall->instancePset('Pset_WallCommon')->prop('IsExternal')->propValue = TRUE
constraint
externalWall->typePset('Pset_WallCommon')->prop('FireRating')->propValue > 0

Figure 1: An example MVDLite ruleset.

is a sequence of rule segments starting from a root nodeset, in which the
output nodeset of the former rule segment is the input nodeset of the latter
rule segment.
An attribute segment is a mapping between two nodesets which is
defined by an attribute. Each attribute segment has an attribute name after
a “->” symbol and the entity type constraint may be attached after “:”. For
example, “->IsTypedBy:IfcRelDefinesByType” is an attribute segment, in
which each input node is mapped to the linked nodes with this attribute. The
attribute name is required but the entity type is optional. When the entity
type is omitted, it can be automatically completed from the IFC Schema.
A metric segment is a mapping from the input nodeset to it self, which
works as a filter for the nodes. The rule for metrics and values of an attribute is represented as a metric segment. Each metric segment is with a
“metric” ([Type], [Value], [Size], [Exists], [Unique]), an operator
(=, >, <, >=, <=, !=), and a value (string value, Boolean value, or number value). For example, “[Value]=TRUE” is a metric segment, in which the
input nodes with value equals TRUE are kept in the output nodeset.
Several rule segments can be linked as a fragment of a rule chain, and
several fragments can be combined with logical operators (AND, OR, XOR,
NOT). A compound segment encapsulates the rule chain fragments and the
logical combination of such fragments in brackets. A compound segment also
acts as a mapping from the input nodeset to the output nodeset, hence it
can be embedded into another rule chain. It can either represents a compound filter for a nodeset (when the inner fragments are ended with metric
segments) or represents a compound path of nodeset mappings (when the
10

inner fragments are not ended with metric segments).
Some syntactic sugar is added to the MVDLite rule expressions to make
the rules easier to write and read. The syntactic sugar does not add or delete
information and does not cause ambiguity.
• The metric “[Value]” can be omitted by default, so “[Value]=TRUE”
can be written as “=TRUE” for short.
• The compound segment “(->Name[Value]=’IsExternal’)” for name
constraint can be written as “(’IsExternal’)” for short.
• “|” can be used to separate several optional values for the same attribute, so “-> NominalValue = 1 | 2” means “-> NominalValue([Value]
= 1 OR [Value] = 2)”.
3.1.2. Concept Expression and Abbreviation Expression
The concept expressions and abbreviation expressions are the auxiliary
structures in the MVDLite grammar, which are used in mapping the definitions of domain concepts and data structures into natural language terms.
The concept expression explicitly defines the fine-grained domain entity types, and the inheritance of entity types with the keyword “extends”.
This idea is consistent with the domain concept definition in mvdXML, but
MVDLite supports multi-level inheritance. A subtype of entity is a subset of
its parent type, which satisfies all the “definition” conditions of the parent type and inherits all the “constraint” rules from the parent type. Any
concept must originate from an IFC entity type.
Keywords “definition” and “constraint” can be added before a set of
expressions. A “definition” part contains the name of an entity type (which
is equivalent to the name of a ConceptRoot in mvdXML), the inheritance
with its parent type, and the applicability rules for distinguishing the subset
of entities out from the parent type. A “constraint” part contains the rule
constraints for this entity type. Both applicability rules and constraint rules
of the parent type are inherited by the subtypes.
The abbreviation expression is used to map some frequently used patterns of rule segments into natural language terms. For example, the path
to reach a type property set in IFC4 is “->IsTypeBy:IfcRelDefinesByType
->RelatingType:IfcTypeObject->HasPropertySets:IfcPropertySet”. It
can be mapped to an natural language term “typePset”, and this terms can

11

be used to compose other rules. This makes the rule statements more concise
and easier to understand by non-IFC-experts.
In addition, by using abbreviations, MVDLite is easy to be switched
between different IFC versions (such as IFC2X3 and IFC4). Between different
IFC Schema versions, the changes in schema are mainly about entity types
(new types, deprecated types, and change in inheritance), attributes and
relationships. For example, the representation of “the type of an element” in
IFC2X3 is started with “IsDefinedBy”, but in IFC4 it changes to “IsTypedBy”.
In many cases, such changed data representation still corresponds to the
same domain concept in natural language. Based on this idea, the different
representations of subgraph structures and domain concepts are mapped to
natural language terms and placed in the header part of MVDLite. If the
rules are organized using the natural language terms, then the ruleset can be
switched to a different IFC Schema versions by just changing the mappings
in the header, but without changing the contents in the body part. For
example, a term “typePset” is defined as
typePset as (IfcObject)->IsDefinedBy:IfcRelDefinesByType
->RelatingType->HasPropertySets
in the header for IFC2X3. If the term “typePset” is used in the ruleset, then
the relevant rules can be switched to IFC4 by replacing the header line as
typePset as (IfcObject)->IsTypedBy->RelatingType
->HasPropertySets .
3.2. The Conversion between MVDLite and mvdXML
MVDLite is designed to be compatible with mvdXML. On the one hand,
any IFC subgraph structure that can be represented by a ConceptTemplate
can also be represented by a rule chain. On the other hand, the metric rule
segment supports the same metrics, operators and logical combinations as
the mvdXML Rule Grammar. As a result, MVDLite supports bi-directional
conversion with mvdXML. In this section, the conversion between MVDLite
and mvdMXL V1.1 will be introduced.
3.2.1. Converting MVDLite to mvdXML
The conversion from MVDLite to mvdXML can be performed in two
major steps.
(1) Parsing ConceptTemplates. One IFC entity type may be used in
multiple rules, and each rule represents a subgraph structure. The union of

12

the subgraph structures can be converted into a ConceptTemplate, in which
each node is assigned with a RuleID.
(2) Generating mvdXML Rule Grammar statements. Using the
RuleIDs, the metric rule segments in MVDLite can be rewritten as mvdXML
Rule Grammar statements. The original metrics and logical operators are
kept in the new rule statements.
3.2.2. Converting mvdXML to MVDLite
An mvdXML rule statement is the logical combination of the RuleIDmetric pairs. The conversion from mvdXML to MVDLite can be performed
in two major steps.
(1) Representing the RuleID-metric pairs in rule chains. For
each RuleID, the path from root entity to this RuleID can be represented
as a chain of attribute segments in MVDLite, and the metric of this RuleID
can be represented as a metric segment linked at the end of the chain.
(2) Merging the rule chains. The rule chains are merged according
to the logical operators (AND, OR, XOR, NOT) in the mvdXML rule statement. The branches of rule chains are merged at the lowest common ancestor nodeset, to make the subgraph structure in MVDLite consistent with the
ConceptTemplate in mvdXML.
As introduced in Section 2.2, in addition to the logical operators in
mvdXML rule statements, there is another type of logical operators in XML
tags, such as “<TemplateRules operator=“or”> ... </TemplateRules>”.
This type of logical operators can be represented in MVDLite as the logical
combination of rule chains at the root entity nodesets.
3.2.3. The scope of mvdMXL and MVDLite rules
To illustrate the feasibility of the bi-directional conversion between mvdXML
V1.1 and MVDLite, another question is to be discussed: do mvdXML and
MVDLite have the same scope of rules? The comparison is made in four aspects: subgraph template structures, metrics, logical operators, and natural
language tags.
Subgraph template structures. Both mvdXML ConceptTemplate
and MVDLite rule chain can represent arbitrary subgraph structure. There
is an implicit constraint in mvdXML that in a ConceptTemplate, one RuleID
can be assigned to different attributes, but one attribute can not be duplicated and assigned with different RuleIDs. This ensures that the branch

13

typePset as (IfcObject)->IsTypedBy->RelatingType->HasPropertySets:IfcPropertySet
prop as (IfcPropertySet)->HasProperties:IfcPropertySingleValue

constraint
IfcWall->typePset('Pset_WallCommon')->prop('IsExternal')[Exists] = TRUE
//{"Name":"Rule 1","Status":"draft","Requirement":"mandatory","ERName":"ER01"}

(a)
<?xml version="1.0"?>
<mvdXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" uuid="ca533756fc05-4f56-b091-04b953e362ed" status="sample" xsi:schemaLocation="http://www.buildingsmart-tech.org/mvd/XML/1.1
http://www.buildingsmart-tech.org/mvd/XML/1.1/mvdXML_V1.1_add1.xsd" xmlns="http://buildingsmart-tech.org/mvd/XML/1.1">
<Templates>
<ConceptTemplate uuid="d22c5deb-95d9-4686-800b-a23d292062c9" status="sample" applicableSchema="IFC4"
applicableEntity="IfcWall">
<Rules>
<AttributeRule RuleID="IsTypedBy_0" AttributeName="IsTypedBy">
<EntityRules>
<EntityRule EntityName="IfcRelDefinesByType">
<AttributeRules>
<AttributeRule RuleID="RelatingType_1" AttributeName="RelatingType">
<EntityRules>
<EntityRule EntityName="IfcTypeObject">
<AttributeRules>
<AttributeRule RuleID="HasPropertySets_2" AttributeName="HasPropertySets">
<EntityRules>
<EntityRule EntityName="IfcPropertySet">
<AttributeRules>
<AttributeRule RuleID="Name_3" AttributeName="Name">
<EntityRules>
<EntityRule EntityName="IfcLabel" />
</EntityRules>
</AttributeRule>
<AttributeRule RuleID="HasProperties_4" AttributeName="HasProperties">
<EntityRules>
<EntityRule EntityName="IfcPropertySingleValue">
<AttributeRules>
<AttributeRule RuleID="Name_5" AttributeName="Name">
<EntityRules>
<EntityRule EntityName="IfcIdentifier" />
</EntityRules>
</AttributeRule>
</AttributeRules>
</EntityRule>
</EntityRules>
</AttributeRule>
</AttributeRules>
</EntityRule>
</EntityRules>
</AttributeRule>
</AttributeRules>
</EntityRule>
</EntityRules>
</AttributeRule>
</AttributeRules>
</EntityRule>
</EntityRules>
</AttributeRule>
</Rules>
</ConceptTemplate>
</Templates>
<Views>
<ModelView uuid="d305b4eb-b668-437a-a9ef-a9ce0d55aa2b" status="sample">
<Definitions>
<Definition>
<Body><![CDATA[Default ModelView]]></Body>
</Definition>
</Definitions>
<ExchangeRequirements>
<ExchangeRequirement uuid="7d726ef8-6ae9-4981-9f18-0228b0e5c0e7" name="ER01" status="sample" applicability="both">
<Definitions>
<Definition>
<Body><![CDATA[ER01]]></Body>
</Definition>
</Definitions>
</ExchangeRequirement>
</ExchangeRequirements>
<Roots>
<ConceptRoot uuid="9ebbc41e-b172-474a-a45e-b862ddd423b8" name="IfcWall" status="sample" applicableRootEntity="IfcWall">
<Definitions>
<Definition>
<Body><![CDATA[IfcWall]]></Body>
</Definition>
</Definitions>
<Concepts>
<Concept uuid="309fe979-2673-414a-a85b-b34b3b22fd03" name="Rule 1" status="draft" override="false">
<Definitions>
<Definition>
<Body><![CDATA[IfcWall->typePset('Pset_WallCommon')->prop('IsExternal')[Exists]= TRUE]]></Body>
</Definition>
</Definitions>
<Template ref="d22c5deb-95d9-4686-800b-a23d292062c9" />
<Requirements>
<Requirement applicability="both" requirement="mandatory" exchangeRequirement="7d726ef8-6ae9-4981-9f180228b0e5c0e7" />
</Requirements>
<TemplateRules operator="and">
<TemplateRule Parameters="Name_3[Value]='Pset_WallCommon' AND Name_5[Value]='IsExternal' AND
HasProperties_4[Exists]=TRUE" />
</TemplateRules>
</Concept>
</Concepts>
</ConceptRoot>
</Roots>
</ModelView>
</Views>
</mvdXML>

(b)
Figure 2: (a) An example ruleset in MVDLite. (b) The converted mvdXML ruleset from
the MVDLite ruleset above.

14

point of two RuleIDs on the ConceptTemplate is at the lowest common ancestor of the two RuleIDs. This feature is used in the mvdXML-to-MVDLite
conversion.
Metrics. The metrics ([Type], [Value], [Size], [Exists], [Unique])
and operators (=, >, <, >=, <=, !=) are the same in MVDLite and mvdXML.
However, the metrics and operators can not be applied to the root entities
in mvdXML, since there is an implicit constraint that the RuleIDs can not
be assigned to the root entities. By supporting the metrics on root entity
set, the MVDLite rule can be used to check the global existence of a certain
node type. For example, MVDLite supports the global existence rules like
“IfcWall[Exists]=true” and “IfcProject[Size]=1”.
Logical operators. As mentioned in Section 3.2.2, both two types
of mvdXML logical operators have their own equivalent representation in
MVDLite.
Natural language tags. The natural language tags (such as the name of
ExchangeRequirements and the “mandatory” or “recommended” tags of rules)
are essential components in mvdXML structure. In MVDLite, such tags are
not included in the rule grammar, but they can be attached to the ruleset in
the comments. For example, in our implementation of MVDLite-to-mvdXML
converter, the tags are included in a JSON string in the comments, and such
tags will be added into mvdXML in the conversion task. If there lack such
comments, the MVDLite rules are still feasible and can be validated. And
in the conversion, some default tags and names are added to ensure that the
structure of the generated mvdXML is complete.
Figure 2 shows an example mvdXML ruleset and an MVDLite ruleset
that can be converted to each other. This is a simple rule for the existence
of attributes. The MVDLite rule has 5 rows, while the mvdXML rule has 94
rows.
By supporting bi-directional conversion, rulesets written in MVDLite can
be converted to mvdXML to support existing mvdXML-based applications;
the existing mvdXML rulesets can also be converted to MVDLite for easier
reading and editing, and supporting MVDLite-based efficient MVD validation and partial model extraction.
4. Efficient MVD Validation with MVDLite
Different from the separation of subgraph templates and attribute value
rules in mvdXML, MVDLite represents them in the unified “rule chain” struc15

ture. Based on this, a faster MVD validation algorithm is proposed, which
is no longer performed for each root entity separately but can be performed
on the set of all root entities of a certain type.
4.1. The MVDLite Validation Algorithm
In Section 3.1.1, the three types of rule segments (attribute segment, metric segment, and compound segment) and the rule chain structure have been
introduced. Each rule segment is a mapping from input nodeset to output
nodeset, and a rule chain is a sequence of such mappings. The proposed
MVD validation algorithm is performed by calculating the mappings on all
rule segments. The algorithm goes a round-trip path on a rule chain: first
go forward through the chain find the paths that can pass the constrains of
all rule segments, and then backtrack to find the root entity set where these
paths started. The detailed visualization and examples of the calculations
on different rule segments are shown below.
Calculating attribute segment mappings. An attribute segment is
a mapping from one nodeset to the linked nodeset, as shown in Figure 3.
Each nodeset consists of nodes of the same type or the same RuleID, and
each edge between the nodes corresponds to an attribute in the IFC data.
In this mapping, one source node may point to multiple target nodes, and
a target node may be pointed by multiple source nodes. Figure 3 shows
an example attribute segment, which is represented as a mapping from an
“IfcPropertySet” nodeset to an “IfcProperty” nodeset.
Calculating metric segment mappings. Metric segments act as filters
for the nodesets. The five types of metrics ([Type], [Value], [Size],
[Exists], [Unique]) can be divided into two groups:
The [Type] and [Value] metrics can be evaluated by each single node
in the nodeset, and they act as filters for the nodeset itself. They are called
“single metric segments”. Figure 4 shows an example single metric segment
“[Value]>=0” as a filter for a IfcValue nodeset. In this filter, a node conforming to the rule links to itself, and the remaining nodes link to nothing.
Thus a single metric segment is a mapping from a nodeset to the set itself.
The [Size], [Exists] and [Unique] metrics act as filters for the parent
nodeset. These metrics can not be evaluated by a single node, but can only
be evaluated by a collection of nodes. They are called “collection metric
segments”. Figure 5 shows an example collection metric segment “[Size]>1”
as a filter for the IfcPropertySet nodes in the parent nodeset. It must be
evaluated in combination with the attribute segment “->HasProperties” in
16

IfcPropertySet

IfcPropertySet

IfcProperty

IfcProperty
IfcPropertySet

IfcValue

IfcProperty

IfcValue

IfcValue

IfcValue
IfcValue

IfcValue

[Value]>=0

[Value]>=0[Value]>=0

->HasProperties

->HasProperties ->HasProperties

Figure 3: An example attribute segment.
IfcPropertySet

IfcProperty
IfcPropertySet

IfcPropertySet

IfcProperty

Figure 4: An example single metric segment.

IfcPropertySet
IfcProperty

IfcPropertySet

IfcPropertySet

->HasProperties
[Size]>1
->HasProperties

[Size]>1

->HasProperties

[Size]>1
Figure 5: An example
collection metric segment

front. The collection metric segment “[Size]>1” is a mapping from a nodeset
to the parent nodeset, and the combination “(->HasProperties[Size]>1)”
is a mapping from the parent nodeset to the parent nodeset itself.
Rule chain and compound segment. If a rule chain is ended with a
metric segment, then by going through a round-trip path on the rule chain,
a subset of the root nodeset can be obtained, in which includes the root
entities that have paths to pass all segments in this rule chain. A compound
segment can encapsulate this round-trip in brackets, so that it works as a
filter of a nodeset that can be added to another rule chain as a segment. The
visualization of a compound segment as a filter is shown in Figure 6(a).
If a fragment of rule chain is not ended with a metric segment, it can
be visualized as the linkage of node mappings. Such node mappings can
be combined with logical operators AND, OR, NOT in a compound segment,
which corresponds to the intersection, union, complement operations of
output nodesets, respectively. The visualization of a compound segment as
17

IfcPropertySet

IfcProperty

->HasProperties

IfcValue

->Name

IfcValue

IfcProperty

IfcPropertySet

[Value]="FireRating"

IfcPropertySet

IfcPropertySet

(->HasProperties->Name[Value]="FireRating")

(a) A round-path on the rule chain and the corresponding compound
segment.
IfcObject

IfcRelDefinesByType

IfcTypeObject

IfcPropertySet
IfcObject

->IsTypedBy

->RelatingType

IfcPropertySet

->HasPropertySets

OR
->RelatingPropertyDefinition

->IsDefinedBy
IfcRelDefinesByProperties

IfcPropertySet

(->typePset OR ->instancePset)

(b) A compound segment as the combination of mappings.
Figure 6: The visualazation of two example compound segments.

the combination of mappings is shown in Figure 6(b).
4.2. Comparison of Different MVD Validation Algorithms
The aim of MVD validation algorithms is to determine the existence
of a subgraph conforming to an MVD rule. An efficient MVD validation
algorithm is to visit as few nodes as possible to determine the existence of a
subgraph that conforms to a rule.

18

As introduced in Section 2.4, due to the separation of templates and rule
statements, the mvdXML validation algorithm is performed by first matching
templates to find all subgraphs, and then checking attribute values to find the
existence of a conforming subgraph. Figure 7 (a) shows the brief schematic
diagram of mvdXML validation algorithm.
Some strategies can be used to speed up the mvdXML validation. For
example, the xBIM mvdXML validation tool [38, 31] uses the caching strategy. For each ConceptTemplate, one root entity is expanded as a table, in
which each column corresponds to a RuleID and each row corresponds to a
subgraph that can match the ConceptTemplate. This table is catched and
reused if the ConceptTemplate is used in multiple rules. Another strategy
can be used in mvdXML validation is pruning. For each ConceptRoot, the
applicability rule is evaluated first to prune out some of the root entities,
hence the number of entities to be checked can be reduced.
Figure 7 (b) shows the schematic diagram of the MVDLite validation
algorithm, which is performed by going through the round-trip path of a
rule chain. Compared with mvdXML validation algorithm, the reason why
the MVDLite-based validation is faster can be explained by that MVDLite
validation algorithm can view fewer nodes to determine the existence of a
subgraph that conforms to a rule:
(1) Calculating on the nodesets. Rather than the “subgraph-bysubgraph” traversal of mvdXML validation, the basic unit in MVDLite validation is a nodeset, which is composed of the root entities of the same type
or the nodes with the same RuleID. One node is needed to be visited at
most twice (forward and backward in a round-trip), which speeds up the
calculation since one same node can usually be referenced by multiple root
entities.
(2) Multi-level inheritance. Rather than the “entity-by-entity” traversal in the root nodeset in mvdXML validation, the MVDLite validation algorithm is able to get the results of all entities in the root nodeset just through
one round-trip path on the rule chain. In addition, since each type of entity
is a subset of its parent type, the calculation can start from the nodeset of
its parent type.
(3) Pruning in the deep. Since MVDLite validation is based on the
mapping between nodesets, pruning can be performed on every nodeset before mapping to the next nodeset. While in mvdXML-based validation, the
pruning can only be performed on the root nodeset, since every node in a
subgraph is already visited at least once in the “matching template” step.
19

A

B

D

E

C='xxx' AND E='yyy'

C

…

…
╳

…
√

√

…

…

╳

…

…
…
…

…
…
…
(1) Get the root entity set.

(2) For each root entity, list all
subgraphs according to the template.

(3) Validate the rule
on each subgraph.

(4) Get the result of
one root entity.

(a) mvdXML validation algorithm
->A

->B

A

(->C

B

='xxx'

C

) ->D

C

B

->E

D

='yyy'

E

E

╳

√
√
╳
√

(1) Get the root entity set.

(2) Filter the nodes through the rule chain.

(3) Backtrack to get the results
of all root entities.

(b) MVDLite validation algorithm
Figure 7: The comparison of validation algorithms for mvdXML and MVDLite.

(4) Caching in the deep. In the MVDLite validation process, each
nodeset corresponds to the prefix of the rule chain from the root to this
segment. The nodesets can be reused if the same prefix occurs again in other
rules. This usually happens. For example, there may be multiple rules for

20

different properties in the same property set. The nodesets are well pruned
and easy to be cached by creating a mapping from the prefix strings to the
nodesets. While in mvdXML, the caching can only be performed without
the deep pruning, which results in larger cached data and longer query time.
The experimental comparisons of the different MVD validation algorithms
are listed in Section 5.1.
5. Experiments and Applications
The parsers for the IFC files and the MVDLite statements are implemented based on ANTLR [39] in C#. Based on these two parsers, a commandline tool for MVDLite validation is implemented, which inputs the model
and the ruleset, then outputs the validation reports. In this section, the performance of our MVD validation algorithm is compared with the mvdXML
validation algorithm on several models and rulesets in different sizes (see Section 5.1). Then a case study is provided to show the user-friendly workflow
for customizing an enterprise-level MVD, and the applications in MVD validation and partial model extraction on a large real-world model (see Section
5.3).
5.1. MVDLite Validation Experiment
(1) The compared tools. The publicly available MVD validation tool
supporting mvdXML includes an xBIM-based tool [38, 31] and a BIMServerbased open source tool [32, 5]. The BIMServer-based tool has not been
updated in recent years thus does not support the mvdXML V1.1. Therefore,
our MVDLite validation tool is mainly compared with the xBIM-based tool.
To fairly compare the efficiency of the algorithm, an mvdXML validation
tool is also implemented based on our own IFC parser. The experiments in
this section compare the efficiencies of these three tools.
(2) The models. Since most of the publicly available MVD rulesets
are for IFC4 Schema, in our experiments several IFC4 models in different
sizes are used. The models are shown in Figure 8, and the sizes of these IFC
models are listed in Table 1.
• Duplex.ifc A small sample model of a duplex building provided by
NIBS [40]. This model is converted and merged from two IFC2X3
models, including an architectural model and an MEP model.

21

UnitTest.ifc

) Office.ifc

(b) Duplex.ifc

(a) Duplex.ifc

(a) UnitTest.ifc

(b) Duplex.i

(c) Office.ifc

(d) F010.if

(b) Office.ifc

(d) F010.ifc

(c) B01.ifc
Figure 8: The models used in the experiments.
Table 1: The size of models
model
Duplex.ifc
file size
52 MB
“IfcElement”s
1,170
“IfcProperty”s
76,118
“IfcShapeModel”s
2,029
data lines
864,327

in the experiments.
Office.ifc
B01.ifc
193 MB
841 MB
7,174
57,344
476,900
1,434,337
11,095
89,735
3,024,817 11,652,719

• Office.ifc A medium-size sample model of an office building provided
by NIBS [40]. This model is converted and merged from three IFC2X3
models, including an architectural model, a structural model, and an
MEP model.
• B01.ifc A model of the B01 underground storey of a commercial complex building. This model is exported from Autodesk Revit, which
includes building elements in architecture, structure and MEP disciplines. This model is the real-world model in the case study in Section
5.3.

22

ruleset

mvdXML

MVDlite

Table 2: The rulesets used in the experiments.
UnitTest
RV
DTV
file size
58 KB 1,065 KB 1,453 KB
“ConceptRoot”s
23
125
160
2
0
0
“Applicability”s
“Concept”s (has rules)
23
319
331
58
1,770
1,791
rule statements
file size
10 KB
231 KB
240 KB
2
0
0
applicability rules
constraint rules
23
319
331

O&M
6,767 KB
1,475
1,472
3,404
14,735
926 KB
1,472
3,404

(3) The rulesets. The sizes of these mvdXML rulesets and the corresponding MVDLite rulesets are listed in Table 2.
• UnitTest.mvdxml A small unit test ruleset used in the xBIM mvdXML
validation tool, which includes several rules about walls [38].
• RV.mvdxml The IFC4 Reference View V1.1 draft provided by buildingSMART [41].
• DTV.mvdxml The IFC4 Design Transfer View V1.1 draft provided
by buildingSMART [41].
• O&M.mvdxml The MVD for operation and maintenance model delivery of a commercial complex building. This ruleset is the enterpriselevel MVD in the case study in Section 5.3. Since this ruleset is developed according to the enterprise classification standard, it is only
tested on the model “B01.ifc”.
Among the the rulesets, “UnitTest.mvdxml”, “RV.mvdxml” and “DTV.mvdxml”
are slightly modified from different mvdXML versions to match the mvdXML
V1.1 format, and then converted to equivalent MVDLite ruleset. “O&M.mvdxml”
is originally in MVDLite and then converted to the equivalent mvdXML ruleset.
(4) Experimental results. The time usage of three MVD validation
algorithms in ten tasks are listed in Table 3, in which the xBIM-based tool
fail to finish the “B01-O&M” task within 12 hours. The experimental results
show that the MVDLite-based validation algorithm is much faster than the
mvdXML-based validation algorithms in all tasks. Both MVDLite-based
and mvdXML-based validation algorithms are implemented on the same
23

Table 3: The time usage of three MVD validation algorithms in ten tasks.
time (seconds)
model
ruleset
mvdXML(xBIM) mvdXML(ours) MVDLite(ours)
Duplex UnitTest
2.4
1.3
0.8
7.1
11
2.0
Duplex RV
Duplex DTV
6.0
12
1.9
Office
UnitTest
177
5.8
1.1
Office
RV
186
89
8.3
178
85
4.8
Office
DTV
B01
UnitTest
10,745
50
5.9
9,423
7,491
106
B01
RV
B01
DTV
8,723
389
55
B01
O&M
time out
11,261
121

IFC parser, to eliminate the performance differences between different IFC
parsers. According to this comparison, we found that the MVDLite-based
validation algorithm is still several times faster in MVD validation on large
IFC models. It is worth mentioning that in the ruleset “O&M”, the domain
concepts have clear inheritance relationships, and MVDLite can effectively
use the concept inheritance to accelerate the calculation, which results in
much faster speed in validation.
(5) The effects of caching and pruning strategies. The enhanced
caching and pruning strategies in the MVDLite validation algorithm have
been introduced in Section 4.2. Due to the nodeset mappings and the rule
chain structure, the caching and pruning can go deep into every nodeset
rather than just the root entity sets. In order to verify the effects of caching
and pruning strategies, an additional experiment is performed when switching off each strategy. The time usage in six tasks are listed in Table 4. The
results show that both caching and pruning strategies can remarkably speed
up the calculation.
5.2. Partial Model Extraction with MVDLite
The proposed fast MVD validation algorithm can efficiently find a set of
nodes that meet certain conditions. This algorithm can be further applied in
partial model extraction tasks, which can extract the nodes and relationships
involved in the MVDLite ruleset, and meanwhile to ensure that the result
is still a valid IFC file. The partial model extraction is performed in three
steps:

24

Table 4: The comparison of time usage in six tasks when switching off caching and
pruning from the MVDLite validation algorithm.
time (seconds)
model
ruleset
Full MVDLite Caching off Pruning off Both off
Duplex UnitTest
0.8
1.0
1.0
1.3
Duplex RV
2.0
26
120
607
1.9
26
115
579
Duplex DTV
Office
UnitTest
1.1
2.8
2.4
8.1
8.3
164
866
3,764
Office
RV
Office
DTV
4.8
169
872
3,756

(1) Selecting the root entity set. In an MVDLite ruleset, the involved
root entities are defined as domain concepts. According to the applicability
rules in the “definition” statements, the root elements can be selected as
an initial extracted nodeset.
(2) Extracting dependency nodes. In an IFC model, most of the
directly referenced nodes in the data list of a node are necessary dependencies.
Such dependency nodes and their dependencies are iteratively added into the
extracted nodeset.
(3) Filtering relationships by rules. Some other nodes are indirectly
referenced by “IfcRelationship” nodes. By performing MVD validation algorithm, the referenced nodes involved in the ruleset can be selected and added
to the extracted nodeset.
The partial model extraction task is performed on the model “B01.ifc” according to the ruleset “O&M.mvdlite”, which extracts the building elements,
the properties and geometry representations involved in operation and maintenance. The algorithm uses 155 seconds to finish the partial model extraction task. The comparison of the original model and the extracted partial
model are listed in Table 5, and the two models are visualized in Figure 9.
Compared with the original model of 841 MB, the extracted model is only
214 MB in size. The building elements and properties that are involved in
the operation and maintenance phase (mainly MEP elements, walls, columns,
and beams) are extracted as a partial model, while the redundant elements
with complicated geometries and properties but unrelated to the operation
and maintenance ruleset are excluded from the partial model.
In addition to extracting a partial model from an existing ruleset, the
partial models can also be extracted from some flexibly written MVDLite
statements. Figure 10 shows three examples of extracting partial models
25

(a)

(b)

(c)

(d)

Figure 9: (a)(c) The global view and partial view of the original model “B01.ifc”, respectively. (b)(d) The global view and partial view of the extracted model, respectively.
Table 5: The comparison of original model and extracted model of “B01.ifc”.
original model extracted model
file size (MB)
841
214
“IfcElement”s
57,344
40,165
“IfcProperty”s
1,434,337
55,515
“IfcShapeModel”s
89,735
69,813
data lines
11,652,719
3,561,396

from “Office.ifc” by several lines of MVDLite statements (the header part for
each statement is omitted). The three partial models are for “external walls”,
“elements contained in Level 2” and “loadbearing elements”, respectively.
5.3. Case Study
This case study is about an MVDLite-based process for enterprises to
customize MVD rules and to use the MVD rules for model validation and
data exchange. A workflow for developing MVD rules is proposed to involve
both domain engineers and IT engineers in in customizing enterprise-level
MVDs. The domain engineers and managers are familiar with the domain
26

definition
externalWall extends IfcWall
externalWall->instancePset->
prop('IsExternal')->propValue = TRUE

definition
elem_Level2 extends IfcElement
elem_Level2->ContainedInStructure->
RelatingStructure->Name = "Level 2"

definition
loadBearing extends IfcElement
loadBearing->instancePset->
prop('LoadBearing')->propValue = TRUE

Figure 10: Three partial models extracted from “Office.ifc” by flexibly written MVDLite
statements.

concepts and exchange requirements, but they are not familiar with the IFC
data format and the MVD rule structure. On the contrary, the IT engineers
are familiar with the data formats of IFC and MVD, but they are not familiar with the domain-specific concepts and requirements. The workflow is
implemented based on the idea of separating the domain-specific rules from
the schema-specific data definitions, which is shown in Figure 11 (a).
First, the IT engineers define the abbreviation expressions in a header (see
Figure 11 (b)), in which the data structures of properties and relationships
involved in the ruleset are represented as abbreviation expressions. Second,
an Excel template is generated to list the domain entity types according to
the classification standard (see Figure 11 (c)), and then the form is handed
to the domain engineers and managers to fill in the detailed requirements, including the options of whether they should be included in the partial model,
the naming rules, and the requirements for properties. Next, an MVDLite
ruleset is generated using the abbreviation header and the collected require-

27

IT engineer

Managers/engineers

+
Abbreviation header

Feedback

Classification codes
&
Exchange requirements

Validation
on model

↔
MVDLite rules

mvdXML rules

(a)
type as (IfcObject)->IsTypedBy->RelatingType
instancePset as (IfcObject)->IsDefinedBy->RelatingPropertyDefinition:IfcPropertySet
typePset as (IfcObject)->type->HasPropertySets:IfcPropertySet
instanceProp as (IfcObject)->instancePset->HasProperties
typeProp as (IfcObject)->typePset->HasProperties
propValue as (IfcPropertySingleValue)->NominalValue
geom as (IfcProduct)->Representation:IfcProductDefinitionShape
->Representations:IfcShapeRepresentation
composedGeom as (IfcProduct)->IsDecomposedBy->RelatedObjects->geom
openingGeom as (IfcElement)->HasOpenings->RelatedOpeningElement->geom
geomID as (IfcShapeRepresentation)->RepresentationIdentifier
geomType as (IfcShapeRepresentation)->RepresentationType

(b)

Generated from
classification standard

Fill in by the domain engineers
according to exchange requirements

(c)
Figure 11: (a) The workflow for MVDLite development. (b) The abbreviation header.
(c) The Excel template for collectiing entity and property requirements (translated to
English).

ments, which is then converted to an equivalent mvdXML ruleset. Finally,
the generated rulesets are validated on a sample model, and the results are

28

fed back to the IT engineers and domain engineers. The header and the
forms are edited accordingly to revision the ruleset to meet the exchange
requirements.
The workflow is implemented in developing “O&M.mvdlite” for operation
and maintenance model delivery of a commercial complex building. The
result ruleset is used for MVD validation and partial model extraction on the
model “B01.ifc”. The comparison of time usage in the validation of ruleset
“O&M” on the model “B01.ifc” is shown in the last row of Table 3. The result
of partial model extraction is shown in Section 5.2. In the experiments, our
method shows good efficiency on large real-world IFC models and rulesets.
6. Conclusion and future work
In this paper, MVDLite is proposed as a light-weight representation for
MVD rules, which extends the application of MVD in flexible scenarios.
Based on the rule chain structure of MVDLite, a new MVD validation algorithm is proposed, which is remarkably faster in MVD validation on large
real-world IFC models. An MVDLite-based process is proposed to customize
enterprise-level MVDs model validation and data exchange.
Currently, MVDLite is compatible with the mvdXML V1.1. In a document released by the mvdXML team [34], some possible updates for mvdXML
are under discussion, including some grammars that are not supported by
mvdXML V1.1 yet. The current mvdXML grammar update is basically
case-oriented: new features are added mainly based on the need proposed by
industry. However, there is few discussion on the logic foundation and the
completeness of MVD rule languages. The theoretical analysis of MVD will
be our future work.
7. Acknowledgment
This research is sponsored in part by the NSFC Program (No. 61527812),
the National Science and Technology Major Project of China (No. 2016ZX
01038101), the MIIT IT Funds of China (Research and Application of TCN
Key Technologies), the National Science and Technology Support Program
of China (No. 2015BAG14B01-02), the National Key R&D Program of
China (No. 2016QY07X1402, 2018YFB0505400), and the Wanda Research
Project (Research on Commercial Complex Building Information Model Storage Technology).
29

References
[1] J. Wix, J. Karlshoej, Information delivery manual: Guide to
components and development methods, available from: http://
iug.buildingsmart.org/idms/development (accessed October 2018)
(2010).
[2] R. See, J. Karlshoej, D. Davis, An integrated process for delivering
IFC based data exchange, available from: http://iug.buildingsmart.
org/idms/methods-and-guides (accessed October 2018) (2012).
[3] J. Hietanen, IFC model view definition format, available from:
https://www.buildingsmartsingapore.org/news/news-docs/
20060410_IFC_MVD_Format.pdf (accessed October 2018) (2006).
[4] T. Chipman, T. Liebich, M. Weise, mvdXML: Specification of a
standardized format to define and exchange Model View Definitions with Exchange Requirements and Validation Rules, available
from:
http://www.buildingsmart-tech.org/specifications/
mvd-overview/mvdxml-releases/mvdxml-1.1 (accessed October
2018) (2016).
[5] C. Zhang, J. Beetz, M. Weise, Model view checking: automated validation for IFC building models, in: eWork and eBusiness in Architecture, Engineering and Construction: ECPPM, 2014, p. 123,
isbn:9781315736952.
[6] C. Zhang, J. Beetz, B. de Vries, Towards model view definition on semantic level: A state of the art review, in: Proceedings of the 20th
International Workshop: Intelligent Computing in Engineering, 2013,
isbn:9781634395496.
[7] T. Chipman, ifcDoc Tool Summary, available from: http://www.
buildingsmart-tech.org/specifications/specification-tools/
ifcdoc-tool/ifcdoc-beta-summary (accessed October 2018) (2012).
[8] A. D. GmbH, BIMQ 2019, available from: http://demo.bim-q.de (accessed May 2019) (2019).

30

[9] G. Lee, Y. H. Park, S. Ham, Extended process to product modeling
(xPPM) for integrated and seamless IDM and MVD development, Advanced engineering informatics 27 (4) (2013) 636–651. doi:10.1016/j.
aei.2013.08.004.
[10] M. Venugopal, C. Eastman, R. Sacks, Configurable model exchanges
for the precast/pre-stressed concrete industry using semantic exchange
modules (SEM), in: International Conference on Computing in Civil
Engineering, 2012. doi:10.1061/9780784412343.0034.
[11] M. Weise, P. Katranuschkov, R. J. Scherer, Generalised model subset
definition schema, in: Proceedings of the CIB-W78 Workshop, 2003,
isbn:0908689713.
[12] J. Beetz, J. Van Leeuwen, B. De Vries, IfcOWL: A case of transforming
express schemas into ontologies, Artificial Intelligence for Engineering
Design, Analysis and Manufacturing 23 (1) (2009) 89–101. doi:10.
1017/S0890060409000122.
[13] L. Zhang, R. R. Issa, Ontology-based partial building information model
extraction, Journal of Computing in Civil Engineering 27 (6) (2012)
576–584. doi:10.1061/(ASCE)CP.1943-5487.0000277.
[14] P. Pauwels, A. Roxin, SimpleBIM: From full ifcOWL graphs to simplified
building graphs, in: eWork and eBusiness in Architecture, Engineering
and Construction: ECPPM, 2016, pp. 11–18, isbn:9781315386898.
[15] T. Krijnen, J. Beetz, A SPARQL query engine for binary-formatted IFC
building models, Automation in Construction 95 (2018) 46–63. doi:
10.1016/j.autcon.2018.07.014.
[16] W. Mazairac, J. Beetz, BIMQL – an open query language for building
information models, Advanced Engineering Informatics 27 (4) (2013)
444–456. doi:10.1016/j.aei.2013.06.001.
[17] A. Wülfing, R. Windisch, R. Scherer, A visual BIM query language, in:
eWork and eBusiness in Architecture, Engineering and Construction:
ECPPM, 2014, pp. 157–64, isbn:9781138027107.

31

[18] C. Zhang, J. Beetz, B. de Vries, BimSPARQL: Domain-specific functional sparql extensions for querying RDF building data, Semantic
Web (Preprint) (2018) 1–27. doi:10.3233/SW-180297.
[19] E. Tauscher, H.-J. Bargstädt, K. Smarsly, Generic BIM queries based on
the IFC object model using graph theory, in: Proceedings of the 16th International Conference on Computing in Civil and Building Engineering
(ICCCBE), 2016, isbn:9784990737122.
[20] A. Borrmann, E. Rank, Topological analysis of 3D building models using a spatial query language, Advanced Engineering Informatics 23 (4)
(2009) 370–385. doi:10.1016/j.aei.2009.06.001.
[21] S. Daum, A. Borrmann, Checking spatio-semantic consistency of building information models by means of a query language, in: Proceedings
of the International Conference on Construction Applications of Virtual
Reality, 2013, isbn:9780992716103.
[22] C. Preidel, A. Borrmann, Integrating relational algebra into a visual
code checking language for information retrieval from building information models, in: Proceedings of the 16th International Conference
on Computing in Civil and Building Engineering (ICCCBE), 2016,
isbn:9784990737122.
[23] H. Amrutha, V. Balasubramanian, A model independent and userfriendly querying system for indoor spaces, in: Proceedings of the 20th
International Conference on Management of Data, Computer Society of
India, 2014, pp. 17–28. doi:10.5555/2726970.2726977.
[24] Y.-C. Lee, C. M. Eastman, W. Solihin, An ontology-based approach
for developing data exchange requirements and model views of building
information modeling, Advanced Engineering Informatics 30 (3) (2016)
354–367. doi:10.1016/j.aei.2016.04.008.
[25] M. Venugopal, C. M. Eastman, J. Teizer, An ontological approach to
building information model exchanges in the precast/pre-stressed concrete industry, in: Construction Research Congress 2012: Construction Challenges in a Flat World, 2012, pp. 1114–1123. doi:10.1061/
9780784412329.112.

32

[26] M. Venugopal, C. M. Eastman, R. Sacks, J. Teizer, Semantics of
model views for information exchanges using the industry foundation
class schema, Advanced engineering informatics 26 (2) (2012) 411–428.
doi:10.1016/j.aei.2012.01.005.
[27] M. Venugopal, C. M. Eastman, J. Teizer, An ontology-based analysis
of the industry foundation class schema for building information model
exchanges, Advanced Engineering Informatics 29 (4) (2015) 940–957.
doi:10.1016/j.aei.2015.09.006.
[28] T. M. de Farias, A. Roxin, C. Nicolle, A rule-based methodology to
extract building model views, Automation in Construction 92 (2018)
214–229. doi:10.1016/j.autcon.2018.03.035.
[29] Stanford University, Protégé, available from: https://protege.
stanford.edu/ (accessed December 2019) (2016).
[30] C. Eastman, J.-m. Lee, Y.-s. Jeong, J.-k. Lee, Automatic rule-based
checking of building designs, Automation in construction 18 (8) (2009)
1011–1033. doi:10.1016/j.autcon.2009.07.002.
[31] M. Weise, T. Liebich, N. Nisbet, C. Benghi, IFC model checking based
on mvdXML 1.1, in: eWork and eBusiness in Architecture, Engineering
and Construction: ECPPM, 2016, p. 19, isbn:9781315386898.
[32] opensourceBIM, mvdXMLChecker, available from: https://github.
com/opensourceBIM/mvdXMLChecker (accessed May 2019) (2014).
[33] simplebim, Simplebim – mvdXML add-on for Simplebim 7.1,
available from:
http://www.datacubist.com/sdm_downloads/
mvdxml-addon-simplebim-7/ (accessed October 2018) (2018).
[34] M. Weise, mvdXML requirements and examples: review of a standardized format to define and exchange model view definitions with
exchange requirements and validation rules, available from: https:
//github.com/BuildingSMART/mvdXML/tree/master/mvdXML1.1 (accessed October 2018) (2014).
[35] Y.-C. Lee, C. M. Eastman, W. Solihin, R. See, Modularized rule-based
validation of a BIM model pertaining to model views, Automation in
Construction 63 (2016) 1–11. doi:10.1016/j.autcon.2015.11.006.
33

[36] Y.-C. Lee, C. M. Eastman, W. Solihin, Logic for ensuring the data
exchange integrity of building information models, Automation in Construction 85 (2018) 249–262. doi:10.1016/j.autcon.2017.08.010.
[37] W. Solihin, C. Eastman, Y.-C. Lee, Toward robust and quantifiable
automated IFC quality validation, Advanced Engineering Informatics
29 (3) (2015) 739–756. doi:10.1016/j.aei.2015.07.006.
[38] xBimTeam, XbimMvdXML, available from: https://github.com/
xBimTeam/XbimMvdXML (accessed May 2019) (2016).
[39] T. J. Parr, R. W. Quong, ANTLR: A predicated-LL (k) parser generator,
Software: Practice and Experience 25 (7) (1995) 789–810. doi:10.1002/
spe.4380250705.
[40] NIBS, Common Building Information Model Files and Tools, available from: https://www.nibs.org/page/bsa_commonbimfiles (accessed May 2019) (2012).
[41] buildingSMART,
IfcDoc/IfcKit/exchanges/,
available
from:
https://github.com/buildingSMART/IfcDoc/tree/master/IfcKit/
exchanges (accessed January 2020) (2018).

34

Appendix A. MVDLite Grammar
grammar MVDLite;
/*
* Parser Rules
*/
file:
(abbr_expression | concept_expression)* (block_definition | block_constraint)* EOF;
abbr_expression:
NAME AS LPAREN NAME RPAREN (mid_rule)+;
concept_expression:
NAME EXTENDS NAME;
block_definition:
DEFINITION (concept_expression | rule_expression)*;
block_constraint:
CONSTRAINT (rule_expression)*;
rule_expression:
rule_term (logical_interconnection rule_term)*;
rule_term:
(NAME rule_chain) | ( LPAREN rule_expression RPAREN ) | ( NOT LPAREN rule_expression RPAREN );
rule_chain:
(mid_rule)* end_rule?;
mid_rule:
attribute_rule | compound_rule | string_rule | special_rule ;
end_rule:
metric_rule ;
metric_rule:
(metric)? operator_value_term;
operator_value_term:
(operator value) | ( LPAREN operator_value_expr RPAREN );
operator_value_expr:
operator_value_term ( logical_interconnection operator_value_term )*;
attribute_rule:
ITS concept;
compound_rule:
( LPAREN rule_chain (logical_interconnection rule_chain)* RPAREN )
|
( LPAREN NOT rule_chain RPAREN );
string_rule:
LPAREN string_literal RPAREN;
special_rule:
LPAREN NAME RPAREN;
concept:
NAME (COLON NAME)?;
metric:
M_VALUE | M_SIZE | M_TYPE | M_UNIQUE | M_EXISTS;
operator:
EQUAL |NOT_EQUAL | GREATER_THAN | GREATER_THAN_OR_EQUAL | LESS_THAN | LESS_THAN_OR_EQUAL;
logical_interconnection:
AND | OR | XOR;
value:
( single_value ( '|' single_value )* ) | ( LPAREN value RPAREN );
single_value:
logical_literal | real_literal | string_literal | NULL;
logical_literal:
TRUE | FALSE | UNKNOWN;
real_literal:
((sign)? ( DIGIT | INT ) ('.')? ( ( DIGIT | INT ) )? ( ('e'|'E') (sign)? ( DIGIT | INT ) )?);
sign:
'+' | '-' ;
string_literal:
STRING | REGEX_STRING | CONTAINS_STRING | STARTS_WITH_STRING | ENDS_WITH_STRING ;

Figure A.12: The MVDLite grammar: parser rules.

35

/*
* Lexer Rules
*/
BLOCK_COMMENT: '/*' .*? '*/' ;
LINE_COMMENT: '//' ~[\r\n]* ;
WS: (' '|'\t'|'\n'|'\r')+ ;
AS: 'as' | '\u66ff\u6362' ; //替换
EXTENDS: 'extends' | '\u7ee7\u627f'; //继承
DEFINITION: 'definition' | '\u5b9a\u4e49'; //定义
CONSTRAINT: 'constraint' | '\u7ea6\u675f'; //约束
ITS: 'its' | '->' | '\u7684'; //的
AND: 'AND'
OR: 'OR' |
XOR: 'XOR'
NOT: 'NOT'

| '&' | '\u4e14' ; //且
'|' | '\u6216' ; //或
| '^' | '\u5f02\u6216'; //异或
| '\u4e0d' | '\u975e'; //不 | 非

EQUAL: '=' ;
NOT_EQUAL: '!=' | '\uff01=';
GREATER_THAN: '>' ;
GREATER_THAN_OR_EQUAL: '>=' ;
LESS_THAN: '<' ;
LESS_THAN_OR_EQUAL: '<=' ;
FALSE: 'FALSE' | 'false' | '\u5047'; //假
TRUE: 'TRUE' | 'true' | '\u771f'; //真
UNKNOWN: 'UNKNOWN' | 'unknown' | '\u672a\u77e5'; //未知
NULL: 'NULL' | 'null' | '\u7a7a'; //空
M_VALUE: '['( 'Value' | '\u503c') ']'; //[值]
M_SIZE: '['( 'Size' | '\u6570\u91cf') ']'; //[数量]
M_TYPE: '['( 'Type' | '\u7c7b\u578b') ']'; //[类型]
M_EXISTS: '['( 'Exists' | '\u5b58\u5728') ']'; //[存在]
M_UNIQUE: '['( 'Unique' | '\u552f\u4e00') ']'; //[唯一]
DIGIT: '0'..'9' ;
INT: '0'..'9'+;
HEX_DIGIT: DIGIT | ('a'..'f' | 'A'..'F') ;
LETTER: ('a'..'z') | ('A'..'Z') ;
COLON: ':' ;
LPAREN: '(' ;
RPAREN: ')' ;
QUOTATION: '\'' | '"';
OCTAL_ESC: '\\' ('0'..'3') ('0'..'7') ('0'..'7') | '\\' ('0'..'7') ('0'..'7') | '\\' ('0'..'7') ;
UNICODE_ESC: '\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT ;
ESC_SEQ: '\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\'
|'.'|'?'|'+'|'*'|'['|']'|'('|')'|'{'|'}'|'^'|'|'|'$'|'s'|'S'|'d'|'D'
) | UNICODE_ESC | OCTAL_ESC ;
STRING: QUOTATION ( ESC_SEQ | ~('\\'| '\'' | '"') )* QUOTATION;
REGEX_STRING: 'r' STRING ;
CONTAINS_STRING: 'c' STRING ;
STARTS_WITH_STRING: 's' STRING ;
ENDS_WITH_STRING: 'e' STRING ;
NAME: NAME_START_CHAR NAME_CHAR*;
fragment
NAME_CHAR:
NAME_START_CHAR
| '0'..'9' | '#' | '$' | '%' | '^' | '&' | '*' | '_' | '+'
| '{' | '}'| ';' | ',' | '.' | '?' | '/' | '~' | '`' | FULL_WIDTH_SYMBOL ;
fragment
NAME_START_CHAR: 'A'..'Z' | 'a'..'z' | '\u4e00'..'\u9fa5' | '@' ;
fragment
FULL_WIDTH_SYMBOL:
'\u3001'|'\uff0c'|'\u3002'|'\uff1b'|'\u300a'|'\u300b'
|'\uffe5'|'\u2014'|'\u3010'|'\u3011'|'\uff1a'
|'\uff08'|'\uff09'|'\u2018'|'\u2019'|'\u201c'|'\u201d';

//、，。；《》
//￥—【】：
//（）‘’“”

Figure A.13: The MVDLite grammar: lexer rules.

36

