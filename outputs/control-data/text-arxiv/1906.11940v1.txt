1

What Do Developers Ask About ML Libraries? A
Large-scale Study Using Stack Overflow

arXiv:1906.11940v1 [cs.SE] 27 Jun 2019

Md Johirul Islam, Hoan Anh Nguyen, Rangeet Pan, Hridesh Rajan
Abstract—Modern software systems are increasingly including machine learning (ML) as an integral component. However, we do not
yet understand the difficulties faced by software developers when learning about ML libraries and using them within their systems. To
that end, this work reports on a detailed (manual) examination of 3,243 highly-rated Q&A posts related to ten ML libraries, namely
Tensorflow, Keras, scikit-learn, Weka, Caffe, Theano, MLlib, Torch, Mahout, and H2O, on Stack Overflow, a popular online technical
Q&A forum. We classify these questions into seven typical stages of an ML pipeline to understand the correlation between the library
and the stage. Then we study the questions and perform statistical analysis to explore the answer to four research objectives (finding
the most difficult stage, understanding the nature of problems, nature of libraries and studying whether the difficulties stayed consistent
over time). Our findings reveal the urgent need for software engineering (SE) research in this area. Both static and dynamic analyses
are mostly absent and badly needed to help developers find errors earlier. While there has been some early research on debugging,
much more work is needed. API misuses are prevalent and API design improvements are sorely needed. Last and somewhat
surprisingly, a tug of war between providing higher levels of abstractions and the need to understand the behavior of the trained model
is prevalent.
Index Terms—Machine learning, Q&A forums, API misuses

F

1

I NTRODUCTION

Machine learning (ML) is becoming an essential computational tool in a software developer’s toolbox for solving
problems that defy traditional algorithmic approach. Software developers are fulfilling this need by development and
refinement of a number of new ML libraries [1]. Recently
it has also been suggested that ML can introduce unique
software development problems [2], [3], [4]. However, we do
not yet know about the problems that users of ML libraries
face and those that they choose to ask about publicly.
Prior work has shown that studying question and answer (Q&A) forums such as Stack Overflow can give significant insights into software developer’s concerns about a
technology [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15],
[16], [17], [18], [19], but has not focused on ML libraries.
More details of related work are discussed in Section 8.
This work presents a study of the problems faced by
developers while using popular ML libraries. Our study
also leverages the posts on Stack Overflow. Since 2015, there
has been growing interest and significant increase in ML
•

Md Johirul Islam is with the Department of Computer Science, Iowa State
University, Ames, IA, 50010.
E-mail: mislam@iastate.edu

•

Hoan Anh Nguyen is with the Department of Computer Science, Iowa
State University, Ames, IA, 50010.
E-mail: hoan@iastate.edu

•

Rangeet Pan is with the Department of Computer Science, Iowa State
University, Ames, IA, 50010.
E-mail: rangeet@iastate.edu

•

Hridesh Rajan is with the Department of Computer Science, Iowa State
University, Ames, IA, 50010.
E-mail: hridesh@iastate.edu

related questions and distinct users making Stack Overflow a
representative source of dataset for our study. We selected
10 ML libraries to study, identified by a survey [1] and
confirmed by counting the number of posts on Stack Overflow related to those libraries. These libraries are Caffe [20],
H2O [21], Keras [22], Mahout [23], MLlib [24], scikit-learn [25],
Tensorflow [26], Theano [27], Torch [28], and Weka [29].
Caffe [20] is a deep learning library for Python and C++.
H2O [21] is a deep learning library for Java, R, Python
or Scala and its key feature is to provide a workflowlike system for building ML models. Keras [22] is a deep
learning library for Python whose key feature is to provide
higher-level abstractions to make creating neural networks
easier. Keras also uses Tensorflow or Theano as the backend.
Mahout [23] is aimed at providing scalable ML facilities for
Hadoop clusters. MLlib [24] is aimed at providing scalable
ML facilities for Spark clusters. scikit-learn [25] is a Python
library that uses Tensorflow or Theano as the backend. This
library provides a rich set of abstract APIs [30] to hide
complexity of ML from the user in an effort to make ML features widely accessible. Tensorflow [26] provides facilities to
represent a ML model as data flow graphs. Theano [27] and
Torch [28] are aimed at scaling ML algorithms using GPU
computing. A novelty of Theano is that it provides some
self-verification and unit testing to diagnose some runtime
errors. Weka [29] is a ML library for Java. It provides
API support for data preparation, classification, regression,
clustering and association rules mining tasks and a GUI for
making models easier.
All in all, this set is both representative and provides
variety. We selected a total of 3,243 highly-rated Stack Overflow posts for this study. A team of three Ph.D. students,
with experience in coursework on AI and ML, and using
ML libraries, independently read and labeled each of the

TABLE 1: Numbers of posts having different score (S) about
ML libraries. The bold column represents selected posts.
Library
Caffe [20]
H2O [21]
Keras [22]
Mahout [23]
MLlib [24]
scikit-learn [25]
Tensorflow [26]
Theano [27]
Torch [28]
Weka [29]
Total

S≥0
2,339
771
5,708
1,186
1,688
9,246
21,115
2,332
1,226
2,512
48,123

S≥1
1,320
452
3,323
610
929
5,302
10,109
1,341
640
1,216
25,242

S≥2
620
167
1,751
293
498
2,898
4,962
711
312
568
12,780

S≥3
318
73
953
160
272
1,759
2,769
421
161
293
7,179

S≥4
192
34
568
103
173
1,188
1,827
265
91
181
4,622

S≥5
132
17
367
48
119
856
1,334
192
61
117
3,243

posts producing 9,849 labels that were then compared for
consistency producing 177 conflicting labels on 177 different
posts. All of these conflicts were resolved using mediated,
face-to-face conflict resolution meetings between all three
participants. We then performed a statistical analysis and a
study of the data to answer the following research questions:
RQ1: Difficult stage Which stages are more difficult in a ML
pipeline? Fig. 1 shows stages in a typical ML pipeline.
RQ2: Nature of problems Which problems are more specific
to library and which are inherent to ML?
RQ3: Nature of libraries Which libraries face problems in
specific stages and which ones face difficulties in all stages?
RQ4: Consistency Did the problems stay consistent over the
time?
The remainder of this work describes our study and
results and makes the following contributions: (1) a labeled
and verified, dataset of 3,243 ML library-related Q&A on
Stack Overflow, (2) a classification scheme for ML-related
Q&A, (3) an intra-library analysis to identify strengths and
weaknesses of ML libraries, and (4) an inter-library analysis
to identify relative strengths and weaknesses.

2

M ETHODOLOGY

Our study uses Q&A posts on Stack Overflow, a popular
platform used by developers. Our first step was to find the
total number of questions asked about all the ML libraries
highlighted by some recent surves [1], [31], [32]. Out of
these, we selected 10 popular ML libraries for the study
as shown in Table 1. We excluded the other five libraries
because the numbers of questions about them were too few
(less than 20).
On Stack Overflow, each question is rated by the community. The score of a question is computed as S = |NU |−|ND |
where |NU | is the number of upvotes and |ND | is the
number of downvotes. The higher score is an indicator of
the higher quality of the question, which has been used in
prior works [33]. Table 1 shows the entire distribution of the
questions for each library based on the score S .
We selected questions with the score of 5 or higher (bold
column in Table 1) to focus on high-quality questions while
keeping the workload of manually labeling each question
manageable.
Next, we manually classified each Stack Overflow question into categories to study them further. We first discuss
the classification of categories and then our labeling process.

2

2.1

Classification of Questions

We classify the questions in Stack Overflow into several
categories. First, we classify the questions into two top-level
categories based on whether the question is related to ML
or not. Questions related to installation problems, dependency, platform incompatibility, Non-ML APIs, overriding
the built-in functionality, adding custom functionality fall
into Non-ML category as shown in Fig. 2. We classify the
ML-related questions into six categories based on the stages
of a typical ML pipeline [34], also reproduced in Fig. 1.
Among those seven stages, data collection is out of the
scope of this study because ML libraries do not provide this
functionality which leaves us with six categories. These six
categories are further divided into different sub categories.
To find these sub categories one of the Ph.D. (an author
of the paper) students with ML expertise first studied 50%
of posts and created the subcategories using open coding
scheme adapted from earlier works [35], [36], [37]. Then
these subcategories were sent to three ML experts for review. Based on the review of the experts the subcategories
were improved and the process continued until agreement
with ML experts was reached. The full classification is
shown in Figure 2. Next, we describe its categories.
2.1.1

Data Preparation

This top-level category includes questions about converting
the raw data into the input data format needed by the ML
library.
Data adaption. Questions under this subcategory are
about reading raw data into the suitable data format required by the library. Data reader provided by the library
usually provides this functionality. Questions about converting data, encoding, etc., also fall under this subcategory.
Featuring. Questions under this subcategory are about
feature extraction and selection. Feature extraction is a process to reduce dimensionality of the data where existing
features are transformed into a lower dimensional space.
Feature selection is another strategy of dimensionality reduction where informative features that have impact on the
model are selected.
Type mismatch. Type mismatch happens when the type
of data provided by the user doesn’t match the type required
by the ML API. For example, if an API needs floating
point data as input but the client provides a String then
the ML API raises an exception.
Shape mismatch. Shape mismatch occurs when the dimension of the tensor or matrix provided by a layer doesn’t
match the dimension needed by the next layer. These kinds
of errors are very common in deep learning libraries.
Data cleaning. Data cleaning phase, sometimes also
called data wrangling, includes removal of null values,
handling missing values, encoding data, etc. Without proper
data cleaning the training may throw exceptions, and accuracy may be suboptimal.
2.1.2

Modelling

The subcategories of this category include:
Model selection. This subcategory includes questions
related to the choice of the best model and choice of the API
version (e.g. whether to chose SVM or decision tree).

3
Data
Collection

Data
Preparation

Prediction

Modelling

Training

accuracy. For example, a bad learning rate may cause a
model to learn poorly and give low accuracy. The subcategories of this category include:
Tuning strategy selection. Questions about choosing
among APIs for different tuning methodologies are placed
into this subcategory. For example, one poster wondered
whether they should use the grid search or randomized
search or parameter sampling for parameter tuning in scikitlearn?
Tuning parameter selection. This subcategory covers
discussions related to the selection of parameters for tuning.
Some parameters may not have an effect on the model
accuracy other than increasing the training time while some
might have a significant effect on the accuracy. For example,
the following code from a post is trying to tune the kernel
and C parameter of the ML algorithm to find the best
combination from values given at line 4.

Evaluation

Parameter Tuning

Fig. 1: Stages in a typical ML pipeline, based on [34].
Model creation. This subcategory includes questions
related to creating the ML model using the APIs.
Model conversion. This subcategory includes questions
related to conversion of a model trained using one library
and then using the trained model for prediction in an
environment using another library. For example, a model
trained in Torch can be used for further training or prediction
using Theano.
Model load/store. This subcategory contains questions
about storing models to disk and loading them to use later.
2.1.3 Training
The subcategories of this category include:
Error/Exception. Questions about errors faced by users
in the training phase fall into this subcategory. The errors
may appear due to various reasons. If the errors are due to
shape mismatch or type mismatch we put them into data
preparation category. Otherwise, all errors are placed into
this subcategory.
Parameter selection. Some frameworks have optional
parameters, and developers have to choose appropriate values for these parameters and also pass relevant values to the
required parameters. Questions related to these problems
fall into this subcategory.
Loss function. Questions related to choosing and creating loss functions fall into this category, e.g., whether to use
cosine distance.
Optimizer. Questions related to the choice of optimizer
are placed into this subcategory, e.g., should I pick Adam or
AdaGrad?
Performance. In this subcategory, questions related to
long training time and/or high memory consumptions are
placed.
Accuracy. Questions related to training accuracy and/or
convergence are placed into this subcategory.
2.1.4 Evaluation
The subcategories of this category include:
Evaluation method selection. Question related to the
problems in the usage of APIs for doing validation fall into
this subcategory, e.g. “which of the eight APIs for eight different types of validations in scikit-learn, namely KFold, LeaveOneOut, StratifiedKFold, RepeatedStratifiedKFold, RepeatedKFold,
LeaveOneGroupOut, GroupKFold and ShuffleSplit, should be
used?”
Visualizing model learning. The developers sometime
need to visualize the behavior of the model to get a better
understanding of the training process and also to know the
effects of evaluation on the change of loss function and
accuracy. Those questions are placed in this subcategory.
2.1.5 Hyper-parameter Tuning
Hyperparameter tuning is used to improve the model’s
performance. The values of hyperparameters affect model

1
2
3
4
5
6

from sklearn import svm, datasets
from sklearn.model selection import GridSearchCV
iris = datasets.load iris()
parameters = {’kernel’:(’linear’,’rbf’), ’C’:[1,10]}
svc = svm.SVC()
clf = GridSearchCV(svc, parameters)

2.1.6

Prediction

After the model is trained and evaluated, the model is
used to predict new input data. Questions in this top-level
category are about problems faced by the developers during
prediction and include the following subcategories.
Prediction accuracy. Questions related to prediction accuracy, e.g. due to overfitting, are placed into this category.
Model reuse. Developers might have difficulty in
reusing existing models with their own datasets for prediction to make use of the state of the art models from wellknown providers.
Robustness. Questions in this subcategory are about the
stability of the models with slight changes, possibly noise,
in the datasets.
2.2

Manual Labeling

Manual labeling of the Q&A dataset was the most important
(and time-consuming) step before our analysis. To decrease
the bias in manual labeling we recruited three participants.
Each participant had coursework in both AI and ML and
had experience using ML libraries to solve problems. Each
participant labeled all the questions producing 9,840 labels.
Participant Training. Before the labeling, the participants were provided with the classification shown in
Fig. 2. Then, a training session was conducted where each
(sub)category was discussed and demonstrated using examples.
Labelling Efforts. First, each participant gave each
question one of the labels from top-level categories namely
Non-ML, Data Preparation, Modelling, Training, Evaluation, Tuning, Prediction. Then, (s)he assigned a subcategory.
We found that, at the steady state, a participant could
label around 50-60 questions per hour. For labeling the
whole dataset consisting of 3,283 questions, each participant
took around 1 week time. In total, 168 person-hours were
spent on labeling this dataset.

4
ML

Robustness

Model reuse

Prediction
Prediction accuracy

Strategy selection

Tuning
Parameter selection

Model visualization

Output interpretation

Accuracy

Optimizer

Evaluation

Performance

Loss function

Error/Exception

Parameter selection

Training

Model load/store

Model conversion

Model creation

Modelling

Model selection

Data cleaning

Shape mismatch

Featuring

Type mismatch

Data adaption

Bug

Setup

Custom Code

Non ML API

Data Preparation

Method selection

Non-ML

Fig. 2: Classification used for categorizing ML library-related Stack Overflow questions for further analysis

R1
R2
R3

R1
1.00
0.94
0.92

R2
0.94
1.00
0.91

R3
0.92
0.91
1.00

(a) Kappa coefficients (κ).

0.00–0.20
0.21–0.40
0.41–0.60
0.61–0.80
0.81–1.00

slight agreement
fair agreement
moderate agreement
substantial agreement
perfect agreement

(b) Interpretation of κ value.

Fig. 3: Cohen’s kappa coefficients for labeling process.
Reconciling Results. After collecting labels separately
from each participant, a moderator then compared them.
If there was an inconsistency between participants for a
question, the moderator created an issue in a repository
for resolution. Among all 3,243 questions, 177 (5%) needed
further discussion.
Then, the three participants had two in-person meetings
to discuss those 177 questions. The participants read the
questions carefully again and voted individually. If the
votes matched we accepted those as resolved, otherwise
participants discussed the reasons behind choosing a label
and tried to achieve consensus. In most cases, the opinions
differed due to the ambiguous nature of the questions. For
example, for a question asking about suboptimal accuracy, it
was difficult to say from the question without further exploration whether it is talking about accuracy in the prediction
stage or accuracy in the training or evaluation stage. We
resolved these type of questions by a careful reanalysis of
the Q&A text.
We measured the inter-rater agreements using Cohen’s
kappa coefficient (κ) as shown in Fig. 3a. It measures the
observed level of agreement between raters of a particular
set of nominal values and corrects for agreements that
would appear by chance. The interpretation of κ’s values
is shown in Fig. 3b. From Fig. 3a, we see that the kappa
coefficient between all the raters involved in the labeling
process is more than 0.9 indicating perfect agreements. We
also computed the Fleiss coefficient [38] which is widely
used for finding IRR between more than 2 raters. The
Fleiss coefficient was 90.68% indicating a perfect level of
agreement. We computed all the IRR coefficients based on
the ratings before the discussion for agreement. After the
discussion for reconciling the conflicts in the presence of a
moderator, the agreement level was 100%
2.3

person meetings. The inter rater reliability coefficient shows
that there was perfect level of agreement between raters.
The possibility of missing relevant posts can also be a
threat. We mitigate this bias by collecting the tags that are
relevant to a particular ML library. We then collect all the
posts containing those tags using Stack Overflow API.
Classification of questions in the top level categories can
also pose threat. To mitigate this threat we use the categorization used and described by practitioners and researchers
[24], [34], [39].
Classifying the top level categories into subcategories
can have bias and missing subcategories due to open coding
scheme. To mitigate this threat one PhD student initially
studied a subset of posts and came up with the subcategories. Then, three ML experts were consulted and their
opinion on the classification was used for multiple round
of revisions and improvements.
The ML expertise of the raters can affect the manual
labeling. To mitigate this threat we selected raters who have
expertise in ML as well as using the libraries in the study.
The raters also study the answers and comments in posts to
improve their insights.
External Validity In Stack Overflow threat to validity can
be low quality posts [40], and chronological order of posts.
To eliminate the quality threat we studied only the posts
that have the tag of the relevant library and then only kept
the posts that have score ¿= 5. This balanced both the quality
and labeling efforts.
Chronological order of the posts can introduce threat as
some older posts may be resolved in later version of the
libraries. To alleviate this threat we classify questions that
may appear only due to the API versions into Non-ML
category.
An external threat can be expertise of the programmers
asking the questions. If the questions are asked only by
newbies then our results aren’t as general. To understand
this threat, we measured reputation, a metric used by Stack
Overflow to estimate expertise. Stack Overflow users above
50 are considered reputable and are allowed to comment
on posts. Table 2 shows that the mean reputation of programmers asking the questions that we have studied is high
indicating that the expertise of the programmers asking the
questions is not a threat to our study.

Threats to Validity

Internal Validity In the manual labeling threat can be due
to the possibility that labeling could be biased. We mitigate
this threat by using 3 raters and resolving the conflicts via in

3

A NALYSIS AND R ESULTS

We have proposed four research questions to understand
what developers ask about ML. We explore the answers to

5

TABLE 2: Reputation of users for posts in our study.
Library
Caffe [20]
H2O [21]
Keras [22]
Mahout [23]
MLlib [24]
scikit-learn [25]
Tensorflow [26]
Theano [27]
Torch [28]
Weka [29]
Overall

Min
28
24
22
26
26
1
26
26
26
26
1

Max
68238
7115
68662
48267
159552
108807
149231
68692
31205
135428
159552

SD
7727
1635
4639
7105
15115
5747
5234
7739
3813
15774
6289

Mean
2252
994
1375
3217
3367
1850
1399
2721
1646
4440
1764

Median
485
194
354
998
427
474
336
497
504
556
389

these research questions in this study. The research questions cover the following aspects: identifying the difficult
stages in the current ML pipeline faced by the developers
(RQ1), understanding whether the problems faced by the
developers are only due to the design of library or there are
some problems inherent to ML (RQ2), exploring whether
some of the libraries are more difficult in certain stages and
are there libraries that shows comparable difficulties in all
the stages (RQ3), exploring whether the problems faced by
the developers changed over time or they stayed consistent
(RQ4). Next, we answer these questions using a statistical
analysis summarized in Tables 3 and 4 and present our
findings. Our raters have read and agree with these findings.

4

RQ1: D IFFICULT STAGES

If we know the relative difficulty of ML stages for developers, then software engineering R&D and educational efforts
can prioritize work on challenging stages. This section explores this question.
4.1

Most difficult stage

As Table 3 shows, and as expected the model creation is
the most difficult, but surprisingly data preparation is the
next difficult stage which turns out to be more difficult than
training stage.
Model creation has the median of 23% across all the
libraries which is the highest compared to all other stages
in the ML pipeline. Some of the libraries for distributed
ML like Mahout, Torch, Caffe, MLlib have abnormally high
difficulty in model creation stage. This suggests that machine learning in distributed environment is not developer
friendly yet.
Finding 1: Model creation is the most challenging
(yet critical) in ML pipeline, especially for libraries
supporting distributed ML on clusters like Mahout and
MLlib.
Finding 1 provides indication that, tool support in creating models, especially in distributed machine learning is
needed. Enhancing tool support to make model creation in
distributed environment easier and research on detecting
and resolving problems in model creation is needed.
Further analysis showed that libraries that model creation is especially harder for ML libraries that require developers to use multiple configuration languages to configure
their models, for example in Caffe. For example in Caffe,

questions about using multiple languages are discussed
frequently. According to a case study by Amershi et al.
[41], Microsoft developers face similar issues in the machine
learning pipeline. It says that though Data Availability, Collection, Cleaning, and Management are most challenging for
all three groups of the developer but Model Evolution, Evaluation, and Deployment are more significant for all groups
according to the frequency. Our results from studying the
posts support what was known at a corporate community
and have found several new findings.
4.2

Data preparation

This top level category includes questions about adapting
the data to the format required by the library, featuring,
dealing with type and shape mismatches, and data cleaning.
All together, this stage is the next most difficult stage across
ML libraries (median 20%).
Finding 2: Data preparation, especially data adaptation, is the second most difficult stage in ML pipeline.
Further analysis showed that ML libraries that use uncommon formats lead to additional difficulties among the
developers to understand the format, use the new formats
in their software, data wrangling and preprocessing to the
format of the data. For example, Weka, MLlib have higher
problem in data adaption due to their use of uncommon
ARFF and RDD formats of data. For some libraries data
preparation turns out to be ever more challenging compared
to model creation. For example, H2O, Torch and Weka have
35.29%, 22.95% and 20.51% of posts, respectively, about data
adaptation.
This finding suggests that the tradeoff in the design of
data preparation APIs, e.g. use of custom formats, needs
more study. Interestingly, most of the ML textbooks and
courses spend little time on data preparation related discussions.
Surprisingly Tuning and Prediction stages of the ML
pipeline—topics discussed frequently in the ML research
papers—appear infrequently in Stack Overflow questions.

5

RQ2: N ATURE OF PROBLEMS

Are some difficulties inherent to ML and thus all ML libraries face them? If so, general solutions could be developed and adapted to all ML libraries. Otherwise, design of
the specific library could be improved by utilizing lessons
learned in this section.
5.1

Type mismatch

Type mismatch questions have median of 1.61%, SD of
1.02%, and IQR of 1.80%. The smaller IQR indicates that
type mismatch appears in most of the ML libraries. scikitlearn, MLlib, Theano and Tensorflow have higher difficulties in
type-related problems with 2.92%, 2.52%, 2.08% and 2.02%,
respectively. MLlib uses a custom data format called RDD
that seems to make type-related problems more frequent for
this library. There are also questions about failures due to
type mismatch in scikit-learn, Tensorflow and Theano as their
APIs have type requirements that are not currently checked.

TABLE 3: Percentage of questions in each top-level category across libraries (in %).

6

Caffe H2O Keras Mahout MLlib scikit-learn Tensorflow Theano Torch Weka Q1 Q3 IQR Median SD
Data preparation 14.0 41.0 16.0
17.0
33.0
26.0
16.0
17.0 23.0 30.0 16.5 29.0 12.5
20.0 8.7
∗ 44.0
Modelling
32.0 24.0 28.0
29.0
25.0
27.0
27.0 33.0 20.0 26.5 31.2 4.7
27.0 5.5
Training
24.0 18.0 25.0
8.0
15.0
18.0
21.0
16.0 20.0 12.0 15.0 20.7 5.7
18.0 4.7
Evaluation
1.0
6.0
8.0
4.0
7.0
9.0
9.0
3.0
3.0 10.0 3.5 8.3 4.8
6.0 2.9
∗ 4.0
Tuning
1.0 ∗ 6.0
0.0
0.0
2.0
1.0
1.0
0.0
0.0 0.0 1.5 1.5
1.0 1.9
Prediction
6.0
0.0 10.0
4.0
6.0
7.0
4.0
2.0
2.0 11.0 2.6 6.6 4.0
5.0 3.2
Non-ML
22.0
6.0 13.0
23.0
6.0
11.0
20.0
35.0 20.0 10.0 10.3 21.4 11.1
16.0 8.6
∗ indicates the library is an outlier for the category in the corresponding row. IQR = Q3 − Q1: inter-quartile range. SD: standard deviation.

TABLE 4: Percentage of questions in each subcategory across libraries (in %).

Caffe H2O Keras Mahout MLlib scikit-learn Tensorflow Theano Torch Weka Q1 Q3 IQR Median SD
Data adaptation
9.84 35.29 7.90
14.58 25.2
8.64
9.22 10.41 22.95 20.51 9.37 22.3 12.93
12.5 8.70
Featuring
0 5.88 1.09
0 4.20
9.34
0.74
0.52
0 4.27 0.13 4.3 4.17
0.92 3.03
Type mismatch
1.52
0 1.09
0 2.52
2.92
2.02
2.08
0 1.71 0.27 2.07 1.80
1.61 1.02
Shape mismatch
1.52
0 ∗ 5.50
0
0
1.86
2.62
2.08
0
0
0 2.03 2.03
0.75 1.70
Data Cleaning
1.52
0 0.55
2.10 2.52
3.62
2.09
1.60
0 3.41 0.79 2.40 1.61
1.82 1.22
Model creation
26.52 17.64 25.88 ∗ 43.75 23.52
21.37
23.01 23.43 22.95 21.36 21.77 25.30 3.53
23.22 6.70
∗ 2.10
Model selection
0
0 0.55
0 0.84
0.60
0
0
0
0 0.58 0.58
0 0.64
Model conversion
3.79
0 0.27
0 0.84
0.33
2.25
2.60 4.91 3.41 0.24 3.21 2.97
1.54 1.71
Model load/store
1.50 5.88 1.63
0 5.04
1.75
1.94
1.01 4.91 1.71 1.55 4.20 2.65
1.73 1.88
Error/Exception
0.76 5.88 5.50
4.20 5.88
4.78
5.32
5.72 1.64 2.56 2.96 5.67 2.71
5.10 1.80
Parameter selction
9.10 5.88 5.50
0 2.52
3.97
3.74
2.60 8.20 5.13 2.89 5.78 2.89
4.50 2.60
Loss function
6.10
0 4.09
0 0.84
1.40
3.74
2.60 3.30 1.71 0.98 3.60 2.62
2.16 1.86
Optimizer
2.30
0 1.09
2.10
0
0.70
2.77
1.04 3.30 0.85 0.74 2.20 1.46
1.07 1.07
Performance
2.30 5.88 6.27
2.10 5.04
3.27
4.87
3.12 1.64 0.85 2.13 5.00 2.87
3.20 1.80
Accuracy
3.78
0 2.45
0 0.84
3.62
0.90
1.04 1.64 0.85 0.84 2.30 1.46
0.97 1.30
Eval. strategy selection
0.75
0 2.18
2.08 5.04
3.85
5.24
0 1.64 8.54 0.84 4.7 3.86
1.86 2.64
Visualization
0
0 1.63
0
0
2.68
1.65
0
0 2.68
0 1.23 1.23
0 0.95
∗
∗
Output interpretation
0 5.88 3.82
2.1 1.68
2.21
2.17
2.60 1.64 1.71 1.69 2.50 0.81
2.13 1.47
Tuning strategy selection 0.75 ∗ 5.88 0.27
0 1.68
3.50
0.45
1.04
0
0 0.07 1.52 1.45
0.60 1.82
∗ 0.81
Tuning param. selection
0
0
0
0
0
0.08
0
0
0
0
0
0
0 0.24
Prediction accuracy
6.10
0 6.81
4.20 5.04
5.25
3.97
2.08 1.64 8.54 2.55 5.85 3.30
4.60 2.44
Model reuse
0
0 ∗ 1.37
0
0
0.23
0.22
0
0 ∗ 1.71
0 0.23 0.23
0 0.60
Robustness
0
0 1.65
0 0.84
1.28
0.30
0
0 0.85
0 0.85 0.85
0.15 0.59
Non-ML API
2.27
0 2.72
4.20 2.52
2.80
4.40
2.08 3.27 1.71 2.13 3.15 1.02
2.63 1.19
Setup
16.67 5.88 9.53
18.75 2.52
5.95
14.50 30.72 16.39 7.69 6.39 16.60 10.21
12.05 7.90
Custom code
1.52
0 0.81
0 0.84
1.51
1.05
1.56
0 0.85 0.21 1.40 1.19
0.84 0.60
∗ 1.52
∗ 0.23
Bug
0
0
0
0
0.07
0
0
0
0 0.06 0.06
0 0.45
∗ indicates the library is an outlier for the subcategory in the corresponding row. IQR and SD are defined in Table 3.

Finding 3: Type mismatches appear in most ML libraries.

Finding 4: Shape mismatch problems appear frequently in deep learning libraries. Keras is an outlier
in this subcategory with 5.5% of posts.

The finding suggests that ML libraries have not focused
on type correctness and ML-specific type correctness. A
static analysis tool might be able to prevent the majority
of these problems. To understand the characteristics of the
type mismatch related posts, we randomly select 44 Stack
Overflow posts. We found 31 out of 44 problems were caused
by the abstraction created by the libraries to create ML
types. The other 13 were standard Python type errors. As
an example, the following exception is thrown due to an
ML type error.
1

Fig. 4: Question 40430186: An example showing dimension
or shape mismatch problem in training in ML.
The finding suggests that techniques for verifying shape
and dimension compatibility are needed for deep learning
libraries. Such techniques could verify if the data conforms
to model architecture, and dynamic modification of the
network against data shape.
Abstract APIs that hide the details of inner-working of
the deep learning networks can further complicate matters.
To illustrate consider the following Keras code.

ValueError: (’Unknown loss function’, ’:root mean squared error’)

5.2

Shape mismatch

Shape mismatch related questions have median of 0.75%,
SD of 1.70%, and IQR of 2.03%. This problem appears in all
deep learning library in which Keras is an outlier with 5.50%.
In these libraries, shapes of neurons at adjacent layers must
be compatible otherwise the library will throw exceptions
during training or fail during prediction. An example is
shown in Fig. 4.

1
2
3
4
5
6
7
8
9

def CreateModel(shape):
if not shape:
raise ValueError(’Invalid shape’)
logging.info(’Creating model’)
model = Sequential()
model.add(LSTM(4, input shape=(31, 3)))
model.add(Dense(1))
model.compile(loss=‘mean squared error’, optimizer=‘adam’)
return model

The error is at line 6 where an invalid value of (31, 3)
is passed to input shape. The accepted answer suggests

7

that input shape should be (32, 1) instead. The user could
not verify statically whether the built model has compatible
shape or if there are any unconnected or extra ports while
building the model. If we had the tools that could tell
the developer that using dimension (32,1) can cause 2 out
of 3 ports of the next layer to be unconnected then it
would be much easier for the developer to find these errors
by themselves. These kind of errors could be detected by
program analyses and by providing feedback to the users.
In fact, many discussions in these high-scored posts call for
richer analysis features. To understand the reason behind
the Keras being an outliner in Shape Mismatch sbcategory,
we have selected 60 random posts from the dataset. We have
found that 21 out of 60 shape mismatch problems are from
Keras and the shape mismatch in Keras occurs due to the
abstraction of APIs used to create layers in the network. The
dimension of the layers violate the contracts between the
layers without giving any hints to the developer.
5.3

Data Cleaning

As shown in Table 4, data cleaning related questions across
the libraries have median of 1.82%, SD of 1.22% and IQR
of 1.61%. Most of the libraries have questions about data
cleaning stage except for H2O and Torch. This is not surprising since data cleaning is an integral part of any data
science pipelines. Libraries scikit-learn, Weka and MLlib have
the most questions.
Finding 5: Most libraries have problems in data cleaning.
This finding suggests that tool support for data cleaning is
needed, but such techniques may need to overcome inherent
technical challenges. The abstract APIs in these libraries
sometimes make cleaning fail. For example, the nan values
in the dataframe needs to be converted first into numpy
nan type before they can be cleaned using APIs provided
by scikit-learn. Furthermore, these failures do not clearly
indicate the root cause making diagnostics difficult.
5.4

When we study the questions about Caffe we see that
Caffe users have problems in model creation due to the
dependency of the model on multiple files. To create a
model successfully, one needs to make a schema file in
protobuf format, create a solver file and write code in C++ or
Python to build the model [42]. Having several components
complicates matters. In our study, 36 out of 135 questions
about Caffe are about model creation problems.
5.5

Error/Exception

Error/Exception subcategory has the median of 5.10%, SD
of 1.80% and IQR of 2.71%. All the libraries have issues
on runtime error/exception. Surprisingly, though model
creation seems problematic in Caffe, runtime failure is very
low in Caffe with 0.76%. MLlib, H2O, Keras, Tensorflow and
scikit-learn have higher percentage of runtime errors with
5.88% and 5.88%, 5.50%, 5.32% and 4.78%, respectively.
Finding 6: Questions on exceptions/errors are prevalent.
This finding suggests that debugging and monitoring facilities for ML needs much improvement to help developers
resolve error/exception independently. We dug deeper to
determine where debugging and monitoring might be most
helpful and found that deep learning and distributed ML
libraries have more posts about runtime errors at training
time, e.g. when a model is throwing an exception at training
time, a model is not converging or learning as the iteration
of training goes on, a model is not predicting well, etc.
Fortunately, some recent work has started to address these
issues [43], [44], but much more work is needed. Due to
the lack of debugging tools to monitor pipelines causes of
failure are hard to identify. More abstract deep learning
libraries throw more runtime exception during training, e.g.
see Figure 6.

Model creation

In model creation subcategory, the most difficult stage according to RQ1, we see problems that are both inherent to
ML, and specific to design choices in the library. Inherent
difficulty of distributed ML is a major source of questions,
e.g. see Fig. 5.

Fig. 6: Question 45030966: An example question about Keras
showing abstraction in deep learning libraries could make
identifying root cause of an error/exception difficult.
5.6

Fig. 5: Question 12319454: An example question on model
creation for distributed ML using Mahout.
Deep learning libraries like Caffe, Keras, Theano and
Tensorflow also have higher percentages of questions about
model creation with 26.52%, 25.88%, 23.43% and 23.01%,
respectively. This shows that model creation for deep neural
networks is difficult as well.

Parameter selection

We expected parameter selection to be an inherent ML
issue but found some variation between libraries, median
of 4.50%, SD of 2.60% and IQR of 2.89%, suggesting key differences among libraries. Caffe and Torch have comparatively
more problems with 9.10% and 8.20%, respectively. Libraries
like Keras, Weka, H2O, MLlib shows larger percentage of
questions on choice of parameters.

8

Finding 7: Parameter selection can be difficult in all
the ML libraries.
For selecting parameters adding support for meta-heuristic
strategies in the libraries can be helpful.
5.7

Loss function selection

Loss functions are used to quantify the difference between
values predicted by the model and actual values (labels).
Our results shows that developers have difficulty selecting
an appropriate loss function but the extent of difficulties
varies across the libraries (median of 2.16%, SD of 1.86% and
IQR of 2.62%). All deep learning libraries have comparatively more questions about loss function, for example Caffe,
Keras, Tensorflow and Torch have the highest percentages of
6.10%, 4.09%, 3.74% and 3.30%.
Finding 8: Choice of loss function is difficult in deep
learning libraries.
This indicates the necessity of further research on the
usage of loss function in deep learning libraries, e.g. on loss
function recommendation. The selection of the loss function
is primarily dependent on the type of the problem. A wrong
selection of the loss function can cause a machine learning
model to perform poorer (low accuracy) or can decrease the
security of a model by decreasing the robustness that can be
utilized by attackers to perform adversarial attack [45].
5.8

Training accuracy

We expected training accuracy to be an inherent ML issue
impacting all libraries; however, there are few questions
about this on Stack Overflow. Caffe and scikit-learn stood out
with 3.78% and 3.62% questions about training accuracy.
These libraries provide highly abstract APIs and a large
number of optional parameters that need to be selected.
Finding 9: Abstract ML libraries have higher percentage of questions about training time accuracy and
convergence.
This suggests that the library documentation could be
clearer about the impact of optional parameters on training
accuracy. Secondly, recommendation system could be developed for parameter recommendation based on dynamic
traces.
5.9

Fig. 7: scikit-learn issue #4800: An example of hyperparameter tuning problem. The user filed a bug report, but a
developer of the library responded that the problem was
with hyperparameter tuning.

Tuning parameter selection

Like accuracy, we considered tuning parameter selection to
be an inherent ML issue, impacting those libraries more that
have higher number of parameters. Even though not too
many libraries have questions about it, scikit-learn and Tensorflow stand out. Tensorflow has higher usage and questions
in general, but scikit-learn was as expected due to the large
number of optional parameters.
As
an
example,
consider
creating
AdaBoostClassifier with 5 optional parameters
initialized to some default values shown below.

1
2

c l a s s s k l e a r n . ensemble . A d a B o o s t C l a s s i f i e r (
b a s e e s t i m a t o r=None , n es tim ato rs =50 , l e a r n i n g r a t e = 1 . 0 ,
a l g o r i t h m= ’SAMME. R ’ , random state=None )

The base estimator is set to None but the user may
need to choose an estimator to get the best performance.
Learning rate is by default set to 1.0. At this learning rate,
it is highly likely that the model will not learn anything. So
the user may often use these APIs incorrectly and wonder
why ML model is not producing useful results. Since these
are optional parameters, the user will not even get any error
or warning. Finding good values for these parameters and
tuning them to make the best model, avoiding over-fitting
are frequent questions among developers using scikit-learn.
There have been some GitHub issues filed to the repository
of scikit-learn as bugs (See Fig. 7 for an example) but the
underlying problem was that the developer was not able
to trace why the model is not showing expected accuracy,
and unable to tune hyperparameters. We have found 36
questions out of 849 in scikit-learn asking help about hyperparameter tuning.
Finding 10: scikit-learn has more difficulty in hyper
parameter tuning compared to other libraries
Overall, our results from this and two previous subsections suggest that parameter recommendation is an urgent
need for ML libraries, especially those that have a lot of optional
parameters.
5.10

Correlation between libraries

Next, we study whether the pattern of problems exhibited
by libraries have similarities. The correlation between libraries based on common pattern of problems is shown in
Fig. 8. We have identified two major groups.
Group 1. Weka, H2O, scikit-learn, and MLlib form a
strongly correlated group with correlation coefficient greater
than 0.84 between the pairs. This suggests that the problems
appearing in these libraries have some correlation and the
difficulties of one library can be described by the difficulty
of other libraries in the group.
Finding 11: Weka, H2O, scikit-learn, MLlib form a strong
correlated group with correlation coefficient greater
than 0.84 between the pairs indicating that these libraries have similar problem in all the ML stages.
This finding is interesting because other than H2O, other
libraries in this category don’t support deep learning. We
believe that the correlation may be because each of these
libraries support many different ML algorithms and allow
the user to select an algorithm for their tasks. This design

9

(a) Question

(b) Best accepted answer

Fig. 9: Question 24617356: An example showing the API
misuse problem in ML libraries. Code snippets are omitted.
Fig. 8: Correlation between distributions of percentage of
questions over stages of the libraries.

API. The answer in Figure 9b suggests that the second API
needs the data to be shuffled properly before passing to
the API in every iteration. Making that change solves the
performance problem. This is an example of API misuse
where the precondition of the second API is not satisfied
which leads to a performance bottleneck. For another example, let’s consider a problem related to the creation of a
NaiveBayes model. Only a part of the code snippet where
API misuse occurred is shown below:

choice is markedly different from the other group that are
specialized for a single ML algorithm.
Group 2. Torch, Keras, Theano, and Tensorflow form
another group with strong correlation of more than 0.86
between the pairs. These libraries are all specialized for deep
learning.
Finding
12:
Deep
learning
libraries
Torch, Keras, Theano and Tensorflow form another
group with strong correlation of more than 0.86
between the pairs indicating these libraries follow
similar problem in all the stages
This finding is interesting because each of these
deep learning libraries have adopted different design and
philosophies. Tensorflow and Torch are focused on providing low-level general facilities, Keras focuses on high-level
abstractions, whereas Theano focuses on efficiency on both
CPU and GPU. Our finding suggests that despite different
design philosophies followed by each of these ML libraries,
the problems are interrelated for the libraries in this category. So, the software engineering research results for one
library may generalize to other deep learning libraries.
5.11

1
2
3
4
5
6
7

The code failed to work successfully giving dimension
mismatch error in some parts of the code. The solution to
the problem is to properly use the API csr matrix(). This
API needs to have a shape parameter defined explicitly and
the correct way to use the API is to explicitly define the
shape shown in the code below.
1

return csr matrix((data, (row, column)), shape=(len(vectors), dimension))

We have observed another kind of API misuse due to
API update by the library provider. To illustrate, consider
the code below that worked well in Apache Spark MLlib
version < 2.0. For Apache Spark version >= 2.0, this API
doesn’t work. This is one of the top voted questions on
Apache Spark MLlib category.

API Misuses in All ML Stages

The ML libraries have APIs that are very often misused.
To identify the misuses we have studied both the questions
asked by some developer and the well accepted answers.
If the answers pointed out to incorrect or wrong use of API
and provided solution using correct use of APIs, we marked
them as posts containing API misuse. API misuse is seen
across all the stages of ML pipeline.
For example, see Figure 9 where a user is asking that
their training takes much time or longer number of iterations to get a certain training accuracy. When they use
one API they are able to achieve the desired accuracy in
5 iterations where in the other API they need 60 iterations
to reach the same accuracy. The second API works fine,
without any error and eventually reaches the same accuracy.
But still, the user is puzzled that almost 12 times higher
number of iterations are required when using the second

def convert to csr matrix(vectors):
logger.info(”building the csr sparse matrix representing tf−idf”)
row = [[i] ∗ len(v) for i, v in enumerate(vectors)]
row = list(chain(∗row))
column = [j for j, in chain(∗vectors)]
data = [d for , d in chain(∗vectors)]
return csr matrix((data, (row, column)))

1
2
3
4

from pyspark.mllib.clustering import KMeans
spark df = sqlContext.createDataFrame(pandas df)
rdd = spark df.map(lambda data: Vectors.dense([float(c) for c in data]))
mdl = KMeans.train(rdd, 2, maxIterations=10, runs=30, initializationMode=”
random”)

MLlib version 2.0 isn’t backward compatible and so the
code at Line 3 is outdated and must be replaced by the
following
1

rdd = spark df.rdd.map(lambda data: Vectors.dense([float(c) for c in data]))

We have found that similar version incompatibility problems are also prevalent in other ML libraries.
Besides, the API misuse scenarios discussed above,
many other kinds of API misuse are common in ML libraries, and a more detailed analysis and categorization of
errors is needed (much like MUBench [46]). Some common

10

problems include failure to find important features, improperly preparing the dataset, performance, over-fitting problems, suboptimal prediction performance, etc. A detailed
analysis of API misuse is beyond the scope of this work.

6

RQ3: N ATURE OF LIBRARIES

In this section we explore whether some of the libraries are
more difficult in certain stages and are there libraries that
shows comparable difficulties in all the stages (RQ3). To
answer RQ3, we look at three measures. Which libraries
have non-zero percentage of questions under the majority
of subcategories? Which libraries have above median percentage of questions under the majority of subcategories?
Which libraries have outliers?
It turns out that scikit-learn and Tensorflow have questions
under all subcategories, and Keras, Weka, MLlib, Caffe, and
Theano have questions under the majority of subcategories.
On the other hand, H2O, Mahout and Torch have questions
concentrated under few subcategories and other subcategories have no questions. We further observed subcategories
under which H2O have the majority of questions and found
that the majority of the questions are in the initial stages
such as how to adapt data to use within H2O, how to create
a model, or how to setup to use the library adequately.
We also observed similar trends for Mahout except it has
proportionally higher percentage of questions about model
creation and setup.
Finding 13: Early stages for H2O and Mahout especially
setup and model creation have comparatively higher
percentage of questions compared to later stages.
This may suggest that getting started is harder with H2O
and Mahout. Reflecting further on the nature of H2O and
Mahout, there is a key similarity between the two libraries.
Both present non-traditional models of computation to the
developers. H2O presents a workflow like model, and Mahout is for distributed ML. The absence of questions for later
stage subcategories might suggest either that developers
who started with H2O and Mahout stopped using the library
or that all developers who faced problems getting started
with H2O and Mahout continued using the library without any major difficulties, and had no questions. Further
research is needed to understand which was the case and
we didn’t find any definitive evidence during this study to
suggest either way.
Next, we look at libraries that have above median percentage of questions under the majority of subcategories.
At the top, >50% subcategories, are Tensorflow (20 subcategories), scikit-learn (19 subcategories), Keras (17 subcategories). Tensorflow and Keras are popular libraries for deep
learning, and above average interest in the majority of the
aspects of their functionality reflects their popularity. scikitlearn is a popular ML library in Python. Though it is not
used for deep learning, its use for regression, supervised
and unsupervised learning, and recommendation related
tasks are well known. This library provides abstract APIs
that hides the details of ML. In our study, the majority
of questions about scikit-learn were about data preparation
(26%), modeling (25%), and training (18%). In the middle,

>30% subcategories, we have MLlib (13 subcategories), Caffe
(12 subcategories), Weka (11 subcategories), Theano (11 subcategories), and Torch (9 subcategories). At the bottom, we
have Mahout (6 subcategories) and H2O (8 subcategories).
We have previously observed that Mahout and H2O have
questions observed under few categories associated with
initial stages. Combining with this observation suggests that
such difficulties are higher for Mahout and H2O compared
to other libraries.
Next, we look at outliers. For shape mismatch Keras is
an outlier, for model creation Mahout is an outlier, for model
selection scikit-learn is an outlier, for output interpretation
H2O and Keras are outliers, for tuning strategy H2O is
an outlier, for tuning parameter selection scikit-learn is an
outlier, for model reuse Keras and Weka are outliers, and for
bug Caffe and scikit-learn are outliers.
Finding 14: scikit-learn is an outlier in several categories suggesting that a deeper look into its API
design might be necessary to improve usability of this
important library.
scikit-learn provides a lot of optional parameters to be
selected in their APIs, whose values are hard to select yet
affect accuracy. That could be the reason why its users have
more difficulties in selecting parameters. scikit-learn also has
an abnormally high percentage of questions about model
selection, which is surprisingly because it is one of the few
libraries to provide abstract model selection APIs, but the
use of these APIs could be simplified. This calls for research
on designing better APIs for scikit-learn.
Next, we will look at the error/exception related questions.
Finding 15: Deep learning libraries Caffe, H2O, Keras,
Tensorflow, Theano, Torch show more training time difficulties compared to other ML libraries
While this finding shouldn’t be a surprise, it reinforces
a well-established worry in both the AI/ML and SE/PL
communities that explaining why a deep learning model
has worked or failed at training time or gives unexpectedly
low performance remains a hard and open question. We
confirm that it is important to solve it to help developers
make effective use of deep learning APIs. To ensure that
the dataset represents the usage of these libraries in the
open source projects, we have calculated the number of
occurrences of these libraries in Github open source projects.
Table 5 reports the number of occurrences of each library
in GitHub. Furthermore, we performed the Kolmogorov
Smirnov [47] test among the distribution of the library usage
population and our dataset population. We have found pvalue of 0.675 and KS − statistics value as 0.3, which
suggest that both samples have been taken from a similar
population.

7

RQ4: T IME CONSISTENCY OF DIFFICULTY

In this section we explore the answer to RQ4 to understand
whether the problems across different stages stayed consistent over time or are there problems that were prominent

TABLE 5: Number of occurences utlizing the libraries in
GitHub.
Library
Caffe
H2O
Keras
Mahout
MLlib
scikit-learn
Tensorflow
Theano
Torch
Weka
Overall

Occurences
1,46,121
33,112
7,55,427
2,793
90,042
2,69,672
39,41,629
2,28,960
1,21,583
21,779
56,11,118

Fig. 10: Difficulties over time, across different stages
only for a certain period of time and then solved by the
library developers. To study this question, we plot the
percentage of posts across different stages of all the libraries
from the year 2009 to March 2018.
Our major observations from Figure 10 are described below: Model creation related problems are consistent over
time. Choice of model problems seem consistent over time
indicating model creation problems are not being affected
by the evolution of libraries. While these are fundamental
problems for ML, deeper involvement of SE engineering
researchers is needed to glean and disseminate lessons,
patterns, and anti-patterns to help ML practice.
Data preparation related problems slowly decrease
after 2013 and show sharp increase after 2017. Weka the
library that has most difficulty in data preparation stage
started losing popularity and new tensor representation of
data gained popularity which explains the slow decline in
the data preparation difficulty. The increase in data preparation since 2017 coincides with the increasing interest in
deep learning, and popularity of deep learning libraries that
provide higher levels of abstraction. Data from a varied set
of sources are prepared for deep learning tasks.
Training related problems shows slow increase over
time. Due to the popularity of deep learning where training time errors occur more frequently the training related
problems are slowly increasing.
Evaluation problems are consistent over time. Evaluation related problems have not been solved by the evolution
of ML libraries over the last decade.

8

R ELATED W ORK

Stack Overflow is the widely used platform to study the software engineering practice from the developer’s perspective.

11

However, existing work has not studied the usage of ML libraries
using Stack Overflow. Meldrum et. al. [33] studied 266 papers
using Stack Overflow platforms to show the growing impact
of Stack Overflow on software engineering research. Treude
et. al. [5] did a manual labeling of 385 questions to manually
classify 385 questions into 10 different categories (how-to,
discrepancy, environment, error, decision help, conceptual,
review, non-functional, novice, and noise) to identify the
question types. This study is useful to learn the general
categories of questions asked by developers. Kavaler et.
al. [8] used Stack Overflow data to study the queries on APIs
used by Android developers and showed the correlation
between APIs used in producing Apps in the market and the
questions on APIs asked by developers. Linares-Vásquez et.
al. [9] studied the effect of the changes in Android API on
the developer community. They used the discussions arising
on Stack Overflow immediately after the API is changed and
behavior of the API is modified to study the impact of the
change among the developers. [48] studied machine learning based algorithms, approaches, execution frameworks
and presented a brief discussion of some libraries used in
machine learning. Barua et. al. [11] studied the Stack Overflow
posts and used LDA topic modeling to extract topics to
study the trend of different topics over time. Rebouças et.
al. [13] studied the usage pattern of swift programming language among developers using Stack Overflow data. Schenk
et. al. [15] studied the geographical distribution of usage and
knowledge of different skills using Stack Overflow posts and
users data. Stanley et. al. [16] proposed a technique based on
the Bayesian probabilistic model to predict the tags of a Stack
Overflow post. McDonnel et. al. [17] presented a study of API
stability using Stack Overflow data and as a test case they
used Android Ecosystem. Baltadzhieva et. al. [18] proposed
a technique to predict the quality of a new Stack Overflow
question. Joorabchi et. al. [19] studied the challenges faced
by computer science learners in different topics and subjects
using the Stack Overflow data. These works are orthogonal
to ours.

9

C ONCLUSION

This work is motivated by the need to empirically understand the problems with usage of ML libraries. To understand the problems, we retrieved a significant dataset of
Q&A from Stack Overflow, classified these questions into categories and subcategories and performed analysis from four
viewpoints: finding the most difficult ML stage, understanding the nature of problems, nature of libraries and studying
whether the difficulties stayed consistent over time. We
found that model creation is the most difficult stage followed by data preparation. We found that type mismatch,
data cleaning and parameter selection are difficult across
all libraries. We also found that initial stages are harder for
H2O and Mahout, and scikit-learn has proportionately higher
problems in several subcategories. Lastly, we observed that
data preparation and training related problems are showing
a sign of increase going forward. These findings are a call
to action for SE researchers as engineering of software with
ML components is likely to be routine in the next decade.

12

ACKNOWLEDGMENTS
We thank the anonymous reviewers for their valuable time
and constructive feedbacks. We also thank PhD students
Hamid Bagheri and Giang NGuyen to take immense pain
and labeling the questions manually with great care and
helping to resolve the difference through multiple meetings
.This material is based upon work supported by the National Science Foundation under Grant CCF-15-18897 and
CNS-15-13263. Any opinions, findings, and conclusions or
recommendations expressed in this material are those of
the authors and do not necessarily reflect the views of the
National Science Foundation.

R EFERENCES
[1]
[2]
[3]

[4]
[5]

[6]

[7]

[8]

[9]

[10]
[11]
[12]

[13]

[14]

[15]

kdnuggets, “Top 15 Frameworks for Machine Learning
Experts,”
2016,
https://www.kdnuggets.com/2016/04/
top-15-frameworks-machine-learning-experts.html.
D. Sculley, T. Phillips, D. Ebner, V. Chaudhary, and M. Young,
“Machine learning: The high-interest credit card of technical debt,”
2014.
D. Sculley, G. Holt, D. Golovin, E. Davydov, T. Phillips,
D. Ebner, V. Chaudhary, M. Young, J.-F. Crespo, and D. Dennison,
“Hidden technical debt in machine learning systems,” in
Proceedings of the 28th International Conference on Neural Information
Processing Systems - Volume 2, ser. NIPS’15. Cambridge, MA,
USA: MIT Press, 2015, pp. 2503–2511. [Online]. Available:
http://dl.acm.org/citation.cfm?id=2969442.2969519
E. Breck, S. Cai, E. Nielsen, M. Salib, and D. Sculley, “What’s
your ml test score? a rubric for ml production systems,” in NIPS
Workshop on Reliable Machine Learning in the Wild, 2016.
C. Treude, O. Barzilay, and M.-A. Storey, “How do programmers
ask and answer questions on the web?: Nier track,” in Software
Engineering (ICSE), 2011 33rd International Conference on. IEEE,
2011, pp. 804–807.
S. Wang, D. Lo, and L. Jiang, “An empirical study on developer
interactions in stackoverflow,” in Proceedings of the 28th Annual
ACM Symposium on Applied Computing. ACM, 2013, pp. 1019–
1024.
J. Yang, K. Tao, A. Bozzon, and G.-J. Houben, “Sparrows and owls:
Characterisation of expert behaviour in stackoverflow,” in International Conference on User Modeling, Adaptation, and Personalization.
Springer, 2014, pp. 266–277.
D. Kavaler, D. Posnett, C. Gibler, H. Chen, P. Devanbu, and
V. Filkov, “Using and asking: APIs used in the android market
and asked about in stackoverflow,” in International Conference on
Social Informatics. Springer, 2013, pp. 405–418.
M. Linares-Vásquez, G. Bavota, M. Di Penta, R. Oliveto, and
D. Poshyvanyk, “How do API changes trigger stack overflow
discussions? a study on the android sdk,” in proceedings of the 22nd
International Conference on Program Comprehension. ACM, 2014,
pp. 83–94.
T. P. Sahu, N. K. Nagwani, and S. Verma, “Selecting best answer:
An empirical analysis on community question answering sites,”
IEEE Access, vol. 4, pp. 4797–4808, 2016.
A. Barua, S. W. Thomas, and A. E. Hassan, “What are developers
talking about? an analysis of topics and trends in stack overflow,”
Empirical Software Engineering, vol. 19, no. 3, pp. 619–654, 2014.
W. Wang and M. W. Godfrey, “Detecting api usage obstacles: A
study of ios and android developer questions,” in Proceedings of
the 10th Working Conference on Mining Software Repositories. IEEE
Press, 2013, pp. 61–64.
M. Rebouças, G. Pinto, F. Ebert, W. Torres, A. Serebrenik, and
F. Castor, “An empirical study on the usage of the swift programming language,” in Software Analysis, Evolution, and Reengineering
(SANER), 2016 IEEE 23rd International Conference on, vol. 1. IEEE,
2016, pp. 634–638.
Y. Zhang, G. Yin, T. Wang, Y. Yu, and H. Wang, “Evaluating bug
severity using crowd-based knowledge: An exploratory study,” in
Proceedings of the 7th Asia-Pacific Symposium on Internetware. ACM,
2015, pp. 70–73.
D. Schenk and M. Lungu, “Geo-locating the knowledge transfer
in stackoverflow,” in Proceedings of the 2013 International Workshop
on Social Software Engineering. ACM, 2013, pp. 21–24.

[16] C. Stanley and M. D. Byrne, “Predicting tags for stackoverflow
posts,” in Proceedings of ICCM, vol. 2013, 2013.
[17] T. McDonnell, B. Ray, and M. Kim, “An empirical study of api
stability and adoption in the android ecosystem,” in Software
Maintenance (ICSM), 2013 29th IEEE International Conference on.
IEEE, 2013, pp. 70–79.
[18] A. Baltadzhieva and G. Chrupała, “Predicting the quality of
questions on stackoverflow,” in Proceedings of the International
Conference Recent Advances in Natural Language Processing, 2015, pp.
32–40.
[19] A. Joorabchi, M. English, and A. E. Mahdi, “Text mining stackoverflow: An insight into challenges and subject-related difficulties
faced by computer science learners,” Journal of Enterprise Information Management, vol. 29, no. 2, pp. 255–275, 2016.
[20] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long, R. Girshick,
S. Guadarrama, and T. Darrell, “Caffe: Convolutional architecture
for fast feature embedding,” in Proceedings of the 22nd ACM international conference on Multimedia. ACM, 2014, pp. 675–678.
[21] A. Candel, V. Parmar, E. LeDell, and A. Arora, “Deep learning
with h2o,” H2O. ai Inc, 2016.
[22] F. Chollet et al., “Keras,” https://github.com/fchollet/keras, 2015.
[23] S. Owen and S. Owen, Mahout in action. Manning Shelter Island,
NY, 2012.
[24] X. Meng, J. Bradley, B. Yavuz, E. Sparks, S. Venkataraman, D. Liu,
J. Freeman, D. Tsai, M. Amde, S. Owen et al., “Mllib: Machine
learning in apache spark,” The Journal of Machine Learning Research,
vol. 17, no. 1, pp. 1235–1241, 2016.
[25] F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion,
O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg et al.,
“Scikit-learn: Machine learning in python,” Journal of machine
learning research, vol. 12, no. Oct, pp. 2825–2830, 2011.
[26] M. Abadi, P. Barham, J. Chen, Z. Chen, A. Davis, J. Dean, M. Devin,
S. Ghemawat, G. Irving, M. Isard et al., “Tensorflow: A system for
large-scale machine learning.” in OSDI, vol. 16, 2016, pp. 265–283.
[27] J. Bergstra, F. Bastien, O. Breuleux, P. Lamblin, R. Pascanu, O. Delalleau, G. Desjardins, D. Warde-Farley, I. Goodfellow, A. Bergeron
et al., “Theano: Deep learning on gpus with python,” in NIPS 2011,
BigLearning Workshop, Granada, Spain, vol. 3. Citeseer, 2011.
[28] R. Collobert, S. Bengio, and J. Mariéthoz, “Torch: a modular
machine learning software library,” Idiap, Tech. Rep., 2002.
[29] G. Holmes, A. Donkin, and I. H. Witten, “Weka: A machine learning workbench,” in Intelligent Information Systems, 1994. Proceedings
of the 1994 Second Australian and New Zealand Conference on. IEEE,
1994, pp. 357–361.
[30] L. Buitinck, G. Louppe, M. Blondel, F. Pedregosa, A. Mueller,
O. Grisel, V. Niculae, P. Prettenhofer, A. Gramfort, J. Grobler,
R. Layton, J. VanderPlas, A. Joly, B. Holt, and G. Varoquaux, “API
design for machine learning software: experiences from the scikitlearn project,” in ECML PKDD Workshop: Languages for Data Mining
and Machine Learning, 2013, pp. 108–122.
[31] Z. Wang, K. Liu, J. Li, Y. Zhu, and Y. Zhang, “Various frameworks
and libraries of machine learning and deep learning: A survey,”
Archives of Computational Methods in Engineering, pp. 1–24, 2019.
[32] G. Nguyen, S. Dlugolinsky, M. Bobák, V. Tran, Á. L. Garcı́a,
I. Heredia, P. Malı́k, and L. Hluchỳ, “Machine learning and deep
learning frameworks and libraries for large-scale data mining: a
survey,” Artificial Intelligence Review, pp. 1–48, 2019.
[33] S. Meldrum, S. A. Licorish, and B. T. R. Savarimuthu, “Crowdsourced knowledge on stack overflow: A systematic mapping
study,” in Proceedings of the 21st International Conference on Evaluation and Assessment in Software Engineering. ACM, 2017, pp.
180–185.
[34] Yufeng
Guo,
“The
7
Steps
of
Machine
Learning,”
2017,
https://towardsdatascience.com/
the-7-steps-of-machine-learning-2877d7e5548e.
[35] S. Lockyer, “Coding qualitative data,” The Sage encyclopedia of social
science research methods, vol. 1, no. 1, pp. 137–138, 2004.
[36] R. S. Life, “Qualitative data analysis,” 1994.
[37] A. Strauss and J. Corbin, Basics of qualitative research.
Sage
publications, 1990.
[38] K. A. Hallgren, “Computing inter-rater reliability for observational
data: an overview and tutorial,” Tutorials in quantitative methods for
psychology, vol. 8, no. 1, p. 23, 2012.
[39] G. Guzzetta, G. Jurman, and C. Furlanello, “A machine learning
pipeline for quantitative phenotype prediction from genotype
data,” BMC bioinformatics, vol. 11, no. 8, p. S3, 2010.

13

[40] C. Rosen and E. Shihab, “What are mobile developers asking
about? a large scale study using stack overflow,” Empirical Software

Md Johirul Islam is a doctoral candidate at
Iowa State University. His research interests include machine learning program analysis, software techniques for machine learning, and programming languages. He has published works
at FSE, Journal of Big Data Analytics in Transportation, and MSR.

Hoan Anh Nguyen has done his post-doctoral
at Iowa State University. He received his PhD
from Iowa State University. His research interests include program analysis, software evolution and maintenance, and mining software
repositories.

Rangeet Pan is a doctoral candidate at Iowa
State University. His research interests include
static analysis, machine learning, and software
security. He has published work at FSE.

Engineering, vol. 21, no. 3, pp. 1192–1223, 2016.
[41] S. Amershi, A. Begel, C. Bird, R. DeLine, H. Gall, E. Kamar,
N. Nagappan, B. Nushi, and T. Zimmermann, “Software engineering for machine learning: a case study,” in Proceedings of
the 41st International Conference on Software Engineering: Software
Engineering in Practice. IEEE Press, 2019, pp. 291–300.
[42] Alexandr Honchar, “Using Caffe with your own dataset,”
2017,
https://medium.com/machine-learning-world/
using-caffe-with-your-own-dataset-b0ade5d71233.
[43] A. Chakarov, A. Nori, S. Rajamani, S. Sen, and D. Vijaykeerthy, “Debugging machine learning tasks,” arXiv preprint
arXiv:1603.07292, 2016.
[44] Tensorflow, “Debugging TensorFlow Programs,” 2016, https://
www.tensorflow.org/programmers guide/debugger.
[45] S. Saito and S. Roy, “Effects of loss functions and target representations on adversarial robustness,” arXiv preprint arXiv:1812.00181,
2018.
[46] S. Amann, S. Nadi, H. A. Nguyen, T. N. Nguyen, and M. Mezini,
“Mubench: A benchmark for api-misuse detectors,” in Proceedings
of the 13th International Conference on Mining Software Repositories,
ser. MSR ’16. New York, NY, USA: ACM, 2016, pp. 464–467.
[Online]. Available: http://doi.acm.org/10.1145/2901739.2903506
[47] H. W. Lilliefors, “On the kolmogorov-smirnov test for normality
with mean and variance unknown,” Journal of the American statistical Association, vol. 62, no. 318, pp. 399–402, 1967.
[48] J. L. Berral-Garcı́a, “A quick view on current techniques and
machine learning algorithms for big data analytics,” in 2016
18th international conference on transparent optical networks (ICTON).
IEEE, 2016, pp. 1–4.
Hridesh Rajan is the Kingland Professor in the
Computer Science Department at Iowa State
University (ISU) where he has been since 2005.
His research interests include programming languages, software engineering, and data science. He founded the Midwest Big Data Summer School to deliver broadly accessible data
science curricula and serves as a Steering Committee member of the Midwest Big Data Hub
(MBDH). He has been recognized by the US
National Science Foundation (NSF) with a CAREER award in 2009 and by the college of LAS with an Early Achievement in Research Award in 2010, and a Big-12 Fellowship in 2012. He
is a senior member of the ACM and of the IEEE.

