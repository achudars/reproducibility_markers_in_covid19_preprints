arXiv:1906.05593v1 [cs.LO] 13 Jun 2019

ON THE DENOTATIONAL SEMANTICS OF LINEAR LOGIC WITH
LEAST AND GREATEST FIXED POINTS OF FORMULAS
THOMAS EHRHARD AND FARZAD JAFAR-RAHMANI
CNRS, IRIF, Université de Paris, France
e-mail address: ehrhard@irif.fr
Université de Paris, IRIF, CNRS, France
e-mail address: farzadhtg@gmail.com

Abstract. We develop a denotational semantics of Linear Logic with least and greatest
fixed points in coherence spaces (where both fixed points are interpreted in the same way)
and in coherence spaces with totality (where they have different interpretations). These
constructions can be carried out in many different denotational models of LL (hypercoherences, Scott semantics, finiteness spaces etc). We also present a natural embedding of
Gödel System T in LL with fixed points thus enforcing the expressive power of this system
as a programming language featuring both normalization and a huge expressive power in
terms of data types.

1. Introduction
Propositional Linear Logic is a well-established logical system introduced by Girard in [13].
It provides a fine-grain analysis of proofs in intuitionistic and classical logic, and more
specifically of their cut-elimination. LL features indeed a well-behaved logical account of
the structural rules (weakening, contraction) which are handled implicitly in intuitionistic
and classical logic. For this reason, LL has many useful outcomes in the Curry-Howard
based approach to the theory of programming: logical understanding of evaluation strategies (CBN and CBV correspond to two different translations from the lambda-calculus
into LL, and such translations extend naturally to abstract machines), new presentation
of proofs/programs (proof-nets), connections with other branches of mathematics (linear
algebra, differential calculus etc), new operational semantics (geometry of interaction). . .
However, just as the simply typed lambda-calculus, propositional LL is not a reasonable
programming language, by lack of data-types and iteration or recursion principles. This
is usually remedied by extending propositional LL to the 2nd order, thus defining a logical
system in which Girard’s System F [16] can be embedded. As explained in [16] for System F,
this extension allows to represent many data-types, for instance the type of natural numbers
can be written as ι = ∀ζ !(!ζ ⊸ ζ) ⊸ !ζ ⊸ ζ, and then integers are represented as Church
numerals. The resulting logical system is extremely expressive in terms of representable
computable functions: all functions N → N whose totality can be proven in second order
arithmetics are representable. In contrast, its algorithmic expressiveness seems quite poor:
Preprint submitted to
Logical Methods in Computer Science

c
CC

SEMANTICS OF LL WITH FIXED POINTS
Creative Commons

2

SEMANTICS OF LL WITH FIXED POINTS

as is well-known it is not possible to write a term !ι ⊸ ι which computes the predecessor
function in one (or a uniformly bounded) number of reduction steps.
Another option to turn propositional LL into a programming language is to extend
it with least and greatest fixed points of formulas. The kind of extension has early been
suggested by Girard in an unpublished note [14], though the first comprehensive prooftheoretic investigation of such an extension of LL is rather recent [1]: Baelde considers
an extension of Multiplicative Additive LL sequent calculus with least and greatest fixed
points, axiomatized by means of two deduction rules. His main motivation for introducing
this extension of LL comes from the need of powerful logical systems for formal verification
of programs and the investigations on µLL were carried out mainly from a proof-search
perspectives (cut-elimination, focusing etc). However from a Curry-Howard viewpoint, fixed
points allow to define inductive data-types (integers, lists, trees) and coinductive types
(streams and other infinite structures). So µLL can also be considered as a programming
language and it is this approach that we develop in this paper. Admittedly the rules
associated with fixed points are complex (this is especially true of the ν-introduction rule,
the Park’s rule) and lead to subtle cut-elimination proof rewrite rules for which Baelde
could prove a restricted form of cut-elimination, sufficient for establishing for instance that
a proof of the type of integers µζ (1 ⊕ ζ) necessarily reduces to an integer. There are also
alternative proof-systems for the same logic, involving infinite or cyclic proofs, see [2], whose
connections with the aforementioned finitary proof-system are not completely clear.
Since the proof-theory (and hence the “operational semantics”) of µLL is sophisticated
and still under development, it is particularly important to investigate its denotational
semantics, whose definition does not rely on the rewrite system µLL is equipped with. We
develop here a semantics of µLL using coherence spaces [13] equipped with a notion of
totality: our model accounts for the termination of computations in µLL and interprets
least and greatest fixed points in different ways. It presents some similarities with the
game-theoretic model of Clairambault [4, 5] of intuitionistic logic with least and greatest
fixed points (see below).
Girard introduced coherence spaces in [12] in his denotational study of System F. In this
model, types (with free variables) are interpreted as continuous (actually, stable) functors
on a category of coherence spaces and embedding-retraction pairs. Our basic observation is
that such functors admit “least fixed points” in a categorical sense. In the case of µLL we
have to depart from Girard’s setting because formulas must act on proofs and not only on
embedding-retraction pairs: given a formula F and a proof π of A ⊸ B, µLL uses crucially
a proof F [π/ζ] of F [A/ζ] ⊸ F [B/ζ] defined by induction on F (syntactic functoriality).
This means that the functors interpreting formulas must act on all stable morphisms, and
not only on embedding-retraction pairs. This is made possible by the fact that, in µLL,
type variables have only positive occurrences in formulas.
µLL has a construction µζ F for least fixed points and a dual construction νζ F for
greatest fixed points. The logical rule for introducing νζ F allows to deduce ⊢ A⊥ , νζ F
from ⊢ A⊥ , F [A/ζ] (Park’s Rule). We prefer to consider a slightly generalized version of this
rule: deduce ⊢ ?Γ, A⊥ , νζ F from ⊢ ?Γ, A⊥ , F [A/ζ] (which does not increase expressiveness
but makes the embedding of functional formalisms such as Gödel’s System T in µLL much
more natural). We need therefore a version of syntactic functoriality which accommodates
these additional contexts ?Γ. The denotational counterpart is that our functors interpreting
types are equipped with a strength (as in [4, 5], and essentially for the same reason). All
together, these requirements lead to the definition of a variable coherence space (VCS). Such

SEMANTICS OF LL WITH FIXED POINTS

3

a functor has a fixed point which is at the same time an initial algebra and a final coalgebra,
meaning that µζ F and νζ F have the same interpretation.
This first model, based on coherence spaces, admits morphisms which are not total (for
instance the interpretation of ι ⊸ ι, where ι = µζ (1 ⊕ ζ) is the type of integers, contains
non total functions N → N). Following [12] we equip our coherence spaces with a semantic
notion of totality. We introduce accordingly variable coherence spaces with totality which
are VCS’s equipped with a functorial notion of totality. Using Knaster-Tarski Theorem,
we show that these functors have least and greatest fixed points, which now are distinct in
general. The benefit of such models is that they give an abstract and compositional account
of normalization: the interpretation of any proof π of ⊢ ι is an integer, which is the normal
form of π: the model “computes” this integer without reducing the proof.
Contents. In Section 2 we recall basic categorical notions essential in the paper: Seely
categories, Eilenberg-Moore and Kleisli categories of the exponential, strong functors and
their extension to categories of comodules and, last, initial algebras (least fixed points)
and final coalgebras (greatest fixed points) of (strong) functors. Section 3 is devoted to a
general presentation of coherence spaces and to a well behaved notion of strong functors
on coherence spaces admitting fixed points (Variable Coherence Spaces, VCSs). In this
setting, there is no distinction between least fixed points and greatest fixed points, due to
the presence of partial computations in the model. Section 4 endows coherence spaces with
a notion of totality rejecting such partial morphisms and introduces an adapted notion of
variables types (VCSTs), giving rise to a clear distinction between least and greatest fixed
points in this model CohT. In Section 5 we present µLL and various associated concepts:
functorial extension of formulas, cut elimination, interpretation of formulas and proofs in
the model CohT. The idea that a semantic notion of totality enforces a distinction between
least and greatest fixed points is of course not new, it is essential for instance in [4, 5]. In
Section 6 we present various examples, stressing in particular that Gödel’s System T can
be embedded in µLL (following Clairambault [5]) and hence showing that this system has a
significant expressive power from the viewpoint of the Curry-Howard correspondence. We
also analyze in our model the encoding of exponentials using least and greatest fixed points
proposed in [1]; we show in particular that these exponentials do not give rise to a Seely
category, thus justifying our choice of considering the whole system µLL, with exponentials.
As an outcome of the paper, Section 7 introduces a quite simple and general notion of
categorical model of classical µLL, of which the model CohT is an instance.
Related work. Most importantly, we want to mention again the work of Pierre Clairambault
(see [4] and the long version [5]) who investigates the denotational semantics of an extension
of intuitionistic logic with least and greatest fixed points. Our categorical notion of model
of classical µLL of Definition 7.1 can probably be seen as a “linearized version” of his
notion of µ-closed category (an extension of the notion of cartesian closed categories with
least and greatest fixed points) — perhaps through some kind of Kleisli construction —
though our setting seems simpler as we do not need contravariant strong functors, only
covariant ones. The concrete model considered by Clairambault is based on games and
features a notion of totality guaranteeing that all computations terminate and enforcing
the distinction between least and greatest fixed points, just as in the present work. Due
to technical limitations intrinsically related to game semantics, Clairambault’s model is

4

SEMANTICS OF LL WITH FIXED POINTS

restricted to the pseudo-polynomial fragment where free variables never appear at the right
hand side of an implication. No such limitations are necessary in our coherence space
interpretation.
Remark 1.1. We use the following notational conventions: ~a stands for a list (a1 , . . . , an ).
When we write natural transformations, we very often omit the objects where they are
taken and prefer to keep these objects implicit for the sake of readability, because they can
easily be retrieved from the context. If F : A × B → C is a functor and A is an object
of A (notation A ∈ A) then FA : B → C is the functor defined by FA (B) = F(A, B) and
FA (f ) = F(IdA , f ).
2. Categorical models of LL
A model of LL consists of the following data (our main reference is the notion of a Seely
category as presented in [17]. We refer to that survey for all the technical material that we
do not record here).
A symmetric monoidal closed category (L, ⊗, 1, λ, ρ, α, γ) where λX ∈ L(1 ⊗ X, X),
ρX ∈ L(X ⊗ 1, X), αX,Y,Z ∈ L((X ⊗ Y ) ⊗ Z, X ⊗ (Y ⊗ Z)) and γX,Y ∈ L(X ⊗ Y, Y ⊗ X)
are natural isomorphisms satisfying coherence diagrams that we do not record here. We use
X ⊸ Y for the object of linear morphisms from X to Y , ev ∈ L((X ⊸ Y ) ⊗ X, Y ) for the
evaluation morphism and cur for the linear curryfication map L(Z ⊗ X, Y ) → L(Z, X ⊸ Y ).
We assume this SMCC to be ∗-autonomous with dualizing object ⊥. We use X ⊥ for the
object X ⊸ ⊥ of L (the dual, or linear negation, of X).
L is cartesian with final object ⊤, product (X1 & X2 , (πi : X1 & X2 → Xi )i=1,2 ). By
∗-autonomy L is cocartesian with initial object 0, coproduct ⊕ and injections π i .
We are given a comonad ! : L → L with counit derX ∈ L(!X, X) (dereliction) and
comultiplication digX ∈ L(!X, !!X) (digging) together with a strong symmetric monoidal
structure (Seely natural isos m0 : 1 → !⊤ and m2 with m2X1 ,X2 : !X1 ⊗ !X2 → !(X1 & X2 ),
we use n0 and n2X1 ,X2 for the inverses of these isos) for the functor ! , from the symmetric
monoidal category (L, &) to the symmetric monoidal category (L, ⊗) satisfying an additional
coherence condition wrt. dig. It is also important to remember that this strong monoidal
structure allows to define a weak monoidal structure (µ0 , µ2 ) of “!” from (L, ⊗) to itself.
More precisely µ0 ∈ L(1, !1) and µ2X1 ,X2 ∈ L(!X1 ⊗ !X2 , !(X1 ⊗ X2 )) are defined using m0
and m2 . Also, for each object X of L, there is a canonical structure of commutative ⊗comonoid on !X given by wX ∈ L(!X, 1) and contrX ∈ L(!X, !X ⊗ !X). The definition of
these morphisms involves all the structure of “!” explained above, and in particular the
Seely isos. In Section 6.4, we will use the fact that the following equation holds
n2X1 ,X2 = (!π1 ⊗ !π2 ) contrX1 &X2

(2.1)

and also, as a consequence:
wX1 &X2 m2X1 ,X2 = wX1 ⊗ wX2
derX1 &X2 m2X1 ,X2 = hderX ⊗ wY , wX ⊗ derY i

contrX1 &X2 m2X1 ,X2 = m2X1 ,X2 ⊗ m2X1 ,X2 γ2,3 (contrX ⊗ contrY )

(2.2)

We use ? for the “De Morgan dual” of ! : ?X = (!(X ⊥ ))⊥ and similarly for morphisms.
It is a monad on L.

SEMANTICS OF LL WITH FIXED POINTS

5

2.1. Eilenberg-Moore category and free comodules. It is then standard to define the
category L! of !-coalgebras. An object of this category is a pair P = (P , hP ) where P ∈ L
and hP ∈ L(P , !P ) is such that derP hP = Id and digP hP = !hP hP . Then f ∈ L! (P, Q) iff
f ∈ L(P , Q) such that hQ f = !f hP . The functor ! can be seen as a functor from L to L!
mapping X to (!X, digX ) and f ∈ L(X, Y ) to !f . It is right adjoint to the forgetful functor
L! → L. Given f ∈ L(P , X), we use f ! ∈ L! (P, !X) for the morphism associated with f by
this adjunction, one has f ! = !f hP . If g ∈ L! (Q, P ), we have f ! g = (f g)! .
Then L! is cartesian (with product of shape P ⊗ Q = (P ⊗ Q, hP ⊗Q ) and final object
(1, h1 ), still denoted as 1). Here is the definition of hP ⊗Q :
P ⊗Q

hP ⊗ hQ

µ2P ,Q

!P ⊗ !Q

!(P ⊗ Q) .

This category is also cocartesian with coproduct of shape P ⊕ Q = (P ⊕ Q, hP ⊕Q ) and
initial object (0, h0 ) still denoted as 0. Here is the definition of hP ⊕Q . One first defines
h1 : P → !(P ⊕ Q) as
P

hP

!P

!π1

!(P ⊕ Q)

and similarly one defines h2 : Q → !(P ⊕ Q) and then hP ⊕Q is defined as the unique
morphism P ⊕ Q → !(P ⊕ Q) such that hP ⊕Q π i = hi for i = 1, 2.
More details can be found in [10]. We use contrP ∈ L! (P, P ⊗ P ) (contraction) for the
diagonal and wP ∈ L! (P, 1) (weakening) for the unique morphism to the final object. These
morphisms turn P into a commutative ⊗-comonoid, and are defined as
P
and P

hP

!P

!τP

hP

!(⊤)

!P

!hId, Idi

(m0 )−1

(m2 )−1

!P ⊗ !P

!(P & P )

derP ⊗ derP

P ⊗P

1.

2.1.1. The model of free comodules on a given coalgebra. Given an object P of L! , we can
define a functor ComodP : L → L which maps an object X to P ⊗ X and a morphism f
to P ⊗ f . This functor is clearly a comonad (with structure maps defined using wP , contrP
and the monoidal structure of L). A coalgebra for this comonad is a P -comodule 1. It was
observed by Girard in [15] that the Kleisli category L[P ] = LComodP of this comonad (that
is, the category of free P -comodules) is in turn a model of LL with operations on objects
defined in the same way as in L, and using the coalgebra structure of P on morphisms. Let
us summarize this construction which will be used in the sequel. First let fi ∈ L[P ](Xi , Yi )
for i = 1, 2. Then we define f1 ⊗P f2 ∈ L[P ](X1 ⊗ X2 , Y1 ⊗ Y2 ) as
P ⊗ X1 ⊗ X2

contrP ⊗ Id

P ⊗ P ⊗ X1 ⊗ X2

∼

P ⊗ X1 ⊗ P ⊗ X2

f1 ⊗ f2

Y1 ⊗ Y2 .

The object of linear morphisms from X to Y in L[P ] is X ⊸ Y , and the evaluation
morphism evP ∈ L[P ]((X ⊸ Y ) ⊗ X, Y ) is simply (keeping implicit the ⊗-monoidality
isos) P ⊗ (X ⊸ Y ) ⊗ X

wP ⊗Id

(X ⊸ Y ) ⊗ X

ev

Y . Then it is easy to check that if f ∈

1This is just the dual notion of the standard algebraic notion of an M -module which can be defined as

soon as a commutative ⊗-monoid M is given.

SEMANTICS OF LL WITH FIXED POINTS

~)
(!X1 ⊗ !X2 ) ⊗ F(Y
!X1 ⊗ b
FX

~)
m2 ⊗ F(Y

~)
!(X1 & X2 ) ⊗ F(Y
~)
1 ⊗ F(Y

~
2 ,Y

b
F
X

~)
!X1 ⊗ F(!X2 ⊗ Y
b
F
X

~

1 ,!X2 ⊗Y

~ ))
F(!X1 ⊗ !X2 ⊗ F(Y

~)
F(m2 ⊗ Y

~)
m0 ⊗ F(Y

~)
!⊤ ⊗ F(Y
b ~
F
⊤,Y

∼

6

~

1 &X2 ,Y

~)
F(1 ⊗ Y

~)
F(m0 ⊗ Y

~)
F(!⊤ ⊗ Y

~)
F(!(X1 & X2 ) ⊗ Y

Figure 1: Monoidality diagrams for strong functors
L[P ](Z ⊗X, Y ), that is f ∈ L(P ⊗Z ⊗X, Y ), the morphism curf ∈ L[P ](Z, X ⊸ Y ) satisfies
the required monoidal closeness equations. With these definitions, the category L[P ] is *autonomous, with ⊥ as dualizing object. Specifically, given f ∈ L[P ](X, Y ), then f ⊥[P ]
P ⊗Y⊥

P ⊗ f⊥

P ⊗ (P ⊸ X ⊥ )

ev

X⊥ ,
and Z ⊸ X ⊥ , and the *-autonomy of L allows

is the following composition of morphisms:

using implicitly the iso between (Z ⊗ X)⊥
to prove that indeed f ⊥[P ]⊥[P ] = f .
The category L[P ] is easily seen to be cartesian with ⊤ as final object, X1 & X2 as
cartesian product (and projections defined in the obvious way, using the projections of L
and the counit wP ). Last we define a functor !P : L[P ] → L[P ] by !P X = !X and, given
hP ⊗ !X

µ2

!f

!P ⊗ !X
!(P ⊗ X) !Y
f ∈ L[P ](X, Y ), we define !P f ∈ L[P ](!X, !Y ) as P ⊗ !X
and this functor is equipped with a comonad structure (der[P ], dig[P ]) easily defined using
der, dig and wP (for this crucial construction, we need P to be a !-coalgebra and not simply
a commutative ⊗-comonoid; notice however that if ! is the free exponential, as in [15], the
latter condition implies the former).
2.2. Strong functors on L. Given n ∈ N, an n-ary strong functor on L is a pair F =
b where F : Ln → L is a functor and F
b ~ ∈ L(!X ⊗ F(Y
~ ), F(!X ⊗ Y
~ ) is a natural
(F, F))
X,Y
transformation, called the strength of F. We use the notation Z ⊗ (Y1 , . . . , Yn ) = (Z ⊗
Y1 , . . . , Z ⊗ Yn ). It is assumed moreover that the diagrams of Figure 1 commute, expressing
a monoidality of this strength.
The main purpose of this definition is that one can then define a functor F[P ] : L[P ]n →
~ Then, given f~ ∈ L[P ]n (X,
~ Y
~ ) we define
~ = F(X).
L[P ] as follows. First one sets F[P ](X)
~
~ F(Y
~ )) as
F[P ](f ) ∈ L[P ](F(X),
~
P ⊗ F(X)

hP ⊗ Id

~
!P ⊗ F(X)

b
F

~
F(!P ⊗ X)

~
F(der P ⊗X)

~
F(P ⊗ X)

F(f~)

~ ).
F(Y

The fact that we have defined a functor results from the two monoidality diagrams of
Figure 1 and from the definition of wP and contrP based on the Seely isomorphisms.
Operations on strong functors. There is an obvious unary identity strong functor I and for
each object Y of L there is an n-ary Y -valued constant strong functor KX ; in the first case
the strength natural transformation is the identity morphism and in the second case, it is
defined using w!X . Let F be an n-ary strong functor and G1 , . . . , Gn be k-ary strong functors.

SEMANTICS OF LL WITH FIXED POINTS

7

Then one defines a k-ary strong functor H = F ◦ (G1 , . . . , Gn ): the functorial component H
is defined in the obvious compositional way. The strength is defined as follows
~)
!X ⊗ H(Y

b
F

~ ))n )
F((!X ⊗ Gi (Y
i=1

ci )k )
F((G
i=1

~ ))n ) = H(!X ⊗ Y
~)
F((Gi (!X ⊗ Y
i=1

and is easily seen to satisfy the required monoidality commutations.
Given an n-ary strong functor, we can define its De Morgan dual F⊥ which is also an
~ ) = F(Y
~ ⊥ )⊥ and similarly for morphisms.
n-ary strong functor. On objects, we set F⊥ (Y
The strength of F⊥ is defined as the Curry transpose of the following morphism (remember
~ ⊥ = (!X ⊗ Y
~ )⊥ up to canonical iso):
that !X ⊸ Y
~ ⊥ )⊥ ⊗ F(!X ⊸ Y
~ ⊥)
!X ⊗ F(Y
∼

~ ⊥ ) ⊗ F(Y
~ ⊥ )⊥
!X ⊗ F(!X ⊸ Y
F(!X ⊗ (!X ⊸

b ⊗ Id
F
~ ⊥ )) ⊗
Y

F(ev) ⊗ Id
~ ⊥) ⊗
F(Y

~ ⊥ )⊥
F(Y

~ ⊥ )⊥
F(Y

ev γ

⊥
Then it is possible to prove, using the *-autonomy of L, that F⊥⊥ and F are canonically
isomorphic (as strong functors)2.
⊥
Lemma 2.1. (F ◦ (G1 , . . . , Gn ))⊥ = F⊥ ◦ (G⊥
1 , . . . , Gn ) up to canonical iso.

Proof. Results straightforwardly from the definition of F⊥ and from the canonical iso between F⊥⊥ and F.
◭
The bifunctor ⊗ can be turned into a strong functor: one defines the strength as
contr!X ⊗ Id

∼

!X ⊗ Y1 ⊗ Y2
!X ⊗ !X ⊗ Y1 ⊗ Y2
!X ⊗ Y1 ⊗ !X ⊗ Y2 . By De Morgan duality, this endows ` with a strength as well. The bifunctor ⊕ is also endowed with a strength,
simply using the distributivity of ⊗ over ⊕ (which in turn results from the fact that L is symmetric monoidal closed). By duality again, & inherits a strength as well. Last the unary funcdigX ⊗ !X

µ2

!(!X ⊗ Y ) .
tor “!” can be equipped with a strength as follows !X ⊗ !Y
!!X ⊗ !Y
The functors on L[P ] that these strong functors induce coincide with the corresponding operations defined in Section 2.1.1.
2.3. Fixed Points of functors. The following definitions and properties are quite standard in the literature on fixed points of functors.
Definition 2.2. Let A be a category and let F : A → A be a functor. A coalgebra of F is
a pair (A, f ) where A is an object of A and f ∈ A(A, F(A)). Given two coalgebras (A, f )
and (A′ , f ′ ) of F, a coalgebra morphism from (A, f ) to (A′ , f ′ ) is an h ∈ A(A, A′ ) such that
the following diagram commutes
2In the concrete settings considered in this paper, these canonical isos are actuality identity maps.

8

SEMANTICS OF LL WITH FIXED POINTS

h

A

f′

f

F(A)

A′

F (h)

F(A′ )

The category of coalgebras of the functor F will be denoted as CoalgA (F). The notion of
algebra of an endofunctor is defined dually (reverse the directions of the arrows f and f ′ )
and the corresponding category is denoted as AlgA (F).
Lemma 2.3 (Lambek’s Theorem). If (A, f ) is a final object in CoalgA (F) then f is an
iso.
In the sequel, we will always assume that this iso is the identity (because this holds in
the concrete situations we consider in this paper) so that this final object (νF, Id) satisfies
F(νF) = νF. We focus on coalgebras rather than algebras for reasons which will become
clear when we shall deal with fixed points of strong functors.
This universal property of νF gives us a powerful tool for proving equalities of morphisms.
Lemma 2.4. Let A be an object of A and let f1 , f2 ∈ A(A, νF). If there exists l ∈
A(A, F(A)) such that F(fi ) l = fi for i = 1, 2, then f1 = f2 .
Proof. The assumption means that both f1 and f2 are coalgebra morphisms from (A, l) to
the final coalgebra, so they must be equal.
◭
Lemma 2.5. Let F : B × A → A be a functor such that, for all B ∈ B, the category
CoalgA (FB ) has a final object. Then there is a functor νF such that (νF(B), Id) is the
final object of CoalgA (FB ) (so that F(B, νF(B)) = νF(B)) for each B ∈ B, and, for each
g ∈ B(B, B ′ ), νF(g) is uniquely characterized by F(g, νF(g)) = νF(g).
Proof. We have F(g, νF(B)) ∈ A(νF(B), F(B ′ , νF(B))) thus defining a FB ′ -coalgebra
structure on νF(B) and hence there exists a unique morphism νF(g) such that
F(B ′ , νF(g)) F(g, νF(B)) = νF(g) ,
that is F(g, νF(g)) = νF(g).
Functoriality follows: consider also g′ ∈ B(B ′ , B ′′ ), then we know that h = νF(g′ g)
satisfies F(g′ g, h) = h by the definition above. Now h′ = νF(g ′ ) νF(g) satisfies the same
equation by functoriality of F and because F(g, νF(g)) = νF(g) and F(g′ , νF(g′ )) =
νF(g′ ), and hence h′ = h by Lemma 2.5, taking l = F(g′ g, νF(B)). In the same way one
proves that νF(Id) = Id.
◭
We consider now the same νF operation applied to strong functors on a model L
of LL. Let F be an n + 1-ary strong functor on L (so that F is a functor Ln+1 → L).
~ ∈ Ln the category CoalgL (F ~ ) has a final object. We have
Assume that for each X
X
~ νF(X))
~
~ and
defined a functor νF : Ln → L uniquely characterized by F(X,
= νF(X)
~ ′ ) (Lemma 2.5). For each Y, X
~ X
~ ∈ L, we define
F(f~, νF(f~)) = νF(f~) for all f~ ∈ Ln (X,
~ νF(!Y ⊗ X)).
~
c ~ ∈ L(!Y ⊗ νF(X),
We have
νF
Y,X
~ = !Y ⊗ F(X,
~ νF(X))
~
!Y ⊗ νF(X)

b ~
F
~
Y,(X,νF(X))

~ !Y ⊗ νF(X))
~
F(!Y ⊗ X,

SEMANTICS OF LL WITH FIXED POINTS

9

~
~ is the final
Since νF(!Y ⊗ X)
exhibiting a F!Y ⊗X~ -coalgebra structure on !Y ⊗ νF(X).
c ~ as the unique morphism !Y ⊗ νF(X)
~ →
coalgebra of the functor F!Y ⊗X~ , we define νF
Y,X
~ such that the following diagram commutes
νF(!Y ⊗ X)
~
!Y ⊗ νF(X)

b ~
F
~
Y,(X,νF(X))

c ~)
νF
(Y,X

~ !Y ⊗ νF(X))
~
F(!Y ⊗ X,
~ νF
c ~)
F(!Y ⊗ X,
Y,X

(2.3)

~ νF(!Y ⊗ X))
~ = νF(!Y ⊗ X)
~
F(!Y ⊗ X,

~ ∈ Ln , the
Lemma 2.6. Let F be an n + 1-ary strong functor on L such that for each X
category CoalgL (FX~ ) has a final object νFX~ . Then there is a unique n-ary strong functor
~ = νF ~ (and hence F(X,
~ νF(X))
~ = νF(X)),
~
νF such that νF(X)
X
~ ′)
~ X
• F(f~, νF(f~)) = νF(f~) for all f~ ∈ Ln (X,
c
c ~)F
b ~
~ νF
• and F(!Y ⊗ X,
~ = νF ~ .
Y,X

Y,(X,νF(X))

Y,X

~ ′ ) and g ∈ L(Y, Y ′ ), we must
c so let f~ ∈ Ln (X,
~ X
Proof. Let us prove the naturality of νF
prove that the following diagram commutes
~
!Y ⊗ νF(X)
!g ⊗ νF(f~)

~ ′)
!Y ′ ⊗ νF(X

c ~
νF
Y,X

~
νF(!Y ⊗ X)

c ′ ~′
νF
Y ,X

νF(!g ⊗ f~)

~ ′)
νF(!Y ′ ⊗ X

c ~ be the two morphisms we must
c ′ ~ ′ (!g ⊗ νF(f~)) and h2 = νF(!g ⊗ f~) νF
Let h1 = νF
Y,X
Y ,X
prove equal. We use Lemma 2.4, taking the following morphism l.
~ = !Y ⊗ F(X,
~ νF(X))
~
!Y ⊗ νF(X)
b ~
F
~
Y,(X,νF(X))

~ !Y ⊗ νF(X))
~
F(!Y ⊗ X,
F(!g ⊗ f~, Id)

~ ′ , !Y ⊗ νF(X))
~
F(!Y ′ ⊗ X
With these notations we have
~ ′ , h1 ) l = F(!Y ′ ⊗ X
~ ′ , νF
c
F(!Y ′ ⊗ X

~′
Y ′ ,X

~ ′ , !g ⊗ νF(f~))
) F(!Y ′ ⊗ X

b ~
~ F
F(!g ⊗ f~, !Y ⊗ νF(X))
~
Y,(X,νF(X))

~ ′ , νF
c ′ ~ ′ ) F(!g ⊗ f~, !g ⊗ νF(f~)) F
b ~
= F(!Y ′ ⊗ X
~
Y,(X,νF(X))
Y ,X

~ ′ , νF
~
~
c ′ ~′) F
b ′ ~′
= F(!Y ′ ⊗ X
~ ′ )) (!g ⊗ F(f , νF(f )))
Y ,X
Y ,(X ,νF(X
b
by naturality of F

c ′ ~ ′ (!g ⊗ F(f~, νF(f~))) by (2.3)
= νF
Y ,X

c ′ ~ ′ (!g ⊗ νF(f~)) by Lemma 2.5
= νF
Y ,X

10

SEMANTICS OF LL WITH FIXED POINTS

~ ′ , h1 ) l = h1 as required. On the other hand we have
so that F(!Y ′ ⊗ X
~ ′ , h2 ) l = F(!Y ′ ⊗ X
~ ′ , νF(!g ⊗ f~)) F(!Y ′ ⊗ X
~ ′ , νF
c
F(!Y ′ ⊗ X

~)
Y,X

~ F
b ~
F(!g ⊗ f~, !Y ⊗ νF(X))
~
Y,(X,νF(X))

~ ′ , νF(!g ⊗ f~)) F(!g ⊗ f~, !Y ⊗ νF(X))
~
= F(!Y ′ ⊗ X
c ~)F
b ~
~ νF
F(!Y ⊗ X,
~
Y,X
Y,(X,νF(X))

c ~ by (2.3)
= F(!g ⊗ f~, νF(!g ⊗ f~)) νF
Y,X
c ~ by Lemma 2.5
= νF(!g ⊗ f~) νF
Y,X

~ ′ , h2 ) l = h2 which proves our contention. The monoidality condition on
so that F(!Y ′ ⊗ X
c is proved similarly.
◭
νF

~ ∈ Ln , the
Lemma 2.7. Let F be an n + 1-ary strong functor on L such that for each X
category AlgL (FX~ ) has an initial object µFX~ . Then there is a unique n-ary strong functor
~ = µF ~ (and hence F(X,
~ µF(X))
~ = µF(X)),
~
µF such that µF(X)
X
~ ′)
~ X
• F(f~, µF(f~)) = µF(f~) for all f~ ∈ Ln (X,
c
~ µF
c ~)F
b ~
• and F(!Y ⊗ X,
~ = µF ~ .
Moreover

(µF)⊥

=

Y,X
Y,(X,µF(X))
⊥
ν(F )

Y,X

Proof. Apply Lemma 2.6 to the strong functor F⊥ .

◭

3. Coherence spaces
We consider now the case where L is the category Coh of coherence spaces and linear maps,
a well-known model of LL introduced in [12, 13].
A coherence space is a structure E = (|E|, ¨E ) where |E| is a set (that we always
assume to be at most countable since this property is preserved by all the constructions
presented in this paper) called the web of E and ¨E is a binary reflexive and symmetric
relation on |E|. A clique of E is a subset u of |E| such that ∀a1 , a2 ∈ u a1 ¨E a2 . We
use Cl(E) for the set of all cliques of E that we consider as a domain, the order relation
on Cl(E) being always inclusion. Observe indeed that ∅ ∈ Cl(E) (that is Cl(E) has a least
element), if u ⊆ v and v ∈ Cl(E) then u ∈ Cl(E) and last if D ⊆ Cl(E) is directed then
∪D ∈ Cl(E).
3.1. Coherence spaces as a model of LL. Given coherence spaces E and F we define a
coherence space E ⊸ F whose web is |E| × |F | and coherence is: (a1 , b1 ) ¨E⊸F (a2 , b2 ) if
a1 ¨E a2 ⇒ (b1 ¨F b2 and b1 = b2 ⇒ a1 = a2 ).
The category Coh has coherence spaces as objects, and homsets Coh(E, F ) = Cl(E ⊸ F ).
In this category the identities are the diagonal relations and composition is the ordinary
composition of relations.
Remark 3.1. It can be useful to keep in mind that these morphisms can be considered
as linear functions: a function f : Cl(E) → Cl(F ) is linear if it is stable (that is ∀u1 , u2 ∈
Cl(E) u1 ∪ u2 ∈ Cl(E) ⇒ f (u1 ∩ u2 ) = f (u1 ) ∩ f (u2 )) and commutes with arbitrary welldefined unions of cliques. Such a function f has a trace trf = {(a, b) ∈ |E|×|F | | b ∈ f ({a})}

SEMANTICS OF LL WITH FIXED POINTS

11

and this trace operation defines a bijection between Cl(E ⊸ F ) and the set of all linear
functions from Cl(E) to Cl(F ). The converse of this operation maps t ∈ Cl(E ⊸ F ) to the
function fun(t) : Cl(E) → Cl(F ) defined by fun(t)(u) = {b ∈ |F | | ∃a ∈ u (a, b) ∈ t}. We
will always write t u instead of fun(t)(u). In this paper we stick to the relational point of
view on morphisms.
This category is monoidal, with tensor product E1 ⊗ E2 having |E1 | × |E2 | as web and
(a1 , a2 ) ¨E1 ⊗E2 (a′1 , a′2 ) if ai ¨Ei a′i for i = 1, 2. Given ti ∈ Coh(Ei , Fi ) for i = 1, 2, one
defines t1 ⊗ t2 as {((a1 , a2 ), (b1 , b2 )) | (ai , bi ) ∈ ti for i = 1, 2} ∈ Coh(E1 ⊗ E2 , F1 ⊗ F2 )
as easily checked. So ⊗ is a functor Coh2 → Coh, which equips Coh with an obvious
symmetric monoidal structure that we will not make explicit here, for a unit object 1 =
({∗}, =). This category is monoidal closed with E ⊸ F object of morphisms from E to
F (and evaluation morphism ev ∈ Coh((E ⊸ F ) ⊗ E, F ) defined by ev = {(((a, b), a), b) |
a ∈ |E| and b ∈ |F |}). Taking ⊥ = 1 as dualizing object, Coh is easily seen to be *autonomous and the corresponding orthogonality is a functor ⊥ : Cohop → Coh where
E ⊥ = (|E|, ˚E ) ≃ (E ⊸ ⊥) (by a trivial iso), the incoherence binary relation ˚E being
defined by a1 ˚E a2 if a1 ¨E a2 ⇒ a1 = a2 . The transpose t⊥ of t ∈ Coh(E, F ) is simply
{(b, a) | (a, b) ∈ t}. Under this linear negation, the De Morgan dual (par or cotensor) of the
tensor product is E1 ` E2 = (E1⊥ ⊗ E2⊥ )⊥ whose web is |E1 | × |E2 | and whose coherence
relation is characterized by: (a1 , a2 ) ˝E1 `E2 (a′1 , a′2 ) iff ai ˝Ei a′i for i = 1 or i = 2 (where
a ˝E b means a ¨E b and a 6= b and is called strict coherence; strict incoherence ˇE is
defined similarly). Remember that, with these notations, E ⊸ F = E ⊥ ` F .
Coh has a final object ⊤ = (∅, ∅) and a cartesian product E1 & E2 = ({1} × |E1 | ∪
{2} × |E2 |, ¨E1 &E2 ) where the coherence relation is defined by: (i, a) ¨E1 &E2 (j, a′ ) if
i = j ⇒ a ¨Ei a′ , the associated projections πi ∈ Coh(E1 & E2 , Ei ) being πi = {((i, a), a) |
a ∈ |Ei |}. Dually the initial object is 0 = ⊤⊥ = ⊤ and the coproduct is E1 ⊕ E2 =
(E1⊥ & E2⊥ )⊥ whose web is {1} × |E1 | ∪ {2} × |E2 | and whose coherence is characterized
by (i, a) ¨E1 ⊕E2 (j, a′ ) if i = j and a ¨Ei a′ . There are canonical injections Ei → E1 ⊕ E2
which are the transposes of the projections defined above.
We define !E as the coherence space whose web is the set of all finite elements of Cl(E)
and the coherence is: u1 ¨!E u2 if u1 ∪ u2 ∈ Cl(E) (that is ∀a1 ∈ u1 ∀a2 ∈ u2 a1 ¨E a2 ).
This operation is a functor: given t ∈ Coh(E, F ) one sets !t = {({a1 , . . . , an }, {b1 , . . . , bn } ∈
|!E| × |!F | | ∀i (ai , bi ) ∈ t}. The comonad structure of this functor is given by the natural
transformations derE = {({a}, a) | a ∈ |E|} ∈ Coh(!E, E) (dereliction) and digE = {(u1 ∪
· · · ∪ un , {u1 , . . . , un }) | u1 , . . . , un ∈ |!E|) with u1 ∪ · · · ∪ un ∈ Cl(E)} (digging). Last
there is an obvious isomorphism m0 ∈ Coh(1, !⊤) and a natural isomorphism m2E1 ,E2 ∈
Coh(!E1 ⊗ !E2 , !(E1 & E2 )) (these isos defining a strong monoidal structure), satisfying an
additional technical condition explained in [17] for instance.
3.2. Coherence spaces form a cpo. Let E and F be coherence spaces, we write E ⊆ F
if |E| ⊆ |F | and ∀a, a′ ∈ |E| a ¨E a′ ⇔ a ¨F a′ .
+
∈ Coh(E, F ) and
Observe that when E ⊆ F , one has two linear morphisms ηE,F
−
+
−
ηE,F ∈ Coh(F, E) given by ηE,F = ηE,F = {(a, a) | a ∈ |E|}.
−
+
+
−
⊆ IdF , defining an embedding-retraction
ηE,F
= IdE and ηE,F
ηE,F
They satisfy ηE,F
pair of coherence spaces as considered for instance in [12] (all embedding-retraction pairs
are of that shape, up to isomorphism of coherence spaces). One major feature of this order

12

SEMANTICS OF LL WITH FIXED POINTS

relation is that it makes linear negation monotonic3, making life quite easy when one needs
to compute fixed points of arbitrary LL formulas in this model.
Lemma 3.2. The relation ⊆ is a partial order relation on coherence spaces, and we have
E ⊆ F ⇔ E⊥ ⊆ F ⊥ .
We use Coh⊆ for the class of coherence spaces ordered under the ⊆ partial order
relation. This partially ordered class has a least element denoted as ∅ (the coherence space
which has an empty web).
Any countable directed subset E of Coh⊆ has a lub ∪E, which is the coherence space
defined by |∪E| = ∪E∈E |E| and, for all a, a′ ∈ |∪E|, one has a ¨∪E a′ iff a ¨E a′ for some
E ∈ E.
The family E gives rise to two diagrams in the category Coh:
+
∈ Coh(E, F ) when E, F ∈ E with E ⊆ F
• the inductive diagram E + with morphisms ηE,F
−
−
∈ Coh(F, E) when E, F ∈ E with
• and the projective diagram E with morphisms ηE,F
E ⊆ F.
+
)E∈E is the colimit of the
Lemma 3.3. Let G = ∪E. Then, in Coh, the cocone (E, ηE,G
−
+
inductive diagram E and the cone (E, ηE,G )E∈E is the limit of the projective diagram E − .

Proof. We prove the first statement, the second one following by duality. Let F be a
coherence space and, for each E ∈ E let tE ∈ Coh(E, F ) defining a cocone based on E + ,
+
′
′
which means ∀E, E ′ ∈ E E ⊆ E ′ ⇒ tE ′ ηE,E
′ = tE , that is ∀E, E ∈ E E ⊆ E ⇒ tE =
+
= tE is
tE ′ ∩ |E| × |F |. Then the unique morphism t ∈ Coh(G, F ) such that ∀E ∈ E t ηE,G
◭
given by t = ∪E∈E tE as easily checked.
~ F~ ∈
Definition 3.4. A functor F : Cohn → Coh is continuous on objects if whenever E,
+
+
n
~ ⊆ F(F
~ ) and F(η
Coh satisfy Ei ⊆ Fi for i = 1, . . . , n, one has F(E)
E1 ,F1 , . . . , ηEn ,Fn ) =
−
−
−
+
.
Moreover,
F
commutes
with the lubs of
)
=
η
,
.
.
.
,
η
and
F(η
η ~
En ,Fn
E1 ,F1
~
~)
~)
F (E),F
(F
F (E),F (F
countable directed families of coherence spaces. In other words, for any countable directed
families of coherence spaces E1 , . . . , En , one has F(∪E1 , . . . , ∪En ) = ∪{F(E1 , . . . , En ) | E1 ∈
E1 , . . . , En ∈ En }.
~ F~ ) satisfy f~ ⊆ ~g
One says that F is continuous on morphisms if when f~, ~g ∈ Cohn (E,
~
~ F~ ), one
(that is ∀i fi ⊆ gi ) one has F(f ) ⊆ F(~g ) and, if D is a directed subset of Cohn (E,
has F(∪D) = ∪f~∈D F(f~) (equivalently F(∪D) ⊇ ∪f~∈D F(f~)).
Last one says that F is continuous if it is both continuous on objects and on morphisms.
Notice that this property is preserved by composition and duality (setting, consistently
~ = (F(E
~ ⊥ ))⊥ and similarly for morphisms).
with Section 2.2, (F ⊥ )(E)
Definition 3.5. A (n-ary) variable coherence space (VCS) is a strong functor E : Cohn →
Coh such that E is monotonic and continuous.
Proposition 3.6. The operations ⊗, `, ⊕, &, ! and ? are VCSs and VCSs are closed
under De Morgan duality and composition.
Proof. This results immediately from the properties of strong functors stated in Section 2.2
◭
and from straightforward computations (for the continuity statement).
3and not antitonic as one might expect having e.g. intersection types in mind

SEMANTICS OF LL WITH FIXED POINTS

13

3.3. Least fixed point of a VCS, universal properties wrt. algebras and coalgebras.
Let F : Coh → Coh be continuous on objects (in the sense of Definition 3.4). Then we
have ∅ ⊆ F(∅) ⊆ · · · ⊆ F n (∅) ⊆ F n+1 (∅) ⊆ · · · as shown by an easy induction on n. We set
n
σ F = ∪∞
n=0 F (∅). By Scott continuity of F, we have F(σ F) = σ F.
Lemma 3.7. One has σ (F ⊥ ) = (σ F)⊥ . If moreover F is continuous on morphisms then
σ F is at the same time the initial object of AlgCoh (F) and the final object of CoalgCoh (F).
Proof. The first statement results from the observation that (F ⊥ )n = (F n )⊥ . For the
second statement, since σ (F ⊥ ) = (σ F)⊥ , it suffices to prove that (σ F, Id) is initial in
◭
AlgCoh (F). This results easily from Lemma 3.3 and from continuity on morphisms.
~
Let E be an n + 1-ary VCS. Applying Lemma 3.7 to the functors EE~ for all E ∈ Cohn ,
Lemma 2.7 shows that there is an n-ary strong functor µE uniquely determined by the
following equations
~ = σ E~
• µE(E)
E
~ ′)
~ E
• E(f~, µE(f~)) = µE(f~) for f~ ∈ Coh(E,
c ~.
c ~)E
b ~
~ µE
• and E(!F ⊗ E,
~ = µEF,E
F,E
F,(E,µE(E))

Proposition 3.8. The functor µE is a variable coherence space. Defining the dual operation
as νE = (µ(E⊥ ))⊥ , one has νE = µE. We use σ E for this unique (final and initial) fixed
point VCS.

Proof. The proof that µE is monotonic and Scott continuous on Cohn⊆ is a standard domain~ F~ in Cohn such that E
~ ⊆ F~ ,
theoretic verification. We are left with proving that given E,
one has
+
µE(η +
~ ~) = η
E,F

~
~)
µE(E),µE(
F

−
µE(η −
~ ~) = η
E,F

~
~)
µE(E),µE(
F

.

Let use prove the first equation, the proof of the second one being completely similar. By
+
+
Lemma 2.4, it suffices to prove E(η +
~
~ ) ) = ηµE(E),µE(
~
~ ) which in turn results
~ F
~ , ηµE(E),µE(
F
F
E,
from the assumption that E is a VCS.
The identity µE = νE results from the uniqueness statements of Lemmas 2.6 and 2.7
~ = σ E ~ = µE(E).
~
and from the fact that νE(E)
◭
E

Remark 3.9. The methods developed in this section are by no way specific to coherence
spaces and could be used in many other models of LL (relational semantics, Scott semantics,
hypercoherence spaces, probabilistic coherence spaces, game models, up to some adaptation
since these are not models of classical LL, etc).
4. Coherence spaces with totality
Let E be a coherence space and let A ⊆ Cl(E). We set
A⊥ = {x′ ∈ Cl(E ⊥ ) | ∀x ∈ A x ∩ x′ 6= ∅} .
Observe that if x ∩ x′ 6= ∅ then this intersection has exactly one element, due to the fact
that x and x′ are cliques in E and E ⊥ respectively.
If A, B ⊆ Cl(E) and A ⊆ B, we have B ⊥ ⊆ A⊥ , and also A ⊆ A⊥⊥ . Therefore
A⊥ = A⊥⊥⊥ .

14

SEMANTICS OF LL WITH FIXED POINTS

A totality candidate on E is a set T ⊆ Cl(E) such that T ⊥⊥ = T , or equivalently
T
⊆ T . This property is equivalent to the existence of a “predual” of T , that is, of a set
A ⊆ Cl(E ⊥ ) such that T = A⊥ . We use Tot(E) for the set of all totality candidates of the
coherence space E, and we consider this set as a poset, equipped with inclusion.
⊥⊥

Lemma 4.1. The poset Tot(E) is a complete lattice.
Proof. Let Θ ⊆ Tot(E) and let Θ′ = {T ⊥ | T ∈ Θ}, which is a subset of Tot(E ⊥ ). Given
x ∈ Cl(E),
x ∈ ∩Θ iff for all T ′ ∈ Θ′ and all x′ ∈ T ′ , x ∩ x′ 6= ∅. in other words
S we have
⊥
⊥
∩Θ = ( T ∈Θ T ) ∈ Tot(E).
◭
⊥
⊥
The greatest element of Tot(E) is Cl(E) and its least element is (Cl(E )) = ∅ as
easily checked. Any subset Θ of Tot(E) has a least upper bound ∨Θ which is given by
∨Θ = (∪Θ)⊥⊥ and this biorthogonal closure cannot be disposed of in general (∪Θ is not
necessarily a totality candidate). It is useful to observe that the map T 7→ T ⊥ is an
isomorphism between the complete lattices Tot(E ⊥ ) and Tot(E)op .
A coherence space with totality is a pair X = (X, TX) where X is a coherence space
(the carrier) and TX ∈ Tot(X).
4.1. Coherence spaces with totality as a model of LL. Let X and Y be coherence
spaces with totality, we define a coherence space with totality X ⊸ Y by X ⊸ Y = X ⊸ Y
and T(X ⊸ Y ) = {t ∈ Cl(X ⊸ Y ) | ∀x ∈ TX t x ∈ TY } = {x ⊗ y ′ | x ∈ TX and y ′ ∈
TY ⊥ }⊥ , this latter equation resulting from the equivalence (t x) ∩ y ′ 6= ∅ ⇔ t ∩ (x × y ′ ) 6= ∅.
It is clear that if s ∈ T(X ⊸ Y ) and t ∈ T(Y ⊸ Z) then t s ∈ T(X ⊸ Z), and also that
Id ∈ T(X ⊸ X), hence we have defined a category that we denote as CohT.
The following is a useful tool for proving that a linear morphism (a morphism in Coh
between the carriers of two coherence spaces with totality) is total.
Lemma 4.2. Let t ∈ Coh(X, Y ) and let A ⊆ Cl(X) be such that TX = A⊥⊥ . If ∀x ∈
A t x ∈ TY then t ∈ CohT(X, Y ).
Proof. Let x ∈ TX, we have to prove that t x ∈ TY so let y ′ ∈ TY ⊥ , we must prove that
(t x) ∩ y ′ 6= ∅. This statement is equivalent to t ∩ (x ⊗ y ′) 6= ∅ ⇔ (t⊥ y ′ ) ∩ x 6= ∅. So we must
prove ∀x ∈ TX ∀y ′ ∈ TY ⊥ (t⊥ y ′ ) ∩ x 6= ∅, that is t⊥ ∈ CohT(Y ⊥ , X ⊥ ). So let y ′ ∈ TY ⊥ ,
we must prove that t⊥ y ′ ∈ TX ⊥ = A⊥ which results from our assumption by the same
reasoning.
◭
We equip 1 and ⊥ with the same totality, namely {{∗}}. We define X1 ⊗ X2 by
X1 ⊗ X2 = X1 ⊗ X2 and T(X1 ⊗ X2 ) = {x1 ⊗ x2 | xi ∈ TXi for i = 1, 2}⊥⊥ , so that
X ⊗ Y = (X ⊸ Y ⊥ )⊥ . Then it is easy to check that CohT is *-autonomous, with the same
operations on morphisms as in Coh (for instance one checks that if ti ∈ CohT(Xi , Yi ) then
t1 ⊗ t2 ∈ CohT(X1 ⊗ X2 , Y1 ⊗ Y2 ) which is easy using Lemma 4.2; in the same way one
proves easily that ev ∈ CohT((X ⊸ Y )⊗X, Y ) etc). Similarly one shows that the cartesian
structure on Coh gives rise to a cartesian structure on CohT: X1 & X2 = X1 & X2 and
{1} × x1 ∪ {2} × x2 ∈ T(X1 & X2 ) if xi ∈ TXi for i = 1, 2. The total cliques of X1 ⊕ X2
are the {i} × z for i = 1, 2 and z ∈ TXi . Notice that ⊤ and 0 are different coherence spaces
with totality: T⊤ = {∅} and T0 = ∅.
Last !X is given by !X = !X and T(!X) = {x! | x ∈ TX}⊥⊥ (where x! = Pfin (x)).
Then one proves easily that t ∈ CohT(X, Y ) ⇒ !t ∈ CohT(!X, !Y ) again using Lemma 4.2.
It is also easy to check that derX ∈ CohT(!X, X) and that digX ∈ CohT(!X, !!X) so we

SEMANTICS OF LL WITH FIXED POINTS

15

denote these morphisms as derX and digX turning “!” into a comonad on CohT. The same
holds for the monoidal structure (Seely isomorphisms): m0 ∈ CohT(1, !⊤) and m2X1 ,X2 ∈
CohT(!X1 ⊗ !X2 , !(X1 & X2 )).
4.2. Variable coherence spaces with totality (VCST). We first recall the well-known
Knaster-Tarski’s Theorem.
Theorem 4.3. Let S be a complete lattice and let f : S → S be a monotonic function.
Then f has a least fixed point in S. Let
W (sα ) be the ordinal-indexed family of elements of
S defined by sα+1 = f (sα ) and sλ = α<λ sα for λ limit ordinal. Then this sequence is
monotonic and there is an ordinal θ such that sθ = sθ+1 . Moreover sθ is the least fixed point
of f in S.
We denote sα as f α(0) where 0 is the least element of S; this notation coincides with a
finite iterations of f when α is a finite ordinal (we have s0 = 0 considering 0 ∈ N as a limit
ordinal).
4.2.1. General definition of a VCST. To make the notations more readable, when E is a
VCS (see Definition 3.5), we use E (instead of E) to denote its functorial part. We keep
b the associated strength natural transformation.
denoting as E

Definition 4.4. An n-ary variable coherence space with totality (VCST) is a pair X =
(X, TX) where
• X : Cohn → Coh is an n-ary VCS called the carrier of X
~ of coherence
• and TX is an operation, called the totality of X, which, with each n-tuple X
~
~ for
~
spaces with totality, associates TX(X) ∈ Tot(X(X)) — and we use the notation X(X)
~ TX(X)).
~
the coherence space with totality (X(X),
Moreover the two following properties must hold.
~ and Y
~ are objects of CohTn and f~ ∈ CohTn (X,
~ Y~ ), then the Coh morphism X(f~)
• If X
~
~
belongs actually to CohT(X(X), X(Y )), so that X defines a functor CohTn → CohT
(denoted simply as X).
b ~
~ is an object of CohTn and Y is an object of CohT then the Coh morphism X
• If X
Y ,X
~ X(!Y ⊗ X)).
~
belongs actually to CohT(!Y ⊗ X(X),
We denote this total morphism as
b ~.
X
Y,X

So we can consider X as a strong functor CohTn → CohT (the monoidality diagram
commutations of Figure 1 hold because the LL operations on morphisms are interpreted in
the same way in CohT and in Coh).

Remark 4.5. To fully understand this definition, it is essential to keep in mind that, if f~ ∈
~ Y~ ) then actually f~ ∈ Coh(X,
~ Y
~ ) so that the morphism X(f~) ∈ Coh(X(X),
~ X(Y
~ ))
CohT(X,
~ and Y
~ and similarly for X
b ~ . This
is defined, independently of the notions of totality on X
Y,X
decoupling of the totality-free part of the notions involved from the totality dependent ones
makes life much simpler. This situation can certainly be axiomatized categorically, around
the obvious forgetful functor CohT → Coh which commutes with all LL constructs; this
abstract categorical analysis is postponed to further work.

16

SEMANTICS OF LL WITH FIXED POINTS

Remark 4.6. Strictly speaking, an n-ary VCST X is not a strong functor CohTn → CohT
but a structure which induces — as explained above — such a strong functor F, that we
have denoted simply as X. This choice of notation is motivated by the fact that X can
very simply be recovered from F. We have indeed a forgetful functor U : CohT → Coh
which maps X to X and acts as the identity on morphisms. This functor has a left adjoint
Z : Coh → CohT which maps a coherence space E to (E, ∅) (no cliques of E are total)
and acts as the identity on morphisms. Then we have X = U ◦ F ◦ Z = U ◦ F ◦ Z ⊥
b ~ = Fb
~
(for the functorial part of X) and for the strength X
~ , and T = TX(X) is
F,E
Z(F ),Z(E)
~ is of shape (F, T ). In these
defined by the fact that the coherence space with totality F(X)
definitions, the choice of Z as “inverse” of U is arbitrary. By the definition of VCSTs we
could have used the right adjoint Z ⊥ (it maps E to (E, Cl(E)) where all cliques are total)
or any other functor Y : Coh → CohT such that U ◦ Y = Id instead: the resulting X
would have been the same. For these reasons, it is meaningful to consider VCSTs as strong
functors CohTn → CohT, what we do now.
This observation also motivates our general notion of model presented in Definition 7.1.
Proposition 4.7. The operations ⊗, `, ⊕, &, ! and ? are VCSTs and VCSTs are closed
under De Morgan duality and composition.
This is a consequence of Proposition 3.6.
4.2.2. Fixed Points of VCST’s. We deal first with least fixed points of unary VCST’s, so let
X be a unary VCST (whose strength is not used in this first step). We define a coherence
space with totality µ X. First, we set µ X = σ X.
We define a map Θ(X) : Tot(µ X) → Tot(µ X) as follows: if T ∈ Tot(µ X), then
TX(µ X, T ) ∈ Tot(X(µ X)) = Tot(µ X) and we set Θ(X)(T ) = TX(µ X, T ). We contend
that this mapping is monotonic on the lattice Tot(µ X). Assume that T , T ′ ∈ Tot(µ X)
with T ⊆ T ′ . Then Id ∈ CohT((µ X, T ), (µ X, T ′ )) (see Section 4) and hence Id =
X(Id) ∈ CohT((µ X, Θ(X)(T )), (µ X, Θ(X)(T ′ ))) by Definition 4.4, from which it follows
that Θ(X)(T ) ⊆ Θ(X)(T ′ ).
Let U be the least fixed point of Θ(X) (applying Theorem 4.3), we set T (µ X) = U and
this ends the definition of the coherence space with totality µ X, which satisfies X(µ X) = µ X.
Now we prove that it is initial in AlgCohT (X).
For this we shall use the following sequence of candidates of totality for µ X, indexed by
S
ordinals: Uα+1 = Θ(X)(Uα ) and Uλ = ( α<λ Uα )⊥⊥ when λ is a limit ordinal. Remember
that there is an ordinal θ such that Uθ+1 = Uθ , and that we have U = Uθ (see Theorem 4.3).
Proposition 4.8. µ X is initial in the category AlgCohT (X).
Proof. Let (X, g) be an object in AlgCohT (X), that is g ∈ CohT(X(X), X). This means
in particular that g ∈ Coh(X(X), X) so that, by Proposition 3.8, we know that there is
exactly one morphism ĝ ∈ Coh(µ X, X) such that
g X(ĝ) = ĝ .
We have to prove that ĝ ∈ CohT(µ X, X). By induction on the ordinal α, we prove that
ĝ ∈ CohT((µ X, Uα ), X)
for all ordinal α. Assume first that the property holds for α and let us prove it for
α + 1. By Definition 4.4 we get X(ĝ) ∈ CohT((µ X, Uα+1 ), X(X)) and hence ĝ = g X(ĝ) ∈

SEMANTICS OF LL WITH FIXED POINTS

17

CohT((µ X, Uα+1 ), X). Let now λ be a limit ordinal and assume that ĝ ∈ CohT((µ X, Uα ), X)
S
for all α < λ. It will be sufficient to prove that ĝ⊥ ∈ CohT(X ⊥ , ( α<λ Uα )⊥ ) so let
S
x′ ∈ TX ⊥ , we must prove that ĝ ⊥ x′ ∈ ( α<λ Uα )⊥ so let y ∈ Uα for some α < λ, we must
prove that (ĝ ⊥ x′ ) ∩ y 6= ∅, that is x′ ∩ g y 6= ∅ which results from our inductive hypothesis
applied to ordinal α.
So we have proven the existence of ĝ ∈ CohT(µ X, X) such that g X(ĝ) = ĝ. Uniqueness
follows from the uniqueness property for µ X.
◭
We consider now the case of several variables, so let X be an n + 1-ary VCST. Given
~ ∈ CohTn consider the unary VCST X ~ defined as follows: X ~ = X ~ and T(X ~ )(X) =
X
X
X
X
X
~
TX(X, X) (the strength can be defined in a similar way though this is not needed actually
because the proof of Proposition 4.8 does not involve the strength). Then by Proposition 4.8
b on CohT such
applied to XX~ and Lemma 2.7 we have an n-ary strong functor Φ = (Φ, Φ)
~ = µ(X ~ ) and whose action on morphisms and strength are uniquely characterized
that Φ(X)
X
by
~ ′)
~ X
• X(f~, Φ(f~)) = Φ(f~) for all f~ ∈ CohTn (X,
b
~
b
b
• and X(!Y ⊗ X, ΦY,X~ ) XY,(X,µF(
~
~ = ΦY,X
~.
X))
By Proposition 3.8, the first equation implies that Φ(f~) = σ X(f~) (remember that ac~ ′ ) and that σ X is an n-ary VCS characterized by that proposi~ X
tually f~ ∈ Cohn (X,
b ~ = σ
d
tion) and the second equation shows that Φ
XY ,X~ . This proves that σ X(f~) ∈
Y,X
d
X ~ ∈ CohT(Y ⊗ µ(X ~ ), µ(X ~ )). Therefore we have
CohT(µ(X ~ ), µ(X ~ )) and that σ
X

Y

Y ,X

X

Y ⊗X

defined a VCST µX whose carrier µX is the VCS σ X and whose totality T(µX) is such that
~ ∈ CohTn . We can summarize our constructions as
~ T(µX)(X))
~ = µ(X ~ ) for all X
(σ X(X),
X
follows.
Theorem 4.9. Let X be an n + 1-ary VCST. There is a unique VCST µ X whose carrier
~ µ X(X))
~ = µ X(X)
~ and (µ X(X),
~ Id) is initial in
is σ X and whose totality is such that X(X,
the category AlgCohT (XX~ ).
Moreover, we have provided a “concrete” way for defining this operation (which involves
an ordinal iteration).
Now we can define “greatest fixed points” by De Morgan duality. So let X be an
~ we set ν X(X)
~ =
n + 1-ary VCST. Given an n-tuple of coherence spaces with totality X,
~ ⊥ ))⊥ . More precisely, this means that the carrier of ν X is the VCS σ X
(µ ((X)⊥ )(X
~ ∈ Tot(σ X(X))
~ is given by T(ν X)(X)
~ =
(the very same as for µ X), and that T(ν X)(X)
~ ⊥ )) and
~ ⊥ ))⊥ which indeed makes sense because Tµ (X⊥ )(X
~ ⊥ ) ∈ Tot(σ X⊥ (X
(T(µ (X⊥ ))(X
⊥
⊥
⊥
~ ) = (σ X(X))
~
by definition of the De Morgan dual of a VCS.
σ X (X
~ = (σ X(X),
~ V) where V is the greatest
More concretely, this means that T(ν X)(X)
~ such that F (V) = V where F (T ) = TX(X,
~ (σ X(X),
~ T )). In
totality candidate of σ X(X)
T α
~
other words, V = α F (Cl(σ X(X))).
5. µLL and its interpretation
We assume to be given an infinite set of propositional variables V (ranged over by Greek
letters ζ, ξ . . . ). We introduce a language of propositional LL formulas with least and greatest

18

SEMANTICS OF LL WITH FIXED POINTS

fixed points.
A, B, . . . := 1 | ⊥ | A ⊗ B | A ` B
| 0 | ⊤ | A⊕B | A &B
| !A | ?A
| ζ | µζ A | νζ A .
The notion of closed types is defined as usual, the two last constructions being the only
binders.
Remark 5.1. In contrast with second-order linear logic or dependent type systems where
open formulas or types play a crucial role — and it is necessary there to provide an interpretation of proofs or programs having non-closed types —, in the case of fixed points,
all formulas appearing in sequents and other syntactical objects allowing to give types to
programs will be closed. In our setting, open types appear only locally, for allowing the
expression of (least and greatest) fixed points. This is made possible by the fact that
the deduction rules we consider for these operations preserve closeness of formulas in both
directions (upwards and downwards) unlike the rule for quantifiers (think of ∀-intro).
We can define two basic operations on formulas.
• Substitution: A [B/ζ], taking care of not binding free variables (uses α-conversion).
• Negation or dualization: defined by induction on formulas 1⊥ = ⊥, ⊥⊥ = 1, (A `
B)⊥ = A⊥ ⊗ B ⊥ , (A ⊗ B)⊥ = A⊥ ` B ⊥ , 0⊥ = ⊤, ⊤⊥ = 0, (A & B)⊥ = A⊥ ⊕ B ⊥ ,
(A ⊕ B)⊥ = A⊥ & B ⊥ , (!A)⊥ = ?A⊥ , (?A)⊥ = !A⊥ , ζ ⊥ = ζ, (µζ A)⊥ = νζ A⊥ and
(νζ A)⊥ = µζ A⊥ .
Remark 5.2. The only subtle point of this definition is negation of
variables:
 propositional

ζ ⊥ = ζ. The purpose of this is that we have (B [A/ζ])⊥ = B ⊥ A⊥ /ζ as easily proven
by induction on B. If we consider B as a compound connective with placeholders labeled
by variables then B ⊥ is its De Morgan dual. This is also a very natural way of preventing
the introduction of fixed points wrt. variables with negative occurrences. For instance D =
µζ (1 & (!ζ ⊸ ζ)) is not a formula of µLL. Indeed D should be written µζ (1 & (?(ζ ⊥ ) ` ζ))
which is not a formula of µLL (if we do not remove the linear negation) or has not the
intended meaning if we apply the equation ζ ⊥ = ζ. The rejection of such general recursive
types is coherent with the fact that D allows, for instance, to type all pure lambda-terms
and hence also non-normalizing ones.
We give now the deduction rules, in a standard unilateral Linear Logic sequent calculus
as in [1].
The identity fragment:
⊥

⊢ A ,A

(ax)

⊢ Γ, A ⊢ A⊥ , ∆
(cut)
⊢ Γ, ∆

The multiplicative fragment:
⊢1

(1)

⊢ Γ, A ⊢ ∆, B
(⊗)
⊢ Γ, ∆, A ⊗ B

⊢Γ
(⊥)
⊢ Γ, ⊥

⊢ Γ, A, B
(`)
⊢ Γ, A ` B

SEMANTICS OF LL WITH FIXED POINTS

19

The additive fragment:
⊢ Γ, ⊤

(⊤)

⊢ Γ, A
(⊕1 )
⊢ Γ, A ⊕ B

⊢ Γ, B
(⊕2 )
⊢ Γ, A ⊕ B

⊢ Γ, A ⊢ Γ, B
(&)
⊢ Γ, A & B

The exponential fragment:
⊢ Γ, ?A, ?A
(c)
⊢ Γ, ?A

⊢Γ
(w)
⊢ Γ, ?A

⊢ Γ, A
(d)
⊢ Γ, ?A

⊢ ?Γ, A
(p)
⊢ ?Γ, !A

The fixed point fragment:
⊢ Γ, F [µζ F /ζ]
(µ − fold)
⊢ Γ, µζ F

⊢ Γ, F [νζ F /ζ]
(ν − fold)
⊢ Γ, νζ F

⊢ ∆, A ⊢ ?Γ, A⊥ , F [A/ζ]
(ν − rec)
⊢ ∆, ?Γ, νζ F

By taking, in the last rule, ∆ = A⊥ and proving the left premise by an axiom, we
obtain the following derived rule
⊢ ?Γ, A⊥ , F [A/ζ]
⊢ ?Γ, A⊥ , νζ F

(ν − rec′ )

The only cut-elimination rule that we give is (µ − fold)/(ν − rec), in Section 5.1; for
the other ones, see for instance [13] or any other presentation of the classical LL Sequent
Calculus. We refer to [1] for a proof that this system admits cut-elimination4. Observe that
a cut-free proof has not the sub-formula property in general because of rule (ν − rec). But
Baelde’s theorem makes sure that a proof of a sequent which does not contain any ν-formula
has a cut-free proof with the sub-formula property. This is the main motivation for this
apparently weird formulation of the ν-rule.
5.1. Functoriality of formulas. Let ζ be a variable, F a formula and τ be a proof of
~ = (C1 , . . . , Cn ) be closed formulas. Then one
⊢ ?Γ, A⊥ , B, let ξ~ = (ξ1 , . . . , ξn ) and C
h
i
h
i⊥
h
i
~ ξ~ of ⊢ ?Γ, F A/ζ, C/
~ ξ~ , F B/ζ, C/
~ ξ~ by induction on F ,
can define a proof F τ /ζ, C/
h
i
~ ξ~ is defined by
see [1]. As an example, assume that F = µξ G. The proof F τ /ζ, C/
h
i
~ ζ~ )
(setting G′ = G C/
h
i
~ ξ~
G τ /ζ, (µξ G′ ) [B/ζ] /ξ, C/
⊥

⊢ ?Γ, G′ [A/ζ, (µξ G′ ) [B/ζ] /ξ] , G′ [B/ζ, (µξ G′ ) [B/ζ] /ξ]
⊥

⊢ ?Γ, G′ [A/ζ, (µξ G′ ) [B/ζ] /ξ] , (µξ G′ ) [B/ζ]
⊢ ?Γ, (µξ G′ ) [A/ζ]⊥ , (µξ G′ ) [B/ζ]

Let
h us also ideal with the case F = !G.
~ ξ~ is defined as
F τ /ζ, C/

(µ − fold)

(ν − rec′ )

Then, with the same conventions as above,

4The system considered by Baelde is slightly different: no exponentials, no context in the (ν − rec) rule.

Though it seems quite clear that his proof can be adapted to the system presented here which has the
same as Baelde’s, in terms of provability. Observe however that, denotationally, our extension µLL is quite
meaningful as explained in Section 6.4

20

SEMANTICS OF LL WITH FIXED POINTS

h
i
~ ξ~
G τ /ζ, G/
⊥

⊢ ?Γ, G′ [A/ζ] , G′ [B/ζ]
⊢ ?Γ, (!G′ [A/ζ])⊥ , G′ [B/ζ]
⊢ ?Γ, (!G′ [A/ζ])⊥ , !G′ [B/ζ]

(d)
(p)

Where we crucially use the fact that the context is made of ?-formulas. This feature is also
essential in the case where F = G1 ⊗ G2 , for instance.
5.2. Cut elimination. The only two reductions that we will mention here are the (µ −
fold)/(ν − rec) and (µ − fold)/(ν − fold). Consider first a proof θ of shape
ρ
λ
π
⊥
⊢ ?Γ, A, (F [A/ζ])⊥
⊢ ∆, A
⊢ Λ, F [µζ F /ζ]
(ν − rec)
(µ − fold)
⊢ Λ, µζ F
⊢ ∆, ?Γ, (µζ F )⊥
⊢ Λ, ∆, ?Γ
ρ
⊢ ?Γ, A, (F [A/ζ])⊥

⊢ A, A⊥

and let ρ′ be the proof

. Then θ reduces to

⊢ ?Γ, A, (µζ F )⊥

F [ρ′ /ζ]

π
⊢ Λ, F [µζ F /ζ]

⊢ ?Γ, F [A/ζ], F [µζ F /ζ]⊥

ρ
⊢ ?Γ, A, (F [A/ζ])⊥

⊢ Λ, ?Γ, F [A/ζ]
⊢ Λ, ?Γ, ?Γ, A
⊢ Λ, ?Γ, A

λ

(c)

⊢ ∆, A⊥
⊢ ∆, Λ, ?Γ

This reduction rule uses the functoriality of formulas as well as the ?-contexts in the (ν −rec)
rule.
Next, a proof of shape
λ
⊢ Γ, A [µζ A/ζ]
(µ − fold)
⊢ Γ, µζ A
⊢ Γ, ∆

ρ
⊢ ∆, (A [µζ A/ζ])⊥
⊢ ∆, (µζ A)⊥

(ν − fold)

reduces to
λ
⊢ Γ, A [µζ A/ζ]

ρ
⊢ ∆, (A [µζ A/ζ])⊥
⊢ Γ, ∆

Remark 5.3. In terms of provability, the rule (ν − fold) is redundant since it can be derived
as follows
A [π/ζ]
⊢ Γ, A [νζ A/ζ]

⊢ (A [νζ A/ζ])⊥ , A [A [νζ A/ζ]/ζ]
(ν − rec)
⊢ Γ, νζ A

where π is the following proof
⊢ (A [νζ A/ζ])⊥ , A [νζ A/ζ]
⊢ (νζ A)⊥ , A [νζ A/ζ]

(µ − fold)

SEMANTICS OF LL WITH FIXED POINTS

21

Though, in terms of algorithmic expressiveness, the (ν − fold) rule is essential since it
corresponds to pattern matching. For instance, with the type ι = µζ (1 ⊕ ζ) of integers
(see 6.1), the (ν − fold) allows to define a function of type ι ⊸ ι which computes the
predecessor of an integer n in a fixed number of reduction steps whereas the predecessor
function defined using the above (ν − rec)-based definition of (ν − fold) requires a number
of steps proportional to n.
5.3. Interpreting formulas and proofs. With any formula F and any repetition-free
sequence ζ~ = (ζ1 , . . . , ζn ) of variables containing all variables free in F , one can associate
an n-ary VCST JF Kζ~ by induction on F , using straightforwardly the constructions of Section 4.2. If F is closed (again, this holds for any formula occurring in a sequent) then JF K
is simply an object of CohT. If Γ = (C1 , . . . , Cn ) is a sequence of closed formulas then
JΓK = JC1 K` · · · `JCn K.
Lemma 5.4. Let F be a formula and ζ~ = (ζ1 , . . . , ζn ) be a repetition-free list of variables
containing all free variables of F . Let G1 , . . . , Gn be a list of formulas and let ξ~ = (ξ1 , . . . , ξk )
be a repetition-free list of variables containing all free variables of G1 , . . . , Gn . Then
JF [G1 /ζ1 , . . . , Gn /ζn ]Kξ~ = JF Kζ~ ◦ (JG1 Kξ~, . . . , JGn Kξ~) .
The proof is a straightforward induction on F .
Next, with any proof π of a sequent ⊢ Γ, we can associate JπK ∈ TJΓK. More precisely,
JπK ∈ Cl(JΓK) and it turns out that this clique is total in JΓK. We describe now this
interpretation. For simplifying the notations, we drop the “ ” notation and write simply
“JπK ∈ Cl(JΓK)” instead of “JπK ∈ Cl(JΓK)”.
5.3.1. Reminder: interpreting the rules of LL. If π is
⊢ A⊥ , A

then JπK = IdJAK = {(a, a) | a ∈ |JAK|}. If π is
λ
⊢ Γ, A

ρ
⊢ A⊥ , ∆
⊢ Γ, ∆

then, considering that JλK ∈ Coh(JΓK⊥ , JAK) and JρK ∈ Coh(JAK, J∆K) then JπK = JρK JλK
that is JπK = {(γ, δ | ∃a ∈ |JAK (γ, a) ∈ JλK and (a, δ) ∈ JρK|)}. If π is
⊢1

then JπK = {∗}. If π is
ρ
λ
⊢ Γ, A
⊢ ∆, B
⊢ Γ, ∆, A ⊗ B

then JπK = JλK ⊗ JρK considering that JλK ∈ Coh(JΓK⊥ , JAK) and JρK ∈ Coh(J∆K⊥ , JBK),
that is JπK = {(γ, δ, (a, b)) | (γ, a) ∈ JλK and (δ, b) ∈ JρK}. If π is
λ
⊢Γ
⊢ Γ, ⊥

22

SEMANTICS OF LL WITH FIXED POINTS

then JπK = {(γ, ∗) | γ ∈ JλK}. If π is
λ
⊢ Γ, A, B
⊢ Γ, A ` B

then JπK = JλK if we consider that JλK ∈ Coh(JΓK⊥ , JA ` BK) that is JπK = {(γ, (a, b)) |
(γ, a, b) ∈ JλK}. If π is
⊢ Γ, ⊤

then JπK = ∅. If π is
ρ
λ
⊢ Γ, A
⊢ Γ, B
⊢ Γ, A & B

then JπK = hJλK, JρKi considering that JλK ∈ Coh(JΓK⊥ , A) and JρK ∈ Coh(JΓK⊥ , B), that
is JπK = {(γ, (1, a)) | (γ, a) ∈ JλK} ∪ {(γ, (2, b)) | (γ, b) ∈ JρK}. If π is
λ
⊢ Γ, A
⊢ Γ, A ⊕ B

then JπK = π 1 JλK where π 1 ∈ Coh(JAK, JAK ⊕ JBK), that is JπK = {(γ, (1, a)) | (γ, a) ∈ JλK},
considering that JλK ∈ Coh(JΓK⊥ , JAK). If π ends with a right ⊕-rule, the interpretation is
similar. If π ends with
λ
⊢ Γ, A
⊢ Γ, ?A

JλK, that is JπK = {(γ, {a}) | (γ, a) ∈ JλK}. If π is
then JπK = der⊥
JAK⊥
λ
⊢Γ
⊢ Γ, ?A

JλK, that is JπK = {(γ, ∅) | (γ, a) ∈ JλK}. If π is
then JπK = w⊥
JAK⊥
λ
⊢ Γ, ?A, ?A
⊢ Γ, ?A

JλK, that is JπK = {(γ, x1 ∪ x2 ) | (γ, xi ) ∈ JλK for i = 1, 2 and x1 ∪ x2 ∈
then JπK = contr⊥
JAK⊥
|?JAK|}, considering that JλK ∈ Coh(JΓK⊥ , ?JAK ` ?JAK). If π is
λ
⊢ ?Γ, A
⊢ ?Γ, !A

then, considering that JλK ∈ Coh(!E1 ⊗ · · · ⊗ !Ek , JAK) where Γ = (C1 , . . . , Ck ) and Ej =
JCj K⊥ for j = 1, . . . , k, we set JπK = JλK! that is JπK = {(γ 1 ∪· · ·∪γ p , {a1 , . . . , ap }) | (γ l , al ) ∈
JλK for l = 1, . . . , p and γj1 ∪ · · · ∪ γjp ∈ Cl(Ej ) for j = 1, . . . , k}.

SEMANTICS OF LL WITH FIXED POINTS

23

5.3.2. Interpreting the fixed point rules. Assume that π is
λ
⊢ Γ, A [µζ A/ζ]
(µ − fold)
⊢ Γ, µζ A

We have JλK ∈ CohT(JΓK⊥ , JAKζ (µ JAKζ )) by inductive hypothesis and Lemma 5.4, that is
JλK ∈ CohT(JΓK⊥ , µ JAKζ ), so that we simply set JπK = JλK. The interpretation is similar
if π ends with (ν − fold). Last, assume that π is
λ
⊢ ?Γ, B ⊥ , A [B/ζ]

(ν − rec′ )

⊢ ?Γ, B ⊥ , νζ A

Let (C1 , . . . , Ck ) = Γ, let Xi = JCi K⊥ for i = 1, . . . , k, and let Y = X1 & · · · & Xk so that
setting P = !X1 ⊗ · · · ⊗ !Xk we have a (generalized) Seely iso mX~ ∈ CohT(P, !Y ). Then
we have JλK ∈ CohT(P ⊗ JBK, JAKζ (JBK)) by inductive hypothesis, using also Lemma 5.4.
Then we consider the object (P ⊗ JBK, f ) of AlgCohT (JAKζ ) where f is defined as the
following composition of morphisms
P ⊗ JBK
contr ⊗JBK

P ⊗ P ⊗ JBK
mX
~ ⊗ JλK

!Y ⊗ JAKζ (JBK)
[ζ
JAK
Y,JBK

JAKζ (!Y ⊗ JBK)
JAKζ (m−1
⊗ JBK)
~
X

JAKζ (P ⊗ JBK)
Then JπK is the unique morphism of AlgCohT
S (JAKζ ) from the coalgebra (P ⊗ JBK, f ) to
the final coalgebra (Jνζ AK, Id). So JπK = ∞
n=0 gn where the morphisms gn ∈ Coh(P ⊗
JBK, σ JAKζ ) are defined by: g0 = ∅ and gn+1 is
P ⊗ JBK
contr ⊗JBK

P ⊗ P ⊗ JBK
mX
~ ⊗ JλK

!Y ⊗ JAKζ (JBK)
[ζ
JAK
Y,JBK

JAKζ (!Y ⊗ JBK)
JAKζ (m−1
⊗ JBK)
~
X

JAKζ (P ⊗ JBK)
JAKζ (gn )

JAKζ (σ JAKζ ) = σ JAKζ

24

SEMANTICS OF LL WITH FIXED POINTS

Indeed (gn )n∈N is a monotonic sequence of cliques and so g = ∪n∈N gn ∈ Coh(P ⊗JBK, σ JAKζ ).
To prove our contention that JπK = g, it suffices to prove that g ∈ AlgCoh (JAKζ )((P ⊗
JBK, f ), (σ JAKζ , Id)), that is g = JAKζ (g) f which follows readily from the observation that
JAKζ (gn ) f = gn+1 by continuity of JAKζ (remember that the functor JAKζ is continuous in
the sense of Definition 3.4).
Lemma 5.5. Let π be a proof of ⊢ (!Γ)⊥ , A⊥ , B and consider JπK as an element of
CohT[!JΓK](JAK, JBK) (see the definition of this category of free comodules in Section 2.1; we
~ = (C1 , . . . , Ck )
use the canonical structure of !-coalgebra of !JΓK). Let F be a formula and C
h
i
~ ζ~ K =
be closed formulas and ζ, ζ1 , . . . , ζk be pairwise distinct variables. Then JF π/ζ, C/
~ (see Section 2.2 for the action of a strong functor on a category of free
~ ζ)
JF K ~(JπK, JCK/
ζ,ζ

comodules).
This means that our definition of the functorial action of formulas on proofs in Section 5.1 is compatible with the definition of the category of free comodules and of the
extension of a strong functor to this category explained in Section 2.2. The proof is a
simple induction on F .
As usual a main feature of this interpretation is the following.
Theorem 5.6. If π reduces to π ′ , then JπK = Jπ ′ K.
The proof is a lengthy and boring verification which uses crucially Lemma 5.5 in the
most interesting case, which is the (µ − fold)/(ν − rec) cut reduction.
6. Examples
6.1. Some data and non-data types.
Strict integers. The type of strict integers is ι = µζ (1 ⊕ ζ). The following deduction rules
are derivable in µLL:
⊢ι

(0)

⊢ ∆, ι
(succ)
⊢ ∆, ι

⊢ ?Γ, A

⊢ ?Γ, C ⊥ , C

⊢ ?Γ, ι⊥ , C

(itι )

The first rule corresponds to the constant 0, the second one to the successor function and
the third one should be understood as an iteration principle: the first premise is the base
case and the second one is the “inductive step”.
More precisely these proofs are defined as follows.
⊢1
⊢1⊕ι
(µ − fold)
⊢ι

⊢ ∆, ι
⊢ ∆, 1 ⊕ ι
(µ − fold)
⊢ ∆, ι

⊢ ?Γ, C
⊢ ?Γ, ⊥, C

⊢ ?Γ, C ⊥ , C

⊢ ?Γ, ⊥ & C ⊥ , C
⊢ ?Γ, ι⊥ , C

(ν − rec′ )

The coherence space JιK is the least fixed point of the VCS E 7→ 1 ⊕ E so that, up to
trivial iso, JιK is the coherence space N = (N, =). For computing TJιK, the method explained
in Section 4.2.2 boils down to computing the least fixed point of the map Θ : Tot(N) →
Tot(N) such that Θ(T ) = {{0}} ∪ {x + 1 | S
x ∈ T } (where x + 1 = {n + 1 | n ∈ x}). We have
Θn (∅) = {{0}, {1}, . . . , {n − 1}} so T = n∈N Θn (∅) = {{n} | n ∈ N}. Hence T ⊥ = {N}

SEMANTICS OF LL WITH FIXED POINTS

25

and it follows that T = T ⊥⊥ , hence T is the least fixed point of Θ in Tot(N). Finally
TJιK = {{n} | n ∈ N}.
We specialize the definition of Section 5.3.2 taking (with the notations of that section)
A = ⊥ & ζ and B = C ⊥ . If π is
⊢ι

(0)

then JπK = {0}. If π is
λ
⊢ ∆, ι
(succ)
⊢ ∆, ι

then π = {(δ, n + 1) | (δ, n) ∈ JλK}. For the (itι ) rule, assume that π is
λ
⊢ ?Γ, C

ρ
⊢ ?Γ, C ⊥ , C

⊢ ?Γ, ι⊥ , C

(itι )

One has first to compute J⊥\
& ζKζ in this special case applying the general definition of
formula interpretation as explained in Section 5.3. Then given coherence spaces E and F ,
the morphism (J⊥\
& ζKζ )F,E ∈ Coh(!F ⊗ (⊥ & E), ⊥ & (!F ⊗ E)) is {((∅, (1, ∗)), (1, ∗))} ∪
{((y0 , (2, a)), (2, (y0 , a))) | y0 ∈ |!F | and a ∈ |E|}. Next applying the recipe at the end of
Section 5.3.2 we obtain that JπK is the least g ∈ Coh(!JΓK⊥ ⊗ N, JCK) such that
g ={(γ, 0, c) | (γ, c) ∈ JλK}
∪ {(γ 1 ∪ γ 2 , n + 1, c) | ∃c′ ∈ |JCK| (γ 1 , n, c′ ) ∈ g,
(γ 2 , c′ , c) ∈ JρK and γ 1 ∪ γ 2 ∈ |!JΓK⊥ |} .
Setting (A1 , . . . , Ak ) = Γ⊥ we can consider JλK as a stable function h : Cl(JA1 K) × · · · ×
Cl(JA1 K) → Cl(JCK) and JρK as a stable function k : Cl(JA1 K) × · · · × Cl(JA1 K) × Cl(JCK) →
Cl(JCK) which is linear in its last argument. Then g can be seen as the stable function
g : Cl(JA1 K) × · · · × Cl(JA1 K) × Cl(JNK) → Cl(JCK), linear in its last argument, such that
g(~x, {0}) = h(~x) and g(~x, {n + 1}) = k(~x, g(~x, {n})).
Remark 6.1. If π is a proof of ⊢ ι⊥ , ι then JπK is a clique of N ⊸ N such that ∀n ∃p (n, p) ∈
JπK, that is, a total function N → N. Using the derived rules above, we shall see in Section 6.3
that a version of Gödel’s System T can be represented in µLL, which shows that all functions
N → N representable in System T appear as interpretations of such proofs π.
Lazy integers. One can define a type of lazy integers as ιl = µζ (1 ⊕ !ζ). The following
deduction rules are derivable in µLL:
⊢ ιl

⊢ ∆, !ιl
⊢ ∆, ιl

⊢ ?Γ, A
⊢ ?Γ, !A ⊸ A
⊢ ?Γ, ιl ⊸ A

Then Jιl K is an object of CohT, that is, a coherence space L equipped with a totality T
which can be described as follows. One defines a sequence of coherence spaces Ln by: L0
is the coherence space which has {(1, ∗)} as web (where ∗ is the unique element of |1|)
and, if Ln is known then an element of |Ln+1 | is either (1, ∗) or a pair (2, x0 ) where x0
is a finite clique of Ln . The coherence relation given by (i, a) ˝ (j, b) iff i = j = 2 and
a ˝!Ln b. Last |L| is the union of all the |Ln | (which form a monotone sequence of sets)

26

SEMANTICS OF LL WITH FIXED POINTS

and a ¨L b if a ¨Ln b for some n. With each integer k is associated a total clique x(k)
of L: x(0) = {(1, ∗)} and x(k + 1) = {(2, x0 ) | x0 ⊆ x(k) and x0 finite} so that x(1) =
{(2, ∅), (2, {(1, ∗)}}, x(2) = {(2, ∅), (2, {(2, ∅)}), (2, {(2, {(1, ∗)})}), (2, {(2, ∅), (2, {(1, ∗)})})}
etc. The clique {(2, ∅)}, which is not total, represents a “partial integer” that one could
denote as succ(Ω) and {((1, ∗), (1, ∗)), ((2, ∅), (2, ∗)} is the interpretation of a proof of ιl ⊸
1 ⊕ 1 which tests whether an integer is zero or not without evaluating it completely:
⊢1
(⊕2 )
⊢1⊕1
(w)
⊢ ?(⊥ & ⊥), 1 ⊕ 1
⊢1
(⊕1 )
⊢1⊕1
⊢ !(1 ⊕ 1) ⊸ 1 ⊕ 1
⊢ ιl ⊸ 1 ⊕ 1

Streams of booleans. Let γ = νζ (1 & (ζ ⊕ ζ)), let C be the carrier of JγK and T be the
totality. Then |C| can be described as the set {0, 1}<ω of finite sequences of booleans, and
s ¨C t if s is a prefix of t or conversely. So a clique of C is set x of finite sequences which
is totally ordered by the prefix order, and one checks easily that T is the set of all maximal
such sets: up to iso, T = {0, 1}ω . Dually a total clique of Jγ ⊥ K is a set x′ of pairwise
incomparable sequences such that each element of {0, 1}ω has a prefix in x′ . Such an x′ is
finite by compactness of the Cantor Space.
Another definition is considered in the literature for the type of streams of booleans,
namely γ ′ = νζ (ζ ⊕ ζ). A simple computation shows that Jγ ′ K = ⊤ which may seem weird
since the formula γ ′ has many different proofs in µLL. This is due to the fact that there is
no way to write a proof π of γ ′ ⊸ 1 ⊕ 1 which would allow to extract a finite information
from a stream of type γ ′ (for instance, its first element). Actually, this model provides a
proof of this fact: if such a proof would exist, it would map ∅ (total in Jγ ′ K = ⊤) to ∅ (not
total in 1 ⊕ 1).
6.2. Polarization in µLL. Among all formulas of µLL, we define two subsets: positive and
negative formulas. We use letters P, Q, . . . to denote positive formulas and letters M, N, . . .
for negative formulas and as before A, B, . . . for general formulas.
P, Q, . . . := 0 | P ⊕ Q | 1 | P ⊗ Q | !A | µζ P | ζ
M, N, . . . := ⊤ | M & N | ⊥ | M ` N | ?A | νζ M | ζ
The only formulas which are at the same time positive and negative are the variables ζ’s.
So there is no closed formula which is both negative and positive, and M is negative iff M ⊥
is positive. There are of course µLL formulas, like 0 ⊗ ⊥, which are neither positive nor
negative.
From our Curry-Howard point of view, the main property of positive formulas is the
following, which expresses that positive formulas have “structural rules”, meaning that they
are types of storable values.
Theorem 6.2. For each positive formula P , each sequence of pairwise distinct variables
~
ζ~ = (ζ1 , . . . , ζn ) and each sequence of closed formulas
h
i A = (A1 , . . . , An ) there is a proof
~ in µLL of ⊢ P ′⊥ , !P ′ where P ′ = P !A/
~ ζ)
~ ζ~ .
χ(P, !A/

SEMANTICS OF LL WITH FIXED POINTS

27

h
i
~
~ ζ~ . The proof χ(0, !A/
~ ζ)
Proof. By induction on P . If A is a formula, we use A′ for A A/
~ is
~ ζ)
is an instance of the (⊤) axiom. The proof χ(ζi , !A/
⊢ (!Ai )⊥ , !Ai
⊢ (!Ai )⊥ , !!Ai
~ is
~ ζ)
The proof χ(P1 ⊕ P2 , !A/
⊥

⊢ P2′ , P2′

⊥

⊢ P1′ , P1′ ⊕ P2′

⊢ P2′ , P1′ ⊕ P2′

⊢ P1′ , P1′
⊥

⊥

~ ζ)
~
χ(P1′ , !A/

⊢ ?P1′ , P1′ ⊕ P2′

⊥

⊢ ?P1′ , !(P1′ ⊕ P2′ )

⊥

⊥

⊢ P1′ , !P1′
⊥

⊢ P1′

⊥

⊢ ?P2′ , P1′ ⊕ P2′

⊥

⊢ ?P2′ , !(P1′ ⊕ P2′ )

⊥

⊥

⊢ P2′ , !P2′

(cut)

⊢ P1′ , !(P1′ ⊕ P2′ )

~ ζ)
~
χ(P1′ , !A/
⊥

⊢ P2′ , !(P1′ ⊕ P2′ )

⊥

& P2′ , !(P1′ ⊕ P2′ )

~ is
~ ζ)
The proof χ(1, !A/
⊢1
⊢ !1
⊢ ⊥, !1

~ is
~ ζ)
The proof χ(P1′ ⊗ P2′ , !A/
⊥

⊥

⊢ P1′ , P1′

⊢ P2′ , P2′

⊥

⊥

⊢ ?P1′ , P1′
~
~ ζ)
χ(P2′ , !A/
~
~ ζ)
χ(P1′ , !A/
⊢

⊥

⊥

⊥

⊢
⊢
⊢

`

⊥

⊢ ?P1′ , ?P2′ , !(P1′ ⊗ P2′ )
⊥
⊥
?P1′ , P2′ , !(P1′

⊥
⊥
P1′ , P2′ , !(P1′

⊥
P1′

⊥

⊢ ?P1′ , ?P2′ , P1′ ⊗ P2′

⊢ P2′ , !P2′

⊥
P1′ , !P1′

⊢ ?P2′ , P2′

⊗ P2′ )

⊗ P2′ )

⊥
P2′ , !(P1′

⊗ P2′ )

~ is
~ ζ)
The proof χ(!A, !A/
⊥

⊢ ?A′ , !A′
⊥

⊢ ?A′ , !!A′

~ is
~ ζ)
The proof χ(µζ P, !A/
P [δ/ζ]
⊢ P [!µζ P /ζ]⊥ , P [µζ P /ζ]
⊢ P [!µζ P /ζ]⊥ , µζ P
~ ζ)
~ µζ P )/ζ,
χ(P, !(A,

⊢ (!P [!µζ P /ζ])⊥ , µζ P

⊢ P [!µζ P /ζ]⊥ , !P [!µζ P /ζ]

⊢ (!P [!µζ P /ζ])⊥ , !(µζ P )
⊥

⊢ P [!µζ P /ζ] , !(µζ P )
⊢ νζ P ⊥ , !(µζ P )

where δ is the proof

(ν − rec′ )

(&)

(cut)

28

SEMANTICS OF LL WITH FIXED POINTS

⊢ µζ P ⊥ , µζ P
⊢ (!µζ P )⊥ , µζ P

◭
As an example (up to some cut-eliminations) the proof χ(ι) is
⊢ ι⊥ , ι
⊢ι
⊢ !ι
⊢ ⊥, !ι

⊢ ι⊥ , ι

(0)

(succ)

⊢ (!ι)⊥ , ι
⊢ (!ι)⊥ , !ι

⊢ ⊥ & (!ι)⊥ , !ι
⊢ ι⊥ , !ι

(&)

(ν − rec′ )

Theorem 6.3. Let N1 , . . . , Nk be closed negative formulas and let A be a closed formula.
Then the generalized promotion rule and the generalized structural rules
⊢ N1 , . . . , Nk , A
(gp)
⊢ N1 , . . . , Nk , !A

⊢ Γ (gw)
⊢ N, Γ

⊢ N, N, Γ
(gc)
⊢ N, Γ

are derivable in µLL.
Proof. Cut the proof
⊢ ?N1 , . . . , ?Nk , A
⊢ ?N1 , . . . , ?Nk , !A
against the proofs χ(Ni⊥ ) (for i = 1, . . . , k) and similarly for the two other proofs.

◭

6.3. Representing a System T in µLL. We define a version of Gödel’s System T where
integers can be handled in a strict way thanks to an additional let construct5 (in contrast
with the system presented in [16]) that we call T. We first define the syntax of our language:
σ, τ . . . := nat | σ ⇒ τ

(types)

s, t, u . . . := n | x | (s) t | λxσ s | succ(s) | rec(s, t, u) | let(x, s, t) (terms)
The typing rules are
n∈N
Φ ⊢ n : nat
Φ, x : σ ⊢ s : τ
Φ ⊢ λxσ s : σ ⇒ τ

Φ, x : σ ⊢ x : σ
Φ ⊢ s : nat
Φ ⊢ succ(s) : nat

Φ ⊢ s : nat

Φ⊢s:σ⇒τ
Φ⊢t:σ
Φ ⊢ (s) t : τ
Φ ⊢ s : nat
Φ, x : nat ⊢ t : σ
Φ ⊢ let(x, s, t) : σ

Φ⊢t:σ
Φ ⊢ u : nat ⇒ σ ⇒ σ
Φ ⊢ rec(s, t, u) : σ

In these rules Φ denotes a typing context Φ = (x1 : σ1 , . . . , xk : σk ). We define an operational
semantics by means of a weak-head reduction relation specified by the following deduction
rules.
(λxσ s) t βwh s [t/x]

let(x, n, s) βwh s [n/x]

succ(n) βwh n + 1

5One motivation for focusing on such a language is explained in [11], in a context of probabilistic comput-

ing. Indeed the setting presented here can easily and meaningfully be applied to such computations whereas
a purely CBN version of system T wouldn’t really make sense in a probabilistic setting from an algorithmic
expressiveness viewpoint.

SEMANTICS OF LL WITH FIXED POINTS

rec(0, t, u) βwh t

rec(n + 1, t, u) βwh (u) n rec(n, t, u)

s βwh s′
let(x, s, t) βwh let(x, s′ , t)

s βwh s′
succ(s) βwh succ(s′ )

29

s βwh s′
(s) t βwh (s′ ) t

s βwh s′
rec(s, t, u) βwh rec(s′ , t, u)

Of course βwh enjoys Subject Reduction as easily checked. The first five rules describe
the three forms of redexes in our System T, the let construct offering the ability to handle
integers in a CBV manner. One can also define a general reduction relation allowing to
reduce these redexes anywhere in a term and it can be proved that this general reduction
is Church-Rosser, but here we focus on βwh which is a deterministic reduction strategy
turning T into a programming language.
Normalization of T. It is well known that System T is strongly normalizing, but, since our
presentation of this system is slightly different from the usual one (by our CBV handling of
integers) it is meaningful to give a direct proof of this fact. We actually don’t prove strong
normalization, but normalization of the βwh strategy, and only for closed terms of type nat,
which will be enough for our purpose and can be done in a few lines.
Lemma 6.4. If ⊢ s : nat and s is βwh -normal then there is an integer n such that s = n.
Proof. Simple inductive analysis of the structure of s.

◭

Theorem 6.5. The reduction βwh is normalizing for closed terms of type ι.
Proof. We adapt the standard reducibility proof. For each type σ we define a set Redσ of
reducible closed terms s such that ⊢ s : σ. The definition, by induction on σ, is: Rednat is
the set of all normalizing closed terms of type nat, and Redσ⇒τ is the set of all s such that
⊢ s : σ ⇒ τ and, for all t ∈ Redσ , one has (s) t ∈ Redτ .
One proves first that if ⊢ s : σ and s βwh s′ ∈ Redσ , then s ∈ Redσ . This is done
by induction on σ. The case σ = nat results immediately from the definition of Rednat so
assume that σ = (τ ⇒ ϕ). Let t ∈ Redτ , we have (s) t βwh (s′ ) t ∈ Redτ by definition of βwh
and hypothesis on s′ , and hence (s) t ∈ Redτ by inductive hypothesis.
Last we prove by induction on s that if x1 : σ1 , . . . , xk : σk ⊢ s : τ , then for all s1 ∈
Redσ1 ,. . . ,sk ∈ Redσk , one has s [s1 /x1 , . . . , sk /xk ] ∈ Redτ . We set Φ = (x1 : σ1 , . . . , xk : σk )
and w̄ = w [s1 /x1 , . . . , sk /xk ] for all term w.
• If s = xi or s = n the reasoning is straightforward.
• Assume s = succ(t) with Φ ⊢ t : nat. By inductive hypothesis t̄ ∈ Rednat and hence
∗ n for some n ∈ N, and hence s̄ β ∗ n + 1 by definition of β .
t̄ βwh
wh
wh
• Assume s = (t) u with Φ ⊢ t : σ ⇒ τ and Φ ⊢ u : σ so that, by inductive hypothesis
t̄ ∈ Redσ⇒τ and ū ∈ Redσ and hence s̄ = (t̄) ū ∈ Redτ by definition of Redσ⇒τ .
• Assume s = λxσ t with Φ, x : σ ⊢ t : τ . We must prove that s̄ = λxσ t̄ ∈ Redσ⇒τ , so let
u ∈ Redσ and let us prove that (s̄) u = (λxσ t̄) u ∈ Redτ . We have (λxσ t̄) u βwh t̄ [u/x]
and we know that t̄ [u/x] ∈ Redτ by inductive hypothesis applied to t. We conclude that
s̄ ∈ Redσ⇒τ by Lemma 6.4.
• Assume s = rec(t, u, v) with Φ ⊢ t : nat, Φ ⊢ u : σ and Φ ⊢ v : nat ⇒ σ ⇒ σ so that
t̄ ∈ Rednat , ū ∈ Redσ and v̄ ∈ Rednat⇒σ⇒σ by inductive hypothesis. By definition of
∗ n and therefore s̄ β ∗ rec(n, ū, v̄) by definition of
Rednat there is n ∈ N such that t̄ βwh
wh
βwh . An easy induction on n (using Lemma 6.4) shows that rec(n, ū, v̄) ∈ Redσ and hence
s̄ ∈ Redσ by Lemma 6.4 again.

30

SEMANTICS OF LL WITH FIXED POINTS

• If s = let(x, t, u) with Φ ⊢ t : nat and Φ, x : nat ⊢ u : σ we have t̄ ∈ Rednat and hence
∗ n for some n ∈ N. Therefore let(x, t̄, ū) β ∗ let(x, n, ū) β
t̄ βwh
wh ū [n/x] by definition of
wh
βwh and we have ū [n/x] ∈ Redτ by inductive hypothesis on u. It follows that s̄ ∈ Redσ
by Lemma 6.4 again.
◭
Therefore, given s such that ⊢ s : nat ⇒ nat, there is a uniquely defined total function
∗ f (n). Following [16], one can show that these
f : N → N such that ∀n ∈ N (s) n βwh
functions which are definable in T are exactly those whose totality can be proved in Peano’s
Arithmetics.
Denotational semantics of T in CohT. With each type σ one associates an object JσK
of CohT using the structure of LL model of this category and with each s such that
Φ ⊢ s : σ (with Φ = (x1 : σ1 , . . . , xk : σk )) one associates an element of CohT(JΦK, JσK)
where JΦK = !Jσ1 K ⊗ · · · ⊗ !Jσk K. For JnatK we take the coherence space with totality N such
that N = (N, =) and TN = {{n} | n ∈ N}. Then we set Jσ ⇒ τ K = (!JσK ⊸ Jτ K). There
is a morphism hN ∈ CohT(N, !N) which turns N into a !-coalgebra, namely hN = {(n, x) ∈
N × P(N) | x = ∅ or x = {n}}. Given n ∈ N, we set n = {n} ∈ Cl(N), that we also consider
as an element of CohT(1, N).
If Φ ⊢ s : σ then JsKΦ ∈ CohT(JΦK, JσK) is defined by induction on s using standard
algebraic constructs. We give here a direct concrete description of this interpretation.
• Jxi KΦ = {(x1 , . . . , xk , n) | n ∈ N, xi = {n} and xj = ∅ if j 6= i}.
• JnKΦ = {(∅, . . . , ∅, n)}.
• Jsucc(s)KΦ = {(~x, n + 1) | (~x, n) ∈ JsKΦ )}.
• Jλxσ sKΦ = {(~x, (x0 , a)) | (~x, x0 , a) ∈ JsKΦ,x:σ }.
• Assume Φ ⊢ s : σ ⇒ τ and Φ ⊢ t : σ so that Φ ⊢ (s) t : τ . Then J(s) tKΦ = {(~x ∪ y~1 ∪
· · · ∪ y~p , a) ∈ |JΦK ⊸ Jτ K| | ∃a1 , . . . , ap ∈ |JσK| (~x, ({a1 , . . . , ap }, a)) ∈ JsKΦ and (y~j , aj ) ∈
JtKΦ for j = 1, . . . , p}.
• Let X be a coherence space with totality. We define by induction on n ∈ N a family
of morphisms rn ∈ CohT(!X ⊗ !(!N ⊸ !X ⊸ X), X) as follows (keeping monoidal isos
implicit). The morphism r0 is
!X ⊗ !(!N ⊸ !X ⊸ X)

!X ⊗ wX

!X

derX

X

and the morphism rn+1 is
!X ⊗ !(!N ⊸ !X ⊸ X)
!X ⊗ contr ⊗ n!

!X ⊗ !(!N ⊸ !X ⊸ X) ⊗ !(!N ⊸ !X ⊸ X) ⊗ !N
! ⊗ der
rn
N⊸!X⊸X ⊗!N

!X ⊗ (!N ⊸ !X ⊸ X) ⊗ !N
e

X
where e uses twice the evaluation morphism ev. Stated otherwise, if we consider rn as a
binary stable function Cl(X) × Cl(!N ⊸ !X ⊸ X) → Cl(X), we have r0 (x, f ) = x and
rn+1 (x, f ) = f ({n}, rn (x, f )) (considering f ∈ Cl(!N ⊸ !X ⊸ X) as a binary stable function Cl(N) × Cl(X) → Cl(X)). Then one defines r ∈ CohT(N ⊗ !X ⊗ !(N ⊸ !X ⊸ X), X)

SEMANTICS OF LL WITH FIXED POINTS

31

by
r = {((n, x0 , f0 ), a) | n ∈ N and ((x0 , f0 ), a) ∈ rn } .
Indeed, the elements of TN are the {n} for n ∈ N and we have r ′ ({n}) = rn ∈ T (!X ⊗ !(N ⊸ !X ⊸ X) ⊸
X) where r ′ is the Curry transpose of r; it follows that r ∈ CohT(N⊗!X⊗!(N ⊸ !X ⊸ X), X).
Assume that Φ ⊢ s : nat, Φ ⊢ t : σ and Φ ⊢ u : nat ⇒ σ ⇒ σ and take X = JσK, then
we have JsKΦ ∈ CohT(JΦK, N), JtKΦ ∈ CohT(JΦK, X) and JuKΦ ∈ CohT(JΦK, !N ⊸
!X ⊸ X) and we define Jrec(s, t, u)KΦ as the following composition of morphisms is CohT
JΦK
c

JΦK ⊗ JΦK ⊗ JΦK
JsKΦ ⊗ JtK!Φ ⊗ JuK!Φ

N ⊗ !X ⊗ !(!N ⊸ !X ⊸ X)
r

X
where c is obtained by combining two copies of contrJΦK .
• Assume last that s = let(x, t, u) where Φ ⊢ t : nat and Φ, x : nat ⊢ u : σ. By inductive
hypothesis we have JtKΦ ∈ CohT(JΦK, N) and JsKΦ,x:nat ∈ CohT(JΦK ⊗ !N, JσK). Then
Jlet(x, t, u)KΦ is
JΦK

c

JΦK ⊗ JΦK

JΦK ⊗ JtKΦ

JΦK ⊗ N

JΦK ⊗ hN

JΦK ⊗ !N

JuKΦ,x:nat

JσK

Proposition 6.6. Assume that Φ ⊢ s : σ and that s βwh s′ (so that Φ ⊢ s′ : σ). Then
Js′ KΦ = JsKΦ .
Proof. We only sketch the proof which is quite standard and relies on a preliminary Substitution Lemma: if Φ, x : σ ⊢ s : τ and Φ ⊢ t : σ, the morphism Js [t/x]KΦ is equal to
JΦK

contr JΦK

JΦK ⊗ JΦK

JΦK ⊗ JtK!Φ

JΦK ⊗ !JσK

JsKΦ,x:σ

Jτ K

which is proven by a simple induction on s. In the proof of the proposition itself the only
delicate case is when s = let(x, n, t) where Φ, x : ι ⊢ t : σ. To deal with it it suffices to
observe that hN JnK = JnK! , in other words, JnK is a !-coalgebra morphism from 1 to N
(see [10] to read more on this point of view on values).
◭
Notice that the elements of T(N ⊸ N) are exactly the total functions N → N. Those
which are of shape JsK hN for some s such that ⊢ s : nat ⇒ nat are exactly the functions
which are provably total in Peano Arithmetics. We prove now that these functions are
definable in µLL.
Translating T into µLL. First we translate types: given a type σ we define a µLL formula
σ ∗ by: nat∗ = ι and (σ ⇒ τ )∗ = !σ ∗ ⊸ τ ∗ . Observe that JσK (in the sense of the semantics
of T) coincides with Jσ ∗ K (in the sense of the semantics of µLL).
Now we define a translation of terms: given s, Φ = (x1 : σ1 , . . . , xk : σk ) and τ such that
Φ ⊢ s : τ (our typing system is such that when τ exists, it is unique), a proof s∗Φ of the sequent
⊢ (!σ1∗ )⊥ , . . . , (!σk∗ )⊥ , τ ∗ . We use the notation Φ∗ for the sequence (!σ1∗ )⊥ , . . . , (!σk∗ )⊥ . This
translation is defined by induction on s as follows. In the course of this inductive definition,
we argue that Js∗Φ K = JsKΦ . Observe indeed that Js∗Φ K ∈ Cl(J!σ1∗ K⊥ ` · · · `J!σk∗ K⊥ `Jτ ∗ K),

32

SEMANTICS OF LL WITH FIXED POINTS

JsKΦ ∈ Coh(!Jσ1 K ⊗ · · · ⊗ !Jσk K, Jτ K) and that Cl(J!σ1∗ K⊥ ` · · · `J!σk∗ K⊥ `Jτ ∗ K) = Coh(!Jσ1 K ⊗
· · · ⊗ !Jσk K, Jτ K) up to trivial iso (using the fact that Jσ ∗ K = JσK for all type σ of T).
If s = xi then s∗Φ is
⊢ (σi∗ )⊥ , σi∗
⊢ (!σi∗ )⊥ , σi∗
⊢ Φ∗ , σi∗

(w)

Then (γ, a) ∈ Js∗Φ K iff γi = {a} and γj = ∅ if j 6= i, Js∗Φ K = JsKΦ follows.
If s = 0 then s∗Φ is
(0)
⊢ι
(w)
∗
⊢ Φ ,ι

Then (γ, k) ∈ Js∗Φ K iff k = 0 and γi = ∅ for all i, Js∗Φ K = JsKΦ follows.
If s = n + 1 then s∗Φ is
n∗Φ
⊢ Φ∗ , ι
(succ)
⊢ Φ∗ , ι

Then (γ, k) ∈ Js∗Φ K iff k = n + 1 and γi = ∅ for all i, Js∗Φ K = JsKΦ follows.
If s = succ(t) then s∗Φ is
t∗Φ
⊢ Φ∗ , ι
(succ)
⊢ Φ∗ , ι

Then (γ, k) ∈ Js∗Φ K iff k > 0 and (γ, k − 1) ∈ Jt∗Φ K, and Js∗Φ K = JsKΦ follows since Jt∗Φ K = JtKΦ
by inductive hypothesis.
If s = (t) u with Φ ⊢ t : σ ⇒ τ and Φ ⊢ u : σ then s∗Φ is
t∗Φ
∗

∗ ⊥

⊢ Φ , (!σ )

⊢ (!σ ∗ )⊥ , !σ ∗
`τ

∗

∗ ⊥

⊢ τ ∗ , (τ ∗ )⊥
∗

∗

∗ ⊥

⊢ (!σ ) , τ , !σ ⊗ (τ )
∗

⊢ Φ , !σ ∗⊥ , τ ∗
⊢ Φ∗ , Φ∗ , τ ∗
⊢ Φ∗ , τ ∗

u∗Φ
⊢ Φ∗ , σ ∗
(p)
⊢ Φ∗ , !σ ∗

(c)

Then (γ, b) ∈ Js∗Φ K iff there are a1 , . . . , ak ∈ |Jσ ∗ K| and γ 0 , γ1 , . . . , γk such that γ = γ 0 ∪ γ 1 ∪
· · · ∪ γ k ∈ |JΦ∗ K| with (γ 0 , {a1 , . . . , ak }, b)) ∈ Jt∗Φ K and (γ j , aj )) ∈ Ju∗Φ K for j = 1, . . . , k and
the required equation follows by inductive hypothesis.
If s = λxσ t with Φ, x : σ ⊢ s : τ then s∗ is
t∗Φ,x:σ
⊢ Φ∗ , (!σ ∗ )⊥ , τ ∗
⊢ Φ∗ , (!σ ∗ )⊥ ` τ ∗

and the required equation results straightforwardly from the inductive hypothesis.
If s = let(x, t, u) with Φ ⊢ t : nat and Φ, x : nat ⊢ u : σ. Then s∗Φ is

SEMANTICS OF LL WITH FIXED POINTS

33

χ(ι)
t∗Φ
u∗Φ,x:nat
⊢ Φ∗ , ι
⊢ ι⊥ , !ι
⊢ Φ∗ , !ι
⊢ Φ∗ , (!ι)⊥ , σ ∗
∗
∗
⊢ Φ , Φ , σ∗
⊢ Φ∗ , σ ∗

and the required equation follows directly from the fact that Jχ(ι)K = hN .
If s = rec(t, u, v) with Φ ⊢ t : nat, Φ ⊢ u : σ, Φ ⊢ v : nat ⇒ σ ⇒ σ then s∗Φ is
∗
vΦ
∗

(ρ)
u∗Φ
(0)
⊢ Φ∗ , σ ∗
⊢ι
∗
∗
⊢ Φ , !σ
⊢ !ι
ϕ : ⊢ Φ∗ , !ι ⊗ !σ ∗

⊢ Φ , (!ι)

⊥

⊢ ι⊥ , ι
∗ ⊥

` ((!σ )

∗

`σ )

⊢ Φ∗ , (!ι)⊥ , (!σ ∗ )⊥ , σ ∗
∗

⊥

∗ ⊥

⊢ Φ , (!ι) , (!σ ) , !σ

⊢ ι⊥ , ι

(succ)

⊢ (!ι)⊥ , ι

∗

⊢ (!ι)⊥ , !ι

⊢ Φ∗ , (!ι)⊥ , (!ι)⊥ , (!σ ∗ )⊥ , !ι ⊗ !σ ∗

⊢ (σ ∗ )⊥ , σ ∗

ψ : ⊢ Φ∗ , (!ι)⊥ , (!σ ∗ )⊥ , !ι ⊗ !σ ∗

⊢ (!σ ∗ )⊥ , σ ∗

∗

⊢ Φ , (!ι)

⊥

∗ ⊥

` (!σ ) , !ι ⊗ !σ

θ : ⊢ Φ∗ , ι⊥ , !ι ⊗ !σ ∗

∗

(itι )

⊢ (!ι)⊥ , (!σ ∗ )⊥ , σ ∗
⊢ (!ι)⊥ ` (!σ ∗ )⊥ , σ ∗

⊢ Φ∗ , ι⊥ , σ ∗

t∗Φ
⊢ Φ∗ , ι

⊢ Φ∗ , Φ∗ , σ ∗
⊢ Φ∗ , σ ∗

where ρ consists of two cuts against tensor rules. The fact that Js∗Φ K = JsKΦ can be seen as
follows (we actually apply an old trick for encoding primitive recursion using iteration).
∗ K can be seen as a stable function Cl(Jσ ∗ K)×· · ·×Cl(Jσ ∗ K)×Cl(N)×
First observe that JvΦ
1
k
∗
∗
∗
Cl(Jσ K) → Jσ K, that JuΦ K can be seen as a stable function Cl(Jσ1∗ K) × · · · × Cl(Jσk∗ K) → Jσ ∗ K
and that Jt∗Φ K can be seen as a stable function Cl(Jσ1∗ K) × · · · × Cl(Jσk∗ K) → JNK.
Then the proof ϕ above the sequent ⊢ Φ∗ , !ι ⊗ !σ ∗ satisfies JϕK(~x) = Ju∗Φ K(~x)! ⊗ {0}! .
The proof ψ can be seen as a stable function Cl(Jσ1∗ K) × · · · × Cl(Jσk∗ K) × Cl(N) × Cl(Jσ ∗ K) →
∗ K(~
!N ⊗ !Jσ ∗ K such that JψK(~x, y, x) = (y + )! ⊗ JvΦ
x, y, x)! where y + = {n + 1 | n ∈ y}.
Applying the interpretation of the derived rule (itι ) as described in Section 6.1, an easy
induction shows that
JθK(~x, {0}) = {0}! ⊗ Ju∗Φ K(~x)!
∗
JθK(~x, {n + 1}) = {n + 1}! ⊗ JvΦ
K(~x, {n}, JθK(~x, {n}))!

from which the required equation follows. So we have proved the following result.
Theorem 6.7. If s is a term of T such that Φ ⊢ s : τ then Js∗Φ K = JsKΦ .
Theorem 6.8. For any function f : N → N, if f can be represented by a term of T then
there is a proof π if µLL of ⊢ ι⊥ , ι such that for all n ∈ N the proof
n
π
⊥
⊢ι
⊢ ι ,ι
⊢ι
reduces to f (n).
Proof. Let s be a closed term of T such that ⊢ s : nat ⇒ nat and s represents f (that is, for
∗ f (n)). Let π = s∗ which is a proof of ⊢ (!ι)⊥ ` ι, that is of ⊢ (!ι)⊥ , ι
all n ∈ N, (s) n βwh

34

SEMANTICS OF LL WITH FIXED POINTS

(up to a cut with a trivial proof). Baelde’s normalization theorem tells us that for all n ∈ N
the following proof6 πn
n∗
⊢ ι (p)
⊢ !ι

π
⊢ (!ι)⊥ , ι
⊢ι
∗
reduces to a proof k for some k ∈ N so that Jπn K = {k} by Theorem 5.6. By Theorem 6.7 we
have {f (n)} = J(s) nK = Jπn K = {k} and hence k = f (n) which proves our contention. ◭
6.4. Encoding of the exponentials. In [1] it is noticed that the exponential connectives
of LL can be encoded using least and greatest fixed points. It is also mentioned that this
encoding is shallow in the sense that it allows, on formulas involving exponentials, proofs
which do not make sense in LL. We propose here a short denotational analysis of this
encoding showing that it gives rise to a resource comonad which however does not validate
the Seely isomorphism. This is our motivation for including the exponentials in µLL from
the beginning. So let us set
!′ A = νζ (1 & A & (ζ ⊗ ζ))

and ?′ A = (!′ A⊥ )⊥ = µζ (⊥ ⊕ A ⊕ (ζ ` ζ)) .

6.4.1. Functoriality and comonadic structure. We consider the binary VCST X given by
X(X, U ) = 1 & X & (U ⊗ U ) and we set !′ X = ν XX (remember that this notation XX
is introduced at the end of the Introduction for arbitrary functors) so that J!′ AK = !′ JAK.
We set der′X = π1 ∈ CohT(!′ X, X) since X(X, !′ X) = !′ X and similarly w′X = π0 ∈
CohT(!′ X, 1) and contr′X = π2 ∈ CohT(!′ X, !′ X ⊗ !′ X), these maps exhibit on !′ X a
structure of “free co-magma” generated by X.
′
For g ∈ CohT(Y, XX (Y )), there is exactly one ext! (g) ∈ CohT(Y, !′ X) such that
′
′
ext! (g) = XX (ext! (g)) g, that is
 ′

′
′
′
′
w′Y ext! (g) = π0 g der′Y ext! (g) = π1 g contr′Y ext! (g) = ext! (g) ⊗ ext! (g) π2 g .
(6.1)
Let f ∈ CohT(!′ X, Y ), we have hw′X , f, contr′X i ∈ CohT(!′ X, XY (!′ X)) and so we can set
′
′
′
f ! = ext! (hw′X , f, contr′X i) ∈ CohT(!′ X, !′ Y ) so that this morphism f ! is fully characterized
by the following equations

 ′
′
′
′
′
(6.2)
w′Y f ! = w′X der′Y f ! = f contr′Y f ! = f ! ⊗ f ! contr′X .
′

Then the action of the exponential on morphisms is defined as !′ f = ( f der′X )! for f ∈
CohT(X, Y ) and is easily seen to be functorial using Equations (6.2). Observe that !′ f is
characterized by the following equations.

w′Y !′ f = w′X der′Y !′ f = f der′Y contr′Y !′ f = !′ f ⊗ !′ f contr′X .
(6.3)
Last the comultiplication of the exponential is defined as
′

dig′X = (Id!′ X )! ∈ CohT(!′ X, !′ !′ X)
6Observe that n∗ is the canonical representation of n as a proof of µLL consisting of a stack of n (succ)
rules topped by a (0) axiom.

SEMANTICS OF LL WITH FIXED POINTS

35

and is easily checked to satisfy the required commutations for the comonad structure, using
again Equations (6.2).
Now we will argue that this exponential lacks the required Seely isomorphisms that we
′
mentioned in Section 2. Indeed, if such isomorphisms m2 X,Y ∈ CohT(!′ X ⊗ !′ Y , !′ (X & Y ))
′
and n2 X,Y ∈ CohT(!′ (X & Y ), !′ X ⊗ !′ Y ) existed they would satisfy the following equations
′

w′X&Y m2 X,Y = w′X ⊗ w′Y
′

der′X&Y m2 X,Y = hder′X ⊗ w′Y , w′X ⊗ der′Y i



′
′
′
contr′X&Y m2 X,Y = m2 X,Y ⊗ m2 X,Y γ2,3 contr′X ⊗ contr′Y
and


′
n2 X,Y = !′ π1 ⊗ !′ π2 contr′X&Y .

(6.4)

(6.5)

′
n2 X,Y

Equation (6.5) can be understood as a mere definition of
since we know how to
compute its right hand member. And by the characterization (6.1), the equations (6.4)
′
determine m2 X,Y uniquely. So it suffices to compute these two morphisms in our model
CohT to convince ourselves that they do not define an isomorphism.
First of all, given a coherence space with totality X, observe that the elements α, α1 , . . .
of the web of the coherence space !′ X can be described by the following grammar
α, α1 , · · · := w | d(a) | c(α1 , α2 )
where a stands for the elements of |X|. In other words, an element of |!′ X| is a finite
binary tree with two kinds of leaves: “weakening leaves” w and “dereliction leaves” d(a).
Coherence in !′ X is given by: α ¨!′ X α′ if α = d(a), α′ = d(a′ ) ⇒ a ¨X a′ and α =
c(α1 , α2 ), α′ = c(α′1 , α′2 ) ⇒ αi ¨!′ X α′i for i = 1, 2. Totality T!′ X is defined as a greatest
fixed point as explained in Section 4.2, and we don’t know yet any more explicit presentation
of this totality. We call paths the elements of {1, 2}<ω and we define a partial function
st : |!′ X| × {1, 2}<ω → |!′ X| by
st(α, hi) = α
st(c(α1 , α2 ), i θ) = st(αi , θ)
and paths(α) is the set of paths θ such that st(α, θ) is defined (it is a finite set).
′
Let f ∈ CohT(X, Y ). By Equations (6.3) and by the fact that ext! (g) is defined as
a least fixed point (see Section 4.2) we get that !′ f is the least set such that (α, β) ∈ !′ f
iff α = β = w or α = d(a), β = d(b) and (a, b) ∈ f or α = c(α1 , α2 ), β = c(β1 , β2 ) and
(αi , βi ) ∈ !′ f for i = 1, 2. In other words (α, β) ∈ !′ f iff paths(α) = paths(β) = D and for all
θ ∈ D which is maximal for the prefix order:
• either st(α, θ) = st(β, θ) = w
• or st(α, θ) = d(a) and st(β, θ) = d(b) with (a, b) ∈ f .
That is, α and β have exactly the same shape and corresponding d( )-leaves of α and β are
related by f .
′
′
Now Equation (6.5) gives us an explicit definition of n2 X,Y , namely: (γ, (α, β)) ∈ n2 X,Y
iff γ = c(1 · α, 2 · β) where 1 · w = w, 1 · d(a) = d(1, a) and 1 · c(α1 , α2 ) = c(1 · α1 , 1 · α2 )

36

SEMANTICS OF LL WITH FIXED POINTS

and similarly for 2 · β. The map (α, β) 7→ c(1 · α, 2 · β) is injective but not surjective and so
′
n2 X,Y is not an iso7.
This suffices to show that !′ does not endow CohT with a structure of Seely category (and hence is not a categorical model of LL in the usual sense), but for the sake of
′
′
completeness we also give m2 X,Y . It is the least set such that ((α, β), γ) ∈ m2 X,Y iff
• α=β=γ=w
• or γ = d(1, a), α = d(a) and β = w
• or γ = d(2, b), α = w and β = d(b)
′
• or γ = c(γ1 , γ2 ), α = c(α1 , α2 ), β = c(β1 , β2 ) and ((αi , βi ), γi ) ∈ m2 X,Y for i = 1, 2.
′

In other words, ((α, β), γ) ∈ m2 X,Y iff α = p1 (γ) and β = p2 (γ) where paths(p1 (γ)) =
paths(γ) = D, and for all θ ∈ D, if θ is maximal (for the prefix order), st(γ, θ) = d(1, a) ⇒
st(p1 (γ), θ) = d(a) and st(γ, θ) = d(2, b) ⇒ st(p1 (γ), θ) = w. That is, p1 (γ) is γ where
the b’s are replaced with w. The definition of p2 (γ) is symmetrical. Again, the map
γ 7→ (p1 (γ), p2 (γ)) is injective but not surjective since p1 (γ) and p2 (γ) have the same
“internal” tree structure (namely, that of γ).
Remark 6.9. Such non-commutative exponentials in coherence spaces have been introduced by Myriam Quatrini in her PhD thesis [18] as early as in 1995 and it would be
interesting to compare them with this !′ construction. One major feature of this exponential is that, unlike the usual set-based and multiset-based exponentials in coherence spaces,
the !′ is non-uniform, meaning that the elements of |E| occurring in an element α of |!′ E|
are not required to be pairwise coherent. There is a price to pay for this feature: the Seely
isos are not available8 and so the Kleisli category Coh!′ is not cartesian closed. In [3] we
exhibited another way of accommodating non-uniform exponentials with coherence spaces,
in a true model of LL and there, the price to pay was the loss of coherence’s reflexivity (on
the web). It would certainly be interesting to explore the connection between these two
kinds of non-uniform exponentials in coherence spaces.
7. Other models and generalizations
The main feature of our model construction is that it is based on a two-level structure:
• The LL model Coh of coherence spaces, where a notion of variable object can be defined
for which least and greatest fixed-points coincide
• and the LL model of CohT of coherence spaces with totality where we can define a notion
of variable types by equipping the variable types of the first level with an additional
structure (here, a totality structure). In this second level, least and greatest fixed points
are interpreted in different ways.
The same two-level structure can certainly be developed on the model of hypercoherence
spaces [7], on the Scott semantics of LL [9] or on the model of probabilistic coherence
space [6]. In all these cases a notion of totality similar to that of CohT can be defined.
A slightly different structure can be obtained by using the category Rel of sets and
relations as base category and the category of finiteness spaces [8] (which are sets equipped
with a finiteness structure) as level-2 structure. In this case, an interesting challenge will
7Remember that f ∈ Coh(E, F ) is an iso iff, as a relation, f is the graph of a bijection ϕ : |E| → |F |

such that a ¨E a′ ⇔ ϕ(a) ¨F ϕ(a′ )
8They are replaced by injections, which are not so far from being bijections after all. . .

SEMANTICS OF LL WITH FIXED POINTS

37

be to understand how the fixed point constructs interact with the linearization typical
of finiteness spaces: given a field, any finiteness space can canonically be turned into a
topological vector space over this field (considered as a discrete space). In this case there
might even be a third level since these linearizations can be equipped with a totality which
is simply a closed affine subspace as explained in [19].
7.1. A categorical axiomatization models of µLL. In Section 2 we tried to give as
much general categorical definitions as possible, to serve as a background for the concrete
developments in further sections, and also for a general categorical presentation of µLL
models extending naturally the concept of Seely category. Here is a tentative such definition,
compatible with the example we have presented in the paper and the other examples that
we mentioned.
~ = (Ln )n∈N where
Definition 7.1. A categorical model of µLL is a family L
• L0 is a Seely category
• Ln is a family of strong functors Ln0 → L0 and our choice of notations for L0 means that
all constant functors are in L0 (see Section 2.2 for basic definitions on strong functors in
our LL categorical setting)
~ ∈ Lk
• if X ∈ Ln and Xi ∈ Lk (for i = 1, . . . , n) then X ◦ X
• the strong functors ⊗ and & belong to L2 , the strong functor ! belongs to L1 and, if
X ∈ Ln , then X⊥ ∈ Ln
• and last, for all X ∈ L1 the category CoalgL0 (X) (see Section 2.3) has a final object or,
equivalently, the category AlgL0 (X) has an initial object.
Of course we should interpret, in such an abstract model, all sequents and proofs of
µLL and we are confident that this can be done following the pattern we developed for
the interpretation in CohT (where Ln is of course the class of n-ary VCSTs, considered
as strong functors as explained in Section 4.2); such a formal verification is postponed to
further work.
8. Conclusion
One of the main goals of this work was to develop syntax-independent tools to study new
proof-systems for µLL and more specifically infinite proof-systems as in [2], and denotational
semantics is clearly a natural framework for such tools. A first step in this study will be
to prove that these infinite proofs can be interpreted in the model of VCSTs. It would
be also quite interesting to understand how the notion of totality is related with that of
productiveness, crucial in the study of coinductive types. Our models should also suggest
natural notions of proof-nets for µLL.
We would like to thank many people for exciting and quite helpful discussions on these
topics, and in particular Amina Doumane, Paul-André Melliès, Rémy Nollet, Alexis Saurin
and Christine Tasson.

38

SEMANTICS OF LL WITH FIXED POINTS

References
[1] David Baelde. Least and Greatest Fixed Points in Linear Logic. ACM Trans. Comput. Log., 13(1):2:1–
2:44, 2012.
[2] David Baelde, Amina Doumane, and Alexis Saurin. Infinitary Proof Theory: the Multiplicative Additive
Case. In Jean-Marc Talbot and Laurent Regnier, editors, 25th EACSL Annual Conference on Computer
Science Logic, CSL 2016, August 29 - September 1, 2016, Marseille, France, volume 62 of LIPIcs, pages
42:1–42:17. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2016.
[3] Antonio Bucciarelli and Thomas Ehrhard. On phase semantics and denotational semantics: the exponentials. Annals of Pure and Applied Logic, 109(3):205–241, 2001.
[4] Pierre Clairambault. Least and greatest fixpoints in game semantics. In Luca de Alfaro, editor, Foundations of Software Science and Computational Structures, 12th International Conference, FOSSACS
2009, Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS
2009, York, UK, March 22-29, 2009. Proceedings, volume 5504 of Lecture Notes in Computer Science,
pages 16–31. Springer, 2009.
[5] Pierre Clairambault. Strong functors and interleaving fixpoints in game semantics. rtia, 47(1):25–68,
2013.
[6] Vincent Danos and Thomas Ehrhard. Probabilistic coherence spaces as a model of higher-order probabilistic computation. Information and Computation, 152(1):111–137, 2011.
[7] Thomas Ehrhard. Hypercoherences: a strongly stable model of linear logic. Mathematical Structures in
Computer Science, 3:365–385, 1993.
[8] Thomas Ehrhard. Finiteness spaces. Mathematical Structures in Computer Science, 15(4):615–646, 2005.
[9] Thomas Ehrhard. The Scott model of Linear Logic is the extensional collapse of its relational model. Theoretical Computer Science, 2011. To appear. A draft version is available on
http://www.irif.fr/~ ehrhard.
[10] Thomas Ehrhard. Call-By-Push-Value from a Linear Logic Point of View. In Peter Thiemann, editor,
Programming Languages and Systems - 25th European Symposium on Programming, ESOP 2016, Held
as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2016, Eindhoven,
The Netherlands, April 2-8, 2016, Proceedings, volume 9632 of Lecture Notes in Computer Science, pages
202–228. Springer-Verlag, 2016.
[11] Thomas Ehrhard, Michele Pagani, and Christine Tasson. Full Abstraction for Probabilistic PCF. Journal of the ACM, 65(4):23:1–23:44, 2018.
[12] Jean-Yves Girard. The system F of variable types, fifteen years later. Theoretical Computer Science,
45:159–192, 1986.
[13] Jean-Yves Girard. Linear logic. Theoretical Computer Science, 50:1–102, 1987.
[14] Jean-Yves Girard. Fixpoint theorem in linear logic. An email posting to the mailing list
linear@cs.stanford.edu, 1992.
[15] Jean-Yves Girard. On denotational completeness. Theoretical Computer Science, 227:249–273, 1999.
[16] Jean-Yves Girard, Yves Lafont, and Paul Taylor. Proofs and types, volume 7 of Cambridge Tracts in
Theoretical Computer Science. Cambridge University Press, 1989.
[17] Paul-André Melliès. Categorical semantics of linear logic. Panoramas et Synthèses, 27, 2009.
[18] Myriam Quatrini. Sémantique cohérente des exponentielles: de la logique linéaire à la logique classique.
Thèse de doctorat, Université Aix-Marseille 2, 1995.
[19] Christine Tasson. Sémantiques et syntaxes vectorielles de la logique linéaire. Thèse de doctorat, Université Paris Diderot – Paris 7, 2009.

This work is licensed under the Creative Commons Attribution License. To view a copy of this
license, visit https://creativecommons.org/licenses/by/4.0/ or send a letter to Creative
Commons, 171 Second St, Suite 300, San Francisco, CA 94105, USA, or Eisenacher Strasse
2, 10777 Berlin, Germany

