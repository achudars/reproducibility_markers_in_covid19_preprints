Subpacketization-Rate Trade-off
in Multi-Antenna Coded Caching
MohammadJavad Salehi∗, Antti Tölli∗ , Seyed Pooya Shariatpanahi†, Jarkko Kaleva∗
∗ Center

arXiv:1905.04349v1 [cs.IT] 10 May 2019

† School

for Wireless Communications, University of Oulu, Oulu, Finland.
of Computer Science, Institute for Research in Fundamental Sciences (IPM), Tehran, Iran.
{fist name.last name}@oulu.fi, pooya@ipm.ir

Abstract—Coded caching can be applied in wireless multiantenna communications by multicast beamforming coded data
chunks to carefully selected user groups and using the existing
file fragments in user caches to decode the desired files at each
user. However, the number of packets a file should be split
into, known as subpacketization, grows exponentially with the
network size. We provide a new scheme, which enables the level
of subpacketization to be selected freely among a set of predefined
values depending on basic network parameters such as antenna
and user count. A simple efficiency index is also proposed as a
performance indicator at various subpacketization levels. The
numerical examples demonstrate that larger subpacketization
generally results in better efficiency index and higher symmetric
rate, while smaller subpacketization incurs significant loss in the
achievable rate. This enables more efficient caching schemes,
tailored to the available computational and power resources.
Index Terms—multi-antenna coded caching, multicast beamforming, flexible subpacketization

I. I NTRODUCTION
Global mobile data traffic has been subject to consistent
strong growth during the recent years. Cisco visual networking
index [1] estimates the global mobile traffic to reach 77
Exabytes per month by 2022, more than six-fold increase
compared to 2017. On the other hand, more than 80% of
this number is expected to be generated by mobile video, and
as a result research efforts in efficient video delivery have
been intensified in recent years. Caching content closer to the
end-users, known as Edge Caching, is among the promising
solutions proposed in this direction [2], [3]. Coded caching,
first appeared in the pioneering work of [4], is an interesting approach to edge caching for wireless communications,
through which one can take benefit of the broadcast nature
of wireless channels. It is shown in [4] that caching at enduser locations and multicasting coded file chunks to carefully
selected user groups enables reduction in delivery bandwidth
over the broadcast channel.
The original scheme of [4] assumes a separate, offline
cache placement phase and an error-free broadcast channel to
the end-users. Since then, significant effort has been carried
out by the research community to apply the coded caching
concept to more general network setups. For example, in [5]–
[7] decentralized, online and hierarchical coded caching are
This work was supported by the Academy of Finland under grants no.
319059 (Coded Collaborative Caching for Wireless Energy Efficiency) and
318927 (6Genesis Flagship).

considered, respectively. Similarly, extension of [4] to multiserver scenario is studied in [8], and the same concept is then
applied to multi-antenna wireless communications in [9]–[12].
We focus on the application of coded caching in multiantenna wireless communications and the well-known problem
of subpacketization, which means the number of packets
each file should be split into, for a caching scheme to work
properly [12]. The very large subpacketization required by
schemes presented in [9]–[11] makes them infeasible for even
moderate-sized networks, and at the same time adds considerably to the complexity of beamformer design. Reducing
subpacketization is partially tackled in [12], by assigning users
to fixed size groups and using zero-forcing (ZF) and finite field
summation for intra- and inter-group interference cancellation,
respectively. However, as will be discussed, this scheme also
results in rate loss compared to [10], [11].
In this paper, we provide a new coded caching scheme,
which enables the selection of a desired subpacketization level
among a set of possible values depending on basic network
parameters such as user count, number of available antennas
and the global cache ratio (as defined in [4]). We show that the
schemes provided in [9] and [12] are two extreme cases of our
scheme, built with the highest and lowest possible subpacketization levels, respectively. We also provide a simple efficiency
index, which is an indicator of how well the performance (in
terms of symmetric rate) will be for a specific subpacketization
level. We show that larger subpacketization usually results
in higher efficiency index; and higher communication rate
accordingly. Particularly, the schemes of [10] and [12] provide
the highest and lowest symmetric rate, and the rate difference
is more considerable at low-SNR regime.
In this paper, we use the following notations. Boldface
lower case and capital letters indicate vectors and matrices,
respectively. Sets are shown with calligraphic letters. For a
positive integer K, [K] means the set {1, 2, ..., K}. For two
sets S and T , |S| indicates the number of elements in S and
S\T is the set of elements in S which are not in T . For any
vector u, kuk is the second norm of u.
II. S YSTEM M ODEL AND L ITERATURE R EVIEW
We consider K users in a MISO wireless channel with L
antennas at the transmitter. Each user has a cache memory
of size M F bits. The cache contents are updated during

the placement phase, which can be for example during offpeak hours. During the delivery phase, users request files
from a library of size N , where each file is of size F bits.
In order to fulfill the requests, each requesting node uses
its cache content together with the data received over the
communication channel. The problem is to design placement
and delivery phases, such that the time needed for all users to
decode their requested files is minimized; or equivalently, the
symmetric rate of all users is maximized.
In [4] it is shown that a global caching gain, proportional to
the total cache size available in the network, is achievable in
addition to the local gain of each single cache memory. This
added gain is obtained by multicasting coded data chunks to
multiple cache-enabled users, so we use the term multicasting
gain interchangeably with global caching gain in this paper.
Defining global cache ratio t = KM
N , the scheme in [4]
provides a multicasting gain of t + 1. In [8] it is shown
that using L servers simultaneously, the multicasting gain
increases to t + L. In [9] this result is applied to the wireless
communication scenario with L antennas at the transmitter.
Here we briefly review the scheme of [9], as it shares many
common parts with the new scheme presented in this paper.
The placement
phase of [9] requires each file W to be first

split into Kt equal-sized packets Wp(T ) , where p(T ) assigns
a unique index for each T ⊆ [K] with |T | = t. Each packet
is then further split into


K −t−1
Q=
(1)
L−1
q
q
equal-sized subpackets Wp(T
) ; and each Wp(T ) is stored at
the cache memory of all users k ∈ T . During the delivery
phase, for each S ⊆ [K] with |S| = t + L a separate vector
x(S) is transmitted. Assume user k requests the file W (k).
For simplicity, we ignore the time index for vectors x(S) sent
in TDMA fashion. To create x(S), first for each V ⊆ S with
|V| = t + 1, codeword X(V) is built as
M q(k,V)
X(V) =
(2)
Wp(V\{k}) (k) ,
k∈V

where ⊕ denotes bit-wise XOR and q(k, V) is defined such
that it is guaranteed that each subpacket is transmitted only
once and also after all transmissions are concluded, each user
is able to decode its requested file (c.f. [9]). Next, vector u(V)
is defined such that ku(V)k = 1 and
u(V) ⊥ hk

∀k ∈ S\V ,

(3)

where ⊥ denotes perpendicularity and hk is the L × 1 channel
vector from base station to user k. Finally, x(S) is built as
X
x(S) =
u(V)p(V)X(V) ,
(4)
V⊆S

where p(V) is the power allocated to the transmission of
codeword X(V). It can be verified that by transmitting x(S),
each user k ∈ S is able to decode part of W (k) using its cache
contents, and after concluding successive transmissions for all
S ⊆ [K], all users in the system are able to completely decode
their requested files. Specifically, after a single transmission
x(S) is concluded, each user k ∈ S faces a MAC channel with

t+L−1
t



terms, and the transmission rate and power should
be adjusted such that simultaneous decoding of all terms is
possible at every user.
Although the scheme of [9] achieves the full multicasting
gain of t + L for each transmission, it has major drawbacks.
First, the required subpacketization grows exponentially with
K, making the scheme infeasible for even moderate values of
K [12]. Second, ZF results in poor rate specially in low-SNR
regime [11]. Finally, the complexity of successive interference
cancellation for decoding all terms in the MAC channel grows
exponentially with the MAC size [10]. Although workarounds
for drawbacks are available in the literature [10]–[12], unfortunately improvements for any drawback causes the others
to become worse. As a quick review, the scheme provided
in [12] divides users into groups of size L and uses ZF and
finite field summation to mitigate both intra- and inter-group
interference. Although this solution results in a dramatic drop
in the required subpacketization (specially if Lt is an integer),
it provides a lower symmetric rate than other schemes, as
demonstrated later in Section IV. On the other hand, the
scheme of [11] suggests designing optimized multicast beamformers instead of ZF to improve the performance at low- and
mid-SNR. More precisely, instead of (4) x(S) is created as
X
x(S) =
w(V)X(V) ,
(5)
V⊆S

where w(V) is the general beamformer vector. The unwanted
terms then appear as (Gaussian) interference instead of being
nulled at each user. Although this formulation significantly
improves the rate at low-SNR, considering interference between parallel multi-group multicast messages makes the
beamformer design significantly more complex [10]. Finally,
different schemes with reduced complexity are proposed in
[10]. However, in certain scenarios, this may have further
detrimental impact on the required subpacketization.
In this paper we provide a new scheme, achieving full
multicasting gain of t+ L with subpacketization P × Q, where
Q is defined in (1) and P can be selected freely among a set of
predefined values. We show that the schemes of [9] and [12]
are two extreme cases of this new scheme, with P = Kt and

P = K/L
respectively1.
t/L
Before providing the details, let us consider a network with
K = 4 and L = t = 2. The scheme
 provided in [10],
[11] requires subpacketization P = 42 = 6, while the
 one
presented in [12] reduces subpacketization to P = 21 = 2.
Using the new scheme, for this network one can build another coded caching scheme with subpacketization P = 4.
Comparison of the rate versus SNR for these three schemes
is shown in Figure 1. It should be noted that the results in
Figure 1 are calculated using optimized beamformer design,
which provides better rate than ZF used in [12]. Still, it is
clear that increasing P results in an increase in the symmetric
rate. The rate advantage of P = 4 over P = 2 is 32% at 0
dB, eventually decreasing to 13% at 40 dB. This illustrates the
stronger impact of increased subpacketization at lower SNR.
1 For

non-integer K/t and t/L, ⌊K/t⌋ and ⌈t/L⌉ are used.

8

X

vp,k × N ×

Symmetric Rate [nats/s]

p

4

6 Subpackets
4 Subpackets
2 Subpackets
0

10

20

30

(9)

which is exactly the available cache size at each user. Moreover, (8b) guarantees that each packet is replicated for the
same number of times throughout all cache memories in the
network. For example, it can be easily checked that all the
placement matrices in (6) and (7) are valid. According to (8a)
and (8b) it is clear that reordering rows or columns in a valid
placement matrix results in another valid placement matrix.
The following lemmas represent the relationship between valid
placement matrices and caching schemes of [9] and [12].

6

2

F
P
KM
NF
=
×
×
= MF ,
P
K
N
P

40

SNR [dB]

Fig. 1: Rate vs SNR, Optimized Beamformer - K = 4, t = L = 2

III. S UBPACKETIZATION -S ELECTIVE S CHEME
First we consider the special case of K = t + L, and then
provide an extension to more general setups.
A. Cache Placement Scheme
Assume K = t + L and each file W is divided into P
equal-sized parts Wp . We define a binary placement matrix
V of size P × K and represent its elements by vp,k , where
p ∈ [P ] and k ∈ [K]. If vp,k = 1, then for any file W in
the file library, we store Wp in the cache memory of user
k. For example consider the three curves in Figure 1. The
corresponding placement matrix for P = 2 is


1 0 1 0
V=
,
(6)
0 1 0 1
while for P = 4 and P = 6 we have used


1 1 0 0


0 1 1 0
1 1 0 0



0 0 1 1

0
1
1
0
′′
′



 , (7)
, V =
V =

0 0 1 1
1 0 0 1
1 0 1 0
1 0 0 1
0 1 0 1
respectively. Denoting the cache content of user k with Z(k)
and considering the file library {A, B, C, D}, we have
Z(1) = {A1 , B1 , C1 , D1 }
Z ′ (1) = {A1 , A4 , B1 , B4 , C1 , C4 , D1 , D4 }
Z ′′ (1) = {A1 , A4 , A5 , B1 , B4 , B5 , C1 , C4 , C5 , D1 , D4 , D5 }
corresponding to V, V′ and V′′ , respectively. We say V is a
valid placement matrix, if its rows are different and
X
Pt
∀k ∈ [K]
(8a)
vp,k =
K
p
X
vp,k = t
∀p ∈ [P ]
(8b)
k

Note that (8a) represents the cache size constraint at each
user; i.e. as the size of each packet is F
P and there exists N files
in the library, the required cache size at each user becomes

Lemma 1. If K = t + L, the cache placement scheme of [9]
is equivalent to a valid placement matrix with P = Kt .

Proof. Consider a valid placement matrix V with P = Kt
rows and K columns. According to the validity condition (8b),
there exist exactly t non-zero elements at each row of V. As
a result, the rows of V include all possible combinations of t
non-zero elements at K positions. Labelling each row with a
set T consisting of column indices of non-zero elements in that
row and using the same index p(T ) for packets as described
in section II, we reach the same placement of [9].
t
Lemma 2. If K
L and L are integers, then the cache placement
scheme of [12] is equivalent to a valid placement matrix with
P = K/L
.
t/L

Proof. Similar to Lemma 1, follows from
 labeling rows in a
valid placement matrix with P = K/L
t/L .

Lemmas 1 and 2 provide higher and lower boundaries
for


K
<
P
<
subpacketization, respectively. Any other K/L
t ,
t/L
for which validity conditions hold, provides a possible cache
placement with a different subpacketization value.
B. Delivery Scheme
Assume cache placement is performed according to a given
valid placement matrix V. At the start of the delivery phase,
each user k reveals its requested file W (k). For each V ⊆ [K]
with |V| = t + 1 we create a codeword X(V) such that all
users in V can decode part of their missing data (the parts for
which the corresponding vp,k is zero) with the help of X(V).
Defining the corresponding packet set of V as
Φ(V) = {p ∈ [P ] | vp,k = 0, ∀k ∈ [K]\V} ,
(10)
the codeword X(V) is built as
M
X(V) =
(1 − vp,k )Wp (k) .

(11)

k∈V
p∈Φ(V)

As a brief explanation, according to the placement condition (8b), each row of V has exactly t non-zero and K −t = L
zero elements. Also as we have L antennas, it is possible to
null (or suppress) X(V) at L − 1 users. The set Φ(V) contains
packet indices for which the corresponding vp,k is zero for all
L − 1 users in [K]\V, and so for each p ∈ Φ(V), there exists
exactly one k ∈ V such that vp,k = 0. This enables each user

k ∈ V to remove unwanted terms from X(V) using its cache
contents, and decode its missing packet accordingly.
Nulling (or suppressing) each X(V) at all L − 1 users
in [K]\V also enables us to transmit all codewords simultaneously, thus achieving the full multicasting gain of t + L.
Defining u(V) such that ku(V)k = 1 and u(V) ⊥ hk for all
k ∈ [K]\V, we can build the transmission vector as in (4).
Alternatively, instead of ZF we can use the optimized beamformer as in (5). In this case, X(V) is considered as Gaussian
interference instead of being nulled at users k ∈ [K]\V, and
the resulting symmetric rate will be higher [10], [11].
According to the above explanation, all users in V can
decode part of their requested data after receiving X(V); and
as each missing data part is addressed in one set V, building
x as (4) enables all users to decode every missing data part
and completely decode their requested files (in Example 1
this procedure is reviewed for a simple network). It should be
noted that each user faces a MAC channel after transmission
of x, and transmission rate and power should be adjusted that
simultaneous decoding of all missing data parts is possible.
C. Efficiency Index
Assume the transmission vector x is built as in (4)2 . After
x is transmitted, user k receives
y(k) = hTk x + zk
(12)
3
where zk is the additive Gaussian noise at user k . For each
constituting term of x, one of the following is possible:
1) k 6∈ V: hk ⊥ u(V) and hence the term X(V) is nulled
(or suppressed by w(V)) at user k;
2) k ∈ V and ∃ p ∈ Φ(V) | vp,k = 0: the term X(V)
is received, from which the user k can then decode the
desired part Wp (k);
3) k ∈ V and ∄ p ∈ Φ(V) | vp,k = 0: the term X(V)
is received at user k, but does not contain any missing
packet for user k and so is entirely removed using its
cache contents.
The third possibility can be interpreted as a case of power
loss, as the power used to transmit the deleted terms is not used
for increasing the signal quality at that particular user. This is
the reasoning behind our definition of the efficiency index.
Let θ(k) denote the number of terms completely removed by
cache contents of user k. Then the efficiency index Γ(k) is
θ(k)
,
(13)
Γ(k) = 1 −
φ(x)
where φ(x) is the total number of terms transmitted in
transmission vector x.
Example 1. Consider the cache placement matrix V′ in (7)
and assume the demand set is {A, B, C, D}. After transmission of x is concluded, user 1 receives
y(1) = (B3 ⊕ D2 )hT1 u1 p1 + (A3 ⊕ C4 )hT1 u2 p2
(14)
+(B4 ⊕ D1 )hT1 u3 p3 + (A2 ⊕ C1 )hT1 u4 p4 + z1 ,
2 For notational convenience we assume ZF beamforming, but the following
discussion also holds for the optimized beamformer (5).
3 For x built as in (5), z would also contain Gaussian interference terms
k
from all w(V)X(V) | k 6∈ V [10], [11].

where uk = u(Vk ), pk = p(Vk ) and Vk = [4]\{k} (as t =
2, each V includes three users). Considering RHS of (14),
B3 ⊕ D2 in nulled (as u1 ⊥ h1 ), while A3 ⊕ C4 and A2 ⊕ C1
contain useful data (A2 and A3 ; C4 and C1 are removed by
the cache). However, B4 ⊕ D1 is entirely removed using the
cache content of user 1. Therefore, φ(x) = 4, θ(1) = 1 and
the efficiency index of user 1 becomes Γ(1) = 0.75. It can be
easily checked that the efficiency index of other users is the
same and independent of the request vector.
D. Building the Placement Matrix
In order to build valid placement matrices, we introduce
placement blocks. Denoted by ΛK
t (p), a placement block of
size p for K users with global memory ratio t is a p × K
binary matrix, for which:
1) Placement validity conditions (8a) and (8b) are met;
2) Each row can be transformed into any other row using
circular shift operations.
For example, V and V′ in (6) and (7) are Λ42 (2) and Λ42 (4),
respectively. It should be noted that ΛK
t (p) is not necessarily
unique (examples will be provided in Section IV). Moreover,
it can be easily checked that the column-wise concatenation of
two (or more) placement blocks results in a valid placement
matrix. For example, concatenation of V and V′ results in
V′′ as mentioned in (7), which is a valid placement matrix.
For general K and t values, one can easily build a placement
block by considering a random 1 × K vector with t non-zero
elements as the first row of the block, and building each new
row by circular shifting previous row for one unit, until the
first row is repeated. The resulting matrix is a placement block.
These placement blocks can then be concatenated freely to
build valid placement matrices with different P values.
E. Extension to K > t + L
So far we have only considered networks with K = t + L.
If K < t + L, as the number of users falls below the
maximum multicasting gain, providing an appropriate coded
caching scheme becomes very straightforward. Specifically,
any solution for a network with L′ = K − t antennas works
for the same network with L > L′ antennas. Moreover, as
mentioned in [10], [11] the extra antennas provide increased
flexibility and gain for the multicast beamformer design.
In case K > t + L the solution is not trivial. Defining Q
as (1) we provide a scheme with total subpacketization P ×
Q, where P can be any number for which a valid placement
matrix of dimensions P × K and global cache ratio t exists.
During the placement phase each file W is first split into P
packets denoted by Wp , and then each packet is further split
into Q subpackets Wpq . Assume V is the given valid placement
matrix and W is a file in the library. For each k ∈ [K] and
p ∈ [P ], if vp,k = 1 we store Wpq for all q ∈ [Q] in the cache
memory of user k.
For delivery, we select all subsets S ⊂ [K] with |S| =
t + L. For each S, we generate matrix VS of size P × K and
S
elements vp,k
, using the procedure of Alg. 1. VS is then used
as the input to Algorithm 2, which executes exactly the same

procedure described in Section III-B, to build the transmission
vector x(S).
Algorithm 1 Generate VS
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:

procedure N EW P LACEMENT(V, S)
S ′ ← [K]\S, Φ(S ′ ) ← 0
for all p ∈ [P ] do
if vp,k = 1, ∀k ∈ S ′ then
Φ(S ′ ) ← Φ(S ′ ) ∪ {p}
for all p ∈ Φ(S ′ ), k ∈ [K] do
S
vp,k
←1
for all p ∈ [P ], k ∈ S ′ do
S
vp,k
←1
for all p ∈ [P ]\Φ(S ′ ), k ∈ S do
S
vp,k
← vp,k

Algorithm 2 Build Transmission Vector x(S)
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:

procedure B UILD TX(S, VS , {W (1), W (2), ..., W (K)})
x(S) ← 0
for all V ⊆ S with |V| = t + 1 do
Φ(V) ← ∅
for all p ∈ [P ] do
if vp,k = 0, ∀k ∈ [K]\V then
Φ(V) ← Φ(V) ∪ {p}
X(V) ← 0
for all p ∈ Φ(V), k ∈ V do
S
if vp,k
= 0 then
q(W (k),k)
X(V) ← X(V) ⊕ Wp
(k)
q(W (k), k) ← q(W (k), k) + 1
x(S) ← x(S) + X(V) × u(V) × p(V)

Note that VS is generated such that no term in x(S) needs
to be nulled (or suppressed) at more than L − 1 users. In
Algorithm 2, the initial values of superscripts q(n, k) are all
set to one.
Example 2. Assume K = 5, t = L = 2 and the file library is
{A,
 B,
 C, D, E}. The scheme of [9] requires subpacketization
5 2
the cache placement matrix
2 1 = 20, but using 

1 1 0 0 0
0 1 1 0 0



(15)
V=
0 0 1 1 0 ,
0 0 0 1 1
1 0 0 0 1

the required subpacketization is reduced to 5 × 21 = 10.
 For
the example demand set {A, B, C, D, E} we need 54 = 5
consecutive transmissions, which are built as
x(S1 ) = (D21 ⊕ B31 )u5 + (E31 ⊕ C41 )u2 + E21 u4 + B41 u3
x(S2 ) = (E32 ⊕ C42 )u1 + (A14 ⊕ D51 )u3 + A13 u5 + C51 u4
x(S3 ) = (A24 ⊕ D52 )u2 + (E11 ⊕ B51 )u4 + B42 u1 + D11 u5
x(S4 ) = (E12 ⊕ B52 )u3 + (C11 ⊕ A12 )u5 + C52 u2 + E22 u1
x(S5 ) = (C12 ⊕ A22 )u4 + (D22 ⊕ B32 )u1 + D12 u3 + A23 u2

where Sk = [K]\{k}, uk is defined such that kuk k = 1
and uk ⊥ hk , and we have ignored power coefficients for
notational simplicity. It can be easily checked that after all
the transmissions are concluded, all users can decode their
requested files.
IV. S IMULATION R ESULTS
We provide simulation results for two network setups, with
parameters shown in Table I. In order to build valid placement
matrices we use placement block concatenation, as described
in Section III-D. Due to lack of space we explicitly explain
the procedure for Network 1 only. For this network, there exist
two placement blocks of size 6 × 6, which are




1 1 0 0 0 0
1 0 1 0 0 0
 0 1 1 0 0 0
0 1 0 1 0 0




 0 0 1 1 0 0
0 0 1 0 1 0




V1 = 
 , V2 = 0 0 0 1 0 1 ,
 0 0 0 1 1 0


 0 0 0 0 1 1
1 0 0 0 1 0
1 0 0 0 0 1
0 1 0 0 0 1
and another placement block of size 3:


1 0 0 1 0 0
V3 = 0 1 0 0 1 0 .
0 0 1 0 0 1
V1 and V2 are confirming examples that placement blocks of
a given size are not necessarily unique. Using V1 , V2 , V3 and
their concatenations, one can create valid placement matrices
with P values mentioned in Table I4 . For example, P = 9 can
be created by concatenating either V1 or V2 with V3 , and
P = 12 can be created by concatenating V1 and V2 . The case
P = 15 is equivalent to the scheme of [9] and is created by
concatenating all the three blocks. It is worth mentioning that
while the scheme presented in [12] is not readily applicable
for Network 1 (as K
L is not an integer), our scheme easily
provides a cache placement with subpacketization P = 3.
K
t
L
P values

Network 1
6
2
4
{3, 6, 9, 12, 15}

Network 2
6
3
3
{2, 6, 12, 18, 20}

TABLE I: Simulation Parameters

In Figures 2 and 3 we have plotted simulation results for
Networks 1 and 2, respectively. For simulations we have used
optimized beamformers as in (4) [10]. Moreover, efficiency
indices corresponding to different P values for both networks
are presented in Table II. It can be verified that higher
subpacketization usually5 results in better efficiency index;
which in turn means higher symmetric rate. Also, as the slopes
are the same for all curves in Figures 2 and 3, it is clear that
selection of P is not affecting the multicasting gain.
4 Although for Network 1 all possible P values are mentioned, the P values
considered for Network 2 are a subset of all possible values. For example,
there exists a placement with P = 8, which is not considered.
5 There exist special cases for which higher subpacketization reduces the
efficiency index. This is not covered here due to lack of space.

8

P = 15
P = 12
P =9
P =6

6

Rate Advantage [%]

Symmetric Rate [nats/s]

50

4
P = 15
P = 12
P =9
P =6
P =3

2

0

10

20

30

10
40

Symmetric Rate [nats/s]

6

4
P = 20
P = 18
P = 12
P =6
P =2

2

30

40

Fig. 3: Rate vs SNR, Optimized Beamformer - K = 6, t = 3, L = 3

Network 2

P =3
0.667
P =2
0.50

P =6
0.722
P =6
0.583

P =9
0.833
P = 12
0.733

P = 12
0.90
P = 18
0.933

P = 15
1.00
P = 20
1.00

TABLE II: Efficiency Index for Various P Values

Finally, in Figure 4 we have plotted the rate advantage of
various subpacketization levels over P = 3, versus SNR for
Network 1 (similar results hold for Network 2). It is clear
that higher subpacketization results in better rate advantage,
specially at low-SNR.
V. C ONCLUSION

AND

10

15

20

25

30

35

Fig. 4: Rate Advantage over P = 3 - K = 6, t = 2, L = 4

R EFERENCES

SNR [dB]

Network 1

5

larger efficiency index and higher symmetric rate, while low
subpacketization incurs significant loss in the achievable rate.
Our scheme enables more efficient caching decisions, tailored
to the available computational and power resources.
Possible future research directions include finding upper
bounds for the achievable symmetric rate for various subpacketization levels, further simplifying the scheme for large
networks, and thorough comparison of various beamformer
design techniques (ZF versus optimized design versus approximate solutions).

8

20

0

SNR [dB]

Fig. 2: Rate vs SNR, Optimized Beamformer - K = 6, t = 2, L = 4

10

30

20

SNR [dB]

0

40

F UTURE W ORK

We provided a new scheme for multi-antenna coded
caching, which enables the subpacketization level to be selected freely among a set of predefined values depending on
basic network parameters such as user count, antenna count
and global cache ratio. We also proposed a simple efficiency
index as a performance indicator (in terms of symmetric
rate) at various subpacketization levels. Numerical examples
demonstrate that larger subpacketization generally results in

[1] C. V. N. Index, “Global mobile data traffic forecast update, 2017–2022
white paper,” Cisco: San Jose, CA, USA, 2019.
[2] E. Bastug, M. Bennis, and M. Debbah, “Living on the edge: The role
of proactive caching in 5g wireless networks,” IEEE Communications
Magazine, vol. 52, no. 8, pp. 82–89, 2014.
[3] X. Wang, M. Chen, T. Taleb, A. Ksentini, and V. C. Leung, “Cache in the
air: Exploiting content caching and delivery techniques for 5g systems,”
IEEE Communications Magazine, vol. 52, no. 2, pp. 131–139, 2014.
[4] M. A. Maddah-Ali and U. Niesen, “Fundamental limits of caching,”
IEEE Transactions on Information Theory, vol. 60, no. 5, pp. 2856–
2867, 2014.
[5] ——, “Decentralized coded caching attains order-optimal memory-rate
tradeoff,” IEEE/ACM Transactions on Networking (TON), vol. 23, no. 4,
pp. 1029–1040, 2015.
[6] R. Pedarsani, M. A. Maddah-Ali, and U. Niesen, “Online coded
caching,” IEEE/ACM Transactions on Networking (TON), vol. 24, no. 2,
pp. 836–845, 2016.
[7] N. Karamchandani, U. Niesen, M. A. Maddah-Ali, and S. N. Diggavi,
“Hierarchical coded caching,” IEEE Transactions on Information Theory, vol. 62, no. 6, pp. 3212–3229, 2016.
[8] S. P. Shariatpanahi, S. A. Motahari, and B. H. Khalaj, “Multi-server
coded caching,” IEEE Transactions on Information Theory, vol. 62,
no. 12, pp. 7253–7271, 2016.
[9] S. P. Shariatpanahi, G. Caire, and B. H. Khalaj, “Multi-antenna coded
caching,” in 2017 IEEE International Symposium on Information Theory
(ISIT). IEEE, 2017, pp. 2113–2117.
[10] A. Tölli, S. P. Shariatpanahi, J. Kaleva, and B. Khalaj, “Multiantenna interference management for coded caching,” arXiv preprint
arXiv:1711.03364, 2017.
[11] A. Tolli, S. P. Shariatpanahi, J. Kaleva, and B. Khalaj, “Multicast
beamformer design for coded caching,” in 2018 IEEE International
Symposium on Information Theory (ISIT). IEEE, 2018, pp. 1914–1918.
[12] E. Lampiris and P. Elia, “Adding transmitters dramatically boosts codedcaching gains for finite file sizes,” IEEE Journal on Selected Areas in
Communications, vol. 36, no. 6, pp. 1176–1188, 2018.

