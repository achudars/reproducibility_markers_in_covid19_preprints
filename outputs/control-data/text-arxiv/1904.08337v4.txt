Logical Methods in Computer Science
Volume 16, Issue 3, 2020, pp. 18:1–18:69
https://lmcs.episciences.org/

Submitted
Published

Apr. 19, 2019
Sep. 24, 2020

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES
LAURA BOCCHI a , HERNÁN MELGRATTI b , AND EMILIO TUOSTO c
a

School of Computing, University of Kent, UK

b

Instituto de Ciencias de la Computación - Universidad de Buenos Aires - Conicet, Argentina

c

Gran Sasso Science Institute, IT and Department of Computer Science, University of Leicester, UK

Abstract. Choreographies specify multiparty interactions via message passing. A realisation of a choreography is a composition of independent processes that behave as specified by
the choreography. Existing relations of correctness/completeness between choreographies
and realisations are based on models where choices are non-deterministic. Resolving nondeterministic choices into deterministic choices (e.g., conditional statements) is necessary to
correctly characterise the relationship between choreographies and their implementations
with concrete programming languages. We introduce a notion of realisability for choreographies –called whole-spectrum implementation– where choices are still non-deterministic
in choreographies, but are deterministic in their implementations. Our notion of whole
spectrum implementation rules out deterministic implementations of roles that, no matter
which context they are placed in, will never follow one of the branches of a non-deterministic
choice. We give a type discipline for checking whole-spectrum implementations. As a case
study, we analyse the POP protocol under the lens of whole-spectrum implementation.

1. Introduction
The context A choreography describes the expected interactions of a system in terms of
the messages exchanged among its components (aka roles):
“Using the Web Services Choreography specification, a contract containing a
global definition of the common ordering conditions and constraints under which
messages are exchanged, is produced [...]. Each party can then use the global
definition to build and test solutions that conform to it. The global specification
is in turn realised by combination of the resulting local systems [...]”
The first part of the excerpt above taken from [30] envisages a choreography as a global
contract regulating the exchange of messages; the last part identifies a distinctive element
of choreographies: the global definition can be used to verify local components (correctly)
Key words and phrases: Choreography, multiparty session types, process algebras, whole-spectrum implementation, message-passing, non-determinism.
Research partly supported by the European Unions Horizon 2020 research and innovation programme
under the Marie Sklodowska-Curie grant agreement No 778233, by the UBACyT projects 20020170100544BA
and 20020170100086BA, and by the PIP project 11220130100148CO .

l

LOGICAL METHODS
IN COMPUTER SCIENCE

c
DOI:10.23638/LMCS-16(3:18)2020

CC

L. Bocchi, H. Melgratti, and E. Tuosto
Creative Commons

18:2

L. Bocchi, H. Melgratti, and E. Tuosto

Vol. 16:3

c−
→b : login
+
c−
→b : deposit

c−
→b : overdraft
+
b−
→c : ko
+

b−
→c : ok
+

Figure 1: ATM Choreography
realise the global contract. A choreography allows for the combination of independently
developed distributed components (e.g., services) while hiding implementation details.
Moreover, the communication pattern specified in the choreography yields sufficient
information to be projected so to check each component implementing one of the roles. For
illustration, take a simple choreography, hereafter called ATM and expressed as the global
graph [35, 25] on Figure 1, involving a customer c and the cash machine of a bank b. The
nodes labelled by + represent branching or merging points of choices. After successful
authentication, b offers a deposit and an overdraft service to c. In the global graph this
choice corresponds to the topmost + branching over the next interactions between the
participants. The bank b can either grant or deny overdrafts asked by the customer c.
On realisations A set of processes is a realisation of a choreography when the behaviour
emerging from their distributed execution matches the behaviour specified by the choreography. A choreography is realisable when it has a realisation.
A realisation of ATM can, for example, be given using two CCS-like processes [38]
(augmented with internal ⊕ and external + choice operators) for roles b and c:
Tb = login.(deposit + overdraft.(ok ⊕ ko))
Tc = login.(deposit ⊕ overdraft.(ok + ko))
In words, Tb specifies that, after c logs in, b waits to interact either on deposit or on overdraft;
in the latter case, b non-deterministically decides whether to grant or deny the overdraft; Tc
is the dual of Tb . Note that ATM uses non-determinism to avoid specifying the criteria for
b to grant or deny an overdraft. The use of non-determinism is also reflected in realisations,
in fact Tb uses the internal choice operator ⊕ to model the reaction when c requests an
overdraft.
Choreographies can be interpreted either as constraints or as obligations of distributed
interactions [37]. The former interpretation (aka partial [37] or weak [43]) admits a realisation
if it exhibits a subset of the behaviour. We propose WSI as a criterion to assess if an
implementation takes into account all the execution cases prescribed by a choreography. The
theory can be used in practice, to implement a static verification checker targeted at specific

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:3

languages, and possibly embedded in a (behavioural) type checker (e.g., for Java [27] or
Haskel [39]), or an API generation tool (e.g., for Java [28] or F# [40]). The aforementioned
tools are generally targeted at checking soundness of implementations, and checking for
WSI would add guarantees of ‘completeness’. In this paper, we use a process algebra as an
abstraction of implementations, instead of a full fledged programming language, to simplify
the presentation and the development of the theory. For instance, take
T0b = login.(deposit + overdraft.ko)
then T0b and Tc form a partial realisation of ATM where overdraft requests are consistently
denied. On the contrary, when interpreting choreographies as obligations, a realisation is
admissible if it is able to exhibit all interaction sequences (hence such realisations are also
referred to as complete realisations [37]).
For instance, Tb and Tc form a complete realisation of ATM .
The problem Typically, realisations are non-deterministic specifications; here we explore
the problem of resolving their non-determinism. In fact, despite being a valuable abstraction
mechanism, non-determinism has to be implemented using deterministic constructs such as
conditional statements.
Using again ATM, we illustrate that traditional notions of complete realisation are not
fully satisfactory. The non-deterministic choice in Tb abstracts away from the actual conditions used in implementations to resolve the choice. This permits a bank to adopt different
policies depending e.g., on the type of the clients’ accounts. Consider the (deterministic)
implementations B1 and B2 of Tb below written as value-passing CCS processes:
Bi
::= login(c). (deposit(x).Q + overdraft(x).Pi (c)) for i = 1, 2
P1 (c) ::= if check (c) then ok else ko
P2 (c) ::= ko

(Q is immaterial)

Both B1 and B2 expect to receive the login credentials c of a client on channel login. After
that, they offer the services deposit and overdraft. The implementations differ in the way
they handle overdraft requests, which are respectively defined by P1 (c) and P2 (c). The
expression check (c) in P1 (c) deterministically discriminates if the overdraft should be granted
depending on the login credentials c provided by the client. Differently, P2 (c) refuses any
overdraft request. It is not hard to see that both B1 and B2 are suitable implementations of
Tb in partial realisations of the choreography1 (as e.g. in [20]).
Conversely, neither B1 nor B2 can be used in a complete realisation. This is straightforward for B2 (unable to interact over ok after receiving an overdraft request), but not so
evident for B1 . Depending on the credentials c sent by the customer at login time, check (c)
will evaluate either to true or to false. Therefore, B1 will execute only one of the branches.
This will be the case for any possible deterministic implementation of ATM : only one branch
will be matched. Consequently, there is not a complete, deterministic realisation for ATM .
We prefer B1 to B2 arguing that they are not equally appealing when interpreting
choreographies as obligations. In fact, B2 consistently precludes one of the alternatives
while B1 guarantees only one or the other alternative (provided that check is not a constant
function) depending on the deterministic implementation of the role Tc .
1For instance, both B and B type-check against T considered as a session type due to the fact that
1
2
b

subtyping for session types [23] is contra-variant with respect to internal choices (and covariant with respect
to external choices).

18:4

L. Bocchi, H. Melgratti, and E. Tuosto

Vol. 16:3

Contributions and synopsis We introduce whole-spectrum implementation (WSI), a new
interpretation of choreographies as interaction obligations. A WSI of a role r guarantees
that, whenever the choreography allows r to make an internal choice, there is a context (i.e.,
an implementation of the remaining roles) for which (the implementation of) r chooses such
alternative. Through the paper, we illustrate the use of WSI to analyse the POP2 protocol
(i.e., choreography Section 3, implementation Section 5, and verification Section 7.3).
In the following, we use an elaboration of global types from [34] to model choreographies.
Implementations of choreographies are abstracted as systems, which are parallel compositions
of processes in an asynchronous calculus. Whole-spectrum implementation (WSI) is defined
in terms of the denotational semantics of global types and systems. A key point on the
characterisation of WSI is the distinction between mandatory and optional behaviour arising
from the implementation of loops. The denotational semantics of a global type G is given
by the set R(G) of traces describing mandatory and optional behaviour (Definition 6.6 in
Section 6). The denotation of a system S is also a set R(S) of traces (Definition 6.4 in
Section 6), which however do not discriminate optional behaviour. WSI is defined as a
covering relation b between the traces of implementations R(S) and those of global types
R(G) (Definition 6.8, Section 6).
We devise a behavioural typing framework for checking WSI. Our global and local
types are in Section 2; the language for implementations is in Section 4. Our typing
discipline is introduced in Section 7. As usual, a type judgement ` S . ∆ says that an
implementation S has local types ∆, obtained by projecting a global type G (cf. Section 2).
We show a theorem of subject reduction and one of conformance (Theorems 8.2 and 8.4 in
Section 8.1) which guarantee that well-typed systems do not deviate from the behaviour
specified by their type. Both results rely on the operational semantics of systems (Section 4)
and of local types (Section 8.1). We show the adequacy of the denotational semantics
of systems to their operational semantics in Theorem 6.5 (Section 6). Analogously, we
establish the correspondence between the operational and denotational semantics of local
types (Lemmas 8.5 and 8.6, Section 8.2).
The proof that our type system ensures WSI is given in two steps: we prove that
• R(G) b R(∆) (Theorem 8.7 in Section 8.2), namely that the traces of the local types
projected from a global type G cover the traces of G; and that
• R(∆) b R(S) (Theorem 8.8 in Section 8.2), namely that the traces of well-typed systems
cover the traces of their local types.
By transitivity of b, we obtain R(G) b R(S), which entails WSI for well-typed implementations (Corollary 8.9 in Section 8.2).

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:5

The main contributions in this paper can be diagrammatically presented as follows:

` S 0 . ∆0
§8.1

§4

Lem

. 8.
§8.2 6-8.5

5,

6.
.
m
6
h §
T

§7

` S . ∆

pro j

,

D

6.6
§6

G

Fi
g.
§6 14

.4
f. 6
De §6

R(G)

R(S)

Thm. 8.7,
§8.2

b

b

Def. 6.8,
§6

b

ef.

ecti
on
§2

R(∆)

Thm. 8.8
§8.2

This is an extended version of [4]. Besides giving detailed proofs, we simplified some
definitions and typing rules. In particular, Section 7.1 was not included in [4] and was
added here to remove communication effects from judgements. We also improved the general
presentation and refined the running example.
2. Global and Local Types
Our types elaborate from [34] and use a form of iteration, which is more tractable than
recursion. We fix three countably infinite and pairwise disjoint sets:
• U of shared names (ranged over by u),
• Y of session channels (ranged over by y, s, . . .), and
• P of (participants) roles ranged over by p, q, r, . . .; it is convenient to assume that P is
(isomorphic to) the set of natural numbers.
Basic data types, called sorts, (e.g., booleans Bool, integers Int, strings Str, singleton Unit,
record types, etc.) are assumed; d ranges over sorts. We use sorted channels y d to specify
that channel y ∈ Y is used to exchange data of sort d. We write ~z = (z1 , . . . , zn ) for a finite
sequence of elements z1 , . . . , zn ∈ Z for a given set Z; when no confusion arises, ~z may also
denote the set {z1 , . . . , zn } (e.g., we write z2 ∈ ~z).
A global type term (GTT, for short) G is derived by the following grammar:
X
f
G ::=
p _ qi : yi di ; Gi
G; G
G∗
end
i∈I

P
A GTT i∈I p _ qi : yi di ; Gi denotes the branching of interactions from a unique selector
p to participants qi for i ∈ I 6= ∅; we tacitly assume that p 6= qi for all i ∈ I, and that
qi = qj implies yi =
6 yj for all i =
6 j ∈ I (namely that channels of a same receiver in
two
different
branches
are
different).
For a singleton I = {n}, p _ qn : yn dn ; Gn shortens
P
p
_
q
:
y
d
;
G
.
A
communication
over a channel of sort Unit is a pure synchronisation
i
i
i i
i∈I
and usually we write p _ q : y ; G instead of p _ q : y Unit; G. A GTT can also be the

18:6

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

sequential ( ; ) composition of two GTTs, the iteration of a GTT ( ∗ ), or the empty term
end. We omit trailing occurrences of end and write p _ q : y d instead of p _ q : y d; end.
f
As in [10], we adopt iteration in global types. Function f in G∗ is an injective map that
assigns sorted channels to roles. The mapping is used to indicate how the termination of the
iteration is communicated to the roles. More precisely, if f (p) = y d then the participant p
will receive a message of type d on channel y when the iteration terminates. We use ch(f )
for the set of channels in the image of f , namely
ch(f ) = {y f (p) = y d

and p ∈ dom(f )}

Example 2.1 (Iterative GTT). We revisit the scenario introduced in Section 1, which
involves a client c and a bank b. The GTT G below defines a protocol in which c, after
being logged in, may perform zero or more deposits and overdrafts.
G = c _ b : login Str; (

c _ b : deposit Int
+
c _ b : overdraft Int; (b _ c : ok + b _ c : ko )

b7→quit

)∗

The protocol starts with the interaction c _ b : login Str, i.e., c sends to b its login information
(of sort Str) over channel login. Then, the protocol continues as an iterative GTT in which
c decides to either perform a deposit, ask for an overdraft, or finalise the protocol. The
protocol can be finalised by c by sending to b a message (of omitted sort Unit) on channel
quit, as indicated by the function b 7→ quit used to decorate the iterative type. In the
interaction c _ b : deposit Int, c requests a deposit by sending the amount to be deposited
over channel deposit. In the interaction c _ b : overdraft Int, c requests an overdraft. Note
that in the case of overdraft request c waits for a notification from b on whether the request
is granted or denied (a message over ok or ko, respectively, of the omitted sort Unit). Once
the chosen branch has been completed, the iteration can be restarted.

We introduce some useful auxiliary notions. For a GTT G
• the set of participants P(G) of G is
X
[
P(
p _ qi : yi di ; Gi ) = {p} ∪ ({qi } ∪ P(Gi ))
i∈I

i∈I

0

P(G; G ) = P(G) ∪ P(G0 )
f

P(G∗ ) = P(G)
P(end) = ∅
• the set of participants ready to send a message, or ready participants rdy(G) of G is
X
rdy(
p _ qi : yi di ; Gi ) = {p}
i∈I

(
rdy(G)
rdy(G; G ) =
rdy(G0 )
0

f

rdy(G∗ ) = rdy(G)
rdy(end) = ∅

if rdy(G) 6= ∅
if rdy(G) = ∅

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:7

• the set of channel names ch(G) ⊆ Y of G is
X
[
ch(
p _ qi : yi di ; Gi ) =
{yi }
i∈I

i∈I

0

ch(G; G ) = ch(G) ∪ ch(G0 )
f

ch(G∗ ) = ch(G) ∪ ch(f )
ch(end) = ∅
Example 2.2. The set ch(G) = {login, deposit, overdraft, ok, ko, quit} is the set of channels
used by the choreography G in Example 2.1. Also, we have the set of participants P(G) =
{b, c}, where c is the one that can initiate the interaction, i.e., rdy(G) = {c}.

A global type is defined by an equation
G(~y) , G

where

ch(G) ⊆ ~y ⊆ Y and ~y are pairwise distinct names

We abbreviate G(~y) , G with G(~y) when G is immaterial; we write G or G instead of G(~y)
when parameters are understood.
For technical reasons (cf. Section 7), our global types are explicitly parameterised on
session channels; however, they will be considered equivalent up-to renaming of parameters.
More precisely, let ≡GTT be the structural congruence relation on GTTs such that
• ; and + form monoids with identity end
• and + is commutative;
we say that G1 (~y) , G1 and G2 (~z) , G2 are structurally equivalent (written G1 ≡ G2 ) when
G1 ≡GTT G2 {~z/~y} where, as usual, {~y/~y} is the capture avoiding substitution replacing the
i-th element of ~y with the i-th element of ~z (for which we assume ~y to be a tuple of pairwise
distinct names of the same length as ~z).
The extensions of P( ) and rdy( ) to G(~y) , G are straightforward: P(G) = P(G) and
rdy(G) = rdy(G).
As customary in session types, we restrict our attention to well-formed global types
in order to rule out specifications that cannot be implemented distributively. We borrow
from [26, 10] the standard wellformedness conditions of knowledge of choice and linearity.
Knowledge of choice requires a unique-selector in a choice and that any other participant
can determine the chosen branch from the received messages. For instance, the global type
p _ q : y1 ; G1 + p _ r : y2 ; s _ q : y1 ; G2

violates the knowledge of choice condition: although there is a unique-selector p in the
choice (hence the first part of the condition is satisfied), there is a participant q that cannot
determine the chosen branch. More precisely, q is ready to receive a message on y1 either
from p in the first branch or from s on the second one; hence q cannot determine which
branch has been selected after the input on y1 .
Linearity requires absence of communication races on channels. Races occur when
causally unrelated interactions happen on a same channel. Consider
p _ q: y ; r _ q: y

where the two sent actions yield a race on y since they are concurrent because performed by
different senders. On the contrary,
p _ q: y ; q _ r: y

18:8

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

satisfies linearity because the two interactions on y are executed sequentially, hence causally
related.
We introduce an additional wellformedness condition (Definition 2.3) that is specific to
our form of iteration.
Definition 2.3 (Well-formed iteration). A GTT of the form Gf is a well-formed iteration if:
(1) ch(f ) ∩ ch(G) = ∅,
(2) rdy(G) is a singleton (we call the participant in rdy(G) the iteration-controller of G)
and dom(f ) = P(G)\rdy(G),
f
(3) for any proper subterm G∗1 1 of G, ch(f1 ) ∩ ch(f ) = ∅.
By condition (1), the channels used to terminate an iteration are disjoint from those in the
body G. This is fundamental to avoid confusion when implementing iterations and resembles
the condition about knowledge of choices. Consider the global type
q7→y

(p _ q : y ; G1 )∗

; G2

that violates condition (1). Note that after receiving a message from p on y, q is unable
to determine whether it should behave as specified by G1 (i.e., to perform the body of the
iteration) or G2 (i.e., to exit the iteration).
Condition (2) requires a unique role (the iteration-controller) to be the one deciding
whether to execute the iteration body or to terminate by notifying all other participants in
global type. This condition avoids situations in which a participant is unaware of the fact
that some iteration has been finalised. For example, in the following GTT
q7→y3

(p _ q : y1 ; q _ r : y2 )∗

; G2

r will not receive any message when p decides to conclude the iteration.
Finally, condition (3) prevents interference between terminations of nested iterations.
Consider
q7→y2
q7→y2 ,r7→y4
((p _ q : y1 )∗
; q _ r : y3 )∗
; G2
Note that after receiving a message on y2 , q is unable to determine if p has concluded the
inner or the outer iteration.
Hereafter, we will assume that for every G(~y) , G, G satisfies knowledge of choice
and linearity (form [26, 10]), and that every iterative GTT appearing in G is a well-formed
iteration.
A local type term (LTT for short) T is derived from the following grammar:
M
X
yi di .Ti
T1 ; T2
T?
end
T ::=
yi di .Ti
i∈I

i∈I

L

P
An LTT is either an internal ( ) or external ( ) guarded choice on non-empty index
sets I, the sequential composition ; , an iteration ? , or the empty termM
end. We usually
omit trailing occurrences of end and write yn dn ; Tn (resp. yn dn ; Tn ) for
yi di .Ti (resp.
i∈I

X
i∈I

yi di .Ti ) when I = {n}.

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:9

We assume that all channels appearing in the guards of an internal or an external choice
are pairwise different. Similarly to GTT, the set ch(T) of channels of an LTT T is defined as
[
M
X
ch(Ti )
ch(
yi di .Ti ) = ch(
yi di .Ti ) = {yi i ∈ I} ∪
i∈I

i∈I

i∈I

ch(T? ) = ch(T)

ch(T1 ; T2 ) = ch(T1 ) ∪ ch(T2 )

ch(end) = ∅

A local type is defined by an equation
T (~y) , T

where

ch(G) ⊆ ~y ⊆ Y

and ~y are pairwise distinct names

We abbreviate T (~y) , T with T (~y) when T is immaterial and we write T or T instead of
T (~y) when parameters are understood.
The structural congruence on LTTs is defined as the smallest congruence ≡LTT such
that
• internal and external choice operators are associative, commutative and have end as
identity,
• and ; is associative and has end as neutral element.
Two local types T1 (~y1 ) , T1 and T2 (~y2 ) , T2 are structurally equivalent (written T1 ≡ T2 )
when T1 ≡LTT T2 {~y1 /~y2 }. In the following, we consider types up-to structural congruence.
The projection operation extracts local types from a global type; we restrict such
operation on well-formed global types. Given a participant r ∈ P, the projection of a
well-formed GTT G on r, denoted as G r, is defined as follows:

G r =


end


M



yi di .Gi r




i∈I

X
X



yi di .Gi r +
Gi r



i∈Ir
i∈I\Ir

if r 6∈ P(G)
X
if G =
r _ qi : yi di ; Gi
i∈I
X
X
if G =
p _ qi : yi di ; Gi +
p _ qi : yi di ; Gi





G1 r; G2 r





(G1 r)? ; b1 d1 ; . . . ; bn dn








(G1 r)? ; b d

r 6= p, and Ir = {i ∈ I qi = r}
if G = G1 ; G2
S
f
if G = G∗1 , {f (p) | p ∈ ch(f )} = {b1 d1 , . . . , bn dn },
and r ∈ rdy(G1 )
f
if G = G∗1 , f (r) = b d

i∈Ir

i∈I\Ir

When projecting a global type G over a participant name r that does not appear in it,
produces the idle local type end. The remaining cases implicitly assume that r ∈ P(G).
The projection of the (unique) selector of a branch results in the internal choice on the
session channels. Dually, the projection on a receiver in a branch results in an external
choice; observe that branches where the receiver is not r (i.e., i ∈ I \ Ir ) are treated differently
from those where the receiver is r (i.e., i ∈ Ir ). We remark that the projected local type is
well-defined when G is well-formed: the condition about knowledge of choices ensures that
r ∈ P(Gi ) for all i ∈ I \ Ir ; moreover, r is the receiver in the first interaction of each branch
Gi .
The projection of a sequential composition is self-explanatory. Iterative GTTs are
f
projected depending on whether the role is a controller or not. For G = G∗1 , recall that
(by well-formedness) there is an iteration-controller r ∈ rdy(G1 ); the projection of G on the
controller generates an iterative local type, which corresponds to the projection of G1 , followed
by the messages that signal the termination of the iteration to the remaining participants

18:10

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

(i.e., the messages b1 d1 ; . . . ; bn dn ). Dually, the projection on the other participants waits for
the signal to exit the iteration (i.e., b d). The projection G(~y) r of a global type G(~y) , G
with respect to r is a local type T (~y) , T where T = G r.
Example 2.4. Consider the GTT G introduced in Example 2.1. Since G consists of a single
branch where c is the selector, the projection on c is an internal choice with a single branch
that sends a message on channel login and follows with the projection of the iterative type
in the continuation. Since c is the interation-controller of the continuation, its projection
consists of the iteration of the body followed by the termination message quit, as shown
below.
G c =login Str.(deposit Int + overdraft Int.(ok + ko ))? ; quit
G b =login Str.(deposit Int + overdraft Int.(ok + ko ))? ; quit


Note that G b and G b are each other’s dual.

3. Types for the POP2 Protocol
We illustrate our approach on the Post Office Protocol Version 2 (POP2) [6] between a client
c and a mail server s. We describe POP2 with the following global type:
GPOP
GEXIT

,
,

c _ s : quit ; GEXIT + c _ s : helo Str; GMBOX
s _ c : bye

The global type GPOP starts with c sending a message to s either on channel quit (of the
omitted sort Unit) or on helo to communicate its password (of sort Str). In the first case, the
interaction ends after s sends a message on bye as per GEXIT ; in the latter case the protocol
follows as per GMBOX below.
GMBOX

,

s _ c : e ; GEXIT + s _ c : r Int; GNMBR

In GMBOX , s either signals an error on e before terminating or sends a message on r containing
the number of messages in the default mailbox and then continues as GNMBR :
GNMBR , (

c _ s : fold Str; s _ c : r Int
+ c _ s : read Int; s _ c : r Int; Gsize )∗s7→quit ; GEXIT

where c repeatedly requests either (a) the number of messages available in a folder, or (b) the
length of a particular message in the current folder. The iteration-controller is c and it uses
quit to communicate the termination of the loop to s. In case (a), c sends the folder’s name
over the channel fold and waits for the answer on r; after this, the body of the iteration is
completed and the loop can be repeated again. In case (b), c sends the index corresponding
to the selected message on channel read and waits for the answer on channel r; after this,
the interaction continues as Gsize specified below:
Gsize , (

c _ s : read Int; s _ c : r Int
+ c _ s : retr ; s _ c : msg Data.Gxfer )∗s7→fold

Str ; s

_ c : r Int

In Gsize , another loop controlled by c lets the client either (a) ask for another message by
interacting again on read as described above or (b) retrieve a message. In the latter case, c
signals on retr that it is ready to receive the message, which is then sent back on msg by s

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:11

(sort Data abstracts away the format of messages specified in [17]). Finally, c acknowledges
the reception of the requested message as follows:
Gxfer

,
+
+

c _ s : acks ; s _ c : r Int
c _ s : ackd ; s _ c : r Int
c _ s : nack ; s _ c : r Int

Basically c may use one among three alternative channels: acks to acknowledge the reception
of the message, ackd to keep the message or, nack to notify that the message has not been
received properly (in which case the message is kept in the mailbox). In each case, s sends
back to c the length of the next message over channel r.
The local type Ts obtained by projecting GPOP on the participant s, i.e., Ts = GPOP s, is
below.
Ts , quit .TEXIT + helo Str.TMBOX
TEXIT , bye
TMBOX , e .TEXIT ⊕ r Int.TNMBR
TNMBR , (fold Str.r Int + read Int.r Int.Tsize )∗ ; quit ; TEXIT
Tsize , (read Int.r Int + retr .msg Data.Txfer )∗ ; fold Str; r int
Txfer , acks .r Int + ackd .r Int + nack .r Int
Note that the messages in Ts are as in GPOP . We remark that s does not control any of the
two iterations (i.e., GNMBR and Gsize ), hence the projections iterate until s receive a signal on
the termination channels: quit in TNMBR and fold in Tsize , respectively.
The projection GPOP c of GPOP on c is obtained analogously; the resulting local type is the
dual of Ts , i.e., the one obtained by substituting internal choices by external ones and vice
versa.
The projection GPOP c of GPOP onto c is obtained analogously; the resulting local type is
the dual of Ts , i.e., the one obtained by substituting internal choices by external ones and
vice versa.
For illustrative purpose, in the next example we present a multiparty variant of GPOP ,
where the authentication is outsourced.
Example 3.1. A multiparty variant of POP2 is defined by the global type G0POP below.
G0POP
G0 MBOX

,
,

c _ s : quit ; GEXIT + c _ s : helo Str; G0 MBOX

s _ a : req Str; a _ s : res Bool; s _ c : e ; GEXIT + s _ c : r Int; GNMBR

In this version, s uses a third-party authentication service a, which is contacted immediately
after the server receives a helo message from the client. The server sends to a an authentication
request over res and waits for the authorisation on res (GNMBR and GEXIT remain unchanged).
The following equations
T0s
TAUTH
T0 MBOX

,
,
,

quit .TEXIT + helo Str.TAUTH
req Str.res Bool.T0 MBOX
e .TEXIT ⊕ r Int.TNMBR

0 on s.
yield the projection T0s G0POP s of GPOP



18:12

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

P, Q ::=

processes
u n (~y).P
request
u p (~y).P
accept
N
choice
ye
send
P;Q
sequential
if e then P else Q conditional
for x in ` do P
for
repeat N until N repeat

N ::= X

input-guarded processes
yi (xi ).Pi choices

i∈I

S

::=

systems
P
S|S
y[~v]
(ν~y@u)S

parallel
queue
restriction

Figure 2: Syntax of processes and systems.
4. Processes and Systems
Choreographies specify distributed applications that we refer to as systems. Concretely,
systems are the parallel composition of processes realising the roles in a choreography.
Processes manipulate and exchange values obtained by evaluating expressions. Let X
and V be two infinite disjoint sets of variables and basic values respectively which are both
disjoint from the sets of shared names U, session channels Y, and participants P. Values are
specified by expressions having the following syntax:
e ::= x

v

e1 bop e2

uop e

` ::= [e1 , . . . , en ]

e1 ..e2

An expression e is either a variable x ∈ X or a value v ∈ V, or else the composition e1 bop e2
of two expressions through a binary operator bop , or the application of a unary operator
uop to an expression (operators are left unspecified and can be thought of as the usual
logical-arithmetic operators of programming languages). We assume that expressions are
implicitly sorted and, for simplicity, our expressions do not include binders of variables,
names, or test for definiteness. Lists [e1 , . . . , en ] and numerical ranges e1 ..e2 are used for
iteration; in the latter case, both expressions e1 and e2 are of sort integer. The empty list is
denoted as ε and the operations hd(`) and tl(`) respectively return the head and tail of `
(defined as usual). Given an expression e or a list `, the sets var(e) and var(`) of variables
of e and ` respectively, are defined as
var(x) = {x}

var(v) = ∅ var( uop e) = var(e) var(e1 bop e2 ) = var(e1 ) ∪ var(e2 )
S
var([e1 , . . . , en ]) = ni=1 var(ei )
var(e1 ..e2 ) = var(e1 ) ∪ var(e2 )

The syntax of processes P , input-guarded non-deterministic sequential processes N ,
and systems S is given in Figure 2. A process u n (~y).P requests a new session on a shared
name u and then behaves as P ; dually, process u p (~y).P accepts the request of a new session
from another process and then behaves as P . A message e is sent on a session channel y by
the process y e. Sequential composition
Xand conditional are standard. An input-guarded
non-deterministic sequential processes
yi (xi ).Pi (conventionally denoted as 0 when I = ∅)
i∈I

can branch over Pi when a message is received on the session channel yi ; we assume yi 6= yj
when i 6= j ∈ I. Our language for processes provide two different constructs for iterations
X
for x in ` do P
and
repeat N until
yi (xi ).Pi
i∈I

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:13

Intuitively, the former realises the controllers of iterative global types, while the latter is
used for the remaining roles (cf. Section 7). A for-loop iterates
X the body P on the list `.
The body N in a repeat-until-loop is a process of the form
yi (xi ).Pi and it is repeated
i∈I

until a message on one of the channels yi on the until guard is received.
We set the following precedence rules: if then else , for in do and repeat until
have the lowest precedence while . has precedence over ; so that, e.g., the term
if e then P else u i (~y).Q reads if e then P else (u i (~y).Q) and u i (~y).P ; Q reads (u i (~y).P ); Q.
Systems consist of a parallel composition of process together with the queues y[~v] that
store the values ~v sent over the session channels y. Given y1 , . . . , yh pairwise distinct session
channels, we write (y1 , . . . , yh )[~v1 , . . . ,~vh ] to denote y1 [~v1 ] | . . . | yh [~vh ]. Names ~y are bound
in (ν~y@u)S and related to the shared name u.
The definition of the set fn( ) of free names is standard but for shared names u which
are also decorated to keep track of roles; formally we define fn( ) on systems as
fn(y[~v]) = {y}

fn((ν~y@u)S) = fn(S) \ ~y

fn(S|S 0 ) = fn(S) ∪ fn(S 0 )

while for processes we have
fn(u n (~y).P ) = {u, u0 } ∪ fn(P ) \ ~y
fn(y e) = {y} ∪ var(e)

p
p
fn(u
X(~y).P ) = {u, uS} ∪ fn(P ) \ ~y
fn( yi (xi ).Pi ) = i∈I ({yi } ∪ fn(Pi ) \ {xi })
i∈I

fn(P ; Q) = fn(P ) ∪ fn(Q)
fn(if e then P else Q) = fn(P ) ∪ fn(Q) ∪ var(e)
fn(for x in ` do P ) = fn(P ) \ {x} ∪ fn(`) fn(repeat N until N 0 ) = fn(N ) ∪ fn(N 0 )
where, in the first equation, a process requesting a new session on u plays the role 0 and, in
the second equation, a process accepting on up plays role p.
The set fu(S) of free shared names of S is defined as fn(S) ∩ U. Similarly the set of
free session names fy(S) (resp. free variables fx(S)) of S is defined as fn(S) ∩ Y (resp.
fn(S) ∩ X). The set bn( ) of bound names is defined as
bn(u n (~y).P ) = ~y ∪ bn(P )
bn(y e) = ∅

p
bn(u
X(~y).P ) = ~y ∪ bn(P
[ )
bn( yi (xi ).Pi ) = ({xi } ∪ bn(Pi ))

bn(P ; Q) = bn(P ) ∪ bn(Q)
bn(for x in ` do P ) = {x} ∪ bn(P )

bn(if e then P else Q) = bn(P ) ∪ bn(Q)
bn(repeat N until N 0 ) = bn(N ) ∪ bn(N 0 )

bn(y[~v]) = ∅
bn(S|S 0 ) = bn(S) ∪ bn(S 0 )

bn((ν~y@u)S) = ~y ∪ bn(S)

i∈I

i∈I

The set by(S) of bound session names of S is defined as bn(S) ∩ Y and the set bx(S) of
bound variables of S is bn(S) ∩ X. Note that bn(S) ∩ U = ∅ for all S.
Figure 3 summarises the notation introduced so far for the syntax of processes.
As customary, we rely on a structural congruence relation ≡ defined as the least
congruence over systems closed with respect to α-conversion and the following axioms
(ν~y@u)(ν~y0 @u 0 )S ≡ (ν~y0 @u 0 )(ν~y@u)S
(ν~y@u)(S|S 0 ) ≡ S | (ν~y@u)S 0 , when ~y 6⊆ fy(S)

(ν~y@u)0 ≡ 0

and such that | and ; form monoids with identity 0 and the former is commutative.
The operational semantics of systems is given by the LTS inductively defined by the
rules in Figures 4 and 5 where

18:14

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

Sets
Set

Elements Description

X
V
U
Y
P
e
`

x, x1 , . . .
v, v1 , . . .
u, u1 , . . .
y, s, . . .
p, q, r, . . .
e, e1 , . . .
`, `1 , . . .

variables
basic values
shared names
session channels
participants
expressions
lists

Functions
Function

Description

var(e), var(`)
fn(P ), fn(S)
bn(P ), fn(S)
by(P ), by(S)
bx(P ), bx(S)

variables of a expression, a list
free names of a process, a system
bound names of a process, a system
bound session names of a process, a system
of bound variables of a process, a system

Figure 3: Summary of notation for processes
• a store σ records both the values assigned to variables and the session channels created by
a process,
• σ[x 7→ v] is the update of σ at x with v (and likewise for σ[y 7→ u]), and
• e ↓ σ is the evaluation of e (defined if var(e) ⊆ dom(σ) and undefined otherwise). We
assume that an expression e depends only on its variables, that is, for all stores σ and σ 0 :
σ|X = σ 0 |X =⇒ e ↓ σ = e ↓ σ 0
where ·| is the standard restriction of a function on a subset of its domain.
Labels are given by the following productions
α ::= u n (~y)

u p (~y)

yv

τ

yv

e`α

(4.1)

that respectively represent the request of initialisation of a session on u, the acceptance
of joining a session on u with role p, the sending of a value on y, the reception of a value
on y, the silent step τ , and conditional actions e ` α where e is a boolean expression. A
e`α
conditional action labelling a transition hS, σi −−→ hS 0 , σ 0 i denotes that hS, σi performs the
action α and moves to hS 0 , σ 0 i because e ↓ σ holds. We may write α instead of true ` α
and e ∧ e0 ` α instead of e ` (e0 ` α).
Functions fy( ) and bn( ) extend to labels as follows:
fy(u n (~y)) = fy(u p (~y)) = {u}

fy(yv) = fy(yv) = {y}

bn(u p (~y)) = bn(u p (~y)) = ~y

bn(yv) = bn(yv) = bn(τ ) = ∅

fy(τ ) = ∅

fy(e ` α) = fy(α)
bn(e ` α) = bn(α)

We comment on the rules in Figure 4 and 5. In Figure 4, rules [SReq] and [SAcc] deal
with the initialisation of new sessions; the store is updated to keep track of the fresh session
channels ~y used in the choreography u (implicitly α-converting ~y when ~y ∈ dom(σ)). Rule
[SSend] is for sending values. Rule [SRcv] is for receiving messages in an early style approach

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

[SReq]

[SAcc]

18:15

[SSend]

~y 6∈ dom(σ)

~y 6∈ dom(σ)

e↓σ=v

u p (~y)

u n (~y)

hu n (~y).P , σi −−−→ hP, σ[~y 7→ u]i

yv

hu p (~y).P , σi −−−→ hP, σ[~y 7→ u]i

hy e, σi −→ h0, σi

[SSeq]

[SRcv]

e`α

hP, σi −−→ hP 0 , σ 0 i

X
yj v
h yi (xi ).Pi , σi −−→ hPj , σ[xj 7→ v]i j ∈ I

e`α

hP ; Q, σi −−→ hP 0 ; Q, σ 0 i

i∈I

[SThen]

[SElse]
e0 `α

0

e0 `α

0

e ↓ σ = false hQ, σi −−−→ hQ0 , σ 0 i

e ↓ σ = true hP, σi −−−→ hP , σ i
e∧e0 `α

¬e∧e0 `α

hif e then P else Q, σi −−−−→ hP 0 , σ 0 i

hif e then P else Q, σi −−−−−→ hQ0 , σ 0 i

[SFor]

[SForEnd]
e`α

` ↓ σ 6= ε

0

`↓σ=ε

0

hP, σ[x 7→ hd(` ↓ σ)]i −−→ hP , σ i

τ

e`α

hfor x in ` do P , σi −
→ h0, σi

hfor x in ` do P , σi −−→ hP 0 ; for x in tl(`) do P , σ 0 i
[SLoop]
e`α

hN, σi −−→ hP, σ 0 i M =

X

[SLoopEnd]

yi (xi ).Pi

∀i ∈ I.yi 6∈ fy(α)

e`α

hM, σi −−→ hP, σ 0 i

i∈I
e`α

e`α

hrepeat N until M , σi −−→ hP, σ 0 i

hrepeat N until M , σi −−→ hP ; repeat N until M , σ 0 i

Figure 4: Labelled transitions for processes
[SInit]
τ
hu n (~y).P0 |u 1 (~y).P1 | . . . |u n (~y).Pn , σi −
→ h(ν~y@u)(P0 | . . . |Pn |~y : ∅), σ[~y 7→ u]i
[SCom1 ]

~y 6∈ dom(σ)

[SCom2 ]
e`yv

e`yv

hP, σi −−−→ hP 0 , σ 0 i

hP, σi −−−→ hP 0 , σ 0 i

e`τ

e`τ

hP | y[~v], σi −−→ hP 0 | y[~v · v], σ 0 i

hP | y[v · ~v], σi −−→ hP 0 | y[~v], σ 0 i

[SPar]
e`α

hS1 , σi −−→ hS10 , σ 0 i

bn(α) ∩ dom(σ) = ∅

fx(S2 ) ∩ (dom(σ 0 ) \ dom(σ)) = ∅

e`α

hS1 |S2 , σi −−→ hS10 |S2 , σ 0 i
[SNew]

[SStr]
e`α

hS, σi −−→ hS 0 , σ 0 i
e`α

~y ∩ fy(α) = ∅

h(ν~y@u)S, σi −−→ h(ν~y@u)S 0 , σ 0 i

S ≡ S1

e`α

hS1 , σi −−→ hS2 , σ 0 i

S2 ≡ S 0

e`α

hS, σi −−→ hS 0 , σ 0 i

Figure 5: Labelled transitions for systems
(variables are assigned when firing an input prefix); the store is updated by recording that v
is is assigned to x. Rule [SSeq] is for sequential composition. Rules [SThen] and [SElse] handle
conditional statements as expected; their only peculiarity is that the guard is recorded on
the label of the transition, which is instrumental for establishing the correspondence between

18:16

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

systems and their types (cf. Section 8). Rules [SFor], [SForEnd], [SLoop], and [SLoopEnd] unfold
the corresponding iterative process as expected.
We now comment on the rules in Figure 5. Rule [SInit] synchronises n roles with the
process u n (~y0 ).P0 initialising the session; this creates a new session with (initially empty)
queues on fresh session names ~y. These queues are used to exchange values as prescribed by
rules [SCom1 ] and [SCom2 ]. Communication actions of processes become silent at system level
capturing the fact that each action is performed over a session queue. Rule [SPar] stands
for those transitions involving just some of the components in a system. By the condition
bn(α) ∩ dom(σ) = ∅ in the premiss of [SPar], α should contain fresh session names when it
corresponds to the creation of a new session (i.e., it is either u n (~y) or u p (~y)). The rightmost
condition in the premiss of rule [SPar] ensures that each process has its own local (logical)
store (i.e., there is no confusion between bound variables of different processes). Rule [SNew]
is standard and allows an action α to be observed only if it does not involve restricted names.
Rule [SStr] is standard.
5. Processes of the POP2 Protocol
We now present an implementation for the role s of the global type GPOP introduced in
Section 3. To ease the presentation, we abstract away from the concrete representation of
folders and use the following auxiliary abstract operations:
auth : Str → Bool the authentication predicate,
msgs : Str → Int
maps a folder name into the number of messages in that folder,
len : Int → Int
maps a message index into the length of the message,
data : Int → Data maps a message index into its content,
next : Int → Int
maps a message index to the next index in the folder,
del : Int → Int
maps a message index to the next index in the folder after
deletion.
As specified for POP2 [6], the value inbox of sort Int denotes the default folder.
Process Init below gives an implementation of the role s in the protocol POP2 described
in Section 3.
Init , u s (~y).Srv

(5.1)

Init starts by joining a session on the shared channel u; it plays role s over the session
channels ~y = (quit, helo, bye, r, e, fold, read, retr, msg, acks, ackd, nack). Once the session is
initiated, the continuation Srv implements the local type Ts in Section 3.
Srv , quit.Exit + helo(c).Mbox (c)

where

Exit , bye

(5.2)

As specified by Ts , Srv waits for a message on either quit or helo. After receiving a message
on quit, it sends a message on bye and terminates, as defined by Exit. If the client sends
instead its credentials over channel helo, then the implementation follows with Mbox (c):
Mbox (c) , if (auth c) then r (msgs inbox); Nmbr else (e ; exit)

(5.3)

Mbox (c) resolves the non-deterministic choice in TMBOX = e .TEXIT ⊕ r Int.TNMBR with a conditional
statement that evaluates the credentials provided by the client. When they are valid, the
implementation sends the number of messages in the default folder inbox over r and proceeds
as Nmbr below. On the contrary, the process closes the session after sending messages over
e and bye.

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:17

Process Nmbr implements the iterative behaviour defined by the local type TNMBR :
Nmbr , repeat fold(f ).r (msgs f ) + read(m).r (len m); Size(m) until quit.Exit

(5.4)

Since s is not the iteration-controller, its implementation uses a repeat-until-loop in which a
client can repeatedly ask for the length of a folder (by using fold) or retrieve messages (by
using read) until it terminates the interaction by sending a message over quit.
Processes Size(m) and Xfer (m) are the implementations of the local types TSize and
TXfer :
Size(m) , repeat retr.msg (data m); Xfer (m) + read(m).r (len m) until fold(f ).r (msgs f )
Xfer (m) , acks.r (len (next m)) + ackd.r (len (del m)) + nack.r (len m)
Let G0POP be the multiparty variant of POP2 introduced in Example 3.1. The process
Init 0 below is a possible implementation of s in G0POP (i.e., T0s ).
Init 0 , u s (~y).Srv 0

(5.5)

Srv 0 , quit.Exit + helo(c).Auth(c)
Auth(c) , req c; res(a).Mbox 0
Mbox 0 (c, a) , if (auth c) ∧ a then r (msgs inbox); Nmbr else e .Exit
Init 0 is analogous to Init in (5.1); we remark that ~y now includes also the session channels req
and res used for interacting with the authorisation authority. After receiving the credentials
of the client on session channel helo, the server interacts with the authorisation authority
as defined in Auth(c): it forwards the credentials over session channel req and awaits for
the authorisation outcome a on session channel res. Finally, Mbox 0 (c, a) resolves the nondeterministic choice in TMbox by taking into account both the authorisation outcome a and
the client’s credentials c. In this variant, a client can access the inbox only if the credentials
satisfy both the local authentication function and the external authentication service.
6. Whole-Spectrum Implementation
In this section we formally characterise the whole-spectrum implementations of a role in a
global type. We start by introducing the notion of (candidate) implementation of a global
type, that is, a system in which each role of the global type is implemented by a process.
The following definition syntactically characterises the processes that can play a specific role
p in the implementation of a global type, i.e., those processes that are able to open a session
to play role p.
Definition 6.1 (Unique role). A process P uniquely plays role p in u if either of the
following cases holds
• P = u n (~y).Q, u 6∈ fn(Q), and p = 0
• P =X
u p (~y).Q and u 6∈ fn(Q)
• P =
yi (xi ).Qi and Qi uniquely plays role p in u for each i ∈ I
i∈I

• P = if e then Q1 else Q2 and both Q1 and Q2 uniquely play role p in u
• P = Q1 ; Q2 and either Q1 uniquely plays role p in u and u 6∈ fn(Q2 ) or Q2 uniquely plays
role p in u and u 6∈ fn(Q1 )

18:18

L. Bocchi, H. Melgratti, and E. Tuosto

Vol. 16:3

• P = repeat Q1 until Q2 and Q2 uniquely plays role p in u and u 6∈ fn(Q1 ).
For technical simplicity, we require a process playing role p in u to open just one session
over the shared channel u (note the restriction u 6∈ fn(Q) in the first two items of the
definition); a process playing different roles in several instances of the same global type can
be handled by using different shared names associated to the same global type. For branches
and conditional forms we require the process to play role p in u regardless of the chosen
branch (e.g., in every continuation Qj of a branching process). The case for sequential
composition is straightforward. We remark that y e does not play a role in a shared name
because it cannot open any session over any shared name. We also exclude processes like
for x in ` do Q, which could potentially open several sessions of a global type (once in any
iteration of the loop). The condition for repeat Q1 until Q2 is analogous when requiring
u 6∈ fn(Q1 ).
To introduce the notion of implementations of a global type it is convenient to use
contexts, that is terms derived from the following productions:
C[ ] ::=

C[ ]|S

S|C[ ]

(ν~y@u)C[ ]

Definition 6.2 (Implementation). Let ι be a mapping assigning a process to each p ∈
{p0 , . . . , pn } ⊆ P, P = ι(p0 ) | . . . | ι(pn ), ~y a tuple of pairwise disjoint session channels in
Y, and u ∈ U. A system ι~y@u is an ι-implementation of ~y at u for {p0 , . . . , pn } if there is a
context C[ ] = (ν~y1 @u1 ) · · · (~yh @uh )( | S) such that

S
yi = ∅
(1) u 6∈ {u1 , . . . uh }, ({u} ∪ ~y) ∩ fn(S) = ∅, and ~y ∩
i=1,...,h ~
(2) if ι~y@u ≡ C[P ] then, for all 0 ≤ j ≤ n, ι(pj ) uniquely plays role pj in u
(3) if ι~y@u ≡ C[(ν~y@u)(P ) | ~y[~v1 , . . . ,~vk ]] for some ~v1 , . . . ,~vk then u 6∈ fn(P ).
Given a global type G(~y), an ι-implementation of G(~y) at u is an ι-implementation at u for
P(G).
Intuitively, a system ι~y@u is an implementation of G(~y) if ι~y@u is built-up from processes that
implement all the roles in G(~y); the association between roles and processes is given by the
function ι. In addition, ι~y@u may contain other processes, possibly running different sessions.
Technically, we require ι~y@u to be written in terms of a context C[ ] = (ν~y1 @u1 ) · · · (~yh @uh )( |
S), which describes the part of the
S systemthat does not directly implement G(~y). The
conditions u 6∈ {u1 , . . . uh }, ~y ∩
yi = ∅, and ({u} ∪ ~y) ∩ fn(S) = ∅ ensure that
i=1,...,h ~
the context does not interfere with the names used for implementing G(~y). Then, an
implementation has two different shapes depending on whether the session for G(~y) has
been initiated or not. Condition (2) stipulates that, before starting the session, each process
ι(p) uniquely plays the role p in u (i.e., ι(p) is able to open a session on u for the role p).
Condition (3) characterises the case in which the session has been initiated, and therefore
the system contains the message queues for the initiated session.
Example 6.3. Consider the global type GPOP in Section 3 and take ι~y@u = ι(s) | ι(c) where
ι is such that ι(s) = Init and ι(c) = C with Init the process in (5.1) (cf. page 16) and
C , u 1 (~y).quit ;bye. It is easy to check that Init uniquely plays s in u while C uniquely plays
c (after assuming that c is 0). Hence, it is straightforward that ι~y@u is a ι-implementation
of G(~y) = GPOP at u (it is enough to consider the identity context C[ ] = ).

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:19

Consider now a more involved situation in which a process C 0 that implements c also
interacts with another process D over a different session, e.g.,
C 0 , u0 a (z).u 1 (~y).quit ;bye.C 00

D , u0 1 (z).D 0

In this case, ι0 is such that ι0 (s) = Init and ι0 (c) = C 0 . Then, ι0~y@u = Init | C | D is an
ι0 -implementation of G(~y) at u (it suffices to consider the context C[ ] = | D). Note that
τ

ι0~y@u −
→ (νz@u0 )(Init | C 000 | D 0 | ~z[]) = ι00~y@u
with C 000 , u 1 (~y).quit ;bye.C 00 and ι00 = ι0 [c 7→ C 000 ]. Then, we can conclude that ι00~y@u is
an ι00 -implementation of G(~y) at u by considering the context C[ ] = (νz@u0 )( | D 0 | ~z[]).
Consider now the transition
τ

ι00~y@u −
→ (νz@u0 )((ν~y@u)(Srv | C 0000 | ~y[[] . . . []]) | D 0 | z[]) = ι000~y@u
where ι000 (s) = Srv and ι000 (c) = C 0000 . In this case ι000~y@u is an ι000 -implementation of G(~y) at
u; the sub-term (ν~y@u)(Srv | C 0000 | ~y[[] . . . []]) stands for the session corresponding to the
global type G(~y), while the context represents the rest of the system.

We characterise WSI as a relation between the execution traces of a global type G and
its implementations ι~y@u . An execution trace of a system ι~y@u is a sequence of events of
the form hp, y di and hp, y di, which respectively represent an output and an input action
performed by p over the channel y.
Definition 6.4 (Runs of implementations). Let ι~y@u be an ι-implementation of G(~y). The
set of runs of ι~y@u initiated on u with store σ, written Rhι~y@u , σi, is the set inductively
defined by the rules in Figure 6. We write Rι~y@u for Rhι~y@u , ∅i and extend the notion to
sets of implementations I as RI = ∪I∈I RI.
Rules in Figure 6 rely on the semantics of Figure 4 and Figure 5. Rule [REnd] establishes
that a completed session, i.e., one in which all processes are terminated and the session
queues are empty, contains the empty run . Non-empty runs of ι~y@u are defined in terms
of the input and output actions that processes ι(p) perform over the session channels ~y, as
described by the rules [RSnd] and [RRcv]. In rule [RSnd], ι(p) performs an output over a session
e`yv

channel associated with u; which is formally captured by the conditions hι(p), σi −−−→ hP, σi
and y ∈ ~y in the premiss. When ι(p) evolves to P by performing yv, ι~y@u evolves to ι0~y@u
with ι0 = ι[p 7→ P ], i.e., ι0 coincides with ι in all roles but p. This is stated by the condition
e0 `τ

hι~y@u , σi −−−→ hι[p 7→ P ]~y@u , σi in the premiss of the rule. Hence, ι~y@u contains a run hp, ydir
(see the conclusion of the rule) when r is a run of the state hι[p 7→ P ]~y@u , σ 0 i reached after
ι(p) performs yv. We remark that runs abstract away from the particular values sent by the
processes and keep instead the sorts of sent value (i.e., condition v : d). Input events are
handled analogously in rule [RRcv]; in this case also σ evolves to σ 0 when ι(p) performs an
input.
Rule [RExt1 ] accounts for the computation steps of ι(p) that do not involve session
channels in ~y (condition n(α) ∩ ~y = ∅), which can be an internal transition τ in a role, a
communication over a channel not in ~y, or a session initiation. This rule allows each process
to freely initiate a session that does not correspond to the global type G, i.e., over a shared
name different from u (condition u 6∈ fn(β)). Rule [RExt2 ] handles the cases in which the
transition of ι~y@u does not involve any process ι(p). This is captured by the fact that the
continuation ι0~y@u uses the same mapping ι. By the definition of ι~y@u , the reduction does
not interfere with the names of the session, i.e., fn(β) ∩ (~y ∪ {u}) holds.

18:20

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

[REnd]

∀p ∈ P(G) : ι(p) = 0

∀y ∈ ~y : queue on y is empty in ι~y@u
 ∈ Rhι~y@u , σi

[RSnd]
e`yv

hι(p), σi −−−→ hP, σi

y ∈ ~y

` v: d

e`τ

hι~y@u , σi −−→ hι[p 7→ P ]~y@u , σi

r ∈ Rhι[p 7→ P ]~y@u , σi

hp, ydir ∈ Rhι~y@u , σi
[RRcv]
e`yv

hι(p), σi −−−→ hP, σ 0 i

y ∈ ~y

e`τ

` v: d
r ∈ Rhι[p 7→ P ]~y@u , σ 0 i

hι~y@u , σi −−→ hι[p 7→ P ]~y@u , σ 0 i
hp, ydir ∈ Rhι~y@u , σi
[RExt1 ]
e`α

hι(p), σi −−→ hP, σ 0 i

n(α) ∩ ~y = ∅

e0 `β

hι~y@u , σi −−−→ hι[p 7→ P ]~y@u , σ 0 i

r ∈ Rhι[p 7→ P ]~y@u , σ 0 i

u 6∈ fn(β)

r ∈ Rhι~y@u , σi
[RExt2 ]
e0 `β

hι~y@u , σi −−−→ h(ι~y@u )0 , σ 0 i

r ∈ Rh(ι~y@u )0 , σ 0 i

r ∈ Rhι~y@u , σi
[ROpen]
e0 `u n (~y)

ei `u i (~y)

hι(p0 ), σi −−−−−→ hP0 , σ0 i

∀1 ≤ i ≤ n : hι(pi ), σi −−−−−→ hPi , σi i

P(G(~y)) = {p0 , p1 , . . . , pn }

ι0 = ι[p0 7→ P0 ] . . . [pn 7→ Pn ]

e`τ

hι~y@u , σi −−→ hι0~y@u , σ[~y 7→ u]i

r ∈ Rhι0~y@u , σ[~y 7→ u]i

r ∈ Rhι~y@u , σi
Figure 6: Runs of implementations
Rule [ROpen] allows for the initiation of a new session on u and requires all roles to
participate in the synchronisation (as stated by the three first premisses). We assume that
any role in the implementation will execute exactly one action over the channel u which also
matches the role assigned by ι. Nested sessions are handled by assuming that all sessions are
created over different channels that have the same type. This is just a technical simplification
analogous to the possibility of having annotations to indicate the particular instance of the
session under analysis.
The runs of an implementation abstractly capture the traces of communications of the
processes in the system. This can be easily formalised by using a more concrete relation on
systems. More precisely, we define ,−
→ as the relation induced by the rules such as those in

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:21

[RGCom]
[RGEnd]

j∈I

r ∈ R(Gj )
P
hp, yj dj ihqj , yj dj ir ∈ R( i∈I p _ qi : yi di ; Gi )

 ∈ R(end)

[RG∗2 ]

[RG∗1 ]

[RGSeq]

r1 ∈ R(G1 ) r2 ∈ R(G2 )

r ∈ R(G)

r1 r2 ∈ R(G1 ; G2 )

e ∗ )
r ∈ R(G

e ∗f )
r1 ∈ R(G) r2 ∈ R(G

f

e ∗f )
r1 [r2 ] ∈ R(G

[RGIter]

e ∗f )
r ∈ R(G

rdy(G) = {p}

P(G) = {p, p1 , . . . , pn }

∀1 ≤ i ≤ n : f (pi ) = yi di

rhp, y1 d1 ihp1 , y1 d1 i . . . hp, yn dn ihpn , yn dn i

∈

f

R(G∗ )

Figure 7: Runs of a global type
Figure 4 once the τ in the conclusion of rules [SCom1 ] and [SCom2 ] is replaced with the output
and input action respectively. Then we can state the following proposition:
Theorem 6.5. Given an implementation ι~y@u and a store σ, if r ∈ Rhι~y@u , σi is a run of
α1

αn

length m then there is a sequence ι~y@u ,−→ hS1 , σ1 i · · · ,−→ hSn , σn i such that we can find an
order preserving bijection χ between the sets {1, . . . , m} and {1 ≤ j ≤ n αi not a τ } such
that the i-th element in r is an input of sort d iff so is the αχ(i) and the value in αχ(i) has
the sort d.
Proof. Straightforward induction on the derivation of r ∈ Rhι~y@u , σi.
We now introduce the notion of runs associated to a global type. Our notion of WSI
will allow us to implement an iterative type, which accounts for an unbounded number
of repetitions, with a process exhibiting a bounded number of iterations. For this reason,
we deviate from the previous definition of traces of global types [14, 10, 25, 24] and use
annotated traces to distinguish mandatory from optional events. Annotating optional events
is instrumental to the comparison of traces of iterative types (which is defined below).
Syntactically, an optional sequence r of events is written [r]. As usual, we consider an
asynchronous communication model and a trace implicitly denotes the equivalence class of
all traces obtained by permuting causally independent events, that is events executed by
different participants on different channels.
Definition 6.6 (Runs of a global type). Given a global type term G, the set R(G) denotes
the runs allowed by G and is defined as the least set closed under the rules in Figure 7.
The first three rules of Figure 7 are straightforward. The runs of an iterative type
e ∗f ) to unfold G∗f (as
are given by the rule [RGIter], whose premiss uses the set R(G
defined by the rules [RG∗1 ] and [RG∗2 ]). Optional events are introduced when unfolding an
f
iterative type (rule [RG∗2 ]). The main motivation is that an iterative type G∗ denotes
an unbounded number of repetitions of (traces of) G (i.e., an infinite number of traces).
e ∗f ) = {r1 , r1 [r2 ], r1 [r2 [r3 ]], . . .} with ri ∈ R(G). Rule [RGIter] adds the events
Note that R(G
associated to the termination of an iteration: (i) the ready role p sends the termination signal
to any other role by using the dedicated channels specified by f (i.e., hp, y1 d1 i, . . . , hp, yn dn i),
and (ii) all roles but the ready one receive the corresponding termination message (i.e.,
f
G∗

18:22

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

hp1 , y1 d1 i, . . . , hpn , yn dn i). We just consider one of the possible interleavings of termination
events because we consider traces up-to the permutation of causally independent events.
Definition 6.7 (Trace preorder). The trace preorder l is the least preorder on annotated
traces satisfying the following axioms and rules.
[ldrop]

[lemp]

−

−

[r] l 

lr

[lcmp]

r1 l r10

r2 l r20

r1 r2 l r10 r20

We say r0 covers r when r l r0 , i.e., when r0 matches all mandatory actions of r.
Analogously, we say a set R2 of annotated traces covers another set R1 , written R1 b R2 , if
for all r ∈ R1 there is r0 ∈ R2 such that r l r0 .
Definition 6.8 (Whole-spectrum implementation). A set I of implementations covers a
global type G(~y) , G if R(G) b RI. A process P is a whole-spectrum implementation of
p ∈ P(G) when there exists a set I of ι-implementations of G(~y) at u that covers G such that
ι~y@u ∈ I implies ι(p) = P .
A whole-spectrum implementation (WSI) of a role p is a process P such that any
expected behaviour of the global type can be obtained by putting P into a proper context.
For iteration types, the comparison of annotated traces implies that the implementation
has to be able to perform the iteration body at least once, but it can arbitrarily choose the
number of iterations.
Remark 6.9 (Trace semantics for WSI). WSI is based on a trace semantics. WSI implementations are deterministic programs, hence their behaviour if faithfully captured by the
set of their execution traces. A stronger notion like bisimulation is not necessary. In fact,
the branching specified in a global type becomes deterministic in a process, therefore the set
of all possible executions of a process (in a given implementation) results in a single trace.

7. Typing
In this section we introduce a typing discipline to guarantee that a well-typed process is a
WSI of the role it plays in a global type. Technically we rely on an enriched version of local
types, dubbed pseudo-types, that takes into account branching enabling conditions.
7.1. Pseudo-types & Typing judgements. The scaffolding of our typing discipline is
standard but for the need of making the typing depending on the expressions the processes
use to render choices. This requires to revisit the usual definition of mergeability (cf.
Definition 7.1 below) that now relies on a notion of normalisation of local types.
The syntax of pseudo-types is given by the following grammar:
X
M
T ::=
ei  yi di .Ti
ei  yi di .Ti
T1 ; T2
T?
e  end
i∈I

i∈I

We call guards the expressions ei occurring in a pseudo-type. Guards keep track of the
conditions that have to be satisfied in order to enable a certain behaviour. For instance, the
pseudo-type
M
T⊕ =
ei  yi int.end
i∈{1,2}

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

nf(e, e0  end)

(1)

18:23

= e ∧ e0  end

let J = {i ∈ I (e ∧ ei ) ⇐⇒ false} in the clauses (2) and (3) below


 end
false
M
M
(2)
nf(e,
ei  yi di .Ti ) =
e
i ∧ e  yi di .nf(ei ∧ e, Ti )


i∈I
i∈I\J


 end
false
X
X
(3)
nf(e,
ei  yi di .Ti ) =
ei ∧ e  yi di .nf(ei ∧ e, Ti )


i∈I

if I = J
if I =
6 J
if I = J
if I =
6 J

i∈I\J

(4)
(5)
(6)

0

T) = nf(e ∧M
e0 , T)
M nf(e, e  end;

nf(e,
ei  yi di .Ti ; T) = nf(e,
ei  yi di .(Ti ; T))
i∈I
i∈I
X
X

nf(e,
ei  yi di .Ti ; T) = nf(e,
ei  yi di .(Ti ; T))
i∈I

(7)
(8)
(9)

i∈I

nf(e, (T; T0 ); T00 )

= (
nf(e, T; (T0 ; T00 ))
e0  end
if nf(e, T) = e0  end
nf(e, T? ; T0 ) =
?
0
nf(e, T ); nf(e, T ) if nf(e, T) 6= e0  end
(
e0  end if nf(e, T) = e0  end
nf(e, T? ) =
nf(e, T)? if nf(e, T) 6= e0  end

Figure 8: Normalisation procedure for pseudo-types
where the guards are e1 = x > 0 and e2 = x ≤ 0. By e1 , x needs to be strictly positive in
order to choose the first branch. Local types from Section 2 can be thought of as pseudo-types
where all guards are true. Hereafter we may omit guards true and have e.g.,
M
M
true  end abbreviated as end
and
true  yi di .Ti abbreviated as
yi di .Ti
i∈I

i∈I

The notions of free and bound names straightforwardly extend to pseudo-types. We will
write var(T) for the set of variables occurring in the expressions of T and fy(T) for the set
of session channels in T; for instance, var(T⊕ ) = {x}.
Given a pseudo-type T, the normal form of T, written nf(T), is defined as nf(T) =
nf(true, T) where nf( , ) given by the equations in Figure 8. Intuitively, the normalisation
of a pseudo-type propagates the guards of branches to their continuations while removing
those alternatives with inconsistent guards. We just remark that nf(T) is defined for any T
(details are in Appendix A.1).
The notion of normalisation is instrumental to adapt the standard merge operation
./ of session types [10] to pseudo-types. Our definition of ./ requires the mergeability of
pseudo-types, which amounts to have branches with the same communication prefix guarded
by mutually exclusive conditions.
Definition 7.1 (Mergeable pseudo-types). Two pseudo-types T1 and T2 in normal form
are mergeable, if
• T1 = eX
 end and T2 = e0  end
X
• T1 =
ei  yi di .Ti , T2 =
e0i  yi di .T0i and for all i ∈ I, Ti and T0i are mergeable,
i∈I

and ei ∧ e0i ⇐⇒ false

i∈I

18:24

• T1 =

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

M
i∈I∪J

ei  yi di .Ti and T2 =

M
i∈I∪K

e0i  yi di .T0i with I ∩ J = I ∩ K = ∅ and sets

{yi }i∈I , {yj }j∈J , and {yk }k∈K pairwise disjoint, and for all i ∈ I, Ti and T0i are mergeable,
and ei ∧ e0i ⇐⇒ false
• T1 = T01 ; T001 , T2 = T02 ; T002 , and T01 and T02 as well as T001 and T002 mergeable
• T1 = (T01 )? , T2 = (T02 )? with T01 and T02 mergeable.
Basically, T1 and T2 are mergeable when they have the same structure and at choice points
branches either use different channels or they use mutually exclusive guards. When types
are mergeable, operation ./ “glues” branches that use the same channel.
Definition 7.2 (Merge). The merge
defined as:

e ∨ e0  end



X



ei ∨ e0i  yi di .T0i ./T0i




 i∈I
M
T1 ./T2 =
ei  yi di .Ti



i∈I∪J




(T01 ./T02 ); (T001 ./T002 )




(T0 ./T0 )?
1

T1 ./T2 of two mergeable pseudo-types T1 and T2 is

2

if T1 = e  end and T2 = e0  end
X
X
if T1 =
ei  yi di .Ti and T2 =
e0i  yi di .T0i
i∈I
i∈I
M
M
if T1 =
ei  yi di .Ti and T2 =
ej  yj dj .Tj
if T1 =

i∈I
T01 ; T001

j∈J

and T2 =

T02 ; T002

if T1 = (T01 )? and T2 = (T02 )?

As we will see, our typing discipline keeps track of the assumptions (i.e., the guards)
necessary to reach a particular point in the processes. In fact, systems are typed by
judgements of the form
e

Γ ` S . ∆

(7.1)

stipulating that, under the assumption e and the type assignment of variables Γ, the system
S is typed as ∆. In (7.1), Γ and ∆ are (possibly empty) partial functions. We adopt the
usual syntactic notation for environments:
Γ ::= ∅

Γ, x : d

∆ ::= ∅

∆, u : G

∆, (~y,p) : T

∆, y : [d]

Environments Γ assign sorts d to variables x. Environments ∆, called specifications, map
(i) shared names u to global types G, (ii) participants’ sessions (~y,p) to pseudo-types T,
and (iii) session names y to queues of sorts d. As usual, we implicitly assume that in a
judgement of the form (7.1) the following holds:
• x 6∈ dom(Γ) when writing Γ, x : d, and
• u 6∈ dom(∆) when writing ∆, u : G (likewise for participants’ sessions and for sessions’
queues).
For judgements of the form (7.1) we also assume that
• fx(e) ⊆ dom(Γ) and fn(S) ⊆ dom(∆), and
• in ∆, (~y,p) : T it is fy(T) ⊆ ~y and
∀(y~1 ,p1 ), (y~2 ,p2 ) ∈ dom(∆),~y1 ∩ ~y2 6= ∅ =⇒ ~y1 = ~y2

(7.2)

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:25

Predicates
Notation

Arity Description

∆ end-only
∆ active
∆1 and ∆2 passively compatible
∆1 and ∆2 independent

1
1
2
2

every session in ∆ is terminated
every session in ∆ is an internal guarded-choice
∆1 and ∆2 agree on the termination of an iteration
disjoint sessions and agreement on shared names

Operations
Notation

Arity Description

∆1 ; ∆2
∆1 ∪ ∆2
∆?
∆|−~y

2
2
1
2

sequential composition
union
closure
restriction of ∆ to names not in ~y

Figure 9: Summary of operations and predicates for environments
Condition (7.2) states that a session channel can be used only in one session. We sometimes
write ~y ∈ dom(∆) when there exists p such that (~y,p) ∈ dom(∆). Similarly, y ∈ dom(∆)
stands for ∃~y ∈ dom(∆) : y ∈ ~y. The extension of var( ) and fy( ) to environments is
straightforward.
Our typing relies on an operation
 that recovers types from pseudo-types by removing
guards. Formally, guard removal a · is defined as





?
a e  end = end
a T; T0 = a T ; a T0
a T? = a T
X
X


a
ei  yi di .Ti =
yα dα .a ./i∈α Ti
a

i∈I
M
i∈I

α∈I/∼
M


ei  yi di .Ti =
yα dα .a ./i∈α Ti
α∈I/∼

where in the last two equations ∼ is the equivalence relation on I defined as i ∼ j ⇐⇒ yi = yj
and yα dα = yi di for i ∈ α. Other auxiliary operations and predicates on environments are
listed in Figure 9 and formally defined in the following section.
7.2. Typing rules. The typing rules for processes and systems are grouped in Figure 10
and Figure 11. For the sake of readability, we restate the typing rules as we comment them
so to introduce notation and concepts appearing in the rules as we present them.
To type a request for a new session u n (~y).P we use the following rule
[VReq]

∆(u) ≡ G(~y)

e

Γ ` P . ∆, (~y,0) : T


a nf(T) = nf(G(~y) 0)

e Γ ` u n (~y).P . ∆
The premiss checks that the continuation P can be typed with ∆ extended with an assignment
of the pseudo-type T to the participant’s session (~y,p), for some T matching the projection of
the global type ∆(u) on the corresponding role. Intuitively, the type obtained by removing
guards from T coincides with the projection of the global type.

18:26

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

The rule [VAcc] for typing the acceptance for the p-th role u p (~y).P is defined analogously.
An external choice is checked by
[VRcv]

∀i ∈ I : yi ∈ ~y
e Γ, xi : di ` Pi . ∆, (~y,p) : Ti
X
X
e Γ `
yi (xi ).Pi . ∆, (~y,p) :
e  yi di .Ti
i∈I

i∈I

that types each branch Pi against the respective continuation of the type (~y,p) : Ti (once
Γ is extended with the type assignment on the bound name xi ); the first condition in the
premiss permits to branch only over a subset of the session channels.
An output y e0 and the idle process are respectively typed as follows
[VSend]

[VEnd]

Γ ` e0 : d
e

y ∈ ~y

∆ end-only

∆ end-only

Γ ` y e0 . ∆, (~y,p) : e  y d; e  end

e

Γ ` 0 . ∆

e0

The expression
in [VSend] has to be of the sort expected on channel y; moreover, no
further actions should occur on session channels (rendered with the condition ∆ end-only
abbreviating ∀(y~0 ,q) ∈ dom(∆) : nf(∆(y~0 ,q)) = e  end); for the idle process we simply
require ∆ to map each session channel to the end type.
The typing of sequential compositions is handled by the rule
[VSeq]

e

Γ ` P1 . ∆1

e

Γ ` P2 . ∆2

e Γ ` P1 ; P2 . ∆1 ; ∆2
that requires to decompose the specification into ∆1 and ∆2 to respectively type each part
of the sequential composition. In the conclusion of the rule, the partial operation ; on
specifications requires that dom(∆2 ) ⊆ dom(∆1 ) and ∆1 |U∪Y = ∆2 |U∪Y and it is defined
as follows
(∆1 ; ∆2 )|U∪Y = ∆
1 |U∪Y

∆1 (~y,p); ∆2 (~y,p) (~y,p) ∈ dom(∆2 )
(∆1 ; ∆2 )(~y,p) =
∆1 (~y,p)
(~y,p) ∈ dom(∆1 ) \ dom(∆2 )


undef
otherwise
The notion of mergeable pseudo-types is extended to specification pairs in order to
type conditionals. Specifications ∆1 and ∆2 are mergeable when the local types they assign
to sessions are mergeable. Formally, ∆1 and ∆2 are mergeable iff ∆1 |U∪Y = ∆2 |U∪Y ,
dom(∆1 ) = dom(∆2 ) and, for all (~y,p) ∈ dom(∆1 ), ∆1 (~y,p) and ∆2 (~y,p) are mergeable.
When ∆1 and ∆2 are mergeable, ∆1 ./∆2 merges the local types of sessions:
(∆1 ./∆2 )|U∪Y = ∆1 |U∪Y

and

(∆1 ./∆2 )(~y,p) = ∆1 (~y,p)./∆2 (~y,p)

We remark that the merge operation on specifications is idempotent, associative, and
commutative. For conditionals we have
[Vif]

e ∧ e0

Γ ` P1 . ∆1
e

e ∧ ¬e0

Γ ` P2 . ∆2

Γ ` if e0 then P1 else P2 . ∆1 ./∆2

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:27

that requires to decompose the specification into two specifications ∆1 and ∆2 so to type
conditional processes with the merge (cf. Definition 7.2) of ∆1 and ∆2 . The premiss checks
that the then-branch is typed in ∆1 after extending the assumption e with the guard e0 of
the conditional while the else-branch is typed in ∆2 after extending e with the negation of
e0 . Recall that judgements require consistency of their assumptions, hence rule [Vif] is not
applicable if e ∧ e0 or e ∧ ¬e0 are inconsistent.
Example 7.3. Our typing distinguishes between B1 and B2 in Section 1 because B1 is
validated while B2 is not. This is due to the rule [VIf]. In fact, after a few verification steps
on B1 we can apply rule [VIf] and prove the following judgement:
true

Γ ` if (check c) then ok else ko . ∆

where Γ assigns some sort to c and ∆ = ((login, deposit, overdraft, ok, ko), b) : ok ⊕ ko .
Instead, for B2 we would have to prove
true

Γ ` ko . ∆

which makes the validation of B2 fail; this is due to the fact that the only rule for typing a
sending process is [VSend], which cannot be applied against the specification ∆ that assigns
ok ⊕ ko to the participant’s session.

For-loops are typed with the following two rules
[VForEnd]

e ∧ ` = ε 6` ⊥
e

Γ ` ` : [d]

∆ end-only

Γ ` for x in ` do P . ∆

[VFor]

e ∧ ` 6= ε 6` ⊥

Γ ` ` : [d] e

Γ, x : d ` P . ∆

∆ active x 6∈ var(∆)

∆?

e Γ ` for x in ` do P .
Rule [VForEnd] handles the case in which the expression ` denotes an empty list, that is
when the for-loop should be skipped. For this reason, the typing is similar to the typing of
the idle process (rule [VEnd]). When the expression ` denotes a non-empty list under the
assumption e (i.e., Γ ` ` : [d] and e ∧ ` 6= ε 6` ⊥), we apply rule [VFor] to validate for-loops.
The conclusion of the rule types the for-loop with ∆? which introduces iterative pseudo-types
and is defined as follows:
∆? |U∪Y = ∆|U∪Y

and

∆? (~y,p) = (∆(~y,p))?

Note that ∆ has to type the body P under the context Γ extended with x : d because
x can occur free in P . Moreover, P has to inform all other peers that the iteration
continues. This
Mis checked by the condition ∆ active, namely that for all (~y,p) ∈ dom(∆),
nf(∆(~y,p)) =
ei  yi di .Ti . Condition x 6∈ var(∆) ensures that guards of P do not depend
i∈I

on the iteration variable x, making each choice available at each iteration.
Rule [VLoop] below types passive processes of iterations.
[VLoop]

e

Γ ` N . ∆1

e
e

Γ ` M . ∆2

∆1 and ∆2 passively compatible

Γ ` repeat N until M . ∆?1 ; ∆2

18:28

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

The premiss of the rule types the iteration body N and the loop exit M with specifications
∆1 and ∆2 respectively. Both specifications are required to be passively compatible, i.e.,
there is just one session that decides whether to continue or terminate the iteration, and use
different channels to communicate such choice. Formally, specifications ∆1 = ∆, (~y,p) : T
and ∆2 = ∆, (~y,p) : T0 are passively compatible iff
X
X
dom(∆) ⊆ U ∪ Y,
T=
ei  yi di .Ti
and
T0 =
ej  yj dj .Tj
i∈I

j∈J

with yi 6= yj for all i ∈ I, j ∈ J.
We now consider the typing rules for systems in Figure 11, which essentially deal with
parallel composition, restriction of shared names, and queues. For parallel composition
[VPar]

e1

Γ ` S1 . ∆1

Γ ` S2 . ∆2

e2

∆1 and ∆2 independent

e1 ∧ e2 Γ ` S1 |S2 . ∆1 ∪ ∆2
requires to split the specification into two independent specifications ∆1 and ∆2 that
respectively type each side of the parallel. Specifications are independent when they agree
on shared names and are disjoint on queues and participants’ sessions; more precisely, ∆1
and ∆2 are independent when
• ∆1 |U = ∆2 |U and dom(∆1 |Y ) ∩ dom(∆2 |Y ) = ∅
• for all (~y,p) ∈ dom(∆1 ) and (y~0 ,p0 ) ∈ dom(∆2 ), if ~y ∩ ~y0 6= ∅ then ~y = ~y0 and p 6= p0
The union of independent specifications enjoys the sanity condition (7.2).
A restricted session is typed by
[VNew]

e
e

Γ ` S . ∆

Γ ` (ν~y@u)S . ∆|−~y

that removes participants’ sessions and sessions’ queues referring to the restricted names ~y
from the specification ∆ typing the scope S (this restricted specification is denoted as ∆|−~y ).
The typing of queues is straightforwardly handled by the following two rules
[VQueue]
[VEmpty]
Γ ` y[~v] . y : [~d]
e Γ ` y : [] . y : []
e Γ ` y[~v · v] . y : [~d · d]
where · denotes the concatenation operation on sequences and [VEmpty] permits to type
empty queues.

` v: d

e

7.3. Typing the POP2 Protocol. We now apply our type system to the implementations
of our running example. We start by considering the process Init in 5.1 (page 16) and the
specification ∆ = u : GPOP with GPOP from Section 3. We recall that its projection on s is
Ts = GPOP  s (also from 3). Then, the typing judgement for Init is obtained by using rule
[VAcc] as follows

∆(u) ≡ GPOP

true
true

..
.
∅ ` Srv . ∆, (~y,s) : Ts
∅ ` u s (~y).Srv . ∆


a Ts = Ts

[VAcc]

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:29

[VReq]

∆(u) ≡ G(~y)

e

Γ ` P . ∆, (~y,0) : T
e


a nf(T) = nf(G(~y) 0)

Γ ` u n (~y).P . ∆

[VAcc]

∆(u) ≡ G(~y)

e

Γ ` P . ∆, (~y,p) : T
e


a nf(T) = nf(G(~y) p)

Γ ` u p (~y).P . ∆

[VRcv]

∀i ∈ I : yi ∈ ~y
e Γ, xi : di ` Pi . ∆, (~y,p) : Ti
X
X
e Γ `
yi (xi ).Pi . ∆, (~y,p) :
e  yi di .Ti
i∈I

i∈I

[VSend]

[VEnd]

Γ ` e0 : d
e

y ∈ ~y

∆ end-only

∆ end-only

Γ ` y e0 . ∆, (~y,p) : e  y d; e  end

e

Γ ` 0 . ∆

[VSeq]

e

Γ ` P1 . ∆1
e

e

Γ ` P2 . ∆2

Γ ` P1 ; P2 . ∆1 ; ∆2

[VIf]

e ∧ e0

e ∧ ¬e0

Γ ` P1 . ∆1

Γ ` P2 . ∆2

Γ ` if e0 then P1 else P2 . ∆1 ./∆2

e
[VForEnd]

e ∧ ` = ε 6` ⊥
e

Γ ` ` : [d]

∆ end-only

Γ ` for x in ` do P . ∆

[VFor]

e ∧ ` 6= ε 6` ⊥

Γ ` ` : [d] e

Γ, x : d ` P . ∆

e

Γ ` for x in ` do P . ∆?

e

Γ ` M . ∆2

∆ active x 6∈ var(∆)

[VLoop]

e

Γ ` N . ∆1
e

∆1 and ∆2 passively compatible

Γ ` repeat N until M . ∆?1 ; ∆2

Figure 10: Typing rules for processes
where the continuation Srv is typed against the specification
 ∆ extended with a new
participant’s session (~y,s) whose type Ts matches Ts , i.e., a Ts = Ts . Such Ts is obtained
from the judgement true ∅ ` Srv . ∆, (~y,s) : Ts . Since Srv , quit.Exit + helo(c).Mbox (c)

18:30

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

[VPar]

Γ ` S1 . ∆1

e1

e2
e1 ∧ e2

Γ ` S2 . ∆2

∆1 and ∆2 independent

Γ ` S1 |S2 . ∆1 ∪ ∆2

[VQueue]
[VEmpty]

Γ ` y[~v] . y : [~d]
Γ ` y[~v · v] . y : [~d · d]

` v: d
e

e

e

Γ ` y : [] . y : []

[VNew]

e

Γ ` S . ∆

Γ ` (ν~y@u)S . ∆|−~y

e

Figure 11: Typing rules for systems
is an input-guarded process, the judgement is obtained by applying rule [VRcv] as follows:
..
..
.
.
true ∅ ` Exit . ∆, (~y,s) : TEXIT
true c : Str ` Mbox (c) . ∆, (~y,s) : TMBOX
[VRcv]
true ∅ ` quit.Exit + helo(c).Mbox (c) . ∆, (~y,s) : Ts
(7.3)
where
Ts , true  quit .TEXIT + true  helo Str.TMBOX


with a TEXIT = TEXIT and a TMBOX = TMBOX so to satisfy a Ts = Ts . The first premiss in (7.3)
is derived as follows by taking TEXIT = true  bye .true  end (recall that Exit , bye and
bye is a shorthand for bye ()).


∅ ` () : Unit

bye ∈ ~y

(∆, (~y,s) : true  end) end-only

[VSend]

true ∅ ` bye () . ∆, (~y,s) : TEXIT
The second premiss in (7.3) follows by using rule [VIf] because Mbox (c) in (5.3) is a
conditional process (hereafter, we write e as shorthand for auth c).
e

..
.
c : Str ` r (mn inbox); Nmbr . ∆, (~y,s) : Tthen
¬e
true

..
.
c : Str ` e ; Exit . ∆, (~y,s) : Telse

c : Str ` Mbox (c) . ∆, (~y,s) : TMBOX

(7.4)
[VIf]

with TMBOX = Tthen ./ Telse . The second premiss above can be shown by using the rules [VSeq]
and [VSend] and by taking
Telse = ¬e  e ; ¬e  end; ¬e  bye ; ¬e  end

For the first premiss in (7.4) we use rule [Seq] as follows
e

..
..
.
.
c : Str ` r (mn inbox) . ∆, (~y,s) : Tthen
e c : Str ` Nmbr . ∆, (~y,s) : Tthen
[VSeq]
e c : Str ` r (mn inbox); Nmbr . ∆, (~y,s) : Tthen
(7.5)
1

2

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:31

with Tthen = Tthen ; Tthen . By applying [VSend], we conclude that Tthen = e  r Int; e  end. Since
Nmbr is a repeat-until loop, the second premiss in (7.5) is obtained by using rule [Vloop] (we
write Nmbrbody for the body of the iteration and Nmbruntil for the until guard).
1

2

1

..
.

..
.

c : Str ` Nmbrbody . ∆, (~y,s) : Tbody
e c : Str ` Nmbruntil . ∆, (~y,s) : Tuntil
[VLoop]
e c : Str ` Nmbr . ∆, (~y,s) : Tthen
with ∆, (~y,s) : Tbody and ∆, (~y,s) : Tuntil passively compatible and Tt hen2 = (Tbody )? ; Tuntil . By
following the same approach, it can be shown that both premisses are derivable by taking
e

2

Tbody = e  fold Str.e  r Int; e  end + e  read Int.e  r Int; TSIZE
Tuntil = e  quit .e  bye ; e  end

for a suitable TSIZE such that a TSIZE = TSIZE . It is straightforward to check that ∆, (~y,s) : Tbody
and ∆, (~y,s) : Tuntil are passively compatible because
the channels in Tbody are different from

the ones appearing in Tuntil . Moreover, a Tthen = a (Tbody )? ; Tuntil = TNmbr .
It remains to show that TMBOX = Tthen ./ Telse is well-defined. We first compute the normal
form of the pseudo types.
2

nf(Tthen ) = e  r Int; nf(Tthen )
nf(Telse ) = ¬e  e ; ¬e  bye ; ¬e  end
2

It is immediate to notice that nf(Tthen ) and nf(Telse ) are mergeable because they are internal
choices on disjoint set of session channels. Therefore,
TMBOX = Tthen ./ Telse = e  r Int; nf(Tthen ) ⊕ ¬e  e ; ¬e  bye ; ¬e  end

Finally, note that a TMBOX = TMBOX .
We now give the main types for the multiparty variant given in (5.5) (cf. page 17).
Assume ∆(u) ≡ G0POP from Section 3 and consider the following pseudo-type:
2

T0 s , true  quit .TEXIT + true  helo Str.TAUTH

TAUTH , true  req Str; true  res Bool.T0 MBOX

T0 MBOX , e ∧ a  r Int; T0 NMBR ⊕ ¬(e ∧ a)  e ; T0 EXIT


such that a T0s = T0s , TNMBR is as Tthen above except that all enabling conditions are (e ∧ a),
and T0 EXIT is as TEXIT except that all enabling conditions are ¬(e ∧ a). The typing judgement
true ∅ ` Init 0 . ∆, (~y,s) : T0 s can be obtained as in the previous case.
2

8. Properties of the Type System
In this section we show that a well-typed process (i) behaves as specified by the global type
(Theorem 8.4) and (ii) is a WSI of the role played in the global type (Theorem 8.8).

18:32

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

[TRcv]

[TReq]

j∈I


∆(u) ≡ G(~y) a T = nf(G(~y) 0)
u n (~y)

∆, (~y,p) :

∆ −−−→ ∆, (~y,0) : T

X
i∈I

y j dj

ei  yi di .Ti −−−→ ∆, (~y,p) : Tj

[TSend]

[TAcc]

j∈I


∆(u) ≡ G(~y) a T = nf(G(~y) p)
u p (~y)

∆, (~y,p) :

∆ −−−→ ∆, (~y,p) : T

i∈I

[TLoop0 ]

[TSeq]
α

∆2 −→ ∆02

α

∆?1 ; ∆2 −→ ∆02

yd

yd

y j dj

ei  yi di .Ti −−−→ ∆, (~y,p) : Tj

[TLoop1 ]

∆1 −
→ ∆01
∆1 ; ∆2 −
→ ∆01 ; ∆2

M

[TLoop2 ]
α

α

∆−
→ ∆0

∆−
→ ∆0

α

∆? −
→ ∆0 ; ∆?

∆? −
→ ∆0

α

[TInit]

∆(u) ≡ G(~y) , G

P(G) = {p0 , . . . , pn }


a Ti = nf(G pi ) ∀i ∈ {0, . . . , n}

τ

∆−
→ ∆, (~y,p0 ) : T0 , . . . , (~y,pn ) : Tn ,~y : []
[TCom1 ]

∆, (~y,p) :

M
i∈I

j∈I
τ
ei  yi di .Ti , yj : [~d] −
→ ∆, (~y,p) : Tj , yj : [~d · dj ]

[TCom2 ]

j∈I
∆, (~y,p) :

X
i∈I

τ
ei  yi di .Ti , yj : [dj · ~d] −
→ ∆, (~y,p) : Tj , yj : [~d]

Figure 12: Labelled transitions for specifications
8.1. Conformance. In order to show that any well-typed process adheres to the behaviour
defined by a global type, we relate the semantics of the process with the one of its specification
through a subject reduction result (Theorem 8.2). The operational semantics of specifications
is generated by the rules in Figure 12, where it is implicitly assumed that we work up-to
normal forms, namely the pseudo-types are normalised before and after transitions. Notice
that the labels are as in (4.1) on page 14 but for the fact that they cannot be conditional
actions e ` α. Intuitively, the rules in Figure 12, barred the last three, state how the
specification of a single participant behaves in a session ~y and are instrumental to establish
subject reduction.
Rules [TReq] and [TAcc] account for a specification that initiates a new session by projecting
(on 0 and p, resp.) the global type associated with the shared name u in dom(∆). Note
that T can use arbitrary guards in the projections G(~y) p as long as the normal form of
T matches the one of the projection. Rule [TRcv] accounts for the reception of a message.
Dually, rule [TSend] accounts for an endpoint that performs one of its outputs. Rule [TSeq]
relies on the definition of sequential composition of specifications (cf. page 26); observe that
the case in which all pseudo-types in ∆1 are of the form e  end is precluded because we
work up-to normal form of pseudo-types. Finally, an iterative local type can be skipped (rule
[TLoop0 ]), executed once (rule [TLoop1 ]), or be unfolded (rule [TLoop2 ]). The last three rules in
Figure 12 state how specifications of systems behave. Rule [TInit] initiates a new session ~y

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

[CEnd]

[CSeq]

e&σ

σ n T1

σ n e  end

18:33

[CLoop]

σ n T2

σnT
σ n T?

σ n T1 ; T2

[CSend]

[CRcv]

∃i ∈ I : ei &σ ∧ σ n Ti
M
σn
ei  yi di .Ti

∀i ∈ I : ei &σ ∧ σ n Ti
X
σn
ei  yi di .Ti

i∈I

i∈I

Figure 13: Consistency relation between stores and pseudo-types
by assigning each participant with a type that matches the corresponding projection of the
global type. Rules [TCom1 ] and [TCom2 ] establish how specifications send and receive messages
through queues.
The behaviour of processes depends on the stores they run on. Consequently, we compare
process and specifications with respect to stores; concretely, we only consider the behaviour
of processes running on stores that are consistent with the guards in the pseudo-types of
the specifications. The consistency predicate n relates stores with pseudo-types and
is inductively defined by the rules in Figure 13. Intuitively, σ n T holds if σ does not
falsify any guard in T; which is checked by rules [CEnd], [CSend] and [CRcv], where e&σ means
e ↓ σ = true or e ↓ σ undefined.
The notion of consistency is then extended to type judgments as follows.
Definition 8.1 (Consistency). A store σ is consistent with a judgement e
written σ n (e; Γ; S; ∆), if
(1) dom(∆|Y ) ∪ dom(Γ) ⊆ dom(σ)
(2) ∀x ∈ dom(Γ) : ` σ(x) : Γ(x)
(3) e ↓ σ = true
(4) ∀(~y,p) ∈ dom(∆) : σ n ∆(~y,p).

Γ ` S . ∆,

A store σ is consistent with a type judgement e Γ ` S . ∆ if σ contains an assignment
for any free name of S (Item 1); the values assigned to variables should match the type
assigned by the environment Γ (Item 2). Besides, the typing assumption e and the guards
in the pseudo-types in ∆ should hold when evaluated over σ (Item 3 and Item 4).
e0 `α

Theorem 8.2 (Subject reduction). If e Γ ` S . ∆, σ n (e; Γ; S; ∆), and hS, σi −−−→
hS 0 , σ 0 i then there exist Γ0 and ∆0 such that
yd

(1) if α = yv then ∆ −→ ∆0 for a sort d; moreover, if ` v : d then there is x ∈ X such that
e ∧ e0

Γ0 , x : d ` S 0 . ∆0 ,

σ 0 (x) = v,

and

σ 0 n (e ∧ e0 ; Γ0 , x : d; S 0 ; ∆0 )

yd

(2) if α = yv then ∆ −→ ∆0 with ` v : d, e ∧ e0 Γ0 ` S 0 . ∆0 , and σ 0 n (e ∧ e0 ; Γ0 ; S 0 ; ∆0 )
α
(3) otherwise ∆ −
→ ∆0 , and e ∧ e0 Γ0 ` S 0 . ∆0 , σ 0 n (e ∧ e0 ; Γ0 ; S 0 ; ∆0 ).
The typing rules in Section 7 ensure the semantic conformance of processes with the behaviour
prescribed by their types. Here, we define conformance in terms of conditional that simulation
relates states and specifications. Our definition is standard, except for input actions, for
which specifications have to simulate only inputs of messages with the expected type (i.e.,
systems are not responsible when receiving ill-typed messages).

18:34

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

α

τ ∗α

y

yv

Define =⇒ =−
→ −
→. Let ∆ =⇒ mean that there are ∆0 and v such that ∆ =⇒ ∆0 .
Definition 8.3 (Conditional simulation). A relation R between pairs state-specification is
e`α

a conditional simulation if for any (hS, σi, ∆) ∈ R, if hS, σi −−→ hS 0 , σ 0 i then
yd

(1) if α = yv then there exists ∆0 such that ∆ =⇒ ∆0 and if ` v : d then there exists x
such that σ 0 = σ[x 7→ v] and (hS 0 , σ 0 i, ∆0 ) ∈ R
α
(2) otherwise, ∆ =⇒ ∆0 and (hS 0 , σ 0 i, ∆0 ) ∈ R.
We write hS, σi - ∆ if there is a conditional simulation R such that (hS, σi, ∆) ∈ R.
By (1), only inputs of S with the expected type have to be matched by ∆ (recall rule [TRec]
in Figure 12), while it is no longer expected to conform to the specification after an ill-typed
input (i.e., not allowed by ∆).
Conformance follows by straightforward coinduction from Theorem 8.2.
Theorem 8.4 (Conformance). If e

Γ ` S . ∆ and σ n (e; Γ; S; ∆) then hS, σi - ∆.

Proof. Using Theorem 8.2 it is straightforward to show that
R = {(hS, σi, ∆) e

Γ ` S . ∆ and σ n (e; Γ; S; ∆)}

is a conditional simulation.
8.2. WSI by Typing. We show that well-typed processes are WSIs (Definition 6.8 on
page 22). First, we relate the runs of a global type with those of its corresponding specifications. Then, we state the correspondence between the runs of specifications and well-typed
implementations. A set of implementations covering a global type G can exhibit more
behaviour than the runs of G. Nonetheless, we use WSI with our subject reduction property
(cf. Definition 8.3 and Theorem 8.4) to characterise valid implementations.
Given a specification ∆ such that ∆(~y,p) is in normal form for all (~y,p) ∈ dom(∆), we
let R~y (∆), inductively defined by the rules in Figure 14, to be of the set of runs of session
~y generated by ∆. Rule [RTCom1 ] accounts for runs starting with output actions hp, yj dj i
performed by an endpoint (~y,p) and followed by a run r of the continuation. Rule [RTCom2 ]
analogously deals with inputs. Rules [RTIt1 ] and [RTIt2 ] unfold an iterative type; one iteration
is mandatory while the additional ones are optional. The remaining rules are self-explanatory.
Since all types in ∆ are in normal form (and therefore inconsistent guards may appear only
in sub terms e  end), the rules in Figure 14 do not generate runs with actions that cannot
be fired. The following two results establish the correspondence between the denotational
and operational semantics of specifications.
Lemma 8.5. Let ∆ be a specification such that for all (~y,p) ∈ dom(∆), ∆(~y,p) is in normal
τ
form. If ∆ −
→ ∆0 , then for all r ∈ R~y (∆0 ) either:
• r ∈ R~y (∆), or
• hp, ydir ∈ R~y (∆), or else
• hq, y dir ∈ R~y (∆).
Lemma 8.6. Let ∆ a specification such that for all (~y,p) ∈ dom(∆), ∆(~y,p) is in normal
τ
form. If r ∈ R~y (∆) and r 6=  then ∆ −
→ ∆0 and either
• r ∈ R~y (∆0 ), or
• r = hp, ydir0 and r0 ∈ R~y (∆0 ), or

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:35

[RTCom1 ]

r ∈ R~y (∆, (~y,p) : Tj , yj : [~d · dj ])
M
hp, yj dj ir ∈ R~y (∆, (~y,p) :
ei  yi di .Ti , yj : [~d])
j∈I

i∈I

[RTCom2 ]

r ∈ R~y (∆, (~y,p) : Tj , yj : [~d])
X
hp, yj dj ir ∈ R~y (∆, (~y,p) :
ei  yi di .Ti , yj : [dj · ~d])
j∈I

i∈I

[RTIt1 ]

[RTIt2 ]

r ∈ R~y (∆)

r1 ∈ R~y (∆1 )

r ∈ R~y (∆? )

r2 ∈ R~y (∆?1 )

r1 [r2 ] ∈ R~y (∆?1 )
[RTSeq]

[RTEnd]

∆ end-only
 ∈ R~y (∆,~y : [])

r1 ∈ R~y (∆1 )

r2 ∈ R~y (∆2 )

r1 r2 ∈ R~y (∆1 ; ∆2 )

Figure 14: Runs of specifications
• r = hq, ydir0 , or else and r0 ∈ R~y (∆0 ).
Theorem 8.7 below ensures that well-formed global types are covered by their projections
(Definition 6.6 on page 21). Theorem 8.8 ensures that a local specification can be covered
by a set of implementations where a role pi that is played by the same well-typed process
P , as is WSI of the role p played by P in the global type. As a corollary we have that a
well-typed process P is a WSI of the role it plays.
Theorem 8.7 (Coverage & projections). Let G(~y) , G be a global type with P(G) =
{p0 , . . . , pn } and ∆ = (~y,p0 ) : T0 , . . . , (~y,pn ) : Tn ,~y : [] such that a Ti = nf(G pi ) for all
0 ≤ i ≤ n. Then R(G) b R~y (∆).
Theorem 8.8 (Typeability & coverage). Let G(~y) , G be a global type
 with P(G) =
{p0 , . . . , pn } and ∆ = (~y,p0 ) : T0 , . . . , (~y,pn ) : Tn ,~y : [] such that a Ti = nf(G pi ) for
all 0 ≤ i ≤ n. If e Γ ` P . ∆0 , (~y,pi ) : Ti then the set I = {ι~y@u | e Γ `
ι~y@u . ∆, ∆00 ∧ ι(pi ) = P } covers R~y (∆), i.e., R~y (∆) b RI.
The result above relies on an auxiliary result that shows that each run r of an specification
∆ can be covered by a well-typed implementation ι~y@u of G(~y) in which P plays role p
(details are provided in Appendix B.4, Lemma B.14). Since b is transitive, we conclude that
any well-typed process is a WSI of a role in a choreography.
Corollary 8.9 (WSI of well-typed processes). Let G(~y) be a global type, p ∈ P(G). If
e Γ ` P . ∆ and (~y,p) ∈ dom(∆), P is a whole-spectrum implementation of p.

9. Conclusion and Related Work
WSI rejects implementations of a role that persistently avoids the execution of some branches
in a choreography. Although WSI is defined as a relation between the traces of a global type

18:36

L. Bocchi, H. Melgratti, and E. Tuosto

Vol. 16:3

and those of its candidate implementations, it can be checked by using multiparty session
types. As standard, the soundness of our type system –guaranteed by the conformance of
the typing (Theorem 8.4)– ensures that the behaviour of well-typed implementations follows
the protocol described by the global type (i.e., global types are interpreted as constraints).
Moreover, we show that (i) the sets of the projections of a global type G preserves all the
traces in G (Theorem 8.7); and (ii) a well-typed process can be used to obtain any trace of
the projections of a global type when interacting in a proper context (Theorem 8.8). These
two results and the fact that the covering relation is transitive allow us to conclude that any
well-typed process is a WSI of a role in a choreography (Corollary 8.9), i.e., global types are
interpreted as obligations.
9.1. Behavioural types. In this paper we have followed the rich line of research fostering
the application of behavioural types to concurrent programs. Examples of similar approaches
are those to guarantee properties of complex concurrent systems such as in the seminal
work of Kobayashi on deadlock freedom for the π-calculus [29, 32] or progress analysis for
choreographies [16], information flow analysis [31, 8], design-by-contract for message-passing
systems [3], or self-adaptation [15, 12]. Our type system is more restrictive than [26, 1, 5, 11, 7]
as it rules out sound but not exhaustive implementations, which previous type systems
considered well-typed. To the best of our knowledge, the only proposal dealing with complete
(i.e., exhaustive) realisations in a behavioural context is [10] but this approach focuses on
non-deterministic implementation languages. WSI coincides with projection realisability [33,
42, 10] when implementation languages feature non-deterministic internal choices. On the
contrary, WSI provides a finer criterion to distinguish deterministic implementations, as
illustrated by the motivating example in the introduction.
Appendix C illustrates that WSI can be recast into other computational models or
settings, e.g., in the context of guarded automata. In such context, WSI admits a more
succinct characterisation, and hence, would appear as a more amenable definition for WSI
(when compared against the definition given in Section 6). However, we remark that several
technicalities in our proposal arise when developing a static and modular technique for
ensuring WSI. MSTs are perhaps the most widely accepted technique for developing static
and modular nal verification techniques for multiparty interactions, and to link their formal
specification to programming languages, even at the expenses of dense technical definition
(e.g., three different languages, static and run-time semantics, well-formed conditions, etc). It
may be the case that similar techniques could be developed for ensuring WSI implementations
in other contexts, e.g., guarded automata, but the starting point is not that obvious. It
could be the case that some model-checking solution could be developed but the existence
of a feasible and simpler approach is an interesting question that requires future work (note
that the definitions in Appendix C are based on an existential quantification over possible
contexts, which could be problematic for obtaining an effective procedure).
9.2. WSI and subtyping. The standard subtyping relation [22] is not suitable for WSI
because the liberal elimination of internal choices prevents WSI. For example, standard
subtyping for output prefixes allows process y(v).y1 e to have local type y d; (y1 d + y2 d),
and this clearly violates WSI. The problematic aspect is that subtyping allows for a liberal
implementation of internal choices, whereas WSI requires a precise implementation of all
branches in a choice. This means that a WSI of a type T, may not be a WSI of a subtype of

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:37

T. The investigation of suitable forms of subtyping for WSIs is scope for future work. To
some extent our proposal is related to the fair subtyping approach in [41], where refinement
is studied under the fairness assumption: fair subtyping differs from usual subtyping when
considering infinite computations but WSI differs from partial implementation also when
considering finite computations.
9.3. Languages for types and processes. Our notation for session types combines
interaction and branching in one single operation. This choice was made for the sake of
conciseness. The combination of interaction and branching in one single operation has been
used in several works, albeit in different flavours (e.g., [13], [34], [2] and [19]). In [34] the
notation is more flexible than ours, allowing (syntactically) global types of the form
p _ q : y1 d1 ; G1 + r _ s : y2 d2 ; G2

(9.1)

which our syntax does not allows (as it requires p = r). However, the work in [34] rules out
types as the one in (9.1) when p 6= r by the well-formedness rules (i.e., knowledge of choice).
Our notation simplifies well-formedness by having this requirement in the syntax. Another
line of work [13, 2] uses a syntax more restrictive than ours: in types of the form (9.1), [13, 2]
require p = r and q = s. Such restriction prevents types of the form
p _ q : y1 d1 ; r _ s : y2 d2 ; end + r _ s : y2 d2 ; p _ q : y1 d1 ; end

which are instead well-formed in our theory. The notation introduced in this paper differs
from usual syntaxes for session types in two other significant ways, which we highlight
below. Firstly, we use iteration instead of recursion. In order to verify WSI, our proof
system needs to statically determine that the body of each iteration: (1) happens at least
once (if interactions in the body are not executed the implementation is not WSI), and (2)
terminates (to ensure that interactions in the continuation of an iteration will be executed).
For this reason, we need finitary interactions in the language for processes. However, usual
interpretation of recursive types (where maximal fixpoints are assumed) is not finitary.
Therefore, the use of standard recursive session types would introduce a mismatch between
the semantics of programs (where we need finitary iterations) with the usual interpretation
of recursive types (where maximal fixpoints are assumed).
Therefore, the static verification of WSI requires a form of recursion more restrictive
than the one in previous work on session types [26, 1], where the number of iterations is
limited. This restriction is on the lines of [10] that also considers finite traces, and is close
to for-loops of programming languages. The extension of our theory with a more general
form of iteration is scope for future work.
Because of the chosen notation for interaction-choice, iteration requires some care to
ensure that all participants agree on whether another iteration should be executed. We do
this by requiring that each iteration has exactly one controller-participant as in [10].
Secondly, we use sequential composition to allow clear delimitation of structured constructs (loops and conditional statements) hence ease static verification and its modularity.
We disregarded delegation in our framework because its addition would greatly increase
the complexity of our framework. A type system guaranteeing WSI under delegation in our
context should not be problematic to device at the cost of a higher technical complexity.

18:38

L. Bocchi, H. Melgratti, and E. Tuosto

Vol. 16:3

9.4. Choreography languages. In the literature, the term ‘choreography’ is used in
two different ways. The first one, which we follow, considers choreographies as abstract
specifications [30] or formal models (e.g., Petri Nets [37] or session types [26, 1]) where choices
are non-deterministic, in the sense that branches are not associated to conditions (e.g., as in
if-then-else statements). The W3C’s Web Services Choreography Description Language (WSCDL) [30] is an XML-based specification language where choices are enumerated without
expressing conditions. In the context of multiparty session types [26, 1], choreographies
are modelled as global types which, by projection, produce abstractions of processes (with
non-deterministic choices in the sense specified above) that can be used for static and
dynamic verification. On this thread, we also mention works that study partial vs complete
realisations [37, 10].Remarkably, WSI coincides with projection realisability [33, 42, 10] when
the language adopted to implement choreographies features non-deterministic internal choices.
On the contrary, WSI provides a finer criterion to distinguish deterministic implementations,
as illustrated by the motivating example in the introduction. The second usage is in the
context of choreographic programming (e.g., [9], [36], [18]) where a choreography is a built
in construct for programs (hence deterministic) used to produce correct-by-design code. In
such contexts there is no need to resolve non-deterministic choices since the language is
deterministic.
9.5. POP 2 specification. We captured (to the best of our understanding) the most
salient aspects of the communication of the POP2 protocol according to its official informal
specification in the state-machines in pages 16–18 of RFC937 [6]. We have focussed on the
interaction structure and left out non-functional aspects such as timeouts that are beyond
the scope of this paper. We have adopted a simplification on the interaction structure for
the sake of a simpler presentation: POP2 has a branch ‘quit’ from state ‘SIZE’ (see [6], page
16) whereas our model GSIZE in Section 5 does not have a ‘quit’ option. To quit the protocol
from state GSIZE one needs to go back to state GFOLD (which offers the option ‘quit’ as also the
corresponding state in the RFC). In our formalism, the end of a loop has to be signalled by
exactly one message (in our case message ‘fold’). We could have encoded this extra ‘quit’
option from state ‘SIZE’ by either:
• extending our choreography language to allow a set of possible messages to signal termination of a loop, which would not add considerable challenge but would increase the
technicalities in the presentation;
• encoding the exact POP2 pattern by introducing intermediary states with additional
messages which would have made the presentation of the protocol itself less clear.
Our goal was to demonstrate that our typing language can model realistic communications,
not to provide an analysis of POP2 on its own sake (which we leave as future work), hence
our simplification of the protocol.
Acknowledgement
We thank the anonymous reviewers for reading the paper carefully and providing thoughtful
comments.

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:39

References
[1] L. Bettini, M. Coppo, L. D’Antoni, M. De Luca, M. Dezani-Ciancaglini, and N. Yoshida. Global progress
in dynamically interleaved multiparty sessions. In CONCUR, volume 5201 of LNCS, pages 418–433.
Springer, 2008.
[2] L. Bocchi, R. Demangeon, and N. Yoshida. A multiparty multi-session logic. In C. Palamidessi and M. D.
Ryan, editors, TGC 2012, volume 8191 of LNCS, pages 97–111. Springer, 2012.
[3] L. Bocchi, K. Honda, E. Tuosto, and N. Yoshida. A theory of design-by-contract for distributed multiparty
interactions. In CONCUR, volume 6269 of LNCS, pages 162–176, 2010.
[4] L. Bocchi, H. Melgratti, and E. Tuosto. Resolving non-determinism in choreographies. In Z. Shao,
editor, Programming Languages and Systems, pages 493–512, Berlin, Heidelberg, 2014. Springer Berlin
Heidelberg.
[5] M. Bravetti and G. Zavattaro. A theory of contracts for strong service compliance. Mathematical
Structures in Computer Science, 19(3):601–638, 2009.
[6] M. Butler, J. Postel, D. Chase, J. Goldberger, and J. Reynoldsa. Post office protocol - version 2. RFC
918, available at http://tools.ietf.org/html/rfc937, February 1985.
[7] L. Caires and H. T. Vieira. Conversation types. In ESOP, volume 5502 of LNCS, pages 285–300. Springer,
2009.
[8] S. Capecchi, I. Castellani, and M. Dezani-Ciancaglini. Information flow safety in multiparty sessions.
Mathematical Structures in Computer Science, 26(8):1352–1394, 2016.
[9] M. Carbone and F. Montesi. Deadlock-freedom-by-design: multiparty asynchronous global programming.
In POPL ’13, pages 263–274. ACM, 2013.
[10] G. Castagna, M. Dezani-Ciancaglini, and L. Padovani. On global types and multi-party session. Logical
Methods in Computer Science, 8(1), 2012.
[11] G. Castagna and L. Padovani. Contracts for mobile processes. In CONCUR 2009, number 5710 in LNCS,
pages 211–228, 2009.
[12] I. Castellani, M. Dezani-Ciancaglini, and J. A. Pérez. Self-adaptation and secure information flow in
multiparty communications. Formal Asp. Comput., 28(4):669–696, 2016.
[13] T.-C. Chen, L. Bocchi, P.-M. Deniélou, K. Honda, and N. Yoshida. Asynchronous distributed monitoring
for multiparty session enforcement. In R. Bruni and V. Sassone, editors, TGC, volume 7173 of Lecture
Notes in Computer Science, pages 25–45. Springer, 2011.
[14] T.-C. Chen and K. Honda. Specifying stateful asynchronous properties for distributed programs. In
CONCUR, 2012.
[15] M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. Self-adaptive multiparty sessions. Service Oriented
Computing and Applications, 9(3-4):249–268, 2015.
[16] M. Coppo, M. Dezani-Ciancaglini, N. Yoshida, and L. Padovani. Global progress for dynamically
interleaved multiparty sessions. Mathematical Structures in Computer Science, 26(2):238–302, 2016.
[17] D. Crocker. Standard for the format of arpa internet text messages. RFC 822, available at www.ietf.
org/rfc/rfc0822.txt, February 1982.
[18] M. Dalla Preda, M. Gabbrielli, S. Giallorenzo, I. Lanese, and J. Mauro. Dynamic Choreographies:
Theory And Implementation. Logical Methods in Computer Science, 13:1 – 57, May 2017.
[19] P. Deniélou and N. Yoshida. Multiparty session types meet communicating automata. In H. Seidl, editor,
Programming Languages and Systems - 21st European Symposium on Programming, ESOP 2012, Held
as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2012, Tallinn,
Estonia, March 24 - April 1, 2012. Proceedings, volume 7211 of Lecture Notes in Computer Science,
pages 194–213. Springer, 2012.
[20] M. Dezani-Ciancaglini and U. de’Liguoro. Sessions and session types: An overview. In C. Laneve and
J. Su, editors, WS-FM, volume 6194 of Lecture Notes in Computer Science, pages 1–28. Springer, 2009.
[21] X. Fu, T. Bultan, and J. Su. Realizability of conversation protocols with message contents. Int. J. Web
Service Res., 2(4):68–93, 2005.
[22] S. Gay and M. Hole. Types and Subtypes for Client-Server Interactions. In Proc. of ESOP’99, volume
1576 of LNCS, pages 74–90. Springer-Verlag, 1999.
[23] S. Gay and M. Hole. Subtyping for Session Types in the Pi-Calculus. Acta Informatica, 42(2/3):191–225,
2005.

18:40

L. Bocchi, H. Melgratti, and E. Tuosto

Vol. 16:3

[24] R. Guanciale and E. Tuosto. An abstract semantics of the global view of choreographies. In Proceedings
9th Interaction and Concurrency Experience, ICE 2016, Heraklion, Greece, 8-9 June 2016., pages 67–82,
2016.
[25] R. Guanciale and E. Tuosto. Semantics of global views of choreographies. Journal of Logic and Algebraic
Methods in Programming, 2017. Revised and extended version of [24]. Accepted for publication. To appear;
version with proof available at http://www.cs.le.ac.uk/people/et52/jlamp-with-proofs.pdf.
[26] K. Honda, N. Yoshida, and M. Carbone. Multiparty asynchronous session types. In G. C. Necula and
P. Wadler, editors, POPL, pages 273–284. ACM, 2008.
[27] R. Hu, D. Kouzapas, O. Pernet, N. Yoshida, and K. Honda. Type-safe eventful sessions in Java. In
ECOOP 2010, volume 6183 of LNCS, pages 329–353. Springer-Verlag, 2010.
[28] R. Hu and N. Yoshida. Hybrid session verification through endpoint api generation. In Fundamental
Approaches to Software Engineering, pages 401–418, Berlin, Heidelberg, 2016. Springer.
[29] A. Igarashi and N. Kobayashi. A generic type system for the pi-calculus. Theor. Comput. Sci., 311(13):121–163, 2004.
[30] N. Kavantzas, D. Burdett, G. Ritzinger, T. Fletcher, and Y. Lafon. http://www.w3.org/TR/2004/
WD-ws-cdl-10-20041217, 2004.
[31] N. Kobayashi. Type-based information flow analysis for the pi-calculus. Acta Inf., 42(4-5):291–347, 2005.
[32] N. Kobayashi. A new type system for deadlock-free processes. In CONCUR 2006 - Concurrency Theory,
17th International Conference, CONCUR 2006, Bonn, Germany, August 27-30, 2006, Proceedings,
volume 4137 of Lecture Notes in Computer Science, pages 233–247. Springer, 2006.
[33] I. Lanese, C. Guidi, F. Montesi, and G. Zavattaro. Bridging the gap between interaction-and processoriented choreographies. In SEFM, 2008.
[34] J. Lange and E. Tuosto. Synthesising choreographies from local session types. In M. Koutny and
I. Ulidowski, editors, CONCUR, volume 7454 of LNCS, pages 225–239, 2012.
[35] J. Lange, E. Tuosto, and N. Yoshida. From Communicating Machines to Graphical Choreographies. In
POPL, pages 221–232, 2015.
[36] A. Lluch-Lafuente, F. Nielson, and H. R. Nielson. Discretionary information flow control for interactionoriented specifications. In Logic, Rewriting, and Concurrency - Essays dedicated to José Meseguer on
the Occasion of His 65th Birthday, volume 9200 of LNCS, pages 427–450. Springer, 2015.
[37] N. Lohmann and K. Wolf. Decidability results for choreography realization. In G. Kappel, Z. Maamar,
and H. R. M. Nezhad, editors, ICSOC, volume 7084 of Lecture Notes in Computer Science, pages 92–107.
Springer, 2011.
[38] R. Milner. Communication and Concurrency. Prentice Hall, 1989.
[39] M. Neubauer and P. Thiemann. An Implementation of Session Types. In Practical Aspects of Declarative
Languages (PADL), volume 3057 of LNCS, pages 56–70. Springer, 2004.
[40] R. Neykova, R. Hu, N. Yoshida, and F. Abdeljallal. A session type provider: compile-time API generation
of distributed protocols with refinements in f#. In CC 2018, pages 128–138. ACM, 2018.
[41] L. Padovani. Fair subtyping for multi-party session types. In COORDINATION, volume 6721 of LNCS,
pages 127–141, 2011.
[42] G. Salaün and T. Bultan. Realizability of choreographies using process algebra encodings. In Integrated
Formal Methods, 2009.
[43] J. Su, T. Bultan, X. Fu, and X. Zhao. Towards a theory of web service choreographies. In M. Dumas and
R. Heckel, editors, WS-FM, volume 4937 of Lecture Notes in Computer Science, pages 1–16. Springer,
2007.

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:41

Appendix A. Auxiliary Properties of Typing
In this section we provide technical details and auxiliary properties of the type system, which
are used in the proof of the main results of the paper.
A.1. Normal form nf( , ). Below we state useful results about the normal form of pseudotypes. We start by introducing a well-founded relation on pseudo-types, which will be used
for inductive proofs. The relation < on pseudo-types is defined in terms of the following
function ω : T → N:
M ω(e  end) = 1
ω(
ei  yi di .Ti ) = 1 + max {ω(Ti )}i∈I
i∈I
X
ω(
ei  yi di .Ti ) = 1 + max {ω(Ti )}i∈I
i∈I

ω(T1 ; T2 ) = 2 ∗ ω(T1 ) + ω(T2 )
ω(T? ) = 1 + ω(T)
We say T1 < T2 iff ω(T1 ) < ω(T2 ). It is straightforward to check that ω(T) > 0 for all
T. Consequently, (T, <) is well-founded.
Lemma A.1. nf(T) is defined for any T (i.e., it terminates).
Proof. The proof follows by showing that the function f (e, T) = ω(T) is a variant function
for the definition of nf(e, T) in Figure 8. We proceed by case analysis on the equations
in Figure 8 (we illustrate the interesting cases below).
M
(2) f (e,
ei  yi di .Ti ) = 1 + max {ω(Ti )}i∈I > ω(Ti ) = f (ei ∧ e, Ti ) for all i ∈ I \ J.
i∈I

(3) Analogous to (2).
(5)
M
M


f (e,
ei  yi di .Ti ; T) = ω(
ei  yi di .Ti ; T)
i∈I

i∈I

2 ∗ (1 + max {ω(Ti )}i∈I ) + ω(T)
2 + max {2 ∗ ω(Ti ) + ω(T)}i∈I
1 +M
max {2 ∗ ω(Ti ) + ω(T)}i∈I

ei  yi di .Ti ; T )
ω(
i∈I
M

= f (e,
ei  yi di .Ti ; T )
=
=
>
=

i∈I

(6) Analogous to (5).
(7)
f (e, (T1 ; T2 ); T3 ) =
=
=
>
=
=

ω((T1 ; T2 ); T3 )
2 ∗ (2 ∗ ω(T1 ) + ω(T2 )) + ω(T3 )
4 ∗ ω(T1 ) + 2 ∗ ω(T2 ) + ω(T3 )
2 ∗ ω(T1 ) + 2 ∗ ω(T2 ) + ω(T3 )
ω(T1 ; (T2 ; T3 ))
f (e, T1 ; (T2 ; T3 ))

Lemma A.2. For all e, e0 , T, if nf(e, T) = e00  end, then nf(e ∧ e0 , T) = e00 ∧ e0  end.

18:42

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

Proof. By well-founded induction on (T, <). The proof follows by case analysis on the
structure of T.
Lemma A.3. For all e, e0 , T, nf(e, nf(e0 , T)) = nf(e ∧ e0 , T).
Proof. By well-founded induction on (T, <). The proof follows by case analysis on the
structure of T.
• T = e00  end: Then,
nf(e, nf(e0 , T)) = nf(e, nf(e0 , e00  end))
= nf(e, e0 ∧ e00  end)
= e ∧ e0 ∧ e00  end
= nf(e ∧ e0 , e00  end)
= nf(e ∧ e0 , T)

• T=

M
i∈I

by
by
by
by
by

def. of
Figure
Figure
Figure
def. of

T
8(1)
8(1)
8(1)
T

ei  yi di .Ti : Then,

M
nf(e, nf(e0 , T)) = nf(e, nf(e0 ,
ei  yi di .Ti ))
M i∈I
= nf(e,
ei ∧ e0  yi di .nf(ei ∧ e0 , Ti ))

by def. of T
by Figure 8(2)

i∈I\J 0

=

M
i∈(I\J 0 )\J

=
=
=

M

6 I
J 0 = {i ∈ I (e ∧ e0i ) ⇐⇒ false} =
0
0
ei ∧ e ∧ e  yi di .nf(e, nf(ei ∧ e , Ti )) by Figure 8(2)
6 I \ J0
J = {i ∈ I \ J 0 (e ∧ e0i ) ⇐⇒ false} =
0
ei ∧ e ∧ e  yi di .nf(ei ∧ e ∧ e, Ti )
by ind . hyp.
0

i∈(I\J 0 )\J
M
nf(e ∧ e0 ,
ei
i∈I
nf(e ∧ e0 , T)

J0

 yi di .Ti )

by Figure 8(2)
by def. of T

J0

The cases in which I =
or I \
= J follow immediately because nf(e, nf(e0 , T)) =
0
false
 end = nf(e ∧ e , T).
X
• T=
ei  yi di .Ti : It follows analogously to the previous one.
i∈I

• T = TM
analysis on the structure of T1 . The cases T1 = e00  end,
1 ; T2 : We proceed by case X
T1 =
ei  yi di .Ti and T1 =
ei  yi di .Ti follow analogously to the previous cases.
i∈I

i∈I

The case for T1 = T0 ; T00 is as follows:
nf(e, nf(e0 , T)) = nf(e, nf(e0 , (T0 ; T00 ); T2 ))
= nf(e, nf(e0 , T0 ; (T00 ; T2 )))
= nf(e ∧ e0 , T0 ; (T00 ; T2 ))
= nf(e ∧ e0 , (T0 ; T00 ); T2 )
= nf(e ∧ e0 , T)

by
by
by
by
by

def. of T
Figure 8(7)
ind. hyp.
Figure 8(7)
def. of T

The case T1 = (T0 )? , is as follows
nf(e, nf(e0 , T)) = nf(e, nf(e0 , (T0 )? ; T2 ))

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:43

There are two cases, when nf(e0 , T0 ) = e00  end, by Figure 8(8)
nf(e, nf(e0 , T)) = e ∧ e00  end

Then, the proof is completed by Lemma A.2. Otherwise (nf(e0 , T0 ) 6= e00  end), we proceed
as follows
nf(e, nf(e0 , T)) = nf(e, nf(e0 , (T0 )? ; T2 ))
by def. of T
= nf(e, nf(e0 , (T0 )? ); nf(e0 , T2 ))
by Figure 8(9)
= nf(e, nf(e0 , T0 )? ; nf(e0 , T2 ))
by Figure 8(11)
= nf(e, nf(e0 , T0 )? ); nf(e, nf(e0 , T2 )) by Figure 8(9)
= nf(e, nf(e0 , T0 ))? ; nf(e, nf(e0 , T2 )) by Figure 8(11)
= nf(e ∧ e0 , T0 )? ; nf(e ∧ e0 , T2 )
by ind. hyp.
= nf(e ∧ e0 , (T0 )? ); nf(e ∧ e0 , T2 )
by Figure 8(11)
= nf(e ∧ e0 , (T0 )? ; T2 )
by Figure 8(9)
= nf(e ∧ e0 , T)
by def. of T
• T = T?1 : Then,

nf(e, nf(e0 , T)) = nf(e, nf(e0 , T?1 ))
If nf(e0 , T?1 ) = e00  end, the proof follows by Lemma A.2, otherwise:
nf(e, nf(e0 , T)) = nf(e, nf(e0 , T?1 ))
= nf(e, nf(e0 , T?1 ))
= nf(e, nf(e0 , T1 )? )
= nf(e, nf(e0 , T1 ))?
= nf(e ∧ e0 , T1 )?
= nf(e ∧ e0 , T?1 )
= nf(e ∧ e0 , T)

by
by
by
by
by
by
by

def. of T
Figure 8(9)
Figure 8(11)
Figure 8(13)
ind . hyp.
Figure 8(13)
def. of T

Lemma A.4. If e ⇐⇒ false then nf(e, T) = e0  end and e0 ⇐⇒ false.

Proof. By well-founded induction on (T, <). The proof follows by case analysis on the
structure of T.
Lemma A.5. For all e, T, T0 , nf(e, T; nf(e, T0 )) = nf(e, T; T0 ).
Proof. By well-founded induction on (T, <). The proof follows by case analysis on the
structure of T.
• T = e0  end: Then,
nf(e, T; nf(e, T0 )) = nf(e, e0  end; nf(e, T0 ))
= nf(e ∧ e0 , nf(e, T0 ))
= nf(e ∧ e0 , T0 )
= nf(e, e0  end; T0 )
= nf(e, T; T0 )

• T=

M
i∈I

by
by
by
by
by

def. of T
Figure 8(1)
Lemma A.3
Figure 8(1)
def. of T

ei  yi di .Ti : Then,
M
nf(e, T; nf(e, T0 )) = nf(e, (
ei  yi di .Ti ); nf(e, T0 )) by def. of T
i∈I
M
= nf(e,
ei  yi di .Ti ; nf(e, T0 ))
by Figure 8(6)
i∈I

18:44

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

The case in which J = {i ∈ I (e∧e0i ) ⇐⇒ false} = I follows immediately. Otherwise,
we proceed as follows
M
by Figure 8(2)
=
ei ∧ e  yi di .nf(ei ∧ e, Ti ; nf(e, T0 ))
i∈I\J

=

M
i∈I\J

=

M
i∈I\J

=

M
i∈I\J

ei ∧ e  yi di .nf(ei , nf(e, Ti ; nf(e, T0 ))) by Lemma A.3
ei ∧ e  yi di .nf(ei , nf(e, Ti ; T0 ))

by ind. hyp.

ei ∧ e  yi di .nf(ei ∧ e, Ti ; T0 )

by Lemma A.3

M

by Figure 8(2)

ei  yi di .Ti ; T0 )
i∈I
M
= nf(e, (
ei  yi di .Ti ); T0 )

= nf(e,

by Figure 8(6)

i∈I

= nf(e, T; T0 )
• T=
• T=

X

ei  yi
i∈I
T1 ; T2 :

by def. of T

di .Ti : It follows analogously to the previous one.

nf(e, T; nf(e, T0 )) = nf(e, (T1 ; T2 ); nf(e, T0 ))
= nf(e, T1 ; (T2 ; nf(e, T0 )))
= nf(e, T1 ; nf(e, T2 ; nf(e, T0 )))
= nf(e, T1 ; nf(e, T2 ; T0 ))
= nf(e, T1 ; (T2 ; T0 ))
= nf(e, (T1 ; T2 ); T0 )
= nf(e, T; T0 )

by
by
by
by
by
by
by

def. of T
Figure 8(7)
ind. hyp.
ind. hyp.
ind. hyp.
Figure 8(7)
def. of T

• T = T?1 :

nf(e, T; nf(e, T0 )) = nf(e, T?1 ; nf(e, T0 )) by def. of T
If nf(e, T) = e0  end, then the proof follows straightforwardly from Figure 8(8). Otherwise,
= nf(e, T?1 ); nf(e, nf(e, T0 ))
= nf(e, T?1 ); nf(e, T0 )
= nf(e, T?1 ; T0 )
= nf(e, T; T0 )

by
by
by
by

Figure 8(9)
Lemma A.3
Figure 8(9)
def. of T

Lemma A.6. If e =⇒ e0 , then nf(e, T; e0  end) = nf(e, T).

Proof. By well-founded induction on (T, <). The proof follows by case analysis on the
structure of T.

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

• T = e00  end: Then,

nf(e, T; e0  end) = nf(e, e00  end; e0  end)
= nf(e ∧ e00 , e0  end)
= e ∧ e00 ∧ e0  end
= e ∧ e00  end
= nf(e, e00  end)
= nf(e, T)

• T=

M
i∈I

by def. of
by Figure
by Figure
e =⇒ e0
by Figure
by def. of

18:45

T
8(6)
8(1)
8(6)
T

ei  yi di .Ti : Then,
M
nf(e, T; e0  end) = nf(e, (
ei  yi di .Ti ); e0  end) by def. of T
i∈I
M
ei  yi di .(Ti ; e0  end)) by Figure 8(7)
= nf(e,
i∈I

If I = J, then the case follows immediately. Otherwise,
M
=
ei ∧ e  yi di .nf(ei ∧ e, Ti ; e0  end) by Figure 8(4)
i∈I\J

=

M
i∈I\J

= nf(e,

ei ∧ e  yi di .nf(ei ∧ e, Ti )

by ind. hyp.

M

by Figure 8(4)

i∈I

ei  yi di .Ti )

= nf(e, T)
• T=
• T=

X

ei  yi di .Ti :
i∈I
T1 ; T2 : Then,
nf(e, T; e0

by def. of T

It follows analogously to the previous one.

 end) = nf(e, (T1 ; T2 ); e0  end)
= nf(e, T1 ; (T2 ; e0  end))
= nf(e, T1 ; nf(e, T2 ; e0  end))
= nf(e, T1 ; nf(e, T2 ))
= nf(e, T1 ; T2 )
= nf(e, T)

by
by
by
by
by
by

def. of T
Figure 8(9)
Lemma A.5
ind. hyp.
Figure 8(9)
def. of T

• T = T?1 : Then,
nf(e, T; e0  end) = nf(e, T?1 ; e0  end)
= nf(e, T?1 ); nf(e, e0  end)
= nf(e, T?1 ); nf(e ∧ e0 , end)
= nf(e, T?1 ); nf(e, end)
= nf(e, T?1 ; end)
= nf(e, T; end)
= nf(e, T)

by def. of
by Figure
by Figure
e =⇒ e0
by Figure
by def. of

T
8(11)
8(6)
8(11)
T

Lemma A.7. Equality nf(e, T; (e0  end; T0 )) = nf(e, T; T0 ) holds for all e and e0 such that
¬(e ⇐⇒ false) and e =⇒ e0 .
Proof. By well-founded induction on (T, <). The proof follows by case analysis on the
structure of T.

18:46

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

• T = e00  end: Then,

nf(e, T; (e0  end; T0 )) = nf(e, e00  end; (e0  end; T0 ))
= nf(e ∧ e00 , e0  end; T0 )
= nf(e ∧ e00 ∧ e0 , T0 );
= nf(e ∧ e00 , T0 );
= nf(e, e00  end; T0 )
= nf(e, T; T0 )
M
• T=
ei  yi di .Ti : Then,

by def. of T
by Figure 8(6)
by Figure 8(6)
e ∧ e00 ∧ e0 ⇐⇒ e ∧ e00
by Figure 8(6)
by def. of T

i∈I

M
nf(e, T; (e0  end; T0 )) = nf(e, (
ei  yi di .Ti ); (e0  end; T0 )) by def. of T
i∈I
M
ei  yi di .(Ti ; (e0  end; T0 ))) by Figure 8(7)
= nf(e,
i∈I

If I = J, then the case follows immediately. Otherwise,
M
=
ei ∧ e  yi di .nf(ei ∧ e, (Ti ; (e0  end; T0 ))) by Figure 8(4)
i∈I\J

M

=

i∈I\J

ei ∧ e  yi di .nf(ei ∧ e, Ti ; T0 )

by ind . hyp.

M

by Figure 8(4)

ei  yi di .(Ti ; T0 ))
i∈I
M
= nf(e, (
ei  yi di .Ti ); T0 )

= nf(e,

by Figure 8(7)

i∈I

= nf(e, T; T0 )
• T=
• T=

by def. of T

X

ei  yi di .Ti : It follows analogously to the previous one.
i∈I
T1 ; T2 : Then,
nf(e, T; (e0  end; T0 )) = nf(e, (T1 ; T2 ); (e0  end; T0 ))
= nf(e, T1 ; (T2 ; (e0  end; T0 )))
= nf(e, T1 ; nf(e, T2 ; (e0  end; T0 )))
= nf(e, T1 ; nf(e, T2 ; T0 ))
= nf(e, T1 ; (T2 ; T0 ))
= nf(e, (T1 ; T2 ); T0 )
= nf(e, T; T0 )

by
by
by
by
by
by
by

def. of T
Figure 8(9)
Lemma A.5
ind . hyp.
Lemma A.5
Figure 8(9)
def. of T

• T = T?1 : Then,
nf(e, T; (e0  end; T0 )) = nf(e, T?1 ; (e0  end; T0 ))
= nf(e, T?1 ); nf(e, e0  end; T0 )
= nf(e, T?1 ); nf(e ∧ e0 , T0 )
= nf(e, T?1 ); nf(e, T0 )
= nf(e, T?1 ; T0 )
= nf(e, T; T0 )
Lemma A.8. nf(e, T./T0 ) = nf(e, T)./nf(e, T0 ).
Proof. By straightforward induction on the derivation of T./T0 .

by def. of
by Figure
by Figure
e =⇒ e0
by Figure
by def. of

T
8(11)
8(6)
8(11)
T

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:47

A.2. Typing. We write var(T) to denote the variables appearing in the expressions occurring
on the pseudo-type T. It is straightforwardly extended to specifications var(∆).
Lemma A.9. If e

Γ ` S . ∆, then var(∆) ⊆ var(e) ∪ fx(S) ∪ bx(S).

Proof. By straightforward structural induction on the typing judgment.
Lemma A.10. If e

Γ ` P . ∆ then e

Γ, x : d ` P . ∆.

Proof. By induction on the structure of the proof e

Γ ` P . ∆.

Lemma A.11. If e Γ ` P . ∆ then
• fx(P ) ∪ fy(P ) ∪ fx(e) ⊆ Γ
• ∀y ∈ fy(P ) : y ∈ dom(∆).
Proof. By induction of the derivation of e Γ ` P . ∆ and inspecting the rules in Figure 10
and 11.
Lemma A.12. If e

Γ ` P . ∆ and P ≡ Q, then e

Γ ` Q . ∆0 and nf(∆) = nf(∆0 ).

Proof. By induction on the proof of P ≡ Q.
• P ; (Q; R) ≡ (P ; Q); R follows by inductive hypothesis and associativity of ; over pseudo
types (Figure 8 (9)).
• 0; P ≡ P ; 0 ≡ P follows by using Lemma A.7 and Lemma A.6.
Lemma A.13. If e

Γ ` P . ∆, (~y,p) : T and e ⇐⇒ false, then nf(T) = false  end.

Proof. Follows by induction on the structure of P . The interesting cases are
• [VSeq]: Then, P = P1 ; P2 , e Γ ` P1 . ∆1 , and e Γ ` P2 . ∆2 and ∆1 ; ∆2 defined.
By inductive hypothesis, if (~y,p) ∈ dom(∆i ) then nf(∆i (~y,p)) = false  end for i = 1, 2.
Then, the result follows by the definition of ; and rule (4) in Figure 8.
• [VIf]: Then, P = if e0 then P1 else P2 , e ∧ e0 Γ ` P1 . ∆1 , and e ∧ ¬e0 Γ ` P2 . ∆2
and ∆1 ./∆2 . By inductive hypothesis, if (~y,p) ∈ dom(∆i ) then nf(∆i (~y,p)) = false  end
for i = 1, 2. Then, the results follows by definition of ./.
Lemma A.14. If e Γ ` P . ∆, then for all e0 there is ∆0 such that:
• dom(∆) = dom(∆0 ), and
• e ∧ e0 Γ ` P . ∆0 , and
• for all (~y,p) ∈ dom(∆), ∆0 (~y,p) = e ∧ e0  end; ∆(~y,p).

Proof. Let ∆(~y,p) = T and ∆0 (~y,p) = T0 . We show that nf(T0 ) = nf(e ∧ e0  end; T) by
induction on the structure of the proof for the judgment e Γ ` P . ∆, (~y,p) : T. We first
assume that ¬(e ∧ e0 ⇐⇒ false), and show
• [VReq], [VAcc]: Follow by inductive hypothesis.

18:48

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

• [VRcv]: Then, T =

X
i∈I

Similarly, T0 =

X
i∈I

e  yi di .Ti , and ∀i ∈ I : e

e ∧ e0  yi di .T0i and ∀i ∈ I : e ∧ e0

nf(true, T0 ) =
=
=

X
i∈I
X
i∈I
X
i∈I
X

Γ, xi : di ` Pi . ∆, (~y,p) : Ti .
Γ, xi : di ` Pi . ∆0 , (~y,p) : T0i

e ∧ e0  yi di .T0i

by def. of T0

e ∧ e0  yi di .nf(e ∧ e0 , T0i )

by Figure 8(5)

e ∧ e0  yi di .nf(e ∧ e0 , e ∧ e0  end; Ti ) by ind . hyp.

e ∧ e0  yi di .nf(e ∧ e0 , Ti )
i∈I
X
e  yi di .Ti )
= nf(e ∧ e0 ,

by Figure 8(6)

= nf(e ∧ e0 , T)
= nf(true, e ∧ e0  end; T)

by def. of T
by Figure 8(6)

=

by Figure 8(5)

i∈I

• [VSend]: Then, T = e  y d; e  end and T0 = e ∧ e0  y d; e ∧ e0  end.
nf(true, T0 ) = nf(true, e ∧ e0  y d; e ∧ e0  end)
= nf(true, e ∧ e0  y d; nf(e ∧ e0 , e  end))
= nf(e ∧ e0 , e  y d; e  end)
= nf(e ∧ e0 , T)
= nf(true, e ∧ e0  end; T)

by
by
by
by
by

• [VEnd]: Then, T = e  end and T0 = e ∧ e0  end. By normalising,
nf(true, T0 ) = nf(true, e ∧ e0  end)
= nf(e ∧ e0 , e  end);
= nf(e ∧ e0 , T);
= nf(true, e ∧ e0  end; T);

by
by
by
by

def. of
Figure
def. of
Figure

def. of
Figure
Figure
def. of
Figure

T0
8(6)
8(4)
T
8(6)

T0
8(1)
T0
8(6)

• [VSeq] There are two cases:
– (~y,i) ∈ (dom(∆1 ) ∪ dom(∆2 )): Then T = T1 ; T2 and T0 = T01 ; T02 . By inductive
hypothesis, T01 = e ∧ e0  end; T1 and T02 = e ∧ e0  end; T2 .
nf(true, T0 ) = nf(true, T01 ; T02 )
= nf(true, (e ∧ e0  end; T1 ); (e ∧ e0  end; T2 ))
= nf(true, e ∧ e0  end; (T1 ; (e ∧ e0  end; T2 )))
= nf(e ∧ e0 , T1 ; (e ∧ e0  end; T2 ))
= nf(e ∧ e0 , T1 ; T2 )
= nf(e ∧ e0 , T)
= nf(true, e ∧ e0  end; T)

by
by
by
by
by
by
by

def. of T0
ind . hyp.
Figure 8(6)
Figure 8(9)
Lemma A.7
def. of T
Figure 8(6)

– (~y,i) 6∈ dom(∆2 ): Then T = T1 and T0 = T01 . By inductive hypothesis, T01 = e ∧ e0 
end; T1 . Hence, T0 = e ∧ e0  end; T.

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:49

• [VIf]: Then T = T1 ./T2 and T0 = T01 ./T02 .
nf(true, T0 ) = nf(true, T01 ./T02 )
= nf(true, T01 )./nf(true, T02 )
= nf(true, (e ∧ e0  end; T1 ))./nf(true, (e ∧ e0  end; T2 ))
= nf(e ∧ e0 , T1 )./nf(e ∧ e0 , T2 )
= nf(e ∧ e0 , T01 ./T02 )
= nf(e ∧ e0 , T)
= nf(true, e ∧ e0  end; T)

by
by
by
by
by
by
by

def. of T0
Lemma A.8
ind . hyp.
Figure 8(6)
Lemma A.8
def. of T
Figure 8(6)

• [VFor]: Then T = (T1 )? , T0 = (T01 )? . Then,

nf(true, T0 ) = nf(true, (T01 )? )
= nf(true, T01 )?
= nf(true, e ∧ e0  end; T1 )?
= nf(e ∧ e0 , T1 )?
= nf(e ∧ e0 , (T1 )? )
= nf(e ∧ e0 , T)
= nf(true, e ∧ e0  end; T)

by
by
by
by
by
by
by

def. of T0
Figure 8(13)
ind . hyp.
Figure 8(6)
Figure 8(13)
def. of T
Figure 8(6)

• [VForEnd]: It follows analogously to the case [VEnd].
• [Vloop]: Since ∆1 and ∆2 are passively compatible, then dom(∆1 ) = dom(∆2 ), then
(~y,i) ∈ (dom(∆1 ) ∩ dom(∆2 )). Consequently, T = (T1 )? ; T2 , T0 = (T01 )? ; T2 . By inductive
hypothesis, T01 = e ∧ e0  end; T1 and T02 = e ∧ e0  end; T2 .
nf(true, T0 ) = nf(true, (T01 )? ; T02 )
= nf(true, (e ∧ e0  end; T1 )? ; (e ∧ e0  end; T2 ))
= nf(true, (e ∧ e0  end; T1 )? ); nf(true, e ∧ e0  end; T2 )
= nf(true, (e ∧ e0  end; T1 ))? ; nf(true, e ∧ e0  end; T2 )
= nf(e ∧ e0 , T1 )? ; nf(e ∧ e0 , T2 )
= nf(e ∧ e0 , T?1 ); nf(e ∧ e0 , T2 )
= nf(e ∧ e0 , (T1 )? ; T2 )
= nf(e ∧ e0 , T)
= nf(true, e ∧ e0  end; T)

by
by
by
by
by
by
by
by
by

If e ∧ e0 ⇐⇒ false, we proceed as follows

nf(true, e ∧ e0  end; T) = nf(e ∧ e0 , T) by Figure 8(6)
= false  end by Lemma A.4
= T0
by Lemma A.13
Lemma A.15. If e Γ ` P . ∆, then
• e ∧ e0 Γ ` P . ∆0 ; and
• for all (~y,p) ∈ dom(∆0 ), ∆0 (~y,p) = nf(e0 , ∆(~y,p))
Proof. Directly from Lemma A.14.

def. of T0
ind . hyp.
Figure 8(11)
Figure 8(13)
Figure 8(6)
Figure 8(13)
Figure 8(11)
def. of T
Figure 8(6)

18:50

L. Bocchi, H. Melgratti, and E. Tuosto

Vol. 16:3

A.3. Consistency.
Lemma A.16. If σ n T, then σ 0 n T for any σ 0 such that σ(x) = σ 0 (x) for all x ∈ var(T).
Proof. By structural induction on the structure of σ n T and by noticing that e ↓ (σ ∩ σ 0 ) =
e ↓ σ for every expression e in T.
Lemma A.17. If x 6∈ var(T) and σ n T then σ|dom(σ)\{x} n T.
Proof. It follows from Lemma A.16.
Lemma A.18. If T./T0 is defined and either σ n T or σ n T0 , then σ n (T./T0 ).
Proof. By induction on the structure of T.
Lemma A.19. Let σ, ∆, e, and Γ be such that conditions (1)–(3) in Definition 8.1 hold.
Then
e Γ ` P . ∆
=⇒
∀(~y,p) ∈ dom(∆) : σ n ∆(~y,p)
Proof. By structural induction on the derivation of the typing judgement. We proceed by
case analysis on the last rule applied in the derivation of the judgment e Γ ` P . ∆.
• [VReq] The thesis directly follows from the inductive hypothesis.
• [VAcc] The thesis directly follows
Xfrom the inductive hypothesis.
e  yi di .Ti . The inductive hypothesis applied to the
• [VRcv] Then, ∆ = ∆0 , (~y,p) :
i∈I

•

•
•

•

premiss of [VRcv] implies that σ, xi 7→ vi n Ti for all i ∈ I and that σ, xi 7→ vi n ∆0 (y~0 ,q).
Since e ↓ σ = true, then e ↓ σ, xi 7→ vi = true for all i ∈ I. By inductive hypothesis on
all the premiss, we conclude that σ, xi 7→ vi n Ti . By Lemma A.17, σ n Ti for all i ∈ I, so
we can apply rule [CRcv] and obtain the thesis.
~0 ,q) = eend
[VSend] Then, ∆ = ∆0 , (~y,p) : ey d; eend and, by the premiss of [VSend], ∆0 (y
and σ n e  end by rule [CRcv]. We just need to prove that σ n e  y d so to apply rule [CSeq]
and obtain the thesis. This is indeed the case as e ↓ σ = true by assumption (3) of
Definition 8.1 which implies e&σ and so, by rule [CSend] we conclude the proof.
[VEnd] Then, (~y,p) ∈ dom(∆) and ∆(~y,p) = e  end. Moreover, e ↓ σ = true by assumption.
Therefore, σ n e  end by rule [CRcv].
[VSeq] We have
e Γ ` P1 . ∆1
e Γ ` P2 . ∆2
with ∆ = ∆1 ; ∆2
e Γ ` P1 ; P2 . ∆1 ; ∆2
For all (~y,p) ∈
/ dom(∆1 ) ∩ dom(∆2 ) the thesis follows directly by the inductive hypothesis
on one of the premiss of the rule above. If (~y,p) ∈ dom(∆1 ) ∩ dom(∆2 ) then ∆(~y,p) =
∆1 (~y,p); ∆2 (~y,p) and, by inductive hypothesis, both σ n ∆1 (~y,p) and σ n ∆2 (~y,p) hold.
Hence, the thesis follows by rule [CSeq].
[VIf] We have
e ∧ e 0 Γ ` P1 . ∆1
e ∧ ¬e0 Γ ` P2 . ∆2
with ∆ = ∆1 ./∆2
e Γ ` if e0 then P1 else P2 . ∆1 ./∆2
Since e ↓ σ = true, we have either (e ∧ e0 ) ↓ σ = true or (e ∧ ¬e0 ) ↓ σ = true; hence, we
can apply the inductive hypothesis to one of the premisise of the rule above. So, we have
that σ n T1 or σ n T2 and σ n T1 ./T2 hold by Lemma A.18.

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:51

• [VFor] We have that ∆ = ∆∗1 for some specification ∆1 such that e ∧ x ∈ ` x : d, Γ `
P . ∆1 . By the inductive hypothesis, we have σ, x 7→ vn∆1 (~y,p) for all (~y,p) ∈ dom(∆1 ) =
dom(∆). The thesis then follows by Lemma A.17 and applying rule [CLoop].
• [VForEnd] Similarly to the case [VEnd].
• [Vloop] We have that ∆ = ∆∗1 ; ∆2 for two specifications ∆1 and ∆2 such that
e

Γ ` N . ∆1

e
e

Γ ` M . ∆2

∆1 and ∆2 passively compatible

Γ ` repeat N until M . ∆?1 ; ∆2

For all (~y,p) ∈ dom(∆1 ) ∪ dom(∆2 ) = dom(∆), we have σ n (~y,p) by the inductive
hypothesis. The thesis follows by using rules [CLoop] and [CSeq].
Lemma A.20. If e
implies α 6= yd.

α

Γ ` P . ∆, σ n (e; Γ; P ; ∆) and ∆ active, then hP, σi −
→ hP 0 , σ 0 i

Proof. By induction on the structure of the typing judgement.
• [VReq]: Then, P = u n (~y).P 0 . By inspecting reduction rules, the only possibility is α = u n (~y).
• [VAcc]: Then, P = u i (~y).P 0 . By inspecting reduction rules, the only possibility is α = u i (~y).
• [VSend]: Then, P = y e0 . By inspecting reduction rules, the only possibility is α = yv.
• [VEnd]: Then, P = 0. Hence, there is no reduction.
α
→ hP 0 , σ 0 i
• [VSeq]: Then, P = P1 ; P2 , ∆ = ∆1 ; ∆2 , and e Γ ` P1 . ∆1 . Note that hP, σi −
α
implies hP1 , σi −
→ hP10 , σ 0 i. Moreover, ∆ active implies ∆1 active. Then, by inductive
hypothesis, α 6= yd.
α
→ hP 0 , σ 0 i implies
• [VIf]: Then, P = if e0 then P1 else P2 , ∆ = ∆1 ./∆2 . Moreover, hP, σi −
α
α
hP1 , σi −
→ hP10 , σ 0 i or hP1 , σi −
→ hP10 , σ 0 i. Moreover, ∆ active implies ∆1 and ∆2 active.
Then, by inductive hypothesis, α 6= yd.
• [VRcv], [VEnd], [VFor], [VForEnd] and [Vloop] implies ∆ not active, hence the cases trivially
hold.
α

Lemma A.21. Let e Γ ` P . ∆ and ~y ∈ dom(∆). If ∆ −
→ ∆0 with α 6= τ and n(α) ⊆ ~y,
then for all stores σ such that σ n (e; Γ; P ; ∆) the following conditions hold
(1)
(2)
(3)
(4)

0

E`β e `α
e ∩ ~y = ∅
hP, σi ,−−→−−−→ hP 0 , σ 0 i with n(β)
0
0
0
00
e ∧ E ∧ e Γ ` P . ∆ with Γ ⊆ Γ0
∆0 (~y,p) = ∆00 (~y,p) for all (~y,p) ∈ dom(∆)
σ 0 n (∆00 ; e ∧ E ∧ e0 ; P 0 ; Γ0 ).
e

Proof. The proof follows by induction on the structure of the derivation of e Γ ` P
We report the representative cases.
n
00
00
• [VReq]Then,
 P = u (~y).P , ∆(u) ≡ G(~y) and e Γ ` P . ∆, (~y,0) : T with a
a G(~y) 0 . There are two cases:
(1) α = u n (~y). Then, ∆0 = ∆, (~y,0) : T. Take P 0 = P 00 , βe = , E = e0 =
σ0

Γ0

∆00

∆0 .

e0 `α

. ∆.

T =
true,

hP 0 , σ 0 i

= σ[~y 7→ u],
= Γ and
=
Note that hP, σi −−−→
by [SReq].
0
0
00
Condition σ n (∆ ; e; P ; Γ) follows straightforwardly from σ n (∆; e; P ; Γ).
α
(2) α 6= u n (~y). Hence, n(α) ∩ ~y = ∅. By Lemma B.1, ∆ −
→ ∆0 implies ∆, (~y,0) :
α
T −
→ ∆0 , (~y,0) : T. By inductive hypothesis on e Γ ` P 00 . ∆, (~y,0) : T and
α

E 0 `βe0 e0 `α

∆, (~y,0) : T −
→ ∆0 , (~y,0) : T, we conclude that hP 00 , σ[~y 7→ u]i ,−−−→−−−→ hP 0 , σ 0 i.

18:52

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

Then, take βe = u n (~y)βe0 and E = E 0 . Conditions (2)–(4) follow straightforwardly from
inductive hypothesis.
X
X
yi (xi ).Pi , and ∆ = (~y,p) :
e  yi di .Ti , ∆0 and ∀i ∈ I : yi ∈ ~y and
• [TRcv] Then, P =
i∈I

i∈I

Γ, xi : di ` Pi . ∆, (~y,p) : Ti .
There are two cases,
(1) α = yj dj with j ∈ I. Then, ∆0 = ∆, (~y,p) : Tj . The proof is completed by taking
P 0 = Pj , and βe = , and E = e0 = true, and σ 0 = σ[xj 7→ v], and Γ0 = Γ, xi : di ,
e

e0 `α

and ∆00 = ∆0 . Note that hP, σi −−−→ hP 0 , σ 0 i by [SRec]. Condition σ 0 n (∆00 ; e; P 0 ; Γ0 )
follows straightforwardly from σ n (∆; e; P ; Γ).
(2) α 6= u n (~y). Hence, n(α) ∩ ~y = ∅. The case follows analogously to rule [VReq].
e`α

Lemma A.22. If hP, σi −−→ hP 0 , σ 0 i, then e ↓ σ = true.
e0 `α

Proof. By straightforward induction on the structure of the proof hP, σi −−−→ hP 0 , σ 0 i.
A.4. Subject reduction. We first state an auxiliary property about the semantics of
systems.
e`α

Lemma A.23. If hS, σi −−→ hS 0 , σ 0 i then dom(σ) ⊆ dom(σ 0 ).
e`α

Proof. By induction on the derivation of hS, σi −−→ hS 0 , σ 0 i inspecting the rules in Figure 4
and 5.
e0 `α

Theorem 8.2 (Subject reduction). If e Γ ` S . ∆, σ n (e; Γ; S; ∆), and hS, σi −−−→
hS 0 , σ 0 i then there exist Γ0 and ∆0 such that
yd

(1) if α = yv then ∆ −→ ∆0 for a sort d; moreover, if ` v : d then there is x ∈ X such that
e ∧ e0

Γ0 , x : d ` S 0 . ∆0 ,

σ 0 (x) = v,

and

σ 0 n (e ∧ e0 ; Γ0 , x : d; S 0 ; ∆0 )

yd

(2) if α = yv then ∆ −→ ∆0 with ` v : d, e ∧ e0 Γ0 ` S 0 . ∆0 , and σ 0 n (e ∧ e0 ; Γ0 ; S 0 ; ∆0 )
α
(3) otherwise ∆ −
→ ∆0 , and e ∧ e0 Γ0 ` S 0 . ∆0 , σ 0 n (e ∧ e0 ; Γ0 ; S 0 ; ∆0 ).
e0 `α

Proof. The proof is by induction on the derivation of hS, σi −−−→ hS 0 , σ 0 i which may end
with the application of one of the rules in Figure 4 (on page 15) or in Figure 5 (on page 15).
It is a simple observation that if α 6= τ then S must be a process, so the proof ends with
one of the rules in Figure 4.
Base cases.
• [SReq] In this case α = u n (~y), e0 = true and
u n (~y)

hu n (~y).P , σi −−−→ hP, σ[~y 7→ u]i
| {z }
| {z }
=S

with S 0 = P

=σ 0

under the hypothesis that ~y ∩ dom(σ) = ∅. By inspecting the typing rules in Figure 10
(page 29), S can be typed only by using rule [VReq], whose hypothesis yields


∆(u) ≡ G(~y)
e Γ ` P . ∆, (~y,0) : T
a nf(T) = a nf(G(~y) 0)
(A.1)

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:53

We show (3) taking ∆0 = ∆, (~y,0) : T. We have that
u n (~y)

∆ −−−→ ∆0

and

e ∧ e0

Γ ` S 0 . ∆0

respectively by rule [TReq] and by the judgment in (A.1) observing that e0 = true and
S 0 = P . It remains to prove that σ 0 n (e ∧ e0 ; Γ; S 0 ; ∆0 ):
(1) We have dom(Γ) ⊆ dom(σ) ⊆ dom(σ) ∪ ~y = dom(σ 0 ) where the first inclusion is
implied by σ n (e; Γ; S; ∆). By definition, dom(∆0 ) = dom(∆) ∪~y, hence dom(∆0 |Y ) =
(dom(∆|Y )) ∪ ~y. Moreover, σ n (e; Γ; S; ∆) implies (dom(∆|Y )) ⊆ dom(σ). Consequently,
(dom(∆0 |Y )) = (dom(∆|Y )) ∪ ~y ⊆ dom(σ) ∪ ~y = dom(σ 0 )
(2) By definition of σ 0 , σ 0 |X = σ|X , hence ` σ 0 (x) : Γ(x) for all x ∈ dom(Γ) since
σ n (e; Γ; S; ∆) implies ` σ(x) : Γ(x) for all x ∈ dom(Γ).
(3) From σ 0 |X = σ|X and σ n (e; Γ; S; ∆), which implies e ↓ σ = true by (3) in Definition 8.1; we have e ∧ e0 ↓ σ 0 = true.
(4) Note that σ n T implies σ 0 n T because σ 0 |X = σ|X . Therefore, for all (~y,p) ∈ dom(∆),
we have that σ 0 n ∆(~y,p) because σ n ∆(~y,p) (which is ensured by σ n (e; Γ; S; ∆)).
Finally, σ 0 n ∆0 (~y,0) follows from Lemma A.19.
• [SAcc] Analogous to the previous case.
• [SRcv] We have
X
yj v
h yi (xi ).Pi , σi −−→ hPj , σ[xj 7→ v]i
where
S 0 = Pj
| {z }
i∈I
=σ 0
{z
}
|
=S

with α = yj v for some j ∈ I. As above e0 = true and, by typing rule [VRcv], we have
X
(A.2)
∆ = ∆00 , (~y,p) :
e  yi di .Ti
∀i ∈ I : e Γ, xi : di ` Pi . ∆0i
i∈I

where

∆0i

=

∆00 , (~y,p)

: Ti for each i ∈ I. We show (1) taking ∆0 = ∆0j . From rule [TRcv],

y j dj

we have ∆ −−→ ∆0 . In addition, if ` v : dj then take x = xj and d = dj . Judgment
e ∧ e0 Γ ` S 0 . ∆0 is derived from the j th judgment in (A.2) by noticing that e0 = true.
Then, observing that dom(σ 0 ) = dom(σ) ∪ {x}, we prove that σ 0 n (e ∧ e0 ; Γ; S 0 ; ∆0 ) as
follows:
(1) We have dom(Γ, x : d) = dom(Γ)∪{x} ⊆ dom(σ)∪{x} = dom(σ 0 ) since σn(e; Γ; S; ∆)
implies dom(Γ) ⊆ dom(σ). Noting that dom(∆0 ) = dom(∆), we have dom(∆0 |Y ) =
dom(∆|Y ) ⊆ dom(σ) because σ n (e; Γ; S; ∆).
(2) Let Γ0 = Γ ∪ {x}. If ` v : d, then σ 0 (x) = v : d = Γ0 (x). We conclude that
σ(x0 ) = σ(x0 ) : Γ0 (x0 ) for all x0 6= x ∈ dom(Γ0 ) by σ n (e; Γ; S; ∆). If it is not the case
that ` v : d, then there is nothing to prove.
(3) Since e0 = true, e ∧ e0 ↓ σ 0 = true trivially holds and σ n (e; Γ; S; ∆) implies
e ↓ σ = true. In addition, σ 0 (x) = σ(x) for all x ∈ dom(σ). Hence, e ↓ σ 0 = true,
which implies (e ∧ e0 ) ↓ σ 0 = true.
(4) By Lemma A.19 we have the thesis.
• [SSend] In this case α = yv with S = y e1 , e1 ↓ σ = v, e0 = true, S 0 = 0 and σ 0 = σ. Hence,
S can be typed only by applying rule [VSend], which yields
Γ ` e1 : d

y ∈ ~y

∆ = ∆00 , (~y,p) : e  y d; e  end

18:54

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

where ∆00 (y~0 ,p) = eend for all (y~0 ,p) ∈ dom(∆00 ). We show (2) taking ∆0 = ∆00 , (~y,p) : end.
Note that, from the hypothesis σ n (e; Γ; S; ∆), we have ` σ(x) : Γ(x) for all x ∈ dom(Γ),
yd

hence ` v : d. From rule [TSend], ∆ −→ ∆0 and, by rule [VEnd], e ∧ e0 Γ ` 0 . ∆0 .
It is straightforward to conclude that σ 0 n (e ∧ e0 ; Γ; 0; ∆0 ) because σ n (e; Γ; S; ∆),
dom(∆0 ) = dom(∆), σ 0 = σ, and e0 = true.
• [SInit] We have
τ

→ h(ν~y@ u)(P0 | . . . |Pn |~y : ∅), σ[~y 7→ u]i
hu n (~y).P0 |u 1 (~y).P1 | . . . |u n (~y).Pn , σi −
{z
}
|
{z
} | {z }
|
=S 0

=S

=σ 0

Γ ` S . ∆ is obtained by repeated application of rule [VPar] on


∆0 (u) ≡ G(~y)
e Γ ` P0 . ∆0 , (~y,0) : T0
a T0 = a G(~y) 0

The judgment e

e

[VReq]

Γ ` u n (~y).P0 . ∆0

and
∆p (u) ≡ G(~y)

e

Γ ` Pp . ∆p , (~y,p) : Tp
e



a Tp = a G(~y) p

Γ ` u p (~y).Pp . ∆p

[VAcc]

with p ∈ {1, . . . , n}, ∆ = ∆0 ∪ ∆1 ∪ · · · ∪ ∆n , under the assumption that ∆1 , . . . , ∆n are
pairwise independent. We show (3) by taking ∆0 = ∆ and observing that, by rule [VNew],
we have

e Γ ` P0 | . . . | Pn | ~y : [] . ∆, (~y,p) 7→ Tp p ∈ {0, . . . , n}
e Γ ` S0 . ∆
with the premiss of the above derivation obtained by rule [VEmpty] and repeated applications
of rule [VPar]. To show that σ 0 n (e; Γ; S 0 ; ∆) we note that dom(σ 0 ) = dom(σ) ∪ ~y by
construction and that
n
n
[
[
0
fy(S ) =
fy(Pp ) \ ~y =
(fx(Pp ) \ ~y) = fy(S)
p=0

p=0

therefore conditions (1), and (4) of Definition 8.1 hold by inductive hypothesis while
conditions (2) and (3) hold because σ 0 |X = σ|X .
• [SForEnd] We have ` ↓ σ = ε and
τ

→ h0, σi
hfor
| x in{z` do P}, σi −

with S 0 = 0, σ 0 = σ, and e0 = true

=S

Since e ↓ σ = true (because σ n (e; Γ; S; ∆)) we have e ∧ ` = ε 6` ⊥ and, consequently,
[VForEnd] is the only applicable rule to type S. Therefore we have ∆ = ∆0? for an end-only
∆0 (by the premiss of [VForEnd]). Finally, we have that (3) holds by rule [TLoop1 ] and
σ n (e; Γ; 0; ∆0 ) directly follows by σ n (e; Γ; S; ∆).

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:55

Inductive step.
• [SThen] In this case
e0 ↓ σ = true

e `α

1
hP1 , σi −−
−→ hP10 , σ 0 i

e0 ∧e `α

1
hif e0 then P1 else P2 , σi −−−−
−→ hP10 , σ 0 i
|
{z
}

=S

with

S0

=

P10 .

To type S we must apply rule [VIf]
e ∧ e0

Γ ` P1 . ∆1

e ∧ ¬e0

Γ ` P2 . ∆2

Γ ` if e0 then P1 else P2 . ∆1 ./∆2
| {z }

e

[Vif]

=∆

recall that ∆1 ./∆2 is defined when ∆1 and ∆2 are mergeable (i.e., dom(∆1 ) = dom(∆2 )
and the pseudo-types ∆1 (~y,p) and ∆2 (~y,p) are mergeable for all (~y,p) ∈ dom(∆1 )).
By the inductive hypothesis, there exist Γ0 and ∆01 such that
yd

(1) if α = yv then ∆1 =⇒ ∆01 ; moreover, if ` v : d then
e ∧ e1 ∧ e0

Γ0 , x : d ` P10 . ∆01
yd

and σ 0 n (e ∧ e1 ∧ e0 ; Γ0 , x : d; P10 ; ∆01 ). By Lemma B.2, ∆ = ∆1 ./∆2 =⇒ ∆01 . Then,
take ∆0 = ∆01 and note that
e ∧ (e1 ∧ e0 )

Γ0 , x : d ` P10 . ∆0

and σ 0 n (e ∧ (e0 ∧ e0 ); Γ, x : d; P10 ; ∆0 ) hold by associativity of ∧.
(2) and (3) analogous to the previous case.
• [SElse] Analogous to [SThen].
• [SSeq] We have
e0 `α

hP1 , σi −−−→ hP10 , σ 0 i
e0 `α

hP1 ; P2 , σi −−−→ hP10 ; P2 , σ 0 i
| {z }
| {z }
=S 0

=S

As in the previous case, we can type S only applying [VSeq]. This implies that ∆ = ∆1 ; ∆2
for some ∆1 and ∆2 such that
– dom(∆2 ) ⊆ dom(∆
1 ) and ∆1 |U∪Y = ∆2 |U∪Y = ∆|U∪Y


∆1 (~y,p); ∆2 (~y,p) (~y,p) ∈ dom(∆2 )
– ∆ : (~y,p) 7→ ∆1 (~y,p)
(~y,p) ∈ dom(∆1 ) \ dom(∆2 )


undef
otherwise
– e Γ ` P1 . ∆1 and e Γ ` P2 . ∆2 .
By the inductive hypothesis, there are Γ0 and ∆01 such that
yd

(1) if α = yv then ∆1 −→ ∆01 for a sort d; also, if ` v : d then there is x ∈ X such that
σ 0 (x) = v, e ∧ e0 Γ0 , x : d ` P10 . ∆01 and σ 0 n (e ∧ e0 ; Γ0 , x : d; P10 ; ∆01 )
yd

(2) if α = yv then ∆1 −→ ∆01 with ` v : d, σ 0 n(e ∧ e0 ; Γ0 ; P10 ; ∆01 ), and e ∧ e0 Γ0 ` P10 . ∆01
α
(3) otherwise ∆1 −
→ ∆01 , σ 0 n (e ∧ e0 ; Γ0 ; P10 ; ∆01 ), and e ∧ e0 Γ0 ` P10 . ∆01
In any case, by rule [TSeq] we have that
α

∆ = ∆1 ; ∆2 −
→ ∆01 ; ∆2 = ∆0

18:56

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

and the proof concludes with the application of rule [VSeq] to the judgement typing P10 and
e Γ0 ` P2 . ∆2 observing that dom(Γ0 ) ⊆ dom(Γ) and dom(∆2 ) ⊆ dom(∆1 ) ⊆ dom(∆01 )
where the latter inclusion holds because the domain of a specification may only grow
after transitions (by inspection of the rules in Figure 12) and, for the same reason,
∆2 |U∪Y = ∆1 |U∪Y = ∆01 |U∪Y since ∆01 and ∆1 differ at one participant’s session only.
• [SFor] We have
` ↓ σ 6= ε

e0 `α

hP, σ[x 7→ hd(` ↓ σ)]i −−−→ hP 0 , σ 0 i
e0 `α

0
; for x in tl(`) do P , σ 0 i
hfor
| x in{z` do P}, σi −−−→ hP
{z
}
|
=S

(A.3)

S0

The first premiss of (A.3) implies e ∧ ` 6= ε 6` ⊥, hence the only applicable rule to type
S is [VFor] which we instantiate as:
Γ ` ` : [d]

e

Γ, x : d ` P . ∆1
e

x 6∈ var(∆1 )

∆1 active

Γ ` for x in ` do P . ∆∗1
|{z}

(A.4)

=∆

for some ∆1 . In order to use the inductive hypothesis, we check that
σ[x 7→ hd(` ↓ σ)] n (e; Γ, x : d; P ; ∆1 )
In fact, from σ n (e; Γ; S; ∆) we have that
(1) dom(Γ, x : d) = dom(Γ) ∪ {x} ⊆ dom(σ) ∪ {x} = dom(σ[x 7→ hd(` ↓ σ)]); also,
dom(∆1 |Y ) ⊆ dom(σ) ⊆ dom(σ[x 7→ hd(` ↓ σ)])
(2) for all z ∈ dom(Γ) we have ` σ[x 7→ hd(` ↓ σ)] : Γ(z) since σ[x 7→ hd(` ↓ σ)](z) = σ(z);
moreover, Γ ` ` : [d] implies that Γ ` hd(` ↓ σ) : d and therefore hd(` ↓ σ) = σ[x 7→
hd(` ↓ σ)](x) has sort d
(3) since e ↓ σ = true, x 6∈ var(e) and therefore e ↓ σ[x 7→ hd(` ↓ σ)] = true
(4) ∀(~y,p) ∈ dom(∆1 ), σ[x 7→ hd(` ↓ σ)] n ∆1 (~y,p) follows from Lemma A.19.
We proceed by case analysis on α. First note that By Lemma A.20, we can exclude the
case α = yv because ∆1 is active. We consider the case α = yv (the proof in the other
cases is analogous and simpler and therefore omitted). Assume that ` v : d0 . By the
yd0

inductive hypothesis on (A.3) and (A.4), there exists ∆1 −−→ ∆01 such that
e ∧ e0

Γ, x : d ` P 0 . ∆01

with σ 0 n (e ∧ e0 ; Γ, x : d; P 0 ; ∆01 )

(A.5)

∆0

We show how to find an environment
required in (2) depending on the possible typings
of for x in tl(`) do P .
If e ∧ e0 ∧ tl(`) = ε 6` ⊥ then, using rule [VForEnd], we have
e ∧ e0

Γ, x : d ` for x in tl(`) do P . ∆01 |U∪Y
(A.6)
since ∀(~y,p) ∈ dom(∆01 |U∪Y ) : (∆01 |U∪Y )(~y,p) = end vacuously holds. Then, from (A.5)
and (A.6), we derive e ∧ e0 Γ, x : d ` S 0 . ∆01 ; (∆01 |U∪Y ) by using rule [VSeq]. Finally,
yd0

∆ = ∆?1 −−→ ∆01 by [TLoop1 ] and the thesis follows by observing that ∆01 = ∆01 ; (∆01 |U∪Y )
since dom(∆01 ) ∩ dom(∆01 ; (∆01 |U∪Y )) ⊆ U ∪ Y by definition of ; on specifications (cf.
page 26).

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:57

If e ∧ e0 ∧ tl(`) 6= ε 6` ⊥ then, using rule [VFor],
Γ ` tl(`) : [d]

Γ, x : d ` P . ∆1

e
e

∆1 active

x 6∈ var(∆1 )

Γ, x : d ` for x in tl(`) do P . ∆∗1

(A.7)

where Γ ` tl(`) : [d] holds because Γ ` ` : [d] and the conditions in the rest of the hypothesis
of (A.7) hold by the typing (A.4). By Lemma A.14 and Lemma A.10 on the conclusion,
from (A.7)
e ∧ e0

Γ, x : d ` for x in tl(`) do P . ∆00

(A.8)

where ∆00 = ∆?1 [(~y,p) 7→ e0  end; ∆?1 (~y,p)](~y,p)∈dom(∆?1 ) .
We now show that ∆01 ; ∆00 and ∆01 ; ∆ are defined and equivalent. Note that dom(∆00 ) =
yd

dom(∆) = dom(∆1 ) ⊆ dom(∆01 ) because ∆1 −→ ∆01 . For the equivalence, we just need to
consider session names; let (~y,p) ∈ dom(∆01 ; ∆00 ), we have two cases: if (~y,p) 6∈ dom(∆00 )
then (∆01 ; ∆00 )(~y,p) = ∆01 (~y,p) = (∆01 ; ∆)(~y,p) by the definition of ; and if (~y,p) ∈ dom(∆00 )
then
(∆01 ; ∆00 )(~y,p) = ∆01 (~y,p); ∆00 (~y,p);
by def. of ;
= ∆01 (~y,p); (e0  end; ∆(~y,p)); by def. of ∆00
= ∆01 (~y,p); ∆(~y,p);
by Lemma A.7
By rule [VSeq], with the judgments in (A.5) and (A.8), we have
e ∧ e0

Γ, x : d ` S 0 . ∆01 ; ∆

(A.9)

yd

and ∆ = ∆?1 −→ ∆01 ; ∆ = ∆0 by rule [TLoop2 ].
It remains to show that σ 0 n (e ∧ e0 ; Γ, x : d; S 0 ; ∆0 ) holds:
(1) It follows immediately from (A.5) and the fact that dom(∆0 ) = dom(∆01 ).
(2) Trivially from (A.5).
(3) Immediate from (A.5);
(4) By Lemma A.19.
• [SLoopEnd] We have
e0 `α

hM, σi −−−→ hP, σ 0 i
e0 `α

hrepeat N until M , σi −−−→ hP, σ 0 i
|
{z
}

with S 0 = P

=S

and the only applicable rule to type S is [VLoop]:
e

Γ ` N . ∆1

e
e

Γ ` M . ∆2

∆1 and ∆2 passively compatible

Γ ` repeat N until M . ∆?1 ; ∆2

with ∆ = ∆?1 ; ∆2 . The inductive hypothesis requires to have σ n (e; Γ; M ; ∆2 ), which
easily follows because (1)-(3) are immediate from σ n (e; Γ; S; ∆) and (4) follows from
Lemma A.19. Note that α has to be an input label yv because M is a choice process.
yd

Hence, there exist Γ0 and ∆2 −→ ∆02 and if ` v : d then
e ∧ e0

Γ0 , x : d ` P . ∆02

and

σ 0 n (e ∧ e0 ; Γ0 , x : d; P ; ∆02 )
yd

Then, take ∆0 = ∆02 and note that by [TLoop0 ] ∆ = ∆?1 ; ∆2 −→ ∆0 .

18:58

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

• [SLoop] We have
e0 `α

hN, σi −−−→ hP, σ 0 i

M=

X
yi (xi ).Pi

∀i ∈ I.yi 6∈ fy(α)

i∈I
e0 `α

(A.10)

hrepeat N until M , σi −−−→ hP ; repeat N until M , σ 0 i
|
{z
}
|
{z
}
=S 0

=S

and, as in the case [SLoopEnd], the only applicable rule to type S is [VLoop]:
Γ ` N . ∆1

e

e
e

Γ ` M . ∆2

∆1 and ∆2 passively compatible

Γ ` repeat N until M . ∆?1 ; ∆2

with ∆ = ∆?1 ; ∆2 . The inductive hypothesis requires to show σ n (e; Γ; N ; ∆1 ), which holds
because (1)-(3) are immediate from σ n (e; Γ; S; ∆) and (4) follows from Lemma A.19.
Note that α has to be an input label yv because N is a choice process. Hence, there exist
yd

Γ0 and ∆1 −→ ∆01 and if ` v : d then
e ∧ e0

Γ0 , x : d ` P . ∆01

and

σ 0 n (e ∧ e0 ; Γ0 , x : d; P ; ∆01 )
yd

Then, take ∆0 = ∆01 ; ∆?1 and note that by [TLoop2 ] ∆ = ∆?1 ; ∆2 −→ ∆0 . Finally, the thesis
follows by applying [VSeq].
• [SCom1 ] In this case:
e0 `yv

hP, σi −−−→ hP 0 , σ 0 i
e0 `τ

hP |y[~v], σi −−−→ hP 0 |y[~v · v], σ 0 i
| {z }
| {z }
=S 0

=S

and, by rule [VPar], we have the following typing for S:
=∆

e

z }|1 {
Γ ` P . ∆ \ {y : ~d} e

=∆

z }|2 {
Γ ` y[~v] . ∆|U , y : ~d ∆1 and ∆2 independent

e Γ ` S . ∆
where the typing of the queue y[~v] is obtained by repeated applications of the rule [VQueue]
ending with an application of [VEmpty] and Lemma A.10; hence, ` ~~v : ~d. Note that
∆ = ∆1 ∪ ∆2 . We now observe that σ n (e; Γ; P ; ∆1 ) and σ n (e; Γ; P ; ∆2 ) directly follow
from σ n (e; Γ; S; ∆) (since dom(∆1 ) ∪ dom(∆2 ) ⊆ dom(∆)) so, by inductive hypothesis,
yd

∆1 −→ ∆01

and σ 0 n (e ∧ e0 ; Γ0 ; P 0 ; ∆01 )
for some environment Γ0 . We now show that we can type S 0 with ∆0 = ∆01 ∪ {y : ~d · d}:
` v: d
e ∧ e0 Γ0 ` y[~v] . y : [~d]
e ∧ e0 Γ0 ` P 0 . ∆01
[VQueue]
e ∧ e0 Γ0 ` y[~v · v] . y : ~d · d
with

` v : d e ∧ e0

Γ ` P 0 . ∆01

[VPar]

e ∧ e0 Γ0 ` S 0 . ∆0
where the judgement in the premiss of [VQueue] holds by Lemma A.10 and the application
of [VPar] is possible because ∆01 and y : ~d · d are independent. The proof of this case
ends by showing that σ 0 n (e ∧ e0 ; Γ0 ; P 0 ; ∆0 ): we have that (1) of Definition 8.1 holds
because fy(S 0 ) = fy(P 0 ) ∪ {y} while dom(∆0 |Y ) = dom(∆01 |Y ) ∪ {y} by definition and, by
Lemma A.23, dom(σ) ⊆ dom(σ 0 ); also, conditions (2) and (3) hold because σ 0 |X = σ|X
while (4) holds because for each (~y,p) we have ∆0 (~y,p) = ∆(~y,p) by construction.

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:59

• [SCom2 ] In this case:
e0 `yv

hP, σi −−−→ hP 0 , σ 0 i
e0 `τ

hP |y[v · ~v], σi −−−→ hP 0 |y[~v], σ 0 i
| {z }
| {z }
=S 0

=S

and, assuming ∆1 = ∆ \ {y : d · ~d}, we observe that σ n (e; Γ; P ; ∆1 ) directly follows from
σ n (e; Γ; S; ∆) (since dom(∆1 ) ⊆ dom(∆)) so, by inductive hypothesis. We can type S
as follows
e Γ ` P . ∆1
e Γ ` y[v · ~v] . ∆|U , y : d · ~d
Γ ` S . ∆
by using rule [VPar] since ∆1 and ∆|U , y : d · ~d are independent and the typing of the queue
y[v · ~v] is obtained by repeated applications of the rule [VQueue] ending with an application
yd
of [VEmpty], which yields ` ~v : d and ` ~~v : ~d. By the inductive hypothesis ∆1 −→ ∆01 and
there are Γ0 and x ∈ X such that e Γ0 , x : d ` P 0 . ∆01 and σ 0 n (e; Γ0 , x : d; P 0 ; ∆01 ).
We now show that we can type S 0 with ∆0 = ∆01 ∪ {y : ~d}:
e ∧ e0 Γ0 , x : d ` P 0 . ∆0
e ∧ e0 Γ0 , x : d ` y[~v] . y : ~d
e

1

e0

[VPar]

Γ0 , x

e∧
: d ` S 0 . ∆0
where the second judgment in the premiss holds by Lemma A.10 and the application of
[VPar] is possible because ∆01 and y : ~
d are independent since y 6∈ dom(∆01 ) otherwise ∆1
would not be independent of ∆|U , y : ~d. The proof of this case ends by showing that
σ 0 n (e ∧ e0 ; Γ0 , x : d; P 0 ; ∆0 ). Since fy(S 0 ) = fy(P 0 ) ∪ {y}, we have that (1) of Definition 8.1
holds; also, dom(∆0 |Y ) = dom(∆01 |Y ) ∪ {y} by definition and, by Lemma A.23, dom(σ) ⊆
dom(σ 0 ); also, conditions (2) and (3) hold because σ 0 |X = σ|X and σ 0 (x) = v has
sort d = Γ0 (x); finally, (4) holds because for each (~y,p) we have ∆0 (~y,p) = ∆(~y,p) by
construction.
• [SPar] In this case we have:
e0 `α

hS1 , σi −−−→ hS10 , σ 0 i bn(α) ∩ dom(σ) = ∅

fx(S2 ) ∩ (dom(σ 0 ) \ dom(σ)) = ∅

e0 `α

hS1 |S2 , σi −−−→ hS10 |S2 , σ 0 i
| {z }
| {z }
=S

=S 0

and the only applicable rule to type S is [VPar]:
e1 Γ ` S1 . ∆1
e 2 Γ ` S2 . ∆2
e1 ∧ e2
| {z }
=e

∆1 and ∆2 independent

Γ ` S1 |S2 . ∆1 ∪ ∆2
| {z }
=∆

Noting that σ n (e; Γ; S; ∆) trivially implies σ n (e1 ; Γ; S1 ; ∆1 ), by the inductive hypothesis
there Γ0 and ∆01 such that
yd

(1) if α = yv then ∆1 −→ ∆01 for a sort d; also, if ` v : d then there is x ∈ X such that
σ 0 (x) = v, e1 ∧ e0 Γ0 , x : d ` S10 . ∆01 and σ 0 n (e1 ∧ e0 ; Γ0 , x : d; S10 ; ∆01 )
yd

(2) if α = yv then ∆1 −→ ∆01 with ` v : d, σ 0 n (e1 ∧ e0 ; Γ; S10 ; ∆01 ), and e1 ∧ e0
S10 . ∆01
α
(3) otherwise ∆1 −
→ ∆01 , σ 0 n (e1 ∧ e0 ; Γ0 ; S10 ; ∆01 ), and e1 ∧ e0 Γ0 ` S10 . ∆01

Γ `

18:60

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

In the first two cases ∆01 and ∆2 are independent because dom(∆01 ) = dom(∆1 ) and
∆1 and ∆2 are independent. In the latter case, we observe that σ 0 n (e1 ∧ e0 ; Γ0 ; S10 ; ∆01 )
implies dom(∆01 ) ⊆ dom(σ 0 ); moreover, σ 0 can contain a new session, say ~y only if the
rule [SInit] had been used to derive the transition. In this case, the side condition of [SInit]
guarantees that ~y 6∈ dom(σ) and therefore they do not occur in S2 and therefore they are
not in dom(∆2 ) since σ n (e; Γ; S; ∆). The judgement e2 Γ0 ` S2 . ∆2 holds because
condition fx(S2 ) ∩ (dom(σ 0 ) \ dom(σ)) = ∅ makes fx(S2 ) ∩ dom(Γ0 ) = ∅, hence we apply
Lemma B.3.
• [SNew] In this case we have:
e0 `α

hS1 , σi −−−→ hS10 , σ 0 i

~y ∩ fy(α) = ∅

e

e0 `α

h(ν~y@u)S1 , σi −−−→ h(ν~y@u)S10 , σ 0 i
| {z }
| {z }

Γ ` S . ∆0
e

∆ = ∆0 |−~y

Γ ` (ν~y@u)S . ∆

=S 0

=S

where on the right we have the typing of S obtained by applying rule [VNew]. The
thesis immediately follows from the inductive hypothesis since fy(S) = fy(S1 ) \ ~y and
fy(S 0 ) = fy(S10 ) \ ~y.
• [SStr] The thesis is immediate by using the inductive hypothesis.

Appendix B. WSI by typing
B.1. Correspondence between semantics of specifications. The next results show
that the denotational semantics of specifications coincides with the operational rules given
in Figure 12.
α

α

Lemma B.1. If ∆ −
→ ∆0 then ∆, ∆00 −
→ ∆0 , ∆00 .
α

Proof. By straightforward induction on the structure of the proof ∆ −
→ ∆0 .
α

α

Lemma B.2. ∆1 −
→ ∆01 , then ∆1 ./∆2 −
→ ∆01 .
α

Proof. By induction on the structure of the derivation ∆1 −
→ ∆01 .
Lemma B.3. R~y (∆1 , ∆2 ) = R~y (∆1 ) if dom(∆2 ) ∩ ~y = ∅.
Proof. By straightforward induction on the structure of the proof r ∈ R~y (∆1 , ∆2 ).
α

Lemma B.4. Let ∆ be a specification and ~y ∈ dom(∆). If ∆ −
→ ∆0 and n(α) ∩ ~y = ∅, then
0
∆(~y,p) = ∆ (~y,p) for all (~y,p) ∈ ∆.
α

Proof. By straightforward induction on the structure of the proof ∆ −
→ ∆0 .
Lemma 8.5. Let ∆ be a specification such that for all (~y,p) ∈ dom(∆), ∆(~y,p) is in normal
τ
form. If ∆ −
→ ∆0 , then for all r ∈ R~y (∆0 ) either:
• r ∈ R~y (∆), or
• hp, ydir ∈ R~y (∆), or else
• hq, y dir ∈ R~y (∆).
τ

Proof. By induction on the structure of the proof ∆ −
→ ∆0 .

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

• [TCom1 ]: ∆ = ∆1 , (~y,p) :

M
i∈I

18:61

ei  yi di .Ti , yj : [~d] and ∆0 = ∆1 , (~y,p) : Tj , yj : [~d · dj ]. Then,

by [RTCom1 ], r ∈ R~y (∆0 ) implies hp, ydir ∈ R~y (∆).
X
• [TCom2 ]: ∆ = ∆1 , (~y,p) :
ei  yi di .Ti , yj : [dj · ~d] and ∆0 = ∆1 , (~y,p) : Tj , yj : [~d]. Then,
i∈I

•

•

•
•
•

by [RTCom2 ], r ∈ R~y (∆0 ) implies hp, yj dj ir ∈ R~y (∆).
~0 ,p0 ) : T0 , . . . , (y~0 ,pn ) : Tn , y~0 : []. By well-formedness conditions
[TInit]: Then, ∆0 = ∆, (y
on specifications, ~y ⊆ dom(∆) implies ~y ∩ ~y0 . The case follows by using Lemma B.3 to
conclude that R~y (∆0 ) = R~y (∆).
τ
→ ∆01 . By rule [RTSeq], r = r1 r2 with
[TSeq]: Then, ∆ = ∆1 ; ∆2 , and ∆0 = ∆01 ; ∆2 with ∆1 −
r1 ∈ R~y (∆01 ) and r2 ∈ R~y (∆2 ). By inductive hypothesis, r1 ∈ R~y (∆01 ) implies r1 ∈ R~y (∆1 ),
hp, ydir1 ∈ R~y (∆1 ), hq, y dir1 ∈ R~y (∆1 ), or r1 = r10 r20 r30 and r10 [r20 ]r30 ∈ R~y (∆1 ). Then, the
proof is completed by using rule [RTSeq].
[TLoop0 ]: Then, ∆0 = ∆ U. By inspection of rules in Figure 14, we conclude that r ∈ R~y (∆0 )
implies r = . Then, r ∈ R~y (∆) by [RTEnd].
[TLoop1 ]: Then, ∆ = ∆?1 and ∆0 = ∆1 . By [RTIt1], r ∈ R~y (∆0 ) implies r ∈ R~y (∆).
[TLoop2 ]: Then, ∆ = ∆?1 and ∆0 = ∆1 ; ∆?1 . By inspection of rules in Figure 14, we
conclude that r ∈ R~y (∆0 ) implies r = r1 r2 with r1 ∈ R~y (∆1 ) and r2 ∈ R~y (∆?1 ). By [RTIt2],
r1 [r2 ] ∈ R~y (∆).

Lemma 8.6. Let ∆ a specification such that for all (~y,p) ∈ dom(∆), ∆(~y,p) is in normal
τ
form. If r ∈ R~y (∆) and r 6=  then ∆ −
→ ∆0 and either
• r ∈ R~y (∆0 ), or
• r = hp, ydir0 and r0 ∈ R~y (∆0 ), or
• r = hq, ydir0 , or else and r0 ∈ R~y (∆0 ).
Proof. The proof follows by induction on the structure of proof r ∈ R~y (∆).
• [RTCom1 ] follows immediately by taking r = hp, ydir0 with r0 ∈ R~y (∆0 ) and using [TCom1 ].
• [RTCom2 ] follows immediately by taking r = hp, ydir0 with r0 ∈ R~y (∆0 ) and using [TCom2 ].
• [RTSeq] Then ∆ = ∆1 ; ∆2 , r = r1 r2 with r1 ∈ R~y (∆1 ) and r2 ∈ R~y (∆2 ). The proof is
τ
completed by using inductive hypothesis on r1 ∈ R~y (∆1 ) to conclude that ∆1 −
→ ∆01 .
τ
Then, by [TSeq], ∆ = ∆1 ; ∆2 −
→ ∆01 ; ∆2 . Finally, take ∆ = ∆01 ; ∆2 and use rule [RTSeq] to
conclude that either r ∈ R~y (∆0 ) or r0 ∈ R~y (∆0 ).
• [RTIt1]. Then ∆ = ∆?1 and r ∈ R~y (∆1 ). The proof is completed by taking ∆0 = ∆1 and
τ
using rule [TLoop1 ] to derive ∆ −
→ ∆0 .
• [RTIt2]. Then ∆ = ∆?1 and r = r1 [r2 ] with r1 ∈ R~y (∆1 ) and r1 ∈ R~y (∆?1 ). The proof is
τ
completed by taking ∆0 = ∆1 ; ∆?1 and using rule [TLoop2 ] to derive ∆ −
→ ∆0 .
B.2. Runs of Specifications.
Lemma B.5. Let r ∈ R~y (∆, (~y,p) :

X

yi di .Ti ) and y ∈ ~y and y =
6 yi for all i ∈ I, then

i∈I

r ∈ R~y (∆, (~y,p) : y d; T +

X

yi di .Ti ).

i∈I

Proof. By straightforward induction on the structure of the proof.

18:62

Vol. 16:3

L. Bocchi, H. Melgratti, and E. Tuosto

Lemma B.6. Let r ∈ R~y (∆, (~y,p) :

M

yi di .Ti ) and y ∈ ~y and y 6= yi for all i ∈ I, then

i∈I

r ∈ R~y (∆, (~y,p) : y d; T ⊕

M

yi di .Ti ).

i∈I

Proof. By straightforward induction on the structure of the proof.


Lemma B.7. Let ∆ and ∆0 be two specifications such that a ∆(~y,p) = a ∆(~y,p) for all
(~y,p) ∈ dom(∆0 ). Then, R~y (∆) = R~y (∆0 ).
Proof. It follows by straightforward induction on the derivation of r ∈ R~y (∆) after noticing
that guards are irrelevant for deriving runs.
B.3. Specifications cover Global types.
Lemma B.8. Let G(~y) , G be a global type with P(G) = {p0 , . . . , pn } and ∆ = (~y,p0 ) : G
e ∗f ) ⊆ R~y (∆? ).
p0 , . . . , (~y,pn ) : G pn ,~y : []. If R(G) ⊆ R~y (∆), then r ∈ R(G
f

e ∗ )
Proof. By induction on the structure of the derivation r ∈ R(G
• [RG∗1 ]: then r ∈ R(G). By hypothesis, r ∈ R~y (∆). By [RTIt1], r ∈ R~y (∆? ).
e ∗f ). By hypothesis, r1 ∈ R~y (∆). By
• [RG∗1 ]: then r = r1 [r2 ], r1 ∈ R(G) and r2 ∈ R(G
inductive hypothesis r2 ∈ R~y (∆? ). By [RTIt2], r1 [r2 ] ∈ R~y (∆? ).
Theorem 8.7 (Coverage & projections). Let G(~y) , G be a global type with P(G) =
{p0 , . . . , pn } and ∆ = (~y,p0 ) : T0 , . . . , (~y,pn ) : Tn ,~y : [] such that a Ti = nf(G pi ) for all
0 ≤ i ≤ n. Then R(G) b R~y (∆).
Proof. We show a stronger result proving that R(G) ⊆ R~y (∆), which obviously implies
R(G) b R~y (∆). We proceed by induction on the derivation of r ∈ R(G). We proceed by
case analysis on the last applied rule in the derivation of r ∈ R(G).
• Case [RGEnd]: Follows straightforwardly from rule [RTEnd] observing that G = end and ∆ is
end-only by the definition of
Pprojection (cf. on page 9).
• Case [RGCom]: Then, G = i∈I p _ qi : yi di ; Gi and r = hp, yh dh , σihqh , yh dh ir0 for an
h ∈ I and an r0 ∈ R(Gh ).
Then, letting Ji = {j ∈ I qj = qi } and Ki = I \ Ji for all i ∈ I
M
X
X
G p =
yi di .Gi p
G qi =
yj dj .Gj  r +
Gk r
i∈I

j∈Ji

k∈Ki

By inductive hypothesis, we know that
r0 ∈ Ry ((~y,p0 ) : Gh p0 , . . . , (~y,pn ) : Gh pn ,~y : [])

(B.1)

By repeatedly applying Lemma B.5 over (B.1), for each pi =
6 ph , we conclude that


~y 7→ []




(~y,p) 7→ Gh p
0
0
0
r ∈ Ry (∆ )
where
∆ : (~y,qh ) 7→ Gh qh



(~y,q) 7→ G q
if q 6∈ {p, qh }



undefined
otherwise

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:63

The proof is completed by using rules [RTCom1 ] and [RTCom2 ] as follows:
r0 ∈ Ry (∆0 )
[RTCom2 ]
hqh , yh dh ir0 ∈ Ry (∆0 [~y, (~y,qh ) 7→ [dh ], G qh ])
hp, yh dh , σihqh , yh dh ir0 ∈ Ry (∆)

[RTCom1 ]

• Case [RGSeq]: Then G = G1 ; G2 and r = r1 r2 with ri ∈ R(Gi ) for i ∈ {1, 2} and
ri ∈ Ry ((~y,p0 ) : Gi p0 , . . . , (~y,pn ) : Gi pn ,~y : [])
by inductive hypothesis; hence, by rule [RTSeq]
r1 r2 ∈ Ry ((~y,p0 ) : G p0 , . . . , (~y,pn ) : G pn ,~y : [])
f

• Case [RGIter]: Then, G = G∗1 with P(G1 ) = {p0 , p1 , . . . , pn }, rdy(G1 ) = p0 , f (pi ) = yi di
e ∗f ).
for all 1 ≤ i ≤ n, and r = r0 hp0 , y1 d1 ihp1 , y1 d1 i . . . hp0 , yn dn ihpn , yn dn i with r0 ∈ R(G
Therefore,
∆ = (~y,p0 ) : (G1 p0 )? ; y1 d1 ; . . . ; yn dn , (~y,p1 ) : (G1 p1 )? ; y1 d1 , . . . ,
(~y,pn ) : (G1 p1 )? ; yn dn ,~y : []
Note that ∆ can be written as the sequential composition ∆ = ∆?1 ; ∆2 where
∆1 = (~y,p0 ) : (G1 p0 ), (~y,p1 ) : (G1 p1 ), . . . , (~y,pn ) : (G1 pn ),~y : []
∆2 = (~y,p0 ) : y1 d1 ; . . . ; yn dn , (~y,p1 ) : y1 d1 , . . . , (~y,pn ) : yn dn ,~y : []
Then, by repeated used of rules [RTCom1 ] and [RTCom2 ] we can build a proof for r00 =
hp0 , y1 d1 ihp1 , y1 d1 i . . . hp0 , yn dn ihpn , yn dn i ∈ R~y (∆2 ), as illustrated by the following sketch
 ∈ R~y ((~y,p0 ) : end, . . . , (~y,pn ) : end,~y : [])

[RTEnd]

..
.
[RTCom1 ]

hp0 , y2 d2 ihp2 , y2 d2 i . . . hp0 , yn dn ihpn , yn dn i ∈
R~y (∆2 [(~y,p1 ), (~y,p0 ) 7→ end, y2 d2 ; . . . ; yn dn ])
[RTCom2 ]
hp1 , y1 d1 ihp0 , y2 d2 ihp2 , y2 d2 i . . . hp0 , yn dn ihpn , yn dn i ∈
∈ R~y (∆2 [y1 , (~y,p0 ) 7→ [d1 @ p0 ], y2 d2 ; . . . ; yn dn ])
r00 ∈ R~y (∆2 )

[RTCom1 ]

e ∗f ) implies r0 ∈ R~y (∆? ). By inductive hypothesis, R(G1 ) ⊆
We now show that r0 ∈ R(G
1
1
e ∗f ) ⊆ R~y (∆? ). Therefore, r0 ∈ R(G
e ∗f ) implies r0 ∈ R~y (∆? ).
R~y (∆1 ). By Lemma B.8, R(G
1
1
By [RTSeq], r = r0 r00 ∈ R~y (∆?1 ; ∆2 ) since r0 ∈ R~y (∆?1 ) and r00 ∈ R~y (∆2 ).

18:64

L. Bocchi, H. Melgratti, and E. Tuosto

Vol. 16:3

B.4. Implementations cover specifications.
Definition B.9 (Viable types). A pseudo-type T is viable if either of the following holds
• nf(T) = eM
 end
X
• nf(T) =
ei  yi di .Ti or nf(T) =
ei  yi di .Ti with Ti viable for all i ∈ I
i∈I

i∈I

• nf(T) M
= T?1 ; T2 with T1 and T2 viable, and either T1 and T2 passively compatible or
T1 =
ei  yi di .Ti .
i∈I

A specification ∆ is viable when every type in ∆ is viable.
Lemma B.10. Let G(~y) a global type and ∆ a specification such that (i) dom(∆) =
{(~y,q) q ∈ P(G)} and (ii) ∆ : (~y,q) 7→ G q for all q ∈ P(G). Then ∆ is viable.
E`e
α

In what follows we write hS, σi ,−−→ hS 0 , σ 0 i with E = e1 ∧ . . . ∧ en and α
e = α1 . . . αn
e `α

e `α

e `α

1
2
n
n
for the sequence hS, σi −−1−−→
hS2 , σ2 i −−2−−→
. . . −−
−−→
hS 0 , σi. Let n(α) = fy(α) ∪ bn(α);
the definitions of n( ), fy( ) and bn( ) straightforwardly extend to sequences of labels.

Lemma B.11. Let T be a viable pseudo-type and e such that nf(e, T) = T. Then, there exist Γ
0
0
and P and
 ∆ and0 T such that for any ~y ⊇ fy(T) and p it holds that e Γ ` P . ∆, (~y,p) : T
and a T = a T .
Proof. The proof follows by induction on the structure of T.
• T = eM
j  end. It follows immediately by using rule [VEnd].
ei  yi di .Ti . Note that nf(e, T) = T implies nf(e, Ti ) = Ti for all i ∈ I. Then,
• T=
i∈I

by inductive hypothesis there exist Γi , Pi , ∆
 i , Ti for
 any ~y ⊇ fy(Ti ) and p it holds
0
0
that e Γi ` Pi . ∆i , (~y,p) : Ti and a Ti = a Ti . Then, take s and x fresh, i.e.,
s 6∈ dom(∆00 , . . . , ∆0n ) and x 6∈ dom(Γ00 , . . . , Γ0n ) and note that
e

Γi , x : d ` Pi . ∆i , (~y,p) : T0i , (s,p0 ) : e  end

for any d and p0 . By Lemma A.14,
e ∧ e0i

Γi , x : d ` Pi . ∆0i , (~y,p) : T0i , (s,p0 ) : e0  end

with e0i = x 6= 0 ∧ . . . ∧ x 6= i − 1 ∧ x = i and

∆0i (~y,p) = e ∧ e0i  end; ∆i (~y,p)
T0i
= e ∧ e0i  end; Ti
0
e  end = e ∧ e0i  end; e  end

0
0
By definition
of nf(

 , ), Ti = nf(e ∧ ei , Ti ). Since x 6∈ fn(T) and nf(e, T) = T we have
0
that a Ti = a Ti . Moreover, by typing rules [VSend] and [VSeq],

e ∧ e0i

Γi , x : d ` yi ci ; Pi . ∆00i

such that ci is some constant of type di and
M

∆00i (~y,p) = e ∧ e0i  yi di ; ∆0i (~y,p)

∆00i (~y,p). Note that T0 is well-defined (because the guards in all types
i∈I




are different) and a T0 = a T because a T0i = a Ti holds for every i.

Then, take T0 =

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:65

Finally, define ∆ = ∆0 , . . . , ∆n , (~y,p) : T0 , (s,p0 ) : e  end, and ∆ = ∆0 , . . . , ∆n and
P = s(x).if x = 0 then P0 else if x = 1 then P1 else . . .. The proof is concluded by straightforward
use of typing rules.
X
•
ei  yi di .Ti . It follows analogously to the previous case.
•

i∈I
T?1 ; T2

with T1 with T1 =

M
i∈I

ei  yi di .Ti . It follows by inductive hypothesis on both T1

and T2 to conclude that there exist P1 and P2 and by taking P = for x in ` do P1 ; P2 .
• T?1 ; T2 and T1 and T2 passively compatible. It follows by inductive hypothesis on both T1
and T2 to conclude that there exist P1 and P2 and by taking P = repeat P1 until P2 .
Lemma B.12. If e Γ ` P . ∆ and x 6∈ fx(P ) then, for all x0 ∈ X, e Γ|−x0 [x 7→ Γ(x0 )] `
P {x/x0 } . ∆0 where ∆0 |U∪Y = ∆|U∪Y and for all (~y,p) ∈ dom(∆), ∆0 (~y,p) = ∆(~y,p){x/x0 }.
Proof. Trivial, observing that typing does not depend on the identity of the variables used
in processes.
Definition B.13. Let ι~y@u be a ι-implementation of a global type G at u, e a guard,
Γ an environemnt, and ∆ a specification. We say that ι~y@u , Γ0 ⊇ Γ, and specification
∆0 = (∆q )q∈P(G) are compatible with e, Γ, and ∆ if
• the queue on each y ∈ ~y in ι~y@u is typed as ∆(y) and
• for all q ∈ P(G)
e



Γ0 ` ι(q) . ∆q and a ∆q (~y,q) = a ∆(~y,q)

(B.2)

Lemma B.14. Let G(~y) be a global type, ∆ be a viable specification such that ~y ⊆ dom(∆)
and (~y,q) ∈ dom(∆) for all q ∈ P(G), and let e Γ ` P . ∆0 be a judgement where
∆0 (~y,p) = ∆(~y,p) for a participant p ∈ P(G). For all r ∈ R~y (∆) there are ι~y@u , an
environment Γ0 , and a specification ∆0 compatible with e, Γ, and ∆ such that
(1) ι(p) = P
(2) for all σ n (∆0 ; e; ι~y@u ; Γ0 ) there is r0 ∈ Rhι~y@u , σi such that r l r0 .
Proof. By induction on the structure of the derivation r ∈ R~y (∆). In the proof, ` ι(~y) : ∆(~y)
shortens ` y[~v] : ∆(y) for all y ∈ ~y where y[~v] is the queue on y in ι~y@u .
• [RTEnd] Then, r =  and for all q ∈ P(G), ∆(~y,q) = eq  end and ∆(~y) = []. Now we show
that each condition holds.
(1) Take ι(p) = P , and ι(q) = 0 for all q 6= p, and ` ι(~y) : [].
(2) Let Γ0 = Γ, ∆p = ∆0 and ∆q : (~y,q) 7→ e  end for all q 6= p.
(a) Then condition (B.2) holds for participant p by the hypothesis e Γ ` P .
∆0 = ∆p , and straightforwardly for participants q 6= p observing that e Γ `
ι(q) . ∆q and guard removals coincide since all local types are end.
(b) For condition (2) it is enough to take any store σ mapping each free variable x of
P in a value of type Γ(x) so that e evaluates to true in σ (the existence of such
values is guaranteed by the typing of P ). This also entails (4) of Definition 8.1.
Finally, note that r0 =  ∈ Rhι~y@u , σi from [REnd] and r l r0 follows from [l-emp].
M
• [RTCom1 ] There is q ∈ P(G) such that ∆(~y,q) =
ei  yi di .Ti and r = hq, yj dj ir1 with
i∈I

j ∈ I and r1 ∈ R~y
where
= ∆[(y,q), ~y 7→ Tj , [~d · dj ]]. Note that ∆00 is viable and
that ∆(~y,q) 6= false  end, which implies ¬(ej ⇐⇒ false).
(∆00 )

∆00

18:66

L. Bocchi, H. Melgratti, and E. Tuosto

Vol. 16:3

We distinguish two cases.
Case q = p. By Lemma A.21, we know that for any σ0 such that σ0 n (e; Γ; P ; ∆0 ) it
e0 `y v

E`β
j
e ∩ ~y = ∅, and
holds that hP, σ0 i ,−−→ hP 00 , σ1 i −−−−→ hP 0 , σ2 i with ` v : dj , and n(β)
0
¬(e ∧ E ∧ e ⇐⇒ false). By applying Theorem 8.2 to the hypothesis e Γ ` P . ∆0
and σ0 , we have
e

βe0

y j dj

∆0 ,−
→ ∆01 −−→ ∆02 , e ∧ E ∧ e0 Γ00 ` P 0 . ∆02 , and Γ ⊆ Γ00
(B.3)
(where the sequence βe0 is the sequence βe where expressions are replaced by their sorts).
By Lemma B.4, n(βe0 ) ∩ ~y = ∅ implies ∆0 (~y,r) = ∆0 (~y,r) = ∆(~y,r) for all r ∈ P(G).
1

Moreover, ∆02 (~y,p) = Tj
r1 ∈ R~y (∆00 ) and (B.3),

yj dj

because of the reduction ∆01 −−→ ∆02 . By inductive hypothesis on
we know that there are ιih~y@u , Γih ⊇ Γ00 , and ∆ih = (∆ih
r )r∈P(G)
compatible with e ∧ E ∧ e0 , Γ00 , and ∆02 . Namely,
(1) ιih (p) = P 0 and


ih y,r) = a ∆00 (~
(2) e ∧ E ∧ e0 Γih ` ιih (r) . ∆ih
y,r) , for all r ∈ P(G)
r and a ∆r (~
(3) for all σ ih n(∆ih ; e ∧ E ∧ e0 ; ιih~y@u ; Γih ) there is r1ih ∈ Rhιih~y@u , σ ih i such that r1 lr1ih .
Then, let
– ι(p) = P , and ι(q) = ιih (q) for all q 6= p ∈ P(G), and ι(yj ) = [~v] where ιih (yj ) = [~v · v]
(note that (1) and the definition of ∆00 imply that ιih (yj ) is a non-empty queue); this
implies ` ιih (yj ) : [~d · d] since [~d · d] = ∆00 (yj ). Observe that for all y ∈ ~y \ {yj } we have
` ι(y) : ∆00 (y) since ιih (y) = ι(y) and ∆(y) = ∆00 (y).
– Note that Γih ⊇ Γ since Γih ⊇ Γ00 and Γ00 ⊇ Γ by (B.3). Let ∆p = ∆0 and ∆r = ∆0r for
all r 6= p; then
(1) by the validity of e Γ ` P . ∆0 and the fact that Γih ⊇ Γ, we have e Γih `
ι(p) . ∆p applying Lemma A.10. For r 6= p ∈ P(G), the validity of the judgement
in (2) implies the validity
var(E ∧ e0 ) are not bound
 of e 00Γ ` ι(r) . ∆r because

in ι(r). Also, a ∆r (~y,r) = a ∆ (~y,r) = a ∆(~y,r) where the first equality holds
by the inductive hypothesis S
and the second by (2).
(2) Let σ be σ ih restricted on r∈P(G) dom(∆r |Y ) ∪ dom(Γih ). Then the first three
conditions of Definition 8.1 are trivially satisfied, e evaluates to true in σ since
σ|var(e) = σ ih |var(e) , and likewise for the last condition of consistency.
– Note that r = hp, yj dj ir1 l hp, yj dj ir1ih = r0 follows from [l-cmp] and (3). The fact that
e followed by
r0 ∈ ι~y@u follows by repeated applications of rule [RExt] (once for any β ∈ β)
an application of [RSnd].
Case q 6= p. By inductive hypothesis on r1 ∈ R~y (∆00 ) and (B.3), we know that there are
0
00
0
ιih~y@u , Γih ⊇ Γ00 , and ∆ih = (∆ih
r )r∈P(G) compatible with e ∧ E ∧ e , Γ , and ∆2 . Namely,
ih
(1) ι (p) = P


(2) e Γih ` ιih (r) . ∆ih
and a ∆ih
(~y,r) = a ∆00 (~y,r) , for all r ∈ P(G)
r
r
S
ih
ih
ih
ih
ih
(3) for all store σ ih n ( r∈P(G) ∆ih
r ; e; ι ~y@u ; Γ ) there is r1 ∈ Rhι ~y@u , σ i such that
r1 l r1ih .
Then, let

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:67

– ι(yj ) = [~v] where ιih (yj ) = [~v · v] (the proof that queues y ∈ ~y are typed by ∆00 is as in
the previous case p = q) and


p 7→ P
ι : r 7→ ιih (r)
∀r ∈ P(G) \ {p, q}


ih
q 7→ s(x).if x then yj v; ι (q) else Q
S
with s and x fresh (formally, s 6∈ r∈P(G) dom(∆ih
r ), and x 6∈ dom(Γ), and ` v : dj ) and
Q a process such that the following judgement holds:
M
ei  yi di .Ti
e ΓQ ` Q . ∆Q where ∆Q (~y,q) =
i∈I\{j}

The above judgment exists for the type T =

M
i∈I\{j}

ei  yi di .Ti by Lemma B.11, since

nf(e, T) = T applying Lemma A.15 to the hypothesis e
wlog we can assume that fx(Q) are fresh.
– Let Γ0 = Γ ∪ ΓQ and

Γ ` P . ∆0 . By Lemma B.12

∆p = ∆ 0
∆q = ∆ih
q [∆Q ][(y,q) 7→ ∆(y,q)][(s, ) 7→ s bool; end]
if r 6∈ {p, q}
∆r = ∆ih
r
(1) by the validity of e Γ ` P . ∆0 and the fact that Γih ⊇ Γ, we have e Γih ` ι(p) .
∆p applying Lemma A.10. For all (y,r)
∈ dom(∆0 ) with r ∈ P(G)

 \ {p, q} we have
that ∆00 (y,r) = ∆0 (y,r) and a ∆r (~y,r) = a ∆00 (~y,r) = a ∆(~y,r) by the inductive
hypothesis. The validity of e Γ0 ` ι(q) . ∆q holds by weakening (Lemma B.1)
and the application of rules [VIf] and [VRcv] to the judgment e ΓQ ` Q . ∆Q
above.
(2) Let σ be an extension of σ ih with assignments to the free variables of Q so that no
guard in Q is falsified. Then the first three conditions of Definition 8.1 trivially follow
from the inductive hypothesis, and the last condition follows from Lemma A.19.
– From (3) we know that r1ih ∈ Rhιih~y@u , σ ih i. Consequently, we conclude that r1ih ∈
Rhιih~y@u , σ ih [x 7→ true]i holds. Moreover,
hι(q), σi

`strue

−−−−→

`yj v

hyj v; ιih (q), σ[x 7→ true]i −−−→

hιih (q), σ[x 7→ true]i

Hence, hq, yj dir1ih ∈ Rhι~y@u , σi which covers hq, yj dir1 by the inductive hypothesis.
• [RTCom2 ] The proof follows analogously to the previous case.
• [RTSeq] Then ∆ = ∆1 ; ∆2 and r = r1 r2 with r1 ∈ R~y (∆1 ) and r2 ∈ R~y (∆2 ). Note that ∆1
and ∆2 are viable, otherwise ∆ would not be viable. Given the structure of ∆, the typing
of P can be achieved with an application of [VSeq], [VLoop], or [VSend].
• [VSeq] We have P = P1 ; P2 ; then there are specifications ∆01 and ∆02 such that e Γ `
Pi . ∆0i for i ∈ {1, 2}, ∆0 = ∆01 ; ∆02 . We consider two cases depending on whether
∆01 = (∆00 )? for some ∆00 .
When there is no ∆00 such that ∆01 =
6 (∆00 )? we proceed as follows. For i ∈ {1, 2},
0
ih
by inductive hypothesis on ri ∈ R~y (∆i ) we know that there are ιih
i ~y@u , Γi ⊇ Γ, and
0
∆ih
i = (∆i,r )r∈P(G) compatible with e, Γ, and ∆i . Namely,
(1) ιih
i (p) = Pi and


(2) e Γih
` ιih
y,r) = a ∆0i (~y,r) , for all r ∈ P(G)w
i
i (r) . ∆i,r and a ∆i,r (~

18:68

L. Bocchi, H. Melgratti, and E. Tuosto

Vol. 16:3

ih
ih
ih
ih
ih
ih
(3) for all σiih n (∆ih
i ; e; ιi ~y@u ; Γi ) there is ri ∈ Rhιi ~y@u , σi i such that ri l ri .
Now let

ι(r)
ι(y)
Γ0
∆0
σ

=
=
=
=
=

ih
ιih
∀r ∈ P(G)
1 (r); ι2 (r)
ih
ι1 (y)
∀y ∈ ~y
ih
ih
Γ1 ∪ Γ2
∆01 ; ∆02
σ1ih

and observe that ∆0 is defined otherwise compatibility would be violated, contradicting
the inductive hypothesis.
If ∆01 = (∆00 )? for some ∆00 , we note that ∆1 = (∆0 )? for some ∆0 because they are the
same when restricted to participants’ session of p. Then, r1 has been obtained by using
either [RTIt1 ] or [RTIt2 ]. Consequently, either r1 ∈ R~y (∆00 ) or r1 = r0 [r3 ] with r0 ∈ R~y (∆00 ).
We consider r1 ∈ R~y (∆00 ) (the other case follows analogously). Since ∆01 = (∆00 )?
and e Γ ` P1 . (∆00 )? , P1 = for x in ` do P0 and e Γ ` P0 . ∆00 . As before,
we apply inductive hypothesis on ∆0 , ∆00 , P0 , and ro ; we hence obtain a system ιih
1 ~y@u ,
ih
ih
ih
an environment Γ1 , and a specification ∆1 such that ι1 (p) = P0 and for all stores
ih
ih
ih
ih
ih
ih
σ1ih n (∆ih
1 ; e; ι1 ~y@u ; Γ1 ) there is r1 ∈ Rhι1 ~y@u , σ1 i such that r1 l r1 . Likewise,
ih
proceeding as in the case of [VSeq] above, there are a system ιih
2 ~y@u , an environment Γ2 ,
ih
ih
ih
ih
ih
ih
and a specification ∆2 such that ι2 (p) = P2 and for all stores σ2 n (∆2 ; e; ι2 ~y@u ; Γ2 )
ih
ih
there is r2ih ∈ Rhιih
2 ~y@u , σ2 i such that r2 l r2 . The proof ends by taking
ι(p) = P
ih
ι(r) = repeat ιih
1 (r) until ι2 (r)
ι(y)
Γ0
∆0
σ

=
=
=
=

ιih
1 (y)
ih
Γih
1 ∪ Γ2
∆01 ; ∆02
σ1ih

∀r 6= p ∈ P(G)

∀y ∈ ~y

The case r1 = r0 [r3 ] with r0 ∈ R~y (∆00 ) is analogous.
• [VLoop] The thesis follows as in the previous case noticing that P = repeat M until N (that
is, P plays a passive role in the loop) and then using the inductive hypothesis on the
premisses of the typing of P and observing that ∆ is viable, hence there it yields an active
role deciding when to terminate the loop.
• [VSend] The thesis follows trivially as in the cases [RTCom1 ] and [RTCom2 ] by observing that
∆0 assigns to the participant session (~y, p) an output on a session channel y ∈ ~y.
Note that [RTIt1] and [RTIt2] cannot be the last rules applied in a derivation of r ∈ R~y (∆).
Theorem 8.8 (Typeability & coverage). Let G(~y) , G be a global type
 with P(G) =
{p0 , . . . , pn } and ∆ = (~y,p0 ) : T0 , . . . , (~y,pn ) : Tn ,~y : [] such that a Ti = nf(G pi ) for
all 0 ≤ i ≤ n. If e Γ ` P . ∆0 , (~y,pi ) : Ti then the set I = {ι~y@u | e Γ `
ι~y@u . ∆, ∆00 ∧ ι(pi ) = P } covers R~y (∆), i.e., R~y (∆) b RI.
Proof. The proof follows directly from Lemma B.14.

Vol. 16:3

ON RESOLVING NON-DETERMINISM IN CHOREOGRAPHIES

18:69

Appendix C. Whole-spectrum implementations and Guarded Automata
In this section we briefly discuss how our notion of whole-spectrum implementation (WSI)
can be defined when specifications and implementations are defined as Guarded Automata.
We first recall some basic definitions from [21]: (P, M ) is a composition schema
where P = {p1 , . . . , pn } is a set of participants and M are the messages (i.e., the alphabet), R = h(P, M ), Ai is a conversation protocol where A is a guarded automaton,
W = h(P, M ), A1 , . . . , An i is a web service composition, L(R) = L(A) is the language of a
conversation protocol. For a web service composition W = h(P, M ), A1 , . . . , An i we have
runs, send sequences and conversations;
(1) a run of W is a sequence of configurations γ = c0 , c1 , . . . , cn where:
• c0 is an initial configuration
• ci → ci+1 (i = 0 . . . n − 1)
• cn is a final configuration
(2) a send sequence γ on a run γ is the sequence messages, one for each send action in γ,
recorded in the order in which they are sent,
(3) a conversation is a word w over M for which there is a run γ of W such that w = γ,
(4) the conversations of a web service W , written C(W ), is the set of all the conversations
for W .
We are now ready to introduce a notion of WSI for guarded automata.
Definition C.1 (Whole-spectrum realisation of a guarded automaton). Let P be a set
of participants defined as {p1 , . . . , pn }. Ai is a whole-spectrum realisation of pi ∈ P in
conversation protocol R = h(P, M ), Ai if for all w ∈ L(R) there exist {Aj }j∈{1,...,n}\{i} such
that w ∈ C(< (P, M ), A1 , . . . , An >).
Definition C.2 (WSI of guarded automaton). Ai is a WSI of pi in conversation protocol
R = h(P, M ), Ai if: (1) Ai is a deterministic guarded automaton, and (2) Ai is a wholespectrum realisation of pi in R = h(P, M ), Ai.

This work is licensed under the Creative Commons Attribution License. To view a copy of this
license, visit https://creativecommons.org/licenses/by/4.0/ or send a letter to Creative
Commons, 171 Second St, Suite 300, San Francisco, CA 94105, USA, or Eisenacher Strasse
2, 10777 Berlin, Germany

