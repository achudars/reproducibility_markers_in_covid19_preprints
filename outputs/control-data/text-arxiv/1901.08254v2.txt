1

A Systematic Construction of MDS Codes
With Small Sub-packetization Level and
Near-Optimal Repair Bandwidth
arXiv:1901.08254v2 [cs.IT] 21 Nov 2020

Jie Li, Member, IEEE, Yi Liu, Graduate Student Member, IEEE, and Xiaohu Tang, Senior Member, IEEE

Abstract—In the literature, all the known high-rate MDS
codes with the optimal repair bandwidth possess a significantly
large sub-packetization level, which may prevent the codes to be
implemented in practical systems. To build MDS codes with small
sub-packetization level, existing constructions and theoretical
bounds imply that one may sacrifice the optimality of the
repair bandwidth. Partly motivated by the work of Tamo et al.
(IEEE Trans. Inform. Theory, 59(3), 1597-1616, 2013), in this
paper, we present a transformation that can greatly reduce the
sub-packetization level of MDS codes with the optimal repair
bandwidth with respect to the same code length n. As applications
of the transformation, four high-rate MDS codes having both
small sub-packetization level and near-optimal repair bandwidth
can be obtained, where three of them are explicit and the required
field sizes are around or even smaller than the code length n.
Additionally, we propose another explicit MDS code which has
a similar structure as that of the first resultant code obtained by
the generic transformation, but can be built on a smaller finite
field.
Index Terms—Distributed storage, high-rate, MDS codes, subpacketization, repair bandwidth.

I. I NTRODUCTION

I

N distributed storage systems such as Hadoop Distributed
File System (HDFS) and Google File System (GFS), redundancy is imperative to ensure reliability. An attractive solution
is to call upon the maximum distance separable (MDS) codes,
which provide the optimal tradeoff between fault tolerance
and storage overhead. By distributing the codeword across
distinct storage nodes, in the case of node failures, the missing
data can be recovered from the data at some surviving nodes,
named helper nodes as well. For this scenario, one of the most
important parameters is the repair bandwidth, which is defined
as the amount of data downloaded from the helper nodes to
repair the failed node. Particularly, Dimakis et al. [1] derived
a lower bound on the repair bandwidth of MDS codes, which
motivated abundant recent research in coding for distributed
storage [2]–[20].
The work of J. Li was supported in part by the National Science Foundation
of China under Grant 61801176. The work of Y. Liu and X. Tang was
supported in part by the National Natural Science Foundation of China under
Grant 61871331 and Grant 61941106. This paper was presented in part at the
2019 IEEE International Symposium on Information Theory.
J. Li is with the Department of Mathematics and Systems Analysis, Aalto
University, FI-00076 Aalto, Finland, and also with the Hubei Key Laboratory
of Applied Mathematics, Faculty of Mathematics and Statistics, Hubei University, Wuhan 430062, China (e-mail: jie.0.li@aalto.fi, jieli873@gmail.com).
Y. Liu and X. Tang are with the Information Security and National Computing Grid Laboratory, Southwest Jiaotong University, Chengdu, 610031, China
(e-mail: yiliu.swjtu@outlook.com; xhutang@swjtu.edu.cn).

In the literature, most existing MDS codes with the repair
bandwidth achieving the lower bound in [1] are a kind of
array codes. A codeword of an (n, k) array code is an N × n
matrix, where the parameter N is called the sub-packetization
level and n is called the code length. When deploying an array
code to a distributed storage system, a code symbol (i.e., a
column) corresponds to a storage node. Then, an array code
is said to have the MDS property if any k out of the n columns
of the matrix can recover the remaining n − k columns. It was
proved in [1] that the repair bandwidth γ(d) of an (n, k) MDS
array code with sub-packetization level N should satisfy
γ(d) ≥ γ ∗ (d) ,

d
N,
d−k+1

(1)

where d (k ≤ d ≤ n − 1) is the number of helper nodes. An
MDS array code is said to have the optimal repair bandwidth if
γ(d) = γ ∗ (d), i.e., the amount of data downloaded from each
N
. In the particular case, when d = n − 1,
helper node is d−k+1
n−1
∗
γ (d) can be reduced to the minimal value n−k
N . Therefore,
d = n − 1 is the main concern in the most known works
[3]–[11]. In this paper, we also follow the same setting and
thus abbreviate γ ∗ (n − 1) to γ ∗ . Especially, we focus on MDS
array codes, and refer to them as MDS codes for simplicity.
Up to now, various MDS code constructions with the
optimal repair bandwidth have been proposed, among which
some notable works are [2]–[5], [11]–[18]. However, in the
high-rate regime, all the known (n, k) MDS code constructions
with the optimal repair bandwidth possessn a significantly large
sub-packetization level N , i.e., N ≥ r r+1 where r = n − k
[9]. In [21], it was shown that for an (n, k) MDS code with the
optimal repair bandwidth, a sub-packetization level N being
exponential in the square root of k is necessary. Very recently,
Alrabiah and Guruswami [22] further improved the lower
bound on N to being exponential in k nand they conjectured
that the construction in [9] with N = r r+1 is exactly tight. An
MDS code with a larger sub-packetization level can lead to a
reduced design space in terms of various system parameters
and make management of meta-data difficult. Moreover, the
implementation in practical systems is a big challenge [23].
Existing constructions and theoretical bounds imply that
one may construct high-rate MDS codes with small subpacketization level by sacrificing the optimality of the repair
bandwidth. In [23], two high-rate (n, k) MDS codes with small
sub-packetization level were presented. The first one can have
a sub-packetization level as small as N = rτ where r = n − k
and τ is a positive integer with 1 ≤ τ ≤ ⌈ nr ⌉ − 1, while

2

the repair bandwidth is no larger than (1 + τ1 )γ ∗ . However,
the code is constructed over a significantly large finite field
Fq with q > n(r−1)N +1 , which may hinder its deployment
in practical systems. The second MDS code is obtained by
combining an MDS code with the optimal repair bandwidth
and another error-correcting code with specific parameters.
The proposed codes, therefore, rely on the existence of the
latter, which may not always be available. For convenience, we
refer to the two codes in [23] as RTGE code 1 and RTGE code
2 in this paper. In [3], an (n = sk ′ + 2, k = sk ′ ) MDS code
′
with sub-packetization level 2k −1 and near-optimal repair
bandwidth only for systematic nodes was proposed, which
is termed duplication-zigzag code in this paper. In fact, the
duplication-zigzag code is constructed based on s-duplication
of the (k ′ + 2, k ′ ) zigzag code, but can only support two parity
nodes.
In this paper, we aim to construct high-rate MDS codes
that have both small sub-packetization level and near-optimal
repair bandwidth for general parameters n and k over a small
finite field Fq . Partly motivated by the work in [3], we present
a transformation that can convert any (n′ = k ′ + r, k ′ ) MDS
code with the optimal repair bandwidth that is defined in
the parity-check matrix form into another (n = k + r, k)
MDS code with much longer code length. Specifically, the
repair bandwidth of the new MDS code is upper bounded by
(1 + nr′ )γ ∗ , but the sub-packetization level is kept unchanged,
or equivalently the generic transformation can reduce the subpacketization level N of the original codes with respect to
the same code length n. By directly applying the generic
transformation to several known high-rate MDS codes with the
optimal repair bandwidth, we get four high-rate (n, k) MDS
codes with both small sub-packetization level N and nearoptimal repair bandwidth, three of which are explicit and the
required field sizes are around or smaller than the code length
n. Besides, we propose another new MDS code which has a
similar structure as that of the first resultant code obtained by
the generic transformation, but can be built on a smaller finite
field. The obtained MDS codes outperform the RTGE code 1
in [23] in terms of the field size, and the first codes in both
[12] and [15] as well as the RTGE code 2 in [23] in terms
of the sub-packetization level. As a matter of convenience, we
refer to the first two codes in [12] respectively as YB code 1
and YB code 2, while referring to the first code in [15] as the
improved YB code 2 (since it is an improvement of the YB
code 2 in [12] with respect to the field size).
The remainder of the paper is organized as follows. Section
II reviews some necessary preliminaries. Section III proposes
the generic transformation and its asserted properties. Section
IV demonstrates several applications of the generic transformation, three of which are explicit. Section V presents another
new explicit construction of high-rate MDS code over a small
finite field that has a small sub-packetization level, nearoptimal repair bandwidth, and the optimal update property.
Section VI gives comparisons of key parameters among the
MDS codes proposed in this paper and some existing notable
MDS codes. Finally, Section VII concludes the study.

II. P RELIMINARIES
In this section, we introduce some preliminaries on highrate MDS codes, and a series of special partitions for a given
basis set.
A. (n, k) MDS codes
Denote by q a prime power and Fq the finite field with q
elements. For any two integers a and b with b > a, denote
by [a, b) the set {a, a + 1, . . . , b − 1}. Let f0 , f1 , . . . , fn−1 be
the data stored across a distributed storage system consisting
of n nodes based on an (n, k) MDS code, where fi is a
column vector of length N over Fq . Throughout this paper,
we consider (n, k) MDS codes that permit a definition in the
following parity-check form:



f0
A0,0
A0,1
···
A0,n−1


 A1,0
A1,1
···
A1,n−1 

  f1 

 = 0rN , (2)
 ..

.
..
.
.
..
..
 .
  .. 
.
fn−1
Ar−1,0 Ar−1,1 · · · Ar−1,n−1
{z
}
|
A

where r = n − k ≥ 2, 0rN denotes the zero column vector
of length rN , and will be abbreviated as 0 in the sequel if its
length is clear. The rN × nN block matrix A in (2) is called
the parity-check matrix of the code, which can be written as
A = (At,i )t∈[0,r),i∈[0,n)

to indicate the block entries.
For every t ∈ [0, r), by (2), we have

n−1
P

At,i fi = 0,

i=0

which contains N linear equations. Particularly, we say that
n−1
P
At,i fi = 0 is the t-th parity-check group.
i=0

B. The MDS property
An (n, k) MDS code defined by (2) possesses the MDS
property that the source file can be reconstructed by connecting
to any k out of the n nodes. That is, any r×r sub-block matrix
of (At,i )t∈[0,r),i∈[0,n) is nonsingular [12].
In particular, if
At,i = Ati , t ∈ [0, r), i ∈ [0, n)

(3)

for some matrices Ai of order N , then we have the following
result.
Lemma 1 ( [12]). An (n, k) code defined by (2) and (3) has
the MDS property if Ai Aj = Aj Ai and Ai −Aj is nonsingular
for all i, j ∈ [0, n) with i 6= j.
C. Repair
When repairing a failed node i (i ∈ [0, n)) of an (n, k) MDS
code, denote by βi,j the amount of data downloaded from
node j, where j ∈ [0, n)\{i}. In fact, the data downloaded
from helper node j can be represented by Ri,j fj , where Ri,j
is a βi,j × N matrix of full rank. Throughout this paper, Ri,j
is called the repair matrix of node i.

3

Clearly, a failed node can be repaired if there are N linearly
independent equations with respect to the N unknowns of fi .
Specially, the N equations should be chosen elaborately so
that the interference in these equations can be cancelled by the
downloaded data Ri,j fj from the helper nodes j ∈ [0, n)\{i}.
In this paper, similar to that in [15], for convenience, we
only consider the symmetric situation where appropriate N/r
linearly independent equations are acquired from each of the
r parity-check groups, which are linear combinations of the
corresponding N parity-check equations. Precisely, these N/r
linearly independent equations can be obtained by multiplying
the t-th parity-check group with an N/r × N matrix Si,t of
full rank, where Si,t is called the select matrix in [15]. As a
consequence, the following linear equations are available.




Si,0 A0,i
Si,0 A0,j
n−1



Si,1 A1,i
X 
Si,1 A1,j




f
+


 fj = 0,

..
..
i




.
.

Ye and Barg showed that an (n, k) MDS code defined in the
form of (2) and (3) has the optimal update property if all the
block matrices of the parity-check matrix are diagonal.

thus regenerating node i requires that
(i) the coefficient matrix of the useful data is of full rank,
i.e.,


Si,0 A0,i


Si,1 A1,i


(4)
rank(
) = N, i ∈ [0, n),
..


.

Vi,t = {ea |ai = t, 0 ≤ a < rm },

j=0,j6=i

Si,r−1 Ar−1,i
|
{z
useful data

}

|

Si,r−1 Ar−1,j
{z

interference by fj

}

Si,r−1 Ar−1,i

(ii) the interference caused by fj can be determinable by
the data Ri,j fj downloaded from node j for all j ∈
[0, n)\{i}, i.e.,


Ri,j


Si,0 A0,j




S
A
i,1 1,j
rank(
) = rank (Ri,j ) ,


..


.
Si,r−1 Ar−1,j
for i, j ∈ [0, n) with i 6= j, which means that


Ri,j
) = rank(Ri,j )
rank(
Si,t At,j

γi =

j=0,j6=i

rank(Ri,j ) =

n−1
X

ei = (0, · · · , 0, 1, 0, · · · , 0), i ∈ [0, rm ),
with only the ith entry being nonzero.
In [11], a series of special partitions of the set
{e0 , · · · , erm −1 } is given for r = 2. These set partitions can
be easily generalized to the case of r ≥ 2, which will play an
important role in our proposed new constructions.
For consistency, we follow the notation in [11] hereafter.
Given an integer 0 ≤ a < rm , denote by (a0 , · · · , am−1 ) its
m−1
P m−1−j
r
aj . For 0 ≤ i < m and
r-ary expansion, i.e., a =
j=0

0 ≤ t < r, define a subset of {e0 , · · · , erm −1 } as

(7)

where ai is the ith element in the r-ary expansion of a.
Moreover, for 0 ≤ t < r, we define a special subset of
{e0 , · · · , erm −1 } as
V∗,t = {ea |a0 + a1 + · · · + am−1 = t, 0 ≤ a < rm },

(8)

where a0 +a1 +· · ·+am−1 is computed modulo r. This special
subset will be used in the MDS code construction in Section
IV-B.
Straightforwardly,
|Vi,t |
=
rm−1 ,
and
{Vi,0 , Vi,1 , · · · , Vi,r−1 } is a partition of the set
{e0 , · · · , erm −1 } for any i ∈ [0, m) ∪ {∗}. Table I gives two
examples of the set partitions defined in (7) and (8).
TABLE I
( A ) AND ( B ) DENOTE THE m + 1 PARTITIONS OF THE SET
{e0 , · · · , er m −1 } DEFINED BY (7) AND (8) FOR m = 3, r = 2, AND
m = 2, r = 3, RESPECTIVELY.
i
Vi,0

(5)

0
e0
e1
e2
e3

1
e0
e1
e4
e5

2
e0
e2
e4
e6

i

*
e0
e3
e5
e6

Vi,1

0
e4
e5
e6
e7

1
e2
e3
e6
e7

*
e1
e3
e8

i

2
e1
e3
e5
e7

*
e1
e2
e4
e7

(A)

for i, j ∈ [0, n) with i 6= j, t ∈ [0, r).
Then, the repair bandwidth of node i is
n−1
X

D. Partition of basis {e0 , · · · , eN −1 }
Assuming that N = rm for two integers r and m with
m
r, m ≥ 2, let e0 , · · · , erm −1 be a basis of Frq . For example,
they can be simply set as the standard basis, i.e.,

i

βi,j .

(6)

j=0,j6=i

As mentioned before, a lower repair bandwidth of a node is
desirable. According to (1), if γi = γ ∗ = (n − 1) Nr , then
node i is said to have the optimal repair bandwidth. If γi ≤
(1 + ǫ)γ ∗ = (1 + ǫ)(n − 1) N
r for a small constant ǫ, then node
i is said to have the near-optimal repair bandwidth [23].
In addition to the (near-) optimal repair bandwidth, an
(n, k) MDS code is also preferred to have the optimal update
property, that is, the minimum number of elements need to
be updated when an information element is changed. In [12],

Vi,0

0
e0
e1
e2

1
e0
e3
e6

*
e0
e5
e7

i
Vi,1

0
e3
e4
e5

1
e1
e4
e7

Vi,2

0
e6
e7
e8

1
e2
e5
e8

*
e2
e4
e6

(B)

Based on the m set partitions in (7), let us define
Vi+sm,t = Vi,t , i ∈ [0, m), s ≥ 1, and t ∈ [0, r).

(9)

Further, for any 0 ≤ i1 , i2 < sm and i1 6≡ i2 mod m, we
define Vi1 ,i2 ,t1 ,t2 = Vi2 ,i1 ,t2 ,t1 = Vi1 ,t1 ∩ Vi2 ,t2 , i.e.,
Vi1 ,i2 ,t1 ,t2 = Vi2 ,i1 ,t2 ,t1
= {ea |ai1 = t1 , ai2 = t2 , a ∈ [0, rm )},

4

where 0 ≤ t1 , t2 < r. Then, we have
Vi1 ,t1 = Vi1 ,i2 ,t1 ,0 ∪ · · · ∪ Vi1 ,i2 ,t1 ,r−1 .

(10)

For the easy of notation, we also denote by Vi1 ,t1 and
Vi1 ,i2 ,t1 ,t2 the rm−1 × rm and rm−2 × rm matrices, whose
rows are formed by vectors ei in their corresponding sets,
respectively, such that i is sorted in ascending order. For
example, when r = 2 and m = 3, V1,0 can be viewed as
a 4 × 8 matrix as follows

⊤ ⊤ ⊤ ⊤
,
V1,0 = e⊤
0 e1 e4 e5

where ⊤ represents the transpose operator.
III. A

GENERIC TRANSFORMATION

In this section, we present a generic transformation that
can convert any MDS code with the optimal repair bandwidth
defined in the form of (2) to a new MDS code with longer
code length and near-optimal repair bandwidth.
A generic transformation: The transformation can be
performed through the following two steps.
Step 1. Choose an (n′ , k ′ ) MDS code with the optimal
repair bandwidth as the base code
We choose an (n′ , k ′ ) MDS code in the form of (2), with
the optimal repair bandwidth over a finite field containing at
least q ′ elements, as the base code. Let N denote its subpacketization level, r = n′ − k ′ , and let (A′t,i )t∈[0,r),i∈[0,n′ )
denote its parity-check matrix while the N/r × N matrices
′
′
, i, j ∈ [0, n′ ) with j 6= i, t ∈ [0, r), respectively
and Si,t
Ri,j
denote the repair matrices and select matrices.
Step 2. Transform the base code to the new MDS code
Through the generic transformation, we intend to design
a new (n = k + r, k) MDS code over a certain finite field
Fq (q > q ′ ) having arbitrary code length n (n > n′ ) while
maintaining the same sub-packetization level N .
The transition from the base code to the new MDS code is
done by designing the parity-check matrix, the repair matrices,
and the select matrices of the new MDS code from those of
the base code as follows.
At,j = xt,j A′t,j%n′ ,
 ′
Ri%n′ ,j%n′ ,
Ri,j =
IN ,

(11)
if j 6≡ i mod n′ ,
otherwise,

Lemma 2 (Theorem 1.2 of [24]). Let Fq be an arbitrary field,
and f = f (x1 , · · · , xn ) be a polynomial in Fq [x1 , · · · , xn ].
n
P
ti , where each ti is a
Suppose that the degree of f is
i=1

nonnegative integer, and the coefficient of

i=1

f (s1 , · · · , sn ) 6= 0.
Theorem 1. The new (n, k) code over Fq obtained by the
generic transformation can possess the MDS property if

1
i) q > N n−1
r−1 + 1, and
ii) every block matrix A′t,j of the parity-check matrix
(A′t,j )t∈[0,r),j∈[0,n′ ) of the base code is nonsingular.
Proof. The proof is given in Appendix A.
Remark 2. To the best of our knowledge, there are only four
classes of MDS codes with the optimal repair bandwidth that
are defined in parity-check matrix form, where the requirement
in Theorem 1-ii) can be satisfied for two of them, i.e., the YB
code 2 in [12] and the improved YB code 2 in [15], while
the remaining codes (i.e., the YB code 1 in [12] and the
constructions in [13] and [14]) need a minor modification.
As a concrete example, the YB code 1 in [12] satisfying this
requirement will be illustrated in Section IV-A.
Theorem 2. Every failed node of the new (n, k) code obtained
by the generic transformation can be regenerated by the repair
matrices defined in (12), where the repair bandwidth for node
i (i ∈ [0, n)) is
γi =

(

(1 +
(1 +

(⌈ nn′ ⌉−1)(r−1)
)γ ∗ ,
n−1
n
(⌊ n′ ⌋−1)(r−1)
)γ ∗ ,
n−1

if 0 ≤ i%n′ < n%n′ ,
otherwise.

Proof. Since the (n′ , k ′ ) base code possesses the optimal
repair bandwidth, by (4) and (5), we have


(12)



rank(


(13)

where xt,j ∈ Fq \{0}, t ∈ [0, r), i, j ∈ [0, n) with j 6= i,
% denotes the modulo operation, and IN denotes the identity
matrix of order N , which will be abbreviated as I in the sequel
if its order is clear.

and

Remark 1. For an (n′ , k ′ ) MDS code defined over a finite
field that contains at least q ′ elements, it can of course be
defined over a larger finite field Fq (q > q ′ ). In the above
generic transformation, the base code is then assumed to be
defined over the same finite field Fq of the resultant new code.

for t ∈ [0, r).

Like many MDS codes in the literature, the MDS property
of the resultant code can be guaranteed by the Combinatorial
Nullstellensatz in [24].

xtii in f is

nonzero. Then, if S1 , · · · , Sn are subsets of Fq with |Si | > ti ,
there are s1 ∈ S1 , · · · , sn ∈ Sn so that

and
′
Si,t = Si%n
′ ,t

n
Q


rank(

′
Si,0
A′0,i
′
Si,1 A′1,i
..
.
′
Si,r−1
A′r−1,i

′
Ri,j
′
Si,t A′t,j





) = N, for i ∈ [0, n′ ),


(14)


) = N/r, i, j ∈ [0, n′ ) with i 6= j (15)

1 Note that the field size required for the base code is ≥ q ′ , therefore, q

should actually satisfy q ≥ max{q ′ , N n−1
+ 2}. However, the smallest
r−1
field size required for any known explicit MDS code with the optimal repair
bandwidth in the literature is far less than N n−1
+ 2. So, we make an
r−1

assumption here that q ′ < N n−1
+
2.
r−1

5

For i, j ∈ [0, n) with j 6= i, we rewrite i and j as i = un′ +i′
and j = vn′ + j ′ such that i′ , j ′ ∈ [0, n′ ). Firstly, we verify
(4) for the new code. By (11) and (13),


Si,0 A0,i


Si,1 A1,i


rank(
)
..


.




= rank(


Si,r−1 Ar−1,i

Si′′ ,0 A′0,i′
Si′′ ,1 A′1,i′
..
.
Si′′ ,r−1 A′r−1,i′

= N,





)


where the last equality follows from (14).
Next, we check (5) for the new code. When i′ 6= j ′ ,




Ri′ ′ ,j ′
Ri,j
) = rank(
rank(
)
Si′′ ,t A′t,j ′
Si,t At,j
= N/r
= rank(Ri,j ), t ∈ [0, r),

(16)

Therefore, according to (6), (16), and (17), the repair
bandwidth of node i is
n−1
X

rank(Ri,j )

j=0,j6=i

N
r
(r − 1)N
|{j : j ∈ [0, n)\{i}, j ≡ i mod n′ }|
+
r
(
(⌈ n ⌉−1)(r−1)
)γ ∗ ,
if 0 ≤ i%n′ < n%n′ ,
(1 + n′ n−1

= (n − 1)

=

(1 +

(⌊ nn′ ⌋−1)(r−1)
)γ ∗ ,
n−1

otherwise,

where γ ∗ = (n − 1) Nr is the optimal value for the repair
bandwidth. This finishes the proof.
Remark 3. In fact, any (n′ , k ′ ) MDS code without the optimal
repair bandwidth can also be chosen as the base code in the
generic transformation. Its repair bandwidth is (n′ − 1)β,
i.e., a failed node can be regenerated by downloading an
amount of β symbols from each surviving node. Then the
repair bandwidth of the
resultant MDS code would be upper
(⌈ nn′ ⌉−1)(N/β−1)
)(n − 1)β according to a
bounded by (1 +
(n−1)
similar analysis as the proof of Theorem 2.
IV. MDS

A. An (n, k) MDS code C1 by applying the generic transformation to the YB code 1 in [12]
The (n′ , k ′ ) YB code 1 was defined in [12] in the form
of (2) and (3), with the optimal update property and the sub′
packetization level being N = rn where r = n′ − k ′ . More
precisely, the parity-check matrix (A′t,i )t∈[0,r),i∈[0,n′ ) of the
(n′ , k ′ ) YB code 1 satisfies A′t,i = (A′i )t and




λi,0 Vi,0
Vi,0


 Vi,1 
λi,1 Vi,1

 ′ 

(18)
,
 Ai = 

..
..




.
.
λi,r−1 Vi,r−1

Vi,r−1

where the second and third equalities follows from (15) and
(12), respectively. When i′ = j ′ , similarly, we have




I
Ri,j
) = rank(
)
rank(
Si′′ ,t A′t,j ′
Si,t At,j
=N
= rank(Ri,j ), t ∈ [0, r).
(17)

γi =

and 2 in [12], the (n′ , k ′ ) improved YB code 2 in [15], and
the counterpart of the long MSR code [9] in the parity-check
form, we get four MDS codes with small sub-packetization
level.

CODE CONSTRUCTIONS BY DIRECTLY APPLYING
THE GENERIC TRANSFORMATION

In this section, by directly applying the generic transformation in Section III respectively to the (n′ , k ′ ) YB codes 1

where
Vi,0 , Vi,1 , · · · , Vi,r−1
are
defined
in
(7),
{λi,t }i∈[0,n′ ),t∈[0,r) are rn′ distinct elements in a finite
field containing at least rn′ elements, the repair matrices and
select matrices are defined by
′
′
Ri,j
= Si,t
= Vi,0 + Vi,1 + · · · + Vi,r−1

for i, j ∈ [0, n′ ) with j 6= i, t ∈ [0, r).
From (18), it is obvious that A′i is nonsingular if and only if
{λi,t }t∈[0,r) are r nonzero elements. In order to meet Theorem
1-ii), i.e., in order for matrices in (18) to be invertible, we
can add a restriction that {λi,t }i∈[0,n′ ),t∈[0,r) are rn′ nonzero
elements when applying the generic transformation to YB code
1. Accordingly, the requirement of the field size q of YB code
1 is then only increased from q ≥ rn′ to q ≥ rn′ + 1, which
can be easily satisfied as the resultant new code will be defined
over a finite field with size larger than rn′ .
Theorem 3. By choosing the (n′ , k ′ ) YB code 1 as the base
code for the generic transformation in Section III, an (n,
 k)
MDS code C1 over Fq with k = n − r and q > N n−1
r−1 + 1
can be obtained. Specifically, the sub-packetization level of
′
the MDS code C1 is rn while its repair bandwidth for node i
(i ∈ [0, n)) is
(
(⌈ n ⌉−1)(r−1)
)γ ∗ ,
if 0 ≤ i%n′ < n%n′ ,
(1 + n′ n−1
γi =
n
(⌊ ⌋−1)(r−1)
(1 + n′ n−1
)γ ∗ ,
otherwise.
For the MDS code C1 directly obtained by the generic
transformation, the required field size is relatively large and the
construction is implicit. In the following, through a concrete
assignment of the coefficients xt,j , t ∈ [0, r) and j ∈ [0, n) in
(11), we provide a solution to determine the exact field size
 of
the MDS code C1 , which is much smaller than N n−1
r−1 + 2.
Theorem 4. The field size q of the (n, k) MDS code C1 can
be reduced to
 ′ n
rn (⌈ rn′ ⌉−1)+r(n%n′ ), if 0 < n%(rn′ ) < n′ ,
q>
(19)
n
otherwise,
rn′ ⌈ rn
′ ⌉,

with r | (q − 1) by setting
′

λi′ ,t = δ t ci

(20)

6

in (18) and
′

xt,i = xti = (czn δ v )t

(21)

in (11) for t ∈ [0, r), i = zrn′ + vn′ + i′ ∈ [0, n), z ∈
n
′
′
[0, ⌈ rn
′ ⌉), v ∈ [0, r), and i ∈ [0, n ), where c is a primitive
q−1
element of the finite field Fq and δ = c r , i.e., a primitive
r-th root of unity in the finite field Fq .
Proof. Obviously, we only need to verify the MDS property
of the code C1 . Note from (21) that C1 is defined in the form
of (2) and (3), i.e.,
′

At,i = xt,i A′t,i′ = (czn δ v A′i′ )t = Ati
′

rank(Ai − Aj )
′

′

δ v0 +t0 −v1 −t1 6= c(z1 −z0 )n +j

′

−i′

for all t0 , t1 ∈ [0, r). (23)

Note that (23) always holds, otherwise,
′

δ v0 +t0 −v1 −t1 = c(z1 −z0 )n +j

′

−i′

for some t0 , t1 ∈ [0, r). Raising both sides to the power of r,
by δ r = 1 one then gets
1 = δ r(v0 +t0 −v1 −t1 ) = cr((z1 −z0 )n +j
′

(22)

for i = zrn′ +vn′ +i′ and the matrix Ai , czn δ v A′i′ . Then, by
Lemma 1, the code C1 possesses the MDS property if Ai Aj =
Aj Ai and Ai − Aj is nonsingular for all i, j ∈ [0, n) with
i 6= j.
Firstly, from (18) and (22), it is seen that Ai is diagonal for
i ∈ [0, n), then Ai Aj = Aj Ai holds for any i, j ∈ [0, n) with
i 6= j.
Secondly, we show that Ai − Aj is nonsingular for all i, j ∈
[0, n) with i 6= j. Let i = z0 rn′ + v0 n′ + i′ and j = z1 rn′ +
n
v1 n′ + j ′ , where i 6= j, z0 , z1 ∈ [0, ⌈ rn
′ ⌉), v0 , v1 ∈ [0, r), and
′ ′
′
i , j ∈ [0, n ).
If j 6≡ i mod n′ , i.e., i′ 6= j ′ , then
′

where the first, third, fourth, and fifth equalities follow from
(22), (10), (18), and (20), respectively. Thus, rank(Ai − Aj ) =
N if and only if

= rank(cz0 n δ v0 A′i′ − cz1 n δ v1 A′j ′ )


Vi′ ,0
′
 z0 n′ v0 ′

..
δ Ai′ − cz1 n δ v1 A′j ′ ))
= rank(
 (c
.
Vi′ ,r−1


′
′
Vi′ ,j ′ ,0,0 (cz0 n δ v0 A′i′ − cz1 n δ v1 A′j ′ )


..


.




′
′
z
n
v
′
z
n
v
′
0
0
1
1

 Vi′ ,j ′ ,0,r−1 (c
δ
A
δ
A
′ − c
′)
i
j




.
.
= rank(
)
.




z0 n′ v0 ′
z1 n′ v1 ′
δ Ai′ − c
δ Aj ′ ) 
 Vi′ ,j ′ ,r−1,0 (c


..




.
′
′
Vi′ ,j ′ ,r−1,r−1 (cz0 n δ v0 A′i′ − cz1 n δ v1 A′j ′ )


′
′
(cz0 n δ v0 λi′ ,0 − cz1 n δ v1 λj ′ ,0 )Vi′ ,j ′ ,0,0


..




.


′
′
z
n
v
z
n
v
 (c 0 δ 0 λi′ ,0 − c 1 δ 1 λj ′ ,r−1 )Vi′ ,j ′ ,0,r−1 




..
= rank(
)
.


′
′


z0 n v0
z1 n v1
δ λi′ ,r−1 − c
δ λj ′ ,0 )Vi′ ,j ′ ,r−1,0 
 (c


.


..


z0 n′ v0
z1 n′ v1
(c
δ λi′ ,r−1 − c
δ λj ′ ,r−1 )Vi′ ,j ′ ,r−1,r−1


′
′
′
′
(δ v0 cz0 n +i − δ v1 cz1 n +j )Vi′ ,j ′ ,0,0


..




.


′
′
′
′
v0 z0 n +i
v1 +r−1 z1 n +j


′ ,j ′ ,0,r−1
(δ
c
−
δ
c
)V
i




.
..
= rank(
)




v0 +r−1 z0 n′ +i′
v1 z1 n′ +j ′
(δ
c
−δ c
)Vi′ ,j ′ ,r−1,0




..




.
′
′
′
′
(δ v0 +r−1 cz0 n +i − δ v1 +r−1 cz1 n +j )Vi′ ,j ′ ,r−1,r−1

′

−i′ )

.

(24)

In the following, we prove that (24) does not hold, i.e.,
0 < |r ((z1 − z0 )n′ + j ′ − i′ ) | < q − 1.
Clearly,
0 < |r ((z1 − z0 )n′ + j ′ − i′ ) | ≤ W
n
′
where W = zrn′ +rw, z = ⌈ rn
′ ⌉−1, w = −1 if n%(rn ) = 1
′
′
′
(in this case zrn +w = n−2 due to j −i 6= 0), w = n%n′ −1
if 1 < n%(rn′ ) < n′ (in this case zrn′ + w = n − 1), and
w = n′ − 1 else (in this case zrn′ + w < n − 1 unless
n%(rn′ ) = n′ ) , i.e.,
 ′ n
if n%(rn′ ) = 1
 rn (⌈ rn′ ⌉ − 1) − r,
n
′
′
W = rn (⌈ rn′ ⌉ − 1) + r(n%n ) − r, if 1 < n%(rn′ ) < n′
 ′ n
rn ⌈ rn′ ⌉ − r,
else

which together with r | (q − 1) implies that (24) does not hold
when (19) is satisfied.
If j ≡ i mod n′ , i.e., i′ = j ′ , then
rank(Ai − Aj )
′

′

= rank(cz0 n δ v0 A′i′ − cz1 n δ v1 A′j ′ )
′

′

= rank((cz0 n δ v0 − cz1 n δ v1 )A′i′ ),
therefore, Ai − Aj is nonsingular if and only if
′

′

cz0 n δ v0 − cz1 n δ v1

q−1
q−1
′
′
= cz1 n + r v1 c(z0 −z1 )n + r (v0 −v1 ) − 1

6= 0

(25)

n
since A′i′ is nonsingular. Note that z0 , z1 ∈ [0, ⌈ rn
′ ⌉), v0 , v1 ∈
′
[0, r), and (z0 , v0 ) 6= (z1 , v1 ) according to i = j ′ and i 6= j,
then we have
q−1
(v0 − v1 )|
0 < |(z0 − z1 )n′ +
r
 n

q−1
≤ ⌈ ′ ⌉ − 1 n′ +
(r − 1),
rn
r
 ′ q−1
n
thus (25) holds if q − 1 > ⌈ rn
′⌉ − 1 n +
r (r − 1), i.e.,
n
′
q > ⌈ rn
′ ⌉ − 1 rn + r by combining r | (q − 1).
This finishes the proof after combining the above analysis.

In the following, we give a concrete example of the MDS
code C1 according to Theorem 4.

7

Example 1. Let n′ = 3, r = 2 and n = 12, then the paritycheck matrix of the (12, 10) MDS code C1 over F13 is defined
through




 2

e0
ce0
c e0
 e1 
 ce1 
 δc2 e1 




 2

 e2 
 δce2 
 c e2 




 2 
 e3 
 δce3 
 δc e3 





A0 = 
 δe4  , A1 =  ce4  , A2 =  c2 e4  ,




 2 
 δe5 
 ce5 
 δc e5 




 2

 δe6 
 δce6 
 c e6 
δe7
δce7
δc2 e7




 2 
δe0
δce0
δc e0
 δe1 
 δce1 
 c2 e 1 




 2 
 δe2 
 ce2 
 δc e2 




 2

 δe3 
 ce3 
 c e3 






A3 = 
 , A4 =  δce4  , A5 =  δc2 e4  ,
 e4 


 2

 e5 
 δce5 
 c e5 




 2 
 e6 
 ce6 
 δc e6 
e7
ce7
c2 e 7
 3

 4

 5

c e0
c e0
c e0
 c3 e 1 
 c4 e 1 
 δc5 e1 
 3

 4 
 5

 c e2 
 δc e2 
 c e2 
 3

 4 
 5 
 c e3 
 δc e3 
 δc e3 





A6 = 
 δc3 e4  , A7 =  c4 e4  , A8 =  c5 e4  ,
 3 
 4

 5 
 δc e5 
 c e5 
 δc e5 
 3 
 4 
 5

 δc e6 
 δc e6 
 c e6 
δc3 e7
δc4 e7
δc5 e7
 3 
 4 
 5 
δc e0
δc e0
δc e0
 δc3 e1 
 δc4 e1 
 c5 e 1 
 3 
 4

 5 
 δc e2 
 c e2 
 δc e2 
 3 
 4

 5

 δc e3 
 c e3 
 c e3 






A9 =  3
 , A10 =  δc4 e4  , A11 =  δc5 e4  ,
 c3 e 4 
 4 
 5

 c e5 
 δc e5 
 c e5 
 3

 4

 5 
 c e6 
 c e6 
 δc e6 
c3 e 7
c4 e 7
c5 e 7
where c = 2 and δ = c6 = −1.
To save space, we only give the repair matrices and select
matrices of node 0, which are

I,
if j = 3, 6, 9,






e0 + e4

 e1 + e5 
R0,j =


otherwise,


 e2 + e6  ,



e3 + e7
and

S0,0 = S0,1




e0 + e4
 e1 + e5 

=
 e2 + e6  .
e3 + e7

Theorem 5. The MDS code C1 has the optimal update
property.
Proof. Note that all the block matrices of the parity-check
matrix of the MDS code C1 are diagonal. By the definition
of the optimal update property and the arguments in [12],

we conclude that the MDS code C1 has the optimal update
property.
B. Two (n, k) MDS codes C2 and C3 by applying the generic
transformation respectively to the YB code 2 in [12] and the
improved YB code 2 in [15]
For consistency, we borrow the notation in [12] and [15]
′
in what follows. Let N = rn −1 where r = n′ − k ′ . For any
a ∈ [0, N ) with (a0 , a1 , · · · , an′ −2 ) being its r-ary expansion,
define
a(i, u) = (a0 , · · · , ai−1 , u, ai+1 , · · · , an′ −2 )

(26)

and
a(i, j, u, v)
= (a0 , · · · , ai−1 , u, ai+1 , · · · , aj−1 , v, aj+1 , · · · , an′ −2 ), (27)
where 0 ≤ i < j < n′ − 1 and u, v ∈ [0, r).
For the (n′ , k ′ ) YB code 2 in [12] and the (n′ , k ′ ) improved
YB code 2 in [15], both of them are defined in the form of
(2) and (3) with the sub-packetization level N . More precisely,
the parity-check matrix (A′t,i )t∈[0,r),i∈[0,n′ ) of the (n′ , k ′ ) YB
code 2 in [12] is defined by A′t,i = (A′i )t and

−1
 NP
′
λi,ai e⊤
a ea(i,ai +1) , i ∈ [0, n − 1),
A′i =
a=0

I,
i = n′ − 1,
where

λi,ai =



ci+1 , if ai = 0,
1,
otherwise,

with c being a primitive element of a finite field with size larger
than n′ . While the parity-check matrix (A′t,i )t∈[0,r),i∈[0,n′ ) of
the (n′ , k ′ ) improved YB code 2 in [15] is defined by A′t,i =
(A′i )t and

−1
 NP
′
λi,a e⊤
′
a ea(i,ai +1) , i ∈ [0, n − 1),
(28)
Ai =
a=0

I,
i = n′ − 1,
where

λi,a =





c,

if

i
P

at = 0,

t=0

(29)

1, otherwise,

with c being a primitive element of a finite field Fq with
(q − 1) ∤ (r − 1).
The YB code 2 in [12] and the improved YB code 2 in [15]
have the same repair matrices and select matrices, which are
respectively defined by

Vi,0 , if i ∈ [0, n′ − 1),
′
Ri,j
=
V∗,0 , if i = n′ − 1,
and
′
Si,t
=



Vi,0 ,
V∗,r−t ,

if i ∈ [0, n′ − 1),
if i = n′ − 1,

where Vi,0 , V∗,0 and V∗,r−t are defined in (7) and (8).
By directly applying the generic transformation in Section
III, we have the following result.

8

Theorem 6. Respectively choosing the (n′ , k ′ ) YB code 2 in
[12] and the (n′ , k ′ ) improved YB code 2 in [15] as the base
code for the generic transformation in Section III, two (n, k)
MDS codes
C2 and C3 over Fq with k = n − r and q >

N n−1
r−1 + 1 can be obtained. Particularly, for both the MDS
′
codes C2 and C3 , the sub-packetization level is rn −1 while
the repair bandwidth for node i (i ∈ [0, n)) is
(
(⌈ n ⌉−1)(r−1)
)γ ∗ ,
if 0 ≤ i%n′ < n%n′ ,
(1 + n′ n−1
γi =
n
(⌊ ⌋−1)(r−1)
(1 + n′ n−1
)γ ∗ ,
otherwise.
In the following, by a concrete assignment of the coefficients xt,j , t ∈ [0, r) and j ∈ [0, n) in (11), we provide a
solution to determine the exact field sizes of the
 MDS codes
C2 and C3 , which are much smaller than N n−1
r−1 +2. Hereafter,
we only derive the values of xt,j , t ∈ [0, r) and j ∈ [0, n) in
(11) for the MDS code C3 in detail, while for MDS code C2 ,
we just give the results but omit the analysis since it is similar
to that of the MDS code C3 .
Theorem 7. The field size q of the MDS code C2 can be
′
reduced to q > r⌈ nr ⌉(⌈ nn′ ⌉ − 1) + n′ by setting xt,i = xti =
i

n′

c⌊ n′ ⌋⌈ r ⌉t in (11) for t ∈ [0, r) and i ∈ [0, n), where c is a
primitive element of Fq .
Before proving the result on C3 , we first introduce some
results related to the parity-check matrix (see (28)) of the
(n′ , k ′ ) improved YB code 2 in [15].
Lemma 3 (Lemma 2, [15]). For any i, j ∈ [0, n′ ) with i 6= j,
A′i A′j = A′j A′i , where A′i and A′j are defined in (28).

That is
Aun′ +n′ −1 = cu A′n′ −1 = cu I, for u ∈ [0, ⌊

(ii)

(iii)

t=0
r−1
Q
t=0

λj,a(i,j,ai −t,aj +t+l) = 1 or cr for j > i;

Aun′ +i′ = cu A′i′ =

N
−1
X

cu λi′ ,a e⊤
a ea(i′ ,ai′ +1) ,

for u ∈ [0, ⌈ nn′ ⌉) and i′ ∈ [0, n′ − 1) with un′ + i′ <
n. According to Lemma 1, the code C3 possesses the MDS
property if Ai Aj = Aj Ai and Ai − Aj is nonsingular for all
i, j ∈ [0, n) with i 6= j.
First, by Lemma 3, (32) and (33), we easily see that Ai Aj =
Aj Ai holds for any i, j ∈ [0, n) with i 6= j.
Next, we show that Ai −Aj is nonsingular. Note that Ai −Aj
being nonsingular is equivalent to saying that for any X =
NP
−1
xa e⊤
a , (Ai − Aj )X = 0 implies X = 0. In the following,
a=0

we analyze it through three cases. For i, j ∈ [0, n) with i 6= j,
let us rewrite i = un′ + i′ and j = vn′ + j ′ for some u, v ∈
[0, ⌈ nn′ ⌉) and i′ , j ′ ∈ [0, n′ ), where (u, i′ ) 6= (v, j ′ ).
Case 1: If i ≡ j mod n′ , i.e., i′ = j ′ and u 6= v, then by
(31), we have
Ai − Aj = (cu − cv )A′i′ = cv (cu−v − 1)A′i′ ,

which is nonsingular since 0 < |u − v| ≤ ⌈ nn′ ⌉ − 1 < q − 1.
Case 2: If i 6≡ j mod n′ , i′ 6= n′ − 1, and j ′ 6= n′ − 1,
then by Lemma 5, we have
(Ai − Aj )X
= (cu A′i′ − cv A′j ′ )X
=

N
−1
X

v
⊤
(cu λi′ ,a xa(i′ ,ai′ +1) e⊤
a − c λj ′ ,a xa(j ′ ,aj′ +1) ea )

a=0

=0

if and only if
cu λi′ ,a xa(i′ ,ai′ +1) − cv λj ′ ,a xa(j ′ ,aj′ +1) = 0, a ∈ [0, N ),

where l ∈ [0, r) is a constant, c is a primitive element of Fq ,
a(i, j, u, v) and λi,a are respectively defined in (27) and (29).

which is equivalent to
cv λj ′ ,a(i′ ,ai′ −1)
xa(i′ ,j ′ ,ai′ −1,aj′ +1)
cu λi′ ,a(i′ ,ai′ −1)
Qr−1 v
t=0 c λj ′ ,a(i′ ,j ′ ,ai′ −t,aj′ +t−1)
xa , a ∈ [0, N ). (34)
= Qr−1
u
t=0 c λi′ ,a(i′ ,j ′ ,ai′ −t,aj′ +t−1)

Lemma 5 (Lemma 4, [15]). For any i ∈ [0, n − 1) and
NP
−1
NP
−1
N
′
X =
xa e⊤
λi,a xa(i,ai +1) e⊤
a ∈ Fq , Ai X =
a where

xa =

Theorem 8. The field size q of the (n, k) MDS code C3 can
be reduced to q > ⌈ nn′ ⌉ with q being odd if r is even, and
q > r⌈ nn′ ⌉ otherwise, by setting

Applying Lemma 4 to (34), if j ′ > i′ , we get

′

a=0

a=0

i

xt,i = xti = c⌊ n′ ⌋t

(30)

in (11) for t ∈ [0, r) and i ∈ [0, n), where c is a primitive
element of Fq .
Proof. Still, we only need to verify the MDS property of the
code C3 . It is seen from (30) that the code C3 is defined in the
form of (2) and (3) with
At,i = Ati = (c

⌊ ni′

⌋

(33)

a=0

λj,a(j,aj +t) = c for j ≥ 0,

A′i is defined in (28).

(32)

and

Lemma 4 (Lemma 3, [15]). For any a ∈ [0, N ) and i, j ∈
[0, n′ − 1),
r−1
Q
(i)
λi,a(i,j,ai −t,aj +t+l) = c for j > i;
t=0
r−1
Q

n
⌋),
n′

A′i%n′ )t , t ∈ [0, r).

(31)

(crv − cru+1 )xa = crv (1 − cru−rv+1 )xa = 0,
or
(crv+r−1 − cru )xa = cru (crv−ru+r−1 − 1)xa = 0,
otherwise, we have
(crv+1 − cru )xa = cru (crv−ru+1 − 1)xa = 0,
or
(crv − cru+r−1 )xa = crv (1 − cru−rv+r−1 )xa = 0.

9

If r is even, then ru − rv + 1, rv − ru + r − 1, rv − ru + 1,
and ru − rv + r − 1 is odd, thus

The parity-check matrix (A′t,i′ )t∈[0,r),i′ ∈[0,n′ ) of the (n′ =
(r + 1)m, k ′ = n′ − r) long code C4′ satisfies

cru−rv+1 , crv−ru+r−1 , crv−ru+1 , cru−rv+r−1 6= 1

′
A′t,i′ = yt,i′ Bt,i
′

when q is odd; Otherwise, for any
W ∈ {|ru−rv+1|, |rv−ru+r−1|, |rv−ru+1|, |ru−rv+r−1|},

we have
0 < W ≤ r⌈

n
⌉−1<q−1
n′

when q > r⌈ nn′ ⌉, i.e.,
cru−rv+1 , crv−ru+r−1 , crv−ru+1 , cru−rv+r−1 6= 1
r⌈ nn′ ⌉.

Hence, if q is odd and r is even, or q >
when q >
and r is odd, we have that

r⌈ nn′ ⌉

(crv −cru+1 )(crv+r−1 −cru )(crv+1 −cru )(crv −cru+r−1 ) 6= 0,
thus xa = 0 for all a ∈ [0, N ), i.e., X = 0. Then, Ai − Aj is
nonsingular.
Case 3: If i 6≡ j mod n′ and either i′ = n′ − 1 or j ′ =
′
n − 1, W.L.O.G., assuming that i′ = n′ − 1, then j ′ 6= n′ − 1.
Similar to Case 2, we have
xa = xa

r−1
Y

cv λj ′ ,a(j ′ ,aj′ +t)

t=0

cu

, a ∈ [0, N ),

(c

and (36) in the next page, where yt,i′ , λi′ ,u ∈ Fq′ \{0} for
i′ ∈ [0, n′ ) and t, u ∈ [0, r), Vi′ ,0 , . . . , Vi′ ,r−1 are respectively
defined by (7) for i′ ∈ [0, m) and (9) for i′ ∈ [m, n′ ), i.e.,
′
Vi′ ,v Bt,i
′

P
λt V ′ + r−1
i′
⌋ = v,
(λti′ ,v−λti′ ,u )Vi′ ,u , if ⌊ m
i′ ,v i ,v
=
(37)
u=0,u6=v
 t
λi′ ,v Vi′ ,v ,
otherwise,

for i′ ∈ [0, n′ ) and v, t ∈ [0, r). The repair matrices and select
matrices of the (n′ , k ′ ) MDS code C4′ are respectively defined
by

if 0 ≤ i′ < rm,
i′ ,
 Vi′ ,⌊ m
⌋
′
′
r−1
P
(38)
Ri′ ,j ′ = Si′ ,t =

Vi′ ,u , if rm ≤ i′ < n′ ,
u=0

′

′

′

for j ∈ [0, n )\{i } and t ∈ [0, r).
′
′
′
Obviously, Bt,i
′ is nonsingular for t ∈ [0, r) and i ∈ [0, n )
according to (36). Then we have the following result.
Theorem 9. The code C4′ has the MDS property over Fq′ if

′
−1
+ 1.
q ′ > N nr−1

Proof. It can be proven similar to that of Theorem 1.

which in conjunction with Lemma 4, we have
rv+1

(35)

ru

− c )xa = 0

for all a ∈ [0, N ). This implies that xa = 0 for all a ∈ [0, N )
by a similar analysis as in Case 2, i.e., X = 0. Thus, Ai − Aj
is nonsingular.
Collecting the above three cases, we finish the proof.

Theorem 10. The code C4′ has the optimal repair bandwidth if
λi′ ,0 , λi′ ,1 , · · · , λi′ ,r−1 are r distinct elements in Fq′ for any
i′ ∈ [0, n′ ).
Proof. The proof is given in Appendix B.
Based on the long code C4′ , we have the following result by
directly applying the generic transformation.

Let us see to what extent the field size q of the (n, k) MDS
code C3 can be reduced by Theorem 8. For example, when
n′ = 12, r = 3, and n = 24. According to Theorem 8, we
i
can set xt,i = xti = 2⌊ 12 ⌋t in (11) over F7 for t ∈ [0, 3) and
i ∈ [0, 24), where 2 is a primitive element of F7 . Whereas,
by Theorem 6, the existence of the MDS code C3 requires a
finite field with size larger than 4 × 107 .

Theorem 11. By applying the generic transformation in
Section III to the (n′ , k ′ ) long code C4′ , an
 (n, k) MDS code C4
over Fq with k = n − r and q > N n−1
r−1 + 1 can be obtained.
Specifically,
the sub-packetization level of the MDS code C4 is
n′
r+1
while its repair bandwidth for node i (i ∈ [0, n)) is
r
(
(⌈ n ⌉−1)(r−1)
)γ ∗ ,
if 0 ≤ i%n′ < n%n′ ,
(1 + n′ n−1
γi =
(⌊ nn′ ⌋−1)(r−1)
(1 +
)γ ∗ ,
otherwise.
n−1

C. An (n, k) MDS code C4 obtained by applying the generic
transformation to a newly constructed MDS code C4′

In what follows, we present a solution to determine the exact
field size of the MDS code C4 for the case of r = 2, which is
much smaller than N n−1
r−1 + 2.
By
(11)
and
(35),
the
parity-check matrix
(At,i )t∈[0,r),i∈[0,n) of the (n, k) MDS code C4 satisfies

In this section, by using the approach of [12], we first
construct an (n′ = (r + 1) m, k ′ = n′ − r) MDS code C4′ with
sub-packetization level rm , and then propose an (n, k) MDS
code C4 with small sub-packetization level by applying the
generic transformation to the code C4′ . In fact, the code C4′ can
be viewed as an extension of the (n′ = rm, k ′ = r(m − 1))
MDS code in [13] with a longer code length. Besides, C4′ in
parity-check form can also be regarded as the counterpart of
the (n′ = k ′ + r, k ′ = (r + 1)m) long minimum storage regenerating (MSR) code [9] in systematic form. For simplicity, we
call C4′ the long code in this paper. In the following, we give
the parity-check matrix, repair matrices and select matrices of
the long code C4′ .

′
′
At,i = xt,i A′t,i%n′ = xt,i yt,i%n′ Bt,i%n
′ = zt,i Bt,i%n′ , (39)

where
zt,i = xt,i yt,i%n′ , t ∈ [0, r), i ∈ [0, n).
Then we have the following result.
Theorem 12. When r = 2, the field size q of the (n, k) MDS
code C4 can be reduced to

2m(⌈ nn′ ⌉ − 1) + 2(n%n′ ), if 0 < n%n′ < m,
(40)
q>
2m⌈ nn′ ⌉,
otherwise,

10

which always holds since

by setting
zt,i = c

2mt⌊ ni′ ⌋

(41)

for t = 0, 1, i ∈ [0, n) and
′

λi′ ,0 = λi′ +m,0 = λi′ +2m,1 = c2i ,

(42)

′

λi′ ,1 = λi′ +m,1 = λi′ +2m,0 = c2i +1 ,

(43)

in (36) for i′ ∈ [0, m), where n′ = 3m and c is a primitive
element of Fq .
Proof. According to (36), the code C4 has the MDS property
if and only if any 2 × 2 sub-block matrix of

 

I
I
···
I
A0,0 A0,1 · · · A0,n−1
=
A1,0 A1,1 · · · A1,n−1
A1,0 A1,1 · · · A1,n−1
is nonsingular, i.e, A1,i − A1,j is nonsingular for any i, j ∈
[0, n) with i 6= j. Let us rewrite i = un′ + i′ and j = vn′ + j ′
for some u, v ∈ [0, ⌈ nn′ ⌉) and i′ , j ′ ∈ [0, n′ ), where (u, i′ ) 6=
(v, j ′ ). In the following, we analyze the nonsingularity of
A1,i − A1,j in the following 6 cases according to (39)-(43).
Case 1: When 0 ≤ i′ = j ′ < 3m, then
rank (A1,i − A1,j )

′
′
= rank z1,i B1,i
′ − z1,j B1,j ′

′
= rank (z1,i − z1,j )B1,i
′







Vi′ ,0
Vi′ ,1
..
.
Vi′ ,r−1




 ′
 Bt,i′ =














































rank(A1,i − A1,j )
′
′
= rank(z1,i B1,i
′ − z1,j B1,j ′ )


Vi′ ,j ′ ,0,0
 Vi′ ,j ′ ,0,1 
′
′

= rank(
 Vi′ ,j ′ ,1,0  (z1,i B1,i′ − z1,j B1,j ′ ))
Vi′ ,j ′ ,1,1


′
′
Vi′ ,j ′ ,0,0 (z1,i B1,i
′ − z1,j B1,j ′ )
′
′
 Vi′ ,j ′ ,0,1 (z1,i B1,i

′ − z1,j B1,j ′ )

= rank(
′
′
 Vi′ ,j ′ ,1,0 (z1,i B1,i′ − z1,j B1,j ′ ) )
′
′
Vi′ ,j ′ ,1,1 (z1,i B1,i
′ − z1,j B1,j ′ )

(z1,i λi′ ,0 − z1,j λj ′ ,0 )Vi′ ,j ′ ,0,0

+z1,i (λi′ ,0 − λi′ ,1 )Vi′ ,j ′ ,1,0


−z1,j (λj ′ ,0 − λj ′ ,1 )Vi′ ,j ′ ,0,1

 (z1,i λi′ ,0 − z1,j λj ′ ,1 )Vi′ ,j ′ ,0,1
= rank(

+z1,i (λi′ ,0 − λi′ ,1 )Vi′ ,j ′ ,1,1

 (z1,i λi′ ,1 − z1,j λj ′ ,0 )Vi′ ,j ′ ,1,0


−z1,j (λj ′ ,0 − λj ′ ,1 )Vi′ ,j ′ ,1,1
(z1,i λi′ ,1 − z1,j λj ′ ,1 )Vi′ ,j ′ ,1,1
=N

′

⇔ c2m(u−v)+2(i −j



..
.
λti′ ,r−1 Vi′ ,r−1
λti′ ,0 Vi′ ,0
r−1
P
λti′ ,1 Vi′ ,1 +
(λti′ ,1 − λti′ ,u )Vi′ ,u















′

)+a−b

− 1 6= 0 for all a, b = 0, 1,

0 < |2m(u − v)+ 2(i′ − j ′ )+ a− b| < q − 1, a, b = 0, 1. (44)

λti′ ,0 Vi′ ,0















)






which is equivalent to











⇔ z1,i λi′ ,a − z1,j λj ′ ,b 6= 0 for all a, b = 0, 1,

′
= rank((c2mu − c2mv )B1,i
′)
=N 

⇔ c2mv c2m(u−v) − 1 6= 0,















































n
⌉ − 2m < q − 1.
n′
Case 2: When 0 ≤ i′ < j ′ < m, then
0 < |2m(u − v)| ≤ 2m⌈

+

r−1
P

(λti′ ,0 −
u=1
λti′ ,1 Vi′ ,1

u=0,u6=1
λti′ ,2 Vi′ ,2

λti′ ,u )Vi′ ,u






,



if 0 ≤ i′ < m,






,




..
.
λti′ ,r−1 Vi′ ,r−1
..
.
λti′ ,0 Vi′ ,0
..
.
λti′ ,r−2 Vi′ ,r−2
r−2
P t
(λi′ ,r−1 − λti′ ,u )Vi′ ,u
λti′ ,r−1 Vi′ ,r−1 +
u=0

λti′ ,0 Vi′ ,0

λti′ ,1 Vi′ ,1

,
..

.
λti′ ,r−1 Vi′ ,r−1

if m ≤ i′ < 2m,



..
.




 , if (r − 1)m ≤ i′ < rm,


if rm ≤ i′ < (r + 1)m,

(36)

11

Case 5: When 0 ≤ i′ < m and 2m ≤ j ′ < 3m, if j ′ =
i′ + 2m, then by (9) we have

Obviously,
0 < |2m(u − v) + 2(i′ − j ′ ) + a − b| ≤ W
where W = 2mz + 2w + 1, z = ⌈ nn′ ⌉ − 1, w = n%n′ − 1 if
0 < n%n′ < m and w = m − 1 otherwise, i.e.,


2m ⌈ nn′ ⌉ − 1 + 2(n%n′ ) − 1, if 0 < n%n′ < m,
W =
2m⌈ nn′ ⌉ − 1,
otherwise.
Therefore, (44) holds if (40) is satisfied.
Case 3: When m ≤ i′ < j ′ < 2m or 2m ≤ i′ < j ′ < 3m,
similar to that of Case 2, we also have that
′

rank(A1,i − A1,j ) = N ⇔ c2m(u−v)+2(i −j

′

)±(a−b)

− 1 6= 0

for all a, b = 0, 1, which holds from a similar analysis as in
Case 2.
Case 4: When 0 ≤ i′ < m and m ≤ j ′ < 2m, if j ′ = i′ +m,
then by (9) we have
rank(A1,i − A1,j )
′
′
= rank(z1,i B1,i
′ − z1,j B1,j ′ )


′
′
Vi′ ,0 (z1,i B1,i
′ − z1,j B1,j ′ )
= rank(
)
′
′
Vi′ ,1 (z1,i B1,i′ − z1,j B1,j ′ )


z1,i λi′ ,0 Vi′ ,0 + z1,i (λi′ ,0−λi′ ,1 )Vi′ ,1 − z1,j λj ′ ,0 Vi′ ,0
= rank(
)
z1,i λi′ ,1 Vi′ ,1 − z1,j λj ′ ,1 Vi′ ,1 − z1,j (λj ′ ,1−λj ′ ,0 )Vi′ ,0


(z1,i λi′ ,0 − z1,j λj ′ ,0 )Vi′ ,0 + z1,i (λi′ ,0 − λi′ ,1 )Vi′ ,1
= rank(
)
(z1,i λi′ ,1 − z1,j λj ′ ,1 )Vi′ ,1 − z1,j (λj ′ ,1 − λj ′ ,0 )Vi′ ,0


(z1,i λi′ ,0 − z1,j λj ′ ,1 )(Vi′ ,0 + Vi′ ,1 )
= rank(
)
(z1,i λi′ ,1 − z1,j λj ′ ,1 )Vi′ ,1 − z1,j (λj ′ ,1 − λj ′ ,0 )Vi′ ,0
= N,

which is equivalent to
(z1,i λi′ ,0 −z1,j λj ′ ,1 ) ((z1,i λi′ ,1−z1,j λj ′ ,1 )+z1,j (λj ′ ,1−λj ′ ,0 )) 6= 0,

rank(A1,i − A1,j )
′
′
= rank(z1,i B1,i
′ − z1,j B1,j ′ )


′
′
Vi′ ,0 (z1,i B1,i
′ − z1,j B1,j ′ )
)
= rank(
′
′
Vi′ ,1 (z1,i B1,i′ − z1,j B1,j ′ )


z1,i λi′ ,0 Vi′ ,0 +z1,i (λi′ ,0−λi′ ,1 )Vi′ ,1 −z1,j λj ′ ,0 Vi′ ,0
= rank(
)
z1,i λi′ ,1 Vi′ ,1 − z1,j λj ′ ,1 Vi′ ,1


(z1,i λi′ ,0 −z1,j λj ′ ,0 )Vi′ ,0 + z1,i (λi′ ,0 −λi′ ,1 )Vi′ ,1
= rank(
)
(z1,i λi′ ,1 − z1,j λj ′ ,1 )Vi′ ,1
=N
′
′
⇔ c2mv+2i +1 (c2m(u−v)−1 − 1)c2mv+2i (c2m(u−v)+1 − 1) 6= 0;

which holds for a similar reason as in Case 4; Otherwise,
rank(A1,i − A1,j )
′
′
= rank(z1,i B1,i
′ − z1,j B1,j ′ )


′
′
Vi′ ,j ′ ,0,0 (z1,i B1,i
′ − z1,j B1,j ′ )
′
′
 Vi′ ,j ′ ,0,1 (z1,i B1,i

′ − z1,j B1,j ′ )
)
= rank(
′
′
 Vi′ ,j ′ ,1,0 (z1,i B1,i

′ − z1,j B1,j ′ )
′
′
Vi′ ,j ′ ,1,1 (z1,i B1,i′ − z1,j B1,j ′ )


z1,i λi′ ,0 Vi′ ,j ′ ,0,0 − z1,j λj ′ ,0 Vi′ ,j ′ ,0,0

+z1,i (λi′ ,0 − λi′ ,1 )Vi′ ,j ′ ,1,0 


 z1,i λi′ ,0 Vi′ ,j ′ ,0,1 − z1,j λj ′ ,1 Vi′ ,j ′ ,0,1 
)
= rank(

+z1,i (λi′ ,0 − λi′ ,1 )Vi′ ,j ′ ,1,1 


 z1,i λi′ ,1 Vi′ ,j ′ ,1,0 − z1,j λj ′ ,0 Vi′ ,j ′ ,1,0 
z1,i λi′ ,1 Vi′ ,j ′ ,1,1 − z1,j λj ′ ,1 Vi′ ,j ′ ,1,1


(z1,i λi′ ,0 − z1,j λj ′ ,0 )Vi′ ,j ′ ,0,0

+z1,i (λi′ ,0 − λi′ ,1 )Vi′ ,j ′ ,1,0 


 (z1,i λi′ ,0 − z1,j λj ′ ,1 )Vi′ ,j ′ ,0,1


)
= rank(

′
′
′
′
+z
(λ
−
λ
)V
1,i i ,0
i ,1 i ,j ,1,1 

 (z1,i λi′ ,1 − z1,j λj ′ ,0 )Vi′ ,j ′ ,1,0

(z1,i λi′ ,1 − z1,j λj ′ ,1 )Vi′ ,j ′ ,1,1
= N,

which is equivalent to
i.e.,
(c

2mu+2i′

−c

2mv+2i′ +1

′


′
′
) (c2mu+2i +1 − c2mv+2i +1 )

′
′
+c2mv (c2i +1 − c2i )
′

=c2mv+2i +1 (c2m(u−v)−1 − 1)c2mv+2i (c2m(u−v)+1 − 1)
6=0.
The above inequality always holds since
0 < |2m(u − v) ± 1| ≤ 2m⌈

n
⌉ − 2m + 1 < q − 1;
n′

z1,i λi′ ,a − z1,j λj ′ ,b 6= 0, for all a, b = 0, 1,
i.e.,
c2mv+2(j

−2m)+1−b

′

(c2m(u−v)+2(i −j

′

+2m)+a+b−1

− 1) 6= 0

for all a, b = 0, 1, which holds due to a similar analysis as in
Case 2.
Case 6: When m ≤ i′ < 2m and 2m ≤ j ′ < 3m, similar
to that of Case 5, if j ′ = i′ + m, we have
rank(A1,i − A1,j ) = N,
is equivalent to
(c2m(u−v)+1 − 1)(c2m(u−v)−1 − 1) 6= 0,

Otherwise, similar to Case 2, we have that
rank(A1,i − A1,j ) = N

′

otherwise
rank(A1,i − A1,j ) = N
is equivalent to

is equivalent to

′

′

c2m(u−v)+2(i −j

′

+m)+a−b

− 1 6= 0, for all a, b = 0, 1,

which holds according to a similar analysis as in Case 2.

c2m(u−v)+2(i −j

′

+m)+a+b−1

− 1 6= 0 for all a, b = 0, 1.

The above two inequalities always hold due to a similar reason
as in Case 5.

12

Combining the above 6 cases, we finish the proof.

Then,

Finally, we demonstrate to what extent Theorem 12 can
reduce the field size q of the (n, k) MDS code C4 . For example,
when n′ = 6, m = 2, and n = 24. According to Theorem 12,
we can set
i
z0,i = 1, z1,i = 34⌊ 6 ⌋ ,
for i ∈ [0, 24) in (39) and
λi′ ,0 = λi′ +2,0 = λi′ +4,1 = 3

2i′

λi′ ,1 = λi′ +2,1 = λi′ +4,0 = 3

2i′ +1

,
,

WITH THE OPTIMAL UPDATE

PROPERTY AND SMALL SUB - PACKETIZATION OVER SMALL
FINITE FIELDS

Note from (22) that the parity-check matrix of the MDS
code C1 has a constraint, that is, block matrices At,i should
satisfy that At,j1 A−1
t,j2 is a scalar matrix over Fq for all
j1 ≡ j2 (mod n′ ) and t ∈ [0, r), which reduces the designing
space for the parameters λi,0 , . . . , λi,r−1 in (18) to guarantee the MDS property. In this section, we propose another
explicit (n, k) MDS code which has a similar structure as
that of the MDS code C1 , but allows more flexible choices of
λi,0 , . . . , λi,r−1 , and thus can further reduce the field size.
′
Let N = rn and n > n′ , where n and n′ are two positive
integer. Construct an (n, k) code C5 with longer code length
given by (2) and (3), where Ai , i ∈ [0, n) satisfy




Vi,0
λi,0 Vi,0
 Vi,1 


λi,1 Vi,1




(45)

 Ai = 
,
..
..




.
.
Vi,r−1
λi,r−1 Vi,r−1

with λi,t ∈ Fq \{0} and Vi,t being defined by (7) and (9)
for t ∈ [0, r). The repair matrices and select matrices are
respectively defined by

Vi,0 + Vi,1 + · · · + Vi,r−1 ,
if j 6≡ i mod n′ ,
Ri,j =
I,
otherwise.
(46)
and
Si,t = Vi,0 + Vi,1 + · · · + Vi,r−1 , t ∈ [0, r).
(47)
Theorem 13. Every failed node of the code C5 can be
regenerated by the repair matrices defined in (46) and (47) if
λi,0 , λi,1 , · · · , λi,r−1 are pairwise distinct for each i ∈ [0, n).
Furthermore, the repair bandwidth for node i (i ∈ [0, n)) is
(
(⌈ n ⌉−1)(r−1)
)γ ∗ ,
if 0 ≤ i%n′ < n%n′ ,
(1 + n′ n−1
γi =
n
(⌊ ⌋−1)(r−1)
(1 + n′ n−1
)γ ∗ ,
otherwise.
Proof. Firstly, for i ∈ [0, n), by (45), we have




λti,0 Vi,0
Vi,0


 Vi,1 
λti,1 Vi,1
 t 


 Ai = 
 , t ∈ [0, r).

..
..




.
.
Vi,r−1
λti,r−1 Vi,r−1



rank(




in (36) for i′ = 0, 1 over F17 with 3 being the primitive
element. Whereas, by Theorem 11, the existence of the MDS
code C4 requires a finite field with size larger than 92.
V. A N (n, k) MDS CODE C5



(48)



=rank(






=rank(





=rank(


Si,0 A0,i
Si,1 A1,i
..
.





)


Si,r−1 Ar−1,i

Si,0

Si,1 Ai

)
..

.
Si,r−1 Ar−1
i

Vi,0 + Vi,1 + · · · + Vi,r−1
λi,0 Vi,0 + λi,1 Vi,1 + · · · + λi,r−1 Vi,r−1
..
.





)


r−1
r−1
λr−1
i,0 Vi,0 + λi,1 Vi,1 + · · · + λi,r−1 Vi,r−1


1
1
1
1
Vi,0


λi,0
λi,1 · · · λi,r−1 
  Vi,1 
).

..
..
..
..
..


.
.
.
.
.

λr−1
i,0

λr−1
i,1

· · · λr−1
i,r−1

Vi,r−1

Obviously, the rank is N if λi,u 6= λi,v for all u, v ∈ [0, r)
with u 6= v.
Next, we prove that (5) holds. By means of (10) and (48),
if j 6≡ i mod n′ , then we have


rank(

Ri,j
Si,t At,j




) = rank(




r−1
P

u=0
r−1
P

u=0

Vi,u

Vi,u Atj
r−1
P

Vi,u




)






 r−1u=0

 P

t


 u=0 Vi,j,u,0 Aj 


 r−1

= rank( P Vi,j,u,1 At )
j


 u=0



.
..




 r−1

P
t
Vi,j,u,r−1 Aj
u=0

r−1
P
Vi,u

u=0

r−1

P

λtj,0
Vi,j,u,0

u=0

r−1

P
= rank(
λtj,1
Vi,j,u,1

u=0


..

.


r−1
P
λtj,r−1
Vi,j,u,r−1
u=0

= rank(Ri,j );










)







13

Otherwise, we have

rank(

Ri,j
Si,t At,j




I
)
P
) = rank( r−1
Vi,u Atj
 u=0

I
)
P t
= rank( r−1
λj,u Vj,u
u=0

= rank(Ri,j ).

Therefore, by (6) and (46), the repair bandwidth of node i is
γi =

n−1
X

rank(Ri,j )

j=0,j6=i

N (r − 1)N
=(n − 1) +
|{j : j ∈ [0, n)\{i}, j ≡ i mod n′ }|
r
r
(
(⌈ n ⌉−1)(r−1)
)γ ∗ ,
if 0 ≤ i%n′ < n%n′ ,
(1 + n′ n−1
n
=
(⌊ ⌋−1)(r−1)
(1 + n′ n−1
)γ ∗ ,
otherwise,
where γ ∗ = (n − 1) Nr is the optimal value for repair
bandwidth.
Theorem 14. The code C5 possesses the MDS property if
(i) λi,u 6= λj,v for all u, v ∈ [0, r) and i, j ∈ [0, n) with
j 6≡ i mod n′ ,
(ii) λi,u 6= λi+gn′ ,u for all u ∈ [0, r), g ∈ [1, ⌈ nn′ ⌉), i ∈
[0, n′ ) with i + gn′ < n.
Proof. The proof can be proceeded in the same fashion as that
of Theorem 4.
In the following, we give an assignment of the values λi,u ,
i ∈ [0, n), u ∈ [0, r) so that the requirements in Theorems 13
and 14 can be satisfied.
Theorem 15. The requirements in Theorems 13 and 14 can
be satisfied if q is a prime power such that

n
′
if 0 < n%(rn′ ) < n′ ,
rn′ (⌈ rn
′ ⌉ − 1) + (n%n )r,
q>
′ n
rn ⌈ rn′ ⌉,
otherwise.
n
n
Proof. If 0 < n%(rn ) < n , then ⌈ rn
′ ⌉ − 1 = ⌊ rn′ ⌋ and
(z)
n
′
′
′
n%(rn ) = n%n , let ξi′ ,v , z ∈ [0, ⌊ rn′ ⌋), i ∈ [0, n′ ), v ∈
(⌊ n ⌋)
n
[0, r), and ξi′ ,vrn′ , i′ ∈ [0, n%n′ ), v ∈ [0, r) be rn′ ⌊ rn
′⌋ +
′
(n%n )r pairwise distinct nonzero elements in Fq ; Otherwise,
(z)
n
′
′
′ n
let ξi′ ,v , z ∈ [0, ⌈ rn
′ ⌉), i ∈ [0, n ), v ∈ [0, r) be rn ⌈ rn′ ⌉
pairwise distinct nonzero elements in Fq . Then for i = zrn′ +
n
un′ +i′ , i′ ∈ [0, n′ ), u ∈ [0, r), z ∈ [0, ⌈ rn
′ ⌉), if we set λi,t =
(z)
ξi′ ,t+u for i ∈ [0, n) and t ∈ [0, r), where the subscript t+u is
′

′

computed modulo r, it is easy to verify that the requirements
in Theorems 13 and 14 can be satisfied.

In the following, we give a concrete example of the MDS
code C5 according to Theorem 15.

Example 2. Let r = 2, n′ = 3, and n = 12, then the paritycheck matrix of the (12, 10) MDS code C5 over F13 is defined
through


 2 
 4 
e0
c e0
c e0
 e1 
 c2 e 1 
 c5 e 1 


 3 
 4 
 e2 
 c e2 
 c e2 


 3 
 5 
 e3 
 c e3 


 , A1 =  2  , A2 =  c4 e3  ,
A0 = 
 ce4 
 c e4 
 c e4 


 2 
 5 
 ce5 
 c e5 
 c e5 


 3 
 4 
 ce6 
 c e6 
 c e6 
3
ce7
c e7
c5 e 7







A3 = 












A6 = 












A9 = 






ce0
ce1
ce2
ce3
e4
e5
e6
e7
c6 e 0
c6 e 1
c6 e 2
c6 e 3
c7 e 4
c7 e 5
c7 e 6
c7 e 7

c7 e 0
c7 e 1
c7 e 2
c7 e 3
c6 e 4
c6 e 5
c6 e 6
c6 e 7

where c = 2.



















 , A4 = 





















 , A7 = 

























 , A10 = 











c3 e 0
c3 e 1
c2 e 2
c2 e 3
c3 e 4
c3 e 5
c2 e 6
c2 e 7
c8 e 0
c8 e 1
c9 e 2
c9 e 3
c8 e 4
c8 e 5
c9 e 6
c9 e 7
c9 e 0
c9 e 1
c8 e 2
c8 e 3
c9 e 4
c9 e 5
c8 e 6
c8 e 7



















 , A5 = 





















 , A8 = 
























 , A11 = 











c5 e 0
c4 e 1
c5 e 2
c4 e 3
c5 e 4
c4 e 5
c5 e 6
c4 e 7








,






c10 e0
c11 e1
c10 e2
c11 e3
c10 e4
c11 e5
c10 e6
c11 e7
c11 e0
c10 e1
c11 e2
c10 e3
c11 e4
c10 e5
c11 e6
c10 e7








,












,






Similar to the MDS code C1 , we have the following result.
Theorem 16. The MDS code C5 has the optimal update
property.
VI. C OMPARISONS
In this section, we give comparisons of some key parameters
among the proposed MDS codes and some existing notable
MDS codes.
Table II compares the details of these codes, while Tables
III-V compare the new MDS code C4 and the RTGE code
1 in terms of the sub-packetization level, the field size, and
the repair bandwidth for r = 2, 3 and 4, respectively. From
these tables, we see that the proposed MDS codes have the
following advantages:

14

TABLE II
A

COMPARISON OF SOME KEY PARAMETERS AMONG THE (n, k) MDS CODES PROPOSED IN THIS PAPER AND SOME EXISTING NOTABLE
CODES , WHERE WE SET n = sn′ FOR CONVENIENCE AND r = n − k

Sub-packetization
level N
′
′

rn
O(r rτ log n)
rn

The new MDS code C5
The RTGE code 2
The YB code 1

′

The new MDS code C2

rn

The new MDS code C3
The improved YB code 2
Shortened duplication-zigzag

r n−1
′
r n −1

The new MDS code C4

r r+1

The RTGE code 1

rτ

Long code C4′

n
r r+1

(s−1)(r−1)
n−1
(s−1)(r−1)
n−1

<1+

r
n′

Thm 7

<1+

r
n′

Thm 8

(Optimal)
= 1 + (s−1)(r−1)
<1+
n−1

r
n′

[15]
[3]

=1+

(s−1)(r−1)
n−1

<1+

r
n′

=1+

(s−1)(r−1)
n−1

<1+

1
τ

1

′

,
q > 2n
3

q > N n−1
+ 1,
r−1

n′

if r = 2
if r > 2

q > n(r−1)N+1

q > N n−1
+1
r−1

COMPARISON OF SOME KEY PARAMETERS AMONG THE

=1+
=1+

A

1

The RTGE code 1

40
60
40
60

Thms 15, 16
[23]
[12]

τ is an integer
1 ≤ τ ≤ ⌈n
⌉−1
r

[23]

Implicit when r > 2

Thms 9, 10

TABLE III
MDS CODES C4 AND THE RTGE CODE 1 UNDER SOME SPECIFIC CODE LENGTHS FOR r = 2

12
18
24
12
18
24

2
2
2
2
2
2

22
22
22
23
23
23

32
13
17
> 109
> 1011
> 1012

γ
γ∗

1+
1+
1+
1+
1+
1+

1
11
2
17
3
23
1
11
2
17
3
23

TABLE IV
MDS CODES C4 AND THE RTGE CODE 1 UNDER SOME SPECIFIC CODE LENGTHS FOR r = 3

3
3
3
3

33
33
34
34

Field size
q
> 6831
> 16065
> 10224
> 10253

γ
γ∗

1+
1+
1+
1+

Remark

1
23
2
35
1
23
2
35

Implicit construction

TABLE V
MDS CODES C4 AND THE RTGE CODE 1 UNDER SOME SPECIFIC CODE LENGTHS FOR r = 4

Code length Number of Sub-packetization
n
parties r
level N
The new MDS code C4

(Optimal)

Field size
q

COMPARISON OF SOME KEY PARAMETERS AMONG THE

Thms 3-5

Optimal update
τ >0
Optimal update

Implicit when r > 2 Thms 11, 12

Sub-packetization
level N

24
36
24
36

Optimal update

1

Code length Number of Sub-packetization
n
parties r
level N

The RTGE code 1

(Optimal)

Number of
parties r

COMPARISON OF SOME KEY PARAMETERS AMONG THE

The new MDS code C4

<1+

r
n′
r
n′

Code length
n

The RTGE code 1

References

<1+

=1+

q > r⌈ nr ⌉(⌈ nn′ ⌉ − 1) + n′
q > s, q is odd, if r is even
q > sr,
otherwise
q>r
q>s

Remark

(s−1)(r−1)
n−1
(s−1)(r−1)
n−1
≤ 1 + τ1

=1+

O(n)
q ≥ rn

The new MDS code C4

A

n
rn′ ⌈ rn
′⌉

q>

−1

′
r n −1

A

n
q > rn′ ⌈ rn
′ ⌉, r|(q − 1)

rn

The new MDS code C1

The ratio of repair bandwidth
to the optimal value γ ∗

Field size

(n, k) MDS

4
4
4
4

44
44
45
45

Field size
q
> 2339584
> 8322304
> 104923
> 105464

γ
γ∗

1+
1+
1+
1+

Remark
1
13
6
59
1
13
6
59

Implicit construction

15

The new MDS codes C1 , C2 , C3 , and C5 can support any
number of parity nodes while the shortened duplicationzigzag code2 in [3] can only support two parity nodes.
• The new MDS codes C1 and C5 have the optimal update
property.
′
• The new (n = sn , k) MDS codes derived in this
paper indeed have a small sub-packetization level N′ .
n
′
Specifically, N = rn for the codes C1 and C5 , N = r r+1
′
for the code C4 , and N = rn −1 for the codes C2 and C3 .
Note that n′ can be fixed as a constant. Consequently, for
each new MDS code, the sub-packetization level can be
a constant, which is independent of code length n.
′
• Compared with the RTGE code 1 in [23], when n =
rτ , the new explicit MDS codes C1 , C2 , C3 , and C5 are
built on much smaller finite fields, but have larger subpacketization levels. Besides, all the proposed MDS codes
have the same repair bandwidth as the RTGE code 1 in
[23] under the same parameters n and k.
• Particularly, the new (n, k) MDS code C4 has not only a
smaller sub-packetization level, but also a much smaller
finite field when compared to the RTGE code 1.
Nevertheless, the code C4 is explicit only for r = 2,
′
n
which requires a finite field with size q > 2n
3 ⌈ n′ ⌉. For
r > 2, further investigation is needed to find the explicit
construction.
• In contrast to RTGE code 2 in [23], which has subpacketization growing logarithmically with the code
length n, the new codes have smaller sub-packetizations.
For example, the sub-packetization level of the MDS code
C5 is around log1 n times that of the RTGE code 2 in [23]
when n′ = rτ .
• The RTGE codes 1 and 2 in [23] show that it is possible
to trade repair bandwidth for sub-packetization, while the
proposed codes C1 , C2 , C3 , and C5 further show that it is
possible to trade sub-packetization for field size base on
the RTGE code 1, as these new codes are explicit and
are over small finite fields.
In addition to the above advantages, the new codes C1 -C5 have
a defect that they do not possess the load balancing property
as some of the helper nodes contribute a higher amount of data
during the node repair process. Whereas, the RTGE code 2 in
[23] is load balanced, where all the contacted nodes provide
(approximately) the same amount of information during the
repair process.
•

VII. C ONCLUSION
In this paper, we provided a powerful transformation that
can greatly reduce the sub-packetization level N of the original
codes with respect to the same code length n. Four applications
of the transformation were demonstrated, three of which are
explicit and over a small finite field. In addition, another
explicit MDS code construction over a small finite field and
with small sub-packetization level, small repair bandwidth
2 Note that the code length of the duplication-zigzag code in [3] is in the
form of uk ′ + 2 with uk ′ ≫ 2, in order to do a fair comparison under the
same code length, we delete two nodes of the duplication-zigzag code in [3]
and term the resultant code as shortened duplication-zigzag code.

as well as the optimal update property was presented. The
comparisons show that the obtained MDS codes outperform
existing MDS codes in terms of the field size and/or the subpacketization level. Extending our transformation and constructions to the case of d < n − 1 or multiple node failures
are part of our ongoing work.
A PPENDIX A
P ROOF OF T HEOREM 1
Before proving Theorem 1, let us introduce some necessary
definitions and results on determinants.
Definition 1 ( [25]). A k-rowed minor of an n-rowed determinant D = det(ai,j )i∈[0,n),j∈[0,n) is any k-rowed determinant
obtained when n − k rows and n − k columns are deleted
from D. The k-rowed minor obtained from D by retaining
only the elements belonging to rows r0 , . . . , rk−1 and columns
s0 , . . . , sk−1 will be denoted by
D(r0 , . . . , rk−1 |s0 , . . . , sk−1 ).
e 0 , . . . , rk−1 |s0 , . . . , sk−1 ) of the minor
The cofactor D(r
D(r0 , . . . , rk−1 |s0 , . . . , sk−1 ) in a determinant D is defined
as
e 0 , . . . , rk−1 |s0 , . . . , sk−1 )
D(r

=(−1)r0 +...+rk−1 +s0 +...+sk−1 D(rk , . . . , rn−1 |sk , . . . , sn−1 ),
where rk , . . . , rn−1 are the n − k numbers among 0, . . . , n −
1 other than r0 , . . . , rk−1 and sk , . . . , sn−1 are the n − k
numbers among 0, . . . , n − 1 other than s0 , . . . , sk−1 .
Lemma 6 (Laplace’s expansion theorem [25]). Let D be an
n-rowed determinant, and let r0 , . . . , rk−1 be integers such
that 0 ≤ k < n − 1 and 0 ≤ r0 < . . . < rk−1 < n. Then
X
D=
D(r0 , . . . , rk−1 |u0 , . . . , uk−1 )
0≤u0 <...<uk−1 <n

e 0 , . . . , rk−1 |u0 , . . . , uk−1 ).
× D(r

Proposition 1. Let u ≥ 2 and let
y0,0 B0,0
 y1,0 B1,0
B =
..

.
yu−1,0 Bu−1,0


y0,1 B0,1
y1,1 B1,1
..
.
yu−1,1 Bu−1,1

···
···
..
.
···

y0,u−1 B0,u−1 
y1,u−1 B1,u−1 

..

.
yu−1,u−1 Bu−1,u−1

be a block matrix of order uN over a certain finite field
Fq , where yi,j is an indeterminate in Fq and Bi,j is a full
rank matrix of order N for i, j ∈ [0, u). Then det(B) is a
homogeneous polynomial of degree uN which includes the
term
!
u−1
Y
N N
N
det(Bt,t ) y0,0
y1,1 · · · yu−1,u−1
.
(49)
t=0

Proof. Clearly, det(B) is a uN -rowed determinant, the expansion of which includes (uN )! terms, where each term is a
monomial of degree uN . Therefore, det(B) is a homogeneous
polynomial of degree uN . In the following, we prove that
det(B) includes the term in (49) by induction.
Let D = det(B), when u = 2, then by Definition 1 and
Lemma 6, we can get (50) in the next page, which implies

16

that D includes the term in (49).
Assume that the induction hypothesis holds, i.e., D includes
the term in (49) for u = v ≥ 2. Then, when u = v + 1, similarly, we can obtain (51) in the next page. Note from Definition
e
1 that D(vN,
. . . , (v + 1)N − 1|vN, . . . , (v + 1)N − 1) is a
vN -rowed determinant, which includes the term
!
v−1
Y
N N
N
det(Bt,t ) y0,0
y1,1 · · · yv−1,v−1
t=0

by the induction hypothesis. Hence, D includes the term
!
v
Y
N N
N
det(Bt,t ) y0,0
y1,1 · · · yv,v
.
t=0

Based on the above analysis, we proved that det(B) includes the term in (49) for any u ≥ 2.
Proof of Theorem 1: By (11),
the new (n, k) code is

A0,0
A0,1
 A1,0
A
1,1

A=
..
..

.
.
Ar−1,0 Ar−1,1

the parity-check matrix of
···
A0,n−1
···
A1,n−1
..
..
.
.
· · · Ar−1,n−1

with the j-th block column being

x0,j A′0,j%n′

x1,j A′1,j%n′


..

.
xr−1,j A′r−1,j%n′











.


Then the new code is MDS if and only if any r × r sub-block
matrix of A is nonsingular.
For any J = {j0 , j1 , · · · , jr−1 } ⊂ [0, n), let PJ be the
r × r sub-block matrix of A formed by the r block columns
indicated by J, i.e.,


···
x0,jr−1 A′0,jr−1 %n′
x0,j0 A′0,j0 %n′
 x1,j0 A′1,j %n′
···
x1,jr−1 A′1,jr−1 %n′ 
0


PJ =
,
..
..
..


.
.
.
′
′
xr−1,j0 Ar−1,j0 %n′ · · · xr−1,jr−1 Ar−1,jr−1 %n′

whichQis nonsingular if det(PJ ) is Q
nonzero. Define P =
PJ , then det(P ) =
det(PJ ). Thus,

J⊂[0,n),|J|=r

J⊂[0,n),|J|=r

it suffices to prove that there is an assignment to the variables
xi,j , i ∈ [0, r), j ∈ [0, n) that does not evaluate det(P ) to
zero.
By Proposition 1, det(PJ ) is a homogeneous polynomial of
degree rN which includes the term
!
r−1
Y
N
N
′
det(At,jt %n′ ) xN
0,j0 x1,j1 · · · xr−1,jr−1 .
t=0


Then, det(P ) is a homogeneous polynomial of degree rN nr,
where each indeterminate xi,j has degree at most N n−1
r−1 .

n−1
Therefore, by Lemma 2, if q > N r−1 + 1, then there
are x0,0 , . . . , x0,n−1 , . . . , xr−1,0 , . . . , xr−1,n−1 ∈ Fq \{0} that
does not evaluate det(P ) to zero. This finishes the proof. 
A PPENDIX B
P ROOF OF T HEOREM 10

The new storage code C4′ has the optimal repair bandwidth
if and only if (4) and (5) hold.
(i) Firstly, by (35), (36), and (38), we determine the necessary and sufficient conditions for (4) according to the following
two cases.
i′
Case 1: For any i′ ∈ [0, rm), let u = ⌊ m
⌋, then we have


Si′′ ,0 A′0,i′


Si′′ ,1 A′1,i′


rank(
)
..


.
′
′
Si′ ,r−1 Ar−1,i′


′
y0,i′ Vi′ ,u B0,i
′
′


y1,i′ Vi′ ,u B1,i
′


=rank(
)
..


.
′
′
′
yr−1,i Vi ,u Br−1,i′


Vi′ ,u
r−1


 λi′ ,u Vi′ ,u + P (λi′ ,u − λi′ ,a )Vi′ ,a 




a=0,a6=u
),
=rank(
..


.




r−1
P

 r−1
r−1
r−1
(λi′ ,u − λi′ ,a )Vi′ ,a
λi′ ,u Vi′ ,u +
a=0,a6=u

which is of full rank if and only if (52) in the next page
holds, i.e., λi′ ,0 , λi′ ,1 , · · · , λi′ ,r−1 are pairwise distinct.

e . . . , N − 1|0, . . . , N − 1)
D = D(0, . . . , N − 1|0, . . . , N − 1)D(0,
X
e . . . , N − 1|j0 , . . . , jN −1 )
+
D(0, . . . , N − 1|j0 , . . . , jN −1 )D(0,
0≤j0 <...<jN −1 <2N
(j0 ,...,jN −1 )6=(0,...,N −1)

= det(y0,0 B0,0 ) det(y1,1 B1,1 ) +

=

1
Y

t=0

!

N N
det(Bt,t ) y0,0
y1,1 +

X

0≤j0 <...<jN −1 <2N
(j0 ,...,jN −1 )6=(0,...,N −1)

X

0≤j0 <...<jN −1 <2N
(j0 ,...,jN −1 )6=(0,...,N −1)

e . . . , N − 1|j0 , . . . , jN −1 )
D(0, . . . , N − 1|j0 , . . . , jN −1 )D(0,

e . . . , N − 1|j0 , . . . , jN −1 ).
D(0, . . . , N − 1|j0 , . . . , jN −1 )D(0,

(50)

17

Case 2: For i′ ∈ [rm, (r + 1)m),




rank(






= rank(






= rank(

=N

⇔

1
λi′ ,0
..
.
λr−1
i′ ,0

Si′′ ,0 A′0,i′
Si′′ ,1 A′1,i
..
.
Si′′ ,r−1 A′r−1,i′

have



Ri′ ′ ,j ′
rank(
)
S ′′ A′ ′
 i ,t t,j 
Vi′ ,u
= rank(
)
Vi′ ,u A′t,j ′

Vi′ ,u
′
 Vi′ ,j ′ ,u,0 Bt,j
′

..


.

′
 Vi′ ,j ′ ,u,v−1 Bt,j
′
= rank(
′
 Vi′ ,j ′ ,u,v Bt,j
′

 Vi′ ,j ′ ,u,v+1 B ′ ′
t,j


..

.





)


′
y0,i′ (Vi′ ,0 + · · · + Vi′ ,r−1 )B0,i
′
′
y1,i′ (Vi′ ,0 + · · · + Vi′ ,r−1 )B1,i
′
..
.
′
yr−1,i′ (Vi′ ,0 + · · · + Vi′ ,r−1 )Br−1,i
′

Vi′ ,0 + · · · + Vi′ ,r−1
λi′ ,0 Vi,0 + · · · + λi′ ,r−1 Vi,r−1 

)
..

.
r−1
′ ,0 + · · · + λ ′
′ ,r−1
λr−1
V
V
′
i
i
i ,0
i ,r−1

···
1
· · · λi′ ,r−1
..
..
.
.
· · · λr−1
′
i ,r−1





)


which holds if and only if λi′ ,0 , λi′ ,1 , · · · , λi′ ,r−1 are
pairwise distinct.
(ii) Secondly, by (9), (35), (37), and (38), we establish the
necessary and sufficient conditions for (5) according to the
following four cases.
Case 1: For t ∈ [0, r) and i′ , j ′ ∈ [0, rm) with i′ 6= j ′ ,
j′
i′
⌋ and v = ⌊ m
⌋. If j ′ 6≡ i′ mod m, then we
let u = ⌊ m







)








Vi′ ,u


λtj ′ ,0 Vi′ ,j ′ ,u,0




.
..






t
′
′
λ
V


j ′ ,v−1 i ,j ,u,v−1


r−1
P
)
= rank( t
t
t
(λj ′ ,v−λj ′ ,a )Vi′ ,j ′ ,u,a

λj ′ ,v Vi′ ,j ′ ,u,v+


a=0,a6=v




λtj ′ ,v+1 Vi′ ,j ′ ,u,v+1


..




.
λtj ′ ,r−1 Vi′ ,j ′ ,u,r−1


Vi′ ,u
 Vi′ ,j ′ ,u,0 


= rank(
)
..


.


6= 0,

′
Vi′ ,j ′ ,u,r−1 Bt,j
′



Vi′ ,j ′ ,u,r−1

= N/r;

Otherwise, u 6= v, thus we have

e
D =D(vN, . . . , (v + 1)N − 1|vN, . . . , (v + 1)N − 1)D(vN,
. . . , (v + 1)N − 1|vN, . . . , (v + 1)N − 1)
X
e
+
D(vN, . . . , (v + 1)N − 1|j0 , . . . , jN −1 )D(vN,
. . . , (v + 1)N − 1|j0 , . . . , jN −1 )
0≤j0 <...<jN −1 <(v+1)N
(j0 ,...,jN −1 )6=(vN,...,(v+1)N −1)

e
= det(yv,v Bv,v )D(vN,
. . . , (v + 1)N − 1|vN, . . . , (v + 1)N − 1)
X
e
+
D(vN, . . . , (v + 1)N − 1|j0 , . . . , jN −1 )D(vN,
. . . , (v + 1)N − 1|j0 , . . . , jN −1 ).

(51)

0≤j0 <...<jN −1 <(v+1)N
(j0 ,...,jN −1 )6=(vN,...,(v+1)N −1)

0
λi′ ,u − λi′ ,0
..
.

···
···
..
.

0
λi′ ,u − λi′ ,u−1
..
.

1
λi′ ,u
..
.

0
λi′ ,u − λi′ ,u+1
..
.

···
···
..
.

r−1
λr−1
i′ ,u − λi′ ,0

r−1
· · · λr−1
i′ ,u − λi′ ,u−1

λr−1
i′ ,u

r−1
λr−1
i′ ,u − λi′ ,u+1

r−1
· · · λr−1
i′ ,u − λi′ ,r−1

=(−1)r−1

1
λi′ ,0
..
.
λr−1
i′ ,0

6=0,

···
1
· · · λi′ ,u−1
..
..
.
.
· · · λr−1
i′ ,u−1

1
λi′ ,u
..
.

1
λi′ ,u+1
..
.

λr−1
i′ ,u

λr−1
i′ ,u+1

0
λi′ ,u − λi′ ,r−1
..
.

···
1
· · · λi′ ,r−1
..
..
.
.
· · · λr−1
i′ ,r−1
(52)

18

Otherwise,

rank(

Ri′ ′ ,j ′
′
Si′ ,t A′t,j ′




Vi′ ,u
) = rank(
)
′
yt,j ′ Vi′ ,u Bt,j
′


Vi′ ,u
= rank(
)
λtj ′ ,u Vi′ ,u
= N/r.

Case 2: For t ∈ [0, r), i′ ∈ [rm, (r + 1)m) and j ′ ∈
j′
⌋. If j ′ 6≡ i′ mod m, we have
[0, rm), let u = ⌊ m


Ri′ ′ ,j ′
rank(
)
S ′′ At,j ′

 i ,t
Vi′ ,0 + Vi′ ,1 + · · · + Vi′ ,r−1
= rank(
)
(Vi′ ,0 + Vi′ ,1 + · · · + Vi′ ,r−1 )Bt,j ′


r−1
P
Vi′ ,a




a=0

 r−1
 P V ′ ′ B′ ′ 
i ,j ,a,0 t,j



 a=0


..


.



 r−1

 P ′ ′
′
Vi ,j ,a,u−1 Bt,j ′ 


 a=0
= rank( r−1
)

 P
′
′
′
V
B ′ 

 a=0 i ,j ,a,u t,j 

 r−1

 P
′


V′ ′
B
 a=0 i ,j ,a,u+1 t,j ′ 


..




.

 r−1

 P
′
Vi′ ,j ′ ,a,r−1 Bt,j
′
a=0


r−1
P
′
V
i ,a


a=0


r−1


P
t


′
′
λj ′ ,0
Vi ,j ,a,0


b=0




..


.




r−1
P


λtj ′ ,u−1
Vi′ ,j ′ ,a,u−1




a=0
 r−1

 P (λt V ′ ′

= rank(
)
j ′ ,u i ,j ,a,u
 a=0



r−1
P


(λtj ′ ,u − λj ′ ,b )Vi′ ,j ′ ,a,b ) 
−



b=0,b6=u


r−1


P
t


′
′
λ
V
i ,j ,a,u+1
j ′ ,u+1


a=0




..


.


r−1


P
t
λj ′ ,r−1
Vi′ ,j ′ ,a,r−1
a=0


r−1
P
′ ,a
V
i


a=0
 r−1

 P



′
′
V
i ,j ,a,0


= rank( a=0
)


.
.


.


 r−1

P
Vi′ ,j ′ ,a,r−1
a=0

= N/r;



Ri′ ′ ,j ′
rank(
)
Si′′ ,t At,j ′


r−1
P
 a=0 Vi′ ,a

)
=rank(
 r−1

P
′
Vi′ ,a Bt,j ′
a=0


r−1
P
Vi′ ,a


a=0
)
=rank(
 t r−1

P
λj ′ ,u
Vj ′ ,a
a=0

=N/r.

Case 3: For t ∈ [0, r), i′ ∈ [0, rm) and j ′ ∈ [rm, (r +
1)m), we easily have
!


Vi′ ,⌊ i′ ⌋
Ri′ ′ ,j ′
m
)
rank(
) = rank(
′
yt,j ′ Vi′ ,⌊ i′ ⌋ Bt,j
Si′′ ,t A′t,j ′
′
m

= N/r.
Case 4: For i′ , j ′ ∈ [rm, (r + 1)m) and i′ 6= j ′ , we have


Ri′ ′ ,j ′
rank(
)
Si′′ ,t A′t,j ′


r−1
P
Vi′ ,a


a=0
)
=rank(
r−1
 P

′
Vi′ ,a Bt,j ′
a=0


r−1
P
Vi′ ,a


 r−1 a=0

 P

′

Vi′ ,j ′ ,a,0 Bt,j ′ 


=rank( a=0
)


.
..




 r−1

P
′
′
′
Vi ,j ,a,r−1 Bt,j ′
a=0


r−1
P
′
V
i ,a


a=0


r−1


P
t


λj ′ ,0
Vi′ ,j ′ ,a,0


a=0
=rank(
)


..


.


r−1


P
λtj ′ ,r−1
Vi′ ,j ′ ,a,r−1
a=0

=N/r.

This finishes the proof after combining (i) and (ii).
ACKNOWLEDGMENT
The authors would like to thank the Associate Editor Dr.
Parastoo Sadeghi and the three anonymous reviewers for
their valuable suggestions and comments, which have greatly
improved the presentation and quality of this paper. Jie Li
would like to thank Prof. Alexander Barg and Prof. Itzhak
Tamo for helpful discussions during his visit at the University
of Maryland, College Park.

19

R EFERENCES
[1] A.G. Dimakis, P. Godfrey, Y. Wu, M. Wainwright, and K. Ramchandran,
“Network coding for distributed storage systems,” IEEE Trans. Inform.
Theory, vol. 56, no. 9, pp. 4539-4551, Sep. 2010.
[2] K.V. Rashmi, N.B. Shah, and P.V. Kumar, “Optimal exact-regenerating
codes for distributed storage at the MSR and MBR points via a productmatrix construction,” IEEE Trans. Inform. Theory, vol. 57, no. 8, pp.
5227-5239, Aug. 2011.
[3] T. Tamo, Z. Wang, and J. Bruck, “Zigzag codes: MDS array codes with
optimal rebuilding,” IEEE Trans. Inform. Theory, vol. 59, no. 3, pp.
1597-1616, Mar. 2013.
[4] D.S. Papailiopoulos, A.G. Dimakis, and V.R. Cadambe, “Repair optimal
erasure codes through Hadamard designs,” IEEE Trans. Inform. Theory,
vol. 59, no. 5, pp. 3021-3037, May 2013.
[5] J. Li, X. Tang, and C. Tian, “A generic transformation to enable optimal
repair in MDS codes for distributed storage systems”, IEEE Trans.
Inform. Theory, vol. 64, no. 9, pp. 6257-6267, Sept. 2018.
[6] X. Tang, B. Yang, J. Li, and H.D.L. Hollmann, “A new repair strategy
for the Hadamard minimum storage regenerating codes for distributed
storage systems,” IEEE Trans. Inform. Theory, vol. 61, no. 10, pp. 52715279, Oct. 2015.
[7] J. Li and X. Tang, “Optimal exact repair strategy for the parity nodes
of the (k + 2, k) Zigzag code,” IEEE Trans. Inform. Theory, vol. 62,
no. 9, pp. 4848-4856, Sep. 2016.
[8] J. Li, X. Tang, and C. Tian, “A generic transformation for optimal repair
bandwidth and rebuilding access in MDS codes”, in Proc. IEEE Int.
Symp. Inform. Theory, Aachen, Germany, Jun. 2017, pp. 1623-1627.
[9] Z. Wang, T. Tamo, and J. Bruck, “Explicit minimum storage regenerating
codes,” IEEE Trans. Inform. Theory, vol. 62, no. 8, pp. 4466-4480, Aug.
2016.
[10] Z. Wang, I. Tamo, and J. Bruck, “On codes for optimal rebuilding
access,” in Proc. 49th Annu. Allerton Conf. Commun., Control, Comput.,
Monticello, IL, Sep. 2011, pp. 1374-1381.
[11] J. Li, X. Tang, and U. Parampalli, “A framework of constructions
of minimal storage regenerating codes with the optimal access/update
property,” IEEE Trans. Inform. Theory, vol. 61, no. 4, pp. 1920-1932,
Apr. 2015.
[12] M. Ye and A. Barg, “Explicit constructions of high-rate MDS array
codes with optimal repair bandwidth,” IEEE Trans. Inform. Theory, vol.
63, no. 4, pp. 2001-2014, Apr. 2017.
[13] M. Ye and A. Barg, “Explicit constructions of optimal-access MDS
codes with nearly optimal sub-packetization,” IEEE Trans. Inform.
Theory, vol. 63, no. 10, pp. 6307-6317, Oct. 2017.
[14] B. Sasidharan, M. Vajha, and P.V. Kumar, “An explicit, coupled-layer
construction of a high-rate MSR code with low sub-packetization level,
small field size and all-node repair,” arXiv: 1607.07335 [cs.IT]
[15] Y. Liu, J. Li, and X. Tang, “Explicit constructions of high-rate MSR
codes with optimal access property over small finite fields,” IEEE Trans.
Commun., vol. 66, no. 10, pp. 4405-4413, Oct. 2018.
[16] S. Goparaju, A. Fazeli, and A. Vardy, “Minimum storage regenerating
codes for all parameters,” IEEE Trans. Inform. Theory, vol. 63, no. 10,
pp. 6318-6328, Oct. 2017.
[17] M. Elyasi and S. Mohajer, “Cascade codes for distributed storage
systems,” IEEE Trans. Inform. Theory, to appear.
[18] M. Elyasi and S. Mohajer, “A cascade code construction for (n, k, d)
distributed storage systems,” in Proc. IEEE Int. Symp. Inform. Theory,
Vail, CO, Jun. 2018, pp. 1241-1245.
[19] J. Li and X. Tang, “Systematic construction of MDS codes with small
sub-packetization level and near optimal repair bandwidth,” in Proc.
IEEE Int. Symp. Inform. Theory, France, Paris, July 2019, pp. 10671071.
[20] S.B. Balaji, M.N. Krishnan, M. Vajha, V. Ramkumar, B. Sasidharan, and
P.V. Kumar, “Erasure coding for distributed storage: An overview,” Sci.
China Inf. Sci., vol. 61, Art. no. 100301, Oct. 2018.
[21] S. Goparaju, I. Tamo, and R. Calderbank, “An Improved SubPacketization Bound for Minimum Storage Regenerating Codes,” IEEE
Trans. Inform. Theory, vol. 60, no. 5, pp. 2770-2779, May 2014.
[22] O. Alrabiah and V. Guruswami, “An exponential lower bound on the subpacketization of MSR codes,” [Online]. Available at: arXiv: 1901.05112
[cs.IT]
[23] A.S. Rawat, I. Tamo, V. Guruswami, and K. Efremenko, “MDS code
constructions with small sub-packetization and near-optimal repair bandwidth,” IEEE Trans. Inform. Theory, vol. 64, no. 10, pp. 6506-6525, Oct.
2018.
[24] N. Alon, “Combinatorial nullstellensatz,” Combinat. Probab. Comput.,
vol. 8, no. 1-2, pp. 7-29, Jan. 1999.

[25] L. Mirsky, “An introduction to linear algebra,” Courier Corporation,
2012.

Jie Li (Member, IEEE) received the B.S. and M.S. degrees in mathematics
from Hubei University, Wuhan, China, in 2009 and 2012, respectively, and
received the Ph.D. degree from the department of communication engineering,
Southwest Jiaotong University, Chengdu, China, in 2017.
From 2015 to 2016, he was a visiting Ph.D. student in the Department of
Electrical Engineering and Computer Science, The University of Tennessee at
Knoxville, TN, USA. From 2017 to 2019, he was a postdoctoral researcher at
the Department of Mathematics, Hubei University, Wuhan, China. Since 2019,
he has been a postdoctoral researcher at the Department of Mathematics and
Systems Analysis, Aalto University, Finland. His research interests include
coding for distributed storage, private information retrieval, and sequence
design.
Dr. Li received the IEEE Jack Keil Wolf ISIT Student Paper Award in
2017.

Yi Liu (Graduate Student Member, IEEE) received the B.S. degree in mathematics and applied mathematics from Xihua University, Chengdu, China,
in 2014. He is currently pursuing the Ph.D. degree in information security
with Southwest Jiaotong University. His research interest includes coding for
distributed storage.

Xiaohu Tang (Senior Member, IEEE) received the B.S. degree in applied
mathematics from the Northwest Polytechnic University, Xi’an, China, the
M.S. degree in applied mathematics from the Sichuan University, Chengdu,
China, and the Ph.D. degree in electronic engineering from the Southwest
Jiaotong University, Chengdu, China, in 1992, 1995, and 2001 respectively.
From 2003 to 2004, he was a research associate in the Department of
Electrical and Electronic Engineering, Hong Kong University of Science and
Technology. From 2007 to 2008, he was a visiting professor at University
of Ulm, Germany. Since 2001, he has been in the School of Information
Science and Technology, Southwest Jiaotong University, where he is currently
a professor. His research interests include coding theory, network security,
distributed storage and information processing for big data.
Dr. Tang was the recipient of the National excellent Doctoral Dissertation
award in 2003 (China), the Humboldt Research Fellowship in 2007 (Germany), and the Outstanding Young Scientist Award by NSFC in 2013 (China).
He served as Associate Editors for several journals including IEEE Transactions on Information Theory and IEICE Transactions on Fundamentals, and
served on a number of technical program committees of conferences.

