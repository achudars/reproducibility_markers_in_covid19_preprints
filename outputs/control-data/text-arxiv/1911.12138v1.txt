Scheduling with Non-Renewable Resources:
Minimizing the Sum of Completion Times∗
Kristóf Bérczi†

Tamás Király‡

Simon Omlor§

November 28, 2019

arXiv:1911.12138v1 [cs.DS] 26 Nov 2019

Abstract
The paper considers single-machine scheduling problems with a non-renewable resource.
In this setting, we are given a set jobs, each of which is characterized by a processing time,
a weight, and the job also has some resource requirement. At fixed points in time, a certain
amount of the resource is made available to be consumed by the jobs. The goal is to assign
the jobs non-preemptively to time slots on the machine, so that at any time their resource
requirement does not exceed the available amounts of resources. The objective that we
consider here is the minimization of the sum of weighted completion times.
We give polynomial approximation algorithms and complexity results for single scheduling machine problems. In particular, we show strong
P NP-hardness of the case of unit resource requirements and weights (1|rm = 1, aj = 1| Cj ), thus answering an open question
of Györgyi and Kis. We also prove that the schedule corresponding to the Shortest Processing Time First ordering provides a 3/2-approximation for the same problem. We give simple
constant factor approximations
and a more complicated PTAS for the case of 0 processing
P
times (1|rm = 1, pj = 0| wj Cj ). We close the paper by proposing a new variant of the
problem in which the resource arrival times are unknown. A 4-approximation is presented
for this variant, together with an (4 − ε)-inapproximability result.
Keywords: Scheduling, Non-renewable resources, Weighted sum of completion times, Polynomial-time approximation scheme, Approximation algorithm, Strong NP-hardness

1

Introduction

The problem of scheduling with non-renewable resources appears naturally in practical problems
where resources like raw materials, energy, or financial constraints are taken into account. These
problems are interesting both from the practical and from the theoretical point of view. In the
general setting, we are given a set of jobs and a set of machines. Each job is equipped with a
requirement vector that encodes the needs of the given job for the different types of resources.
There is an initial stock for each resource, and some additional resource arrival times in the
future are known together with the arriving quantities. The aim is to find a schedule of the
jobs on the machines such that the resource requirements are met.
∗

Supported by DAAD with funds of the Bundesministerium für Bildung und Forschung (BMBF) and by DFG
project MN 59/4-1.
†
MTA-ELTE Egerváry Research Group, Department of Operations Research, Eötvös Loránd University, Budapest, Hungary. Email: berkri@cs.elte.hu.
‡
MTA-ELTE Egerváry Research Group, Department of Operations Research, Eötvös Loránd University, Budapest, Hungary. Email: tkiraly@cs.elte.hu.
§
TU Hamburg, Institute for Algorithms and Complexity, Hamburg, Germany. Email: simon.omlor@tuhh.de.

1

We will use the standard α|β|γ notation of Graham, Lawler, Lenstra and Kan [4]. Grigoriev,
Holthuijsen and Van De Klundert [5] extended this notation by adding the restriction rm = r
to the β field, meaning that there P
are r resources (raw materials). In the present paper, we
concentrate on problem 1|rm = 1| wj Cj , that is, when we have a single machine, a single
resource, and the goal is to minimize the weighted sum of completion times. While there is a
long list of results on the approximability of the makespan objective, much less is known about
the complexity and approximability of the total weighted completion time objective.
Previous work Scheduling problems with resource restrictions were introduced by Carlier [1]
and Slowinski [13]. Carlier settled the computational complexity
P of several variants for the sinlge
machine case [1]. In particular, it was shown that 1|rm = 1| wj Cj is NP-hard in the strong
sense. This was also proved independently by Gafarov, Lazarev and Wener in [2]. Kis [12]
showed that the problem remains weakly NP-hard even when the numberPof resource arrival
times is 2. On the positive side, he gave an FPTAS for 1|rm = 1, q = 2| wj Cj . A variant
of the problem where each job has processing time 1, there areP
q = n resource arrival times
such that ti = iM and bi = M for i = 1, . . . , n, and M =
j∈J aj /n is an integer, was
considered in [2]. Recently, Györgyi and Kis [11] gave polynomial time algorithms for several
special cases, and also showed that the problem remains weakly NP-hard even under the very
strong assumption that the processing time, the resource requirement and the weight are the
same for each job. They also provided a 2-approximation algorithm for this variant, and a
polynomial-time approximation scheme (PTAS) when the number of resource arrival times is a
constant and the processing time equals the weight for each job, while the resource requirements
are arbitrary.
In contrast to the case of total weighted completion objective, much is known about scheduling problems with non-renewable resources for the maximum makespan and maximum lateness
objectives. Slowinski [13] studied the preemptive scheduling of independent jobs on parallel
unrelated machines with the use of additional renewable and non-renewable resources under
financial constraints. Toker, Kondakci and Erkip [14] examined a single machine scheduling
problem under non-renewable resource constraint, using the makespan as a performance criterion. Xie [15] generalized this result to the problem with multiple financial resource constraints.
Grigoriev, Holthuijsen and Van De Klundert [5] presented polynomial time algorithms, approximations and complexity results for single scheduling machine problems with unit or all
equal processing times, and maximum lateness and makespan objectives. In a series of papers [6, 7, 8, 9, 10], Györgyi and Kis presented approximation schemes and inapproximability
results both for single and parallel machine problems with the makespan and the maximum
lateness objectives. In [11], they proposed a bracnh-and-cut algorithm for minimizing the maximum lateness.
P
Our results The first problem that we consider is 1|rm = 1, aj = 1| Cj . The complexity
of this problem was posed as an open question in [11]. We show that the problem is NP-hard
in the strong sense.
P
Theorem 1. 1|rm = 1, aj = 1| Cj is strongly NP-hard.
In the light of Theorem 1, one might be interested in finding an approximation algorithm
for the problem. Given any scheduling problem on a single machine, the Shortest Processing
Time First (SPT) schedule orders the jobs by processing times, i.e. pspt−1 (i) ≤ pspt−1 (i+1)
for all i. We prove that spt provides a 3/2-approximation. Although the algorithm is merely
scheduling according to the SPT order, the analysis if the algorithm is rather involved.

2

Theorem 2. The SPT schedule gives a 23 -approximation for 1|rm = 1, aj = 1|
approximation guarantee is tight.

P

Cj , and the

The second problem considered is the special case when the processing time is 0 for every
job. This setting is a relaxation of those instances where the processing times are short and the
resource arrival times are far away from each other. First we give a 6-approximation based on
a non-trivial greedy approach.
P
Theorem 3. There exists a 6-approximation for 1|rm = 1, pj = 0| Cj wj with running time
O(n log(n)).
We give a slightly more complicated (4 + ε)-approximation that illustrates one of the important ideas of the general PTAS.
P
Theorem 4. There exists a (4 + ε)-approximation for 1|rm = 1, pj = 0| Cj wj with running
time polynomial in 1/ε and the input length.
As a next step toward an efficient approximation algorithm, we present a PTAS for the case
of a constant number of resource arrival times. This procedure will be used as a subroutine in
our algorithm for the general case.
P
Theorem 5. There exists an (1 + kq )-approximation for 1|rm = 1, pj = 0| Cj wj with running
time O(nqk+1 ).
Finally, we prove the main result of the paper, which is a PTAS for the case of an arbitrary
number of resource arrival times.
P
Theorem 6. There exists a PTAS for 1|rm = 1, pj = 0| Cj wj .
P
The last problem that we is another variant of 1|rm = 1, pj = 0| Cj wj P
where the arrival
times are unknown. We denote this problem by 1|rm = 1, pj = 0, ti unkown| Cj wj .
P
Theorem 7. There exists a (4+ε)-approximation for 1|rm = 1, pj = 0, ti unkown| Cj wj with
running time polynomial in 1/ε and the input length. Moreover, there is no (4−ε)-approximation
algorithm for the problem for any ε > 0.
Organization The rest of the paper is organized as follows. Basic notation and terminology
are introduced in Section 2. APstrong NP-hardness proof and a 3/2-approximation algorithm
forPproblem 1|rm = 1, aj = 1| Cj are given in Section 3. Results on problem 1|rm = 1, pj =
0| Cj are discussed in Section 4, where a greedy 6-approximation, a (4 + ε)-approximation,
a PTAS for the case of constant resource arrival times, and a PTAS for the general case are
presented. We close the paper by proposing a new variant of the problem in which the resource
arrival times are unknown. A 4-approximation is presented for this case, together with an
(4 − ε)-inapproximability result.

2

Preliminaries

Throughout the paper, we will use the following notation. We are given a set J of n jobs. Each
job j ∈ J has a non-negative integer processing time pj , a non-negative weight wj , and a resource
requirement aj . The resources arrive at time points t1 , . . . , tq , and the amount
of resource
Pq
P
that arrives at time point ti is denoted by bi . We might assume that i=1 bi = nj=1 aj
holds. We will always assume that t1 = 0, as this does not effect the approximation ratio of our
algorithms.
3

The jobs should be processed non-preemptively on a single machine. A schedule is an
ordering of the jobs, that is, a mapping σ : J → [n], where σ(j) = i means that job j is the
ith job scheduled on the machine. The completion time of job j in schedule σ is denoted
by Cjσ . We will drop the index σ if the schedule is clear from the context. In any reasonable
schedule, there is an idle time before a job j only if there is not enough resource left to start j
after finishing the last job before the idle period. Hence the completion time of job j is basically
determined by the ordering and by the resource arrival times, as j will be scheduled at the first
moment when the preceding jobs are already finished and the amount of available resource is
at least aj .

3

The problem 1|rm = 1, aj = 1|

3.1

P

Cj

Strong NP-completeness

The aim of this section is to prove Theorem 1.
P
Theorem 1. 1|rm = 1, aj = 1| Cj is strongly NP-hard.
Proof. Recall that all aj and wj values are 1, and each job has an integer processing time pj .
The number of resource arrival times is part of the input.
We prove NP-completeness by reduction from the 3-Partition problem. The input
contains
P3n
numbers B ∈ N, n ∈ N, and xj ∈ N (j = 1, . . . , 3n) such that B/4 < xj < B/2 and
P j=1 xj =
nB. A feasible solution is a partition J1 , . . . , Jn of [3n] such that |Ji | = 3 and j∈Ji xj = B
for every i ∈ [n]. In contrast to the Partition problem, the 3-partition problem remains
NP-complete even when the integers xj are bounded above by a polynomial in n. That is, the
problem remains NP-complete even when the numbers in the input are represented as unary
numbers [3, Pages 96–105 and 224].
P
Let K = 4nB. The reduction to 1|rm = 1, aj = 1| Cj involves three types of jobs.
Normal jobs These correspond to the numbers xj in the 3-Partition instance, so there are
3n of them and the processing time pj of the j-th normal job is xj .
Small jobs Their processing time is 1 and there are nK of them.
Large jobs Their processing time is K and there are nK of them.
There are also three types of resource arrivals:
Type 1 Three resources arrive at times i(B + K) (i = 0, . . . , n − 1).
Type 2 One resource arrives at i(B + K) + j
(i = 0, . . . , n − 1, j = B, . . . , B + K − 1).
Type 3 One resource arrives at n(B + K) + iK (i = 0, . . . , nK − 1).
Suppose that the 3-Partition instance has a feasible solution J1 , . . . , Jn . We consider the
following schedule S: resources of Type 1 are used by normal jobs, such that jobs in Ji are
scheduled between (i − 1)(B + K) and iB + (i − 1)K (in spt order). Type 2 resources are used
by small jobs that start immediately. Type 3 resources are used by the large jobs that also start
immediately atPthe resource arrival times (see Figure 1).
P
Instead of
Cj , consider the equivalent shifted objective function (Cj − tj − pj ), where
tj is the arrival time of the resource used by job j and pj is its processing time – we assume
without loss of generality that resources are used by jobs in order of arrival. Note that all terms
4

b

b

b

B+K

0

J1

small
jobs

b

b

b

b

(n−1)(B+K)

b

b

b

n(B+K)

small
jobs

Jn

n(B+K)+nK 2

n(B+K)+K

nB+(n−1)K

B

large job

b

b

n(B+K)+nK 2 −K

large job

Figure 1: The schedule corresponding to a feasible solution of 3-Partition.
P
of (Cj − tj − pj ) are nonnegative. As small jobs and large jobs start immediately at the arrival
of the corresponding resource in schedule S, their contribution to the shifted objective function
is 0. The jobs in Ji have total processing time B, and their contribution to the shifted objective
function is two times the processing time of the shortest job plus the processing time of the
second shortest job, which is at most B. Hence the schedule S has objective value at most nB.
We claim that if the 3-Partition instance has no feasible solution, then the objective value
of any schedule is strictly larger
P than nB. First, notice that if a large job is scheduled to start
before time n(B + K), then (Cj − tj − pj ) has a term strictly larger than nB as there is a
resource that arrives while the large job is processed and is not used for more than nB time
units. Similarly, if the first large job starts at n(B + K) but uses a resource that arrived earlier,
then the resource that arrives at n(B + K) is not used for more than nB time units. We can
conclude that the first large job uses the resource arriving at n(B + K).
If the first large job does not start at n(B +K), then all large jobs have positive contribution
to the objective value, so again, the objective value is larger than nB. We can therefore assume
that the large jobs start exactly at n(B + K) + iK (i = 0, . . . , nK − 1) and that there is no
idle time before (B + K)n. In particular this means all other jobs are already completed at
(B + K)n.
Consider Type 2 resources arriving at i(B + K) + j (j = B, . . . , B + K − 1) for some fixed
i. If the first or the second resource is not used immediately, then none of the subsequent ones
are, so the objective value is more than nB. Hence, the first resource must be used immediately
by a small job.
Suppose that some resource in this interval is used by a normal job. If it is followed by
a small job, then we may improve the objective value by exchanging the two. Thus, in this
case, we can assume that the last resource of the interval is used by a normal job, and also the
Type 1 resources arriving at (i + 1)(B + K) are used by normal jobs. But this is impossible,
because normal jobs have processing time at least B/4 + 1, and a small job starts at time
(i + 1)(B + K) + B.
To sum up, we can assume that all resources of Type 2 are used immediately by small jobs.
This means that normal jobs have to use resources of Type 1, and must exactly fill the gaps
of length B between the arrival of resources of Type 2. This is only possible if the 3-partition
instance has a feasible solution, concluding the proof of Theorem 1.

3.2

Shortest processing time first for unit resource requirements

In the previous section, we have seen that scheduling with a non-renewable resource is strongly
NP-hard already for unit resource requirements. Now we show that scheduling the jobs according to an spt ordering provides a 3/2-approximation for the problem with unit weight and unit
resource requirements, thus proving Theorem 2.
P
Theorem 2. The SPT schedule gives a 23 -approximation for 1|rm = 1, aj = 1| Cj , and the
approximation guarantee is tight.
5

Proof. To prove the theorem consider any instance I. We denote the completion times for
the spt ordering by Cj and their sum by spt. Furthermore, let Sspt−1 (i) := Cspt−1 (i) − pspt−1 (i)
denote the starting time of the ith job in the spt schedule. Let opt be the optimal schedule
for I. We denote the completion times for opt by Cj0 and their sum by opt. Furthermore, let
0
0
Sopt
−1 (i) := Copt−1 (i) − popt−1 (i) denote the starting time of the ith job in the optimal schedule.
Our strategy is to simplify the instance by revealing its structural properties while not
spt
decreasing opt
. This way we get an upper bound for the approximation factor. We first consider
the resource arrival times.
0
Claim 8. We may assume that the ith resource arrives at Sopt
−1 (i) for i = 1, . . . , n.

Proof. As the ith resource is used by job opt−1 (i), the arrival time of that resource is at most
0
0
Sopt
−1 (i) . If we move the arrival time of the resource to exactly Sopt−1 (i) , then opt does not
change and spt cannot decrease.
The next claim shows that we can get rid of the idle times in the optimal schedule.
0
Claim 9. We may assume that there is no idle time in schedule opt, that is, Sopt
−1 (i) =
0
Copt−1 (i−1) for i = 2, . . . , n.
0
0
Proof. Suppose that there is some i such that ti > Copt
−1 (i−1) . We reduce t(i ) by ∆ = t(i) −
0
0
0
0
Copt
−1 (i−1) for all i ≥ i. Then for each i ≥ i, the completion time Copt−1 (i0 ) decreases by ∆.
For each i0 ≥ i, the completion time Cspt−1 (i0 ) decreases by at most ∆. This follows from the
fact that the resource arrival times decrease by ∆ and the completion time of the previous job
can decrease by at most ∆ (which can be shown by induction). Hence opt decreases by at least
spt
as much as spt. Since spt ≥ opt, the ratio opt
will not decrease by this change.

Next, we modify the processing times.
Claim 10. We may assume that popt−1 (1) > pspt−1 (1) and that pspt−1 (1) = 0.
Proof. If both schedules start with the same job, then we can remove the job from the instance
and decrease b1 by 1. Then opt decreases by the same amount as spt. We can repeat this
until the schedules start with jobs of different processing times. Now popt−1 (1) > pspt−1 (1) , since
spt starts with the shortest job. Decreasing the processing time of job spt−1 (1) to 0 (without
changing any arrival time) decreases spt by pspt−1 (1) and opt by at least pspt−1 (1) . We can
eliminate idle times in the new optimal schedule as in the proof of Claim 9.
Claim 11. We may assume that pj ∈ {0, 1} for all j ∈ J.
Proof. Let pmax = maxj∈J pj be the maximum processing time. Scaling the processing times
spt
by dividing all processing and arrival times by pmax has no effect on opt
, hence we may assume
0
that pmax = 1. Now assume that there is a job j with p = pj 0 ∈ (0, 1). Let p+ = min{pj | j ∈
J, pj > p} and p− = max{pj | j ∈ J, pj < p}. Let Jp = {j ∈ J | pj = p} be the set of jobs with
processing time p. We will show that we can either increase the processing time of all jobs in
spt
Jp to p+ or decrease the processing time of all jobs in Jp to p− without decreasing opt
.
For j ∈ J, let hj denote the number of jobs processed after j plus 1 with respect to schedule
opt, i.e. hj = n − opt−1 (j) + 1. Changing the processing times of all jobs in Jp by some
∆P
∈ [p− − p, p+ − p] and adopting the arrival times of the resources will increase opt by
∆ j∈Jp hj . Indeed, every time we change the processing time of one job j, the completion
time of j and of all jobs after j will be increased by ∆. Note that ∆ can be negative, which
means the completion times can also ’decrease’ by |∆|.

6

Notice that the order of the jobs in the spt schedule is not changed. Consider the spt schedule
before the change. Let job j ∈ J be any job, and let j0 be the the first job that is processed
after the last idle time before the starting time of j. Let fj be the number of jobs j 0 ∈ Jp
with Cj0 0 ≤ Sj0 . For each of those jobs, the arrival time of the resource needed to start j0 will
be changed by ∆fj . Thus, the starting time of job j0 in the changed spt schedule is at least
Sj0 + ∆fj . Now let gj be the number of jobs j 0 ∈ Jp that are processed in the time interval
[Sj0 , Cj ) before the change. For each of those jobs, the processing time is changed by ∆ and the
job is started at or after the new starting time of job j0 . Thus the new
P completion time of j is
at least Cj + ∆fj + ∆gj . P
Consequently, spt will increase by at least j∈J (fj + gj )∆ if ∆ > 0,
and decrease by at most j∈J (fj + gj )|∆| if ∆ < 0.
If

P
j∈J (fj +gj )
P
j∈Jp hj

≥

spt
opt ,

then increasing the processing times in Jp to p+ will not decrease

spt
opt .

spt
. Each time we
Otherwise, decreasing the processing times in Jp to p− will not decrease opt
apply this operation, the number of distinct processing times decreases by 1. Finally, we get an
instance where the only processing times are pmin = 0 and pmax = 1.

Lastly, we modify the order of the jobs in the optimal solution. If opt and spt process a job
of length 0 at the same time, then we can remove the job from the instance and reduce the
number of resources that arrive at this time by 1. This will reduce opt and spt by the same
amount.
Let t be the time at which schedule spt first starts to process a job of length 1. On one
hand, opt does not process jobs of length 0 before t by the above argument. On the other hand,
there is no idle time after t in spt, because that would mean idle time in opt. Thus, if we move
all jobs of length 0 and their corresponding resource arrivals in opt to time t, then spt does not
change but opt decreases. We may thus assume that schedule opt processes every job of length
0 at t.
k1 jobs
of length 1

k1 jobs
of length 0

k2 jobs
of length 1

OPT
b

b

b

b

b

b

SPT
b

b

b

b

b

b

k1 jobs
of length 0

b

b

b

k1 +k2 jobs
of length 1

Figure 2: Schedules opt and spt after the reductions. The 0 length jobs are scheduled in opt to
the first resource arrival time when multiple resources arrive.
We conclude that opt first processes k1 jobs of length 1, then k1 jobs of length 0 and then
k2 jobs of length 1, while spt starts with the jobs of length 0 having a lot of idle time in the
beginning and then consecutively processes all jobs of length 1 (see Figure 2). The weighted
sums of completion times are then given by
opt =
and
spt =

k1 (k1 + 1)
k2 (k2 + 1)
+ k12 + k2 k1 +
2
2

k1 (k1 − 1)
k1 (k1 + 1)
k2 (k2 + 1)
+ k2 k1 +
+ (k1 + k2 )k1 +
.
2
2
2
7

We get

3
k 2 k 2 k1 k2 3k1 + k2
(k1 − k2 )2
opt − spt = 1 + 2 −
+
≥
≥ 0,
2
4
4
2
4
4

showing that the approximation factor is at most 32 .
spt
Setting k2 = k1 and letting k1 go to infinity gives us a sequence of instances such that opt
converges to 32 as we have spt = 92 k12 + O(k1 ) and opt = 3k12 + O(k1 ). This concludes the proof
of Theorem 2.

4

The problem 1|rm = 1, pj = 0|

P

Cj w j

P
InP
this section we consider problem 1|rm = 1, pj = 0| Cj wj , another special case of 1|rm =
1| Cj wj . The problem clearly is NP-hard even for q = 2 as the knapsack problem can be
reduced to it. Indeed, maximizing the weight of the items in the knapsack is equivalent to
the task of maximizing the weight of jobs that areP
scheduled at the first resource arrival time.
Recall that Kis [12] gave a FPTAS for 1|rm = 1| Cj wj when there are two resource arrival
times.
First we give a 6-approximation for the problem based on a greedy approach. Next, we give
a more complicated 4-approximation that illustrates one of the important ideas of the more
general PTAS. Then we provide a PTAS for the case when q, the number of resource arrival
times is a constant. This algorithm will be used as a subroutine in the PTAS for the general
case. Finally, we prove the main result of the paper which is a PTAS for the case of an arbitrary
number of resource arrival times.
Since the processing times are 0, every job is processed at one of the arrival times in any
optimal schedule. Thus a schedule can be represented by a mapping π : J → [q], where π(j)
denotes the index of the resource arrival time when job j is processed. A schedule is feasible if
the resource requirements are met, that is, if
X
X
aj ≤
bi
(1)
i≤k

j:π(j)≤k

for all 1 ≤ k ≤ q. As we assume that

P

i bi

=

X

P

j

aj holds, this is equivalent to

aj ≥

X

bi

(2)

i≥k

j:π(j)≥k

for all 1 ≤ k ≤ q.P
Define Bk = i≥k bi , and consider the set of jobs that are not processed before a given time
point ti . Then (2) says that if the resource requirements of these jobs add up to at least Bi ,
then our schedule is feasible. We will mostly use the second characterization of feasibility, as
our algorithms assign the jobs to later time points first. The intuition is that the total weight
Wi of jobs that are not processed at a time point ti gives a lower bound for their contribution
to the objective function. Therefore it is better to approximate Wi , rather than the weight of
P
the jobs already processed, given by
j∈J wj − Wi .

4.1

A greedy 6-approximation for arbitrary q

The idea of our first algorithm is to have a balance between adding jobs that have small weights
and jobs that have high resource requirements. More precisely, we will assign jobs to the time
points going back in time. When we add a job to the set of jobs scheduled after a given time
8

point, we will choose the most inefficient job, i.e. the job minimizing wj /aj among all jobs that
have weight at most the weight W of all jobs that have already been chosen up to this point.
If there is no job with weight at most W , then we simply choose a job with minimal weight.
Intuitively, this rule guarantees that the jobs we choose are not too efficient but their total
weight is not too large either.
Algorithm 1 Greedy algorithm for 1|rm = 1, pj = 0|

1:
2:
3:
4:
5:
6:
7:
8:

P

C j wj .

Input: Jobs J with |J| = n, resource requirements aj , weights wj , resource arrival times
t1 ≤ . . . ≤ tq and resource quantities b1 , . . . bq .
Output: A feasible schedule π.
Set A = 0.
Set W = 0.
for i from 0 to q − 1 do
while A < Bq−i do
if there is an unassigned job j with wj ≤ W then
Let j be an unassigned job with wj ≤ W minimizing wj /aj .
else
Let j be an unassigned job minimizing wj .

W ← W + wj
A ← A + aj
11:
Set π(j) = q − i.
12: return π
9:

10:

Theorem 3. There exists a 6-approximation for 1|rm = 1, pj = 0|
O(n log(n)).

P

Cj wj with running time

Proof. We claim that Algorithm 1 satisfies the requirements of the theorem. To prove this, we
show that at the end of each iteration of the for loop, W is a 6-approximation for the problem of
finding a minimum weight job set S consuming at least Bi resources. Let opt be the optimum
value of this problem. Since the Bi ’s are monotone decreasing and the algorithm does not
consider the Bi ’s when picking the jobs, it is enough to show that the statement holds for the
case q = 2, i = 0.
Consider the last iteration of the while loop when W < opt holds at the beginning of the
loop. Since there exists a set of jobs of total weight opt, the value of W at the end of this
iteration is bounded by 2 · opt. After this iteration, our algorithm will always pick jobs that
are at least as inefficient as any of the jobs picked by the optimum solution. Consequently, the
while loop will end at the latest when the weight of the jobs scheduled after this iteration is at
least opt.
Now consider the last iteration of the while loop. At the beginning of the iteration, we have
A < Bq−i and W is bounded by 3 · opt by the above. Since there exists a set of jobs of total
weight opt, W is at most doubled during the iteration. This means that W is bounded by 6 · opt
at the end of the while loop, as stated.
The running time follows by ordering the jobs according to their weight and by using AVL
trees for picking j in the while loop.
The following example shows that the bound is tight. We have 5 jobs with weights w1 =
w2 = 1 − 2ε, w3 = 1 − ε, w4 = 1 and w5 = 3. The resource requirements are a1 = a2 = ε/5,
a3 = 1 − ε/2, a4 = 1 and a5 = 4. The resource arrival times are t1 = 0 and t2 = 1, with resource
quantities b1 = 5 − ε/10 and b2 = 1. Here the optimum solution is to schedule the job with
9

weight 1 to time point t2 and all the remaining jobs to time point t1 . However, our algorithm
will schedule the job with weight 1 to time point t1 and all the remaining jobs to t2 .

4.2

A (4 + ε)-approximation for arbitrary q

Now we give a slightly better approximation for the problem. The algorithm is slightly more
complicated than the one presented in Section 4.1, but the proof illustrates one of the important
ideas of the general PTAS.
P
Theorem 4. There exists a (4 + ε)-approximation for 1|rm = 1, pj = 0| Cj wj with running
time polynomial in 1/ε and the input length.
Proof. The idea of the algorithm is as follows. We may assume without loss of generality that
resource arrival times are integer. First we shift all resource arrival times to powers of 2. For
each time point t = ti in the shifted instance, we apply the FPTAS by Kis [12] to the instance
which has only two resource arrival times t1 and t, and the resource quantity for t is Bi . Denote
the set of jobs assigned to t this way by Si . Then, going back from the last time point tq to the
first one t1 , we assign all unassigned jobs from Si to ti , i.e. π(j)
P = max{i : j ∈ Si }.
More formally, let I be an instance of 1|rm = 1, pj =P0| j Cj wj . We assume t1 = 0 and
t2 = 1. We define a new instance I 0 of 1|rm = 1, pj = 0| j Cj wj with shifted resource arrival
times as follows. Set
(
0
if i = 1,
0
ti =
i−2
2
for i = 2, . . . , dlog2 (tq )e + 2,
and

(
bi
b0i = P
[bi : ti ∈ (2i−3 , 2i−2 ] ]

if i = 1, 2,
for i = 3, . . . , dlog2 (tq )e + 2.

Claim 12. A solution to I with weighted sum of completion times W can be transformed into
a solution of I 0 with weighted sum of completion times at most 2W . Furthermore, any feasible
schedule for I 0 also is a feasible schedule for I.
Proof. Let us define si = min{t0i : ti ≤ t0i } for i = 1, . . . , q. Let π be the solution for I. Then
assigning all jobs that are assigned to time point ti to si gives us a feasible solution to I 0 . By
this change, the completion of any job is at most doubled (recall that each ti is assumed to be
integer).
Since the available amount of resources at each time in I 0 is at most as much as in I, a
feasible schedule for I 0 is also a feasible schedule for I.
Claim 13. There exists a polynomial time (2 + ε)-approximation algorithm for constant ε for
all instances I where the resource arrival times are integer powers of 2.
Proof. We use the procedure that we described, i.e. we solve the instance for each of the time
points using an α-approximation provided by [12], where α = 1 + ε. Let π opt be an optimum
solution and let Jkopt be the set of jobs j with π opt (j) = k. We have
w(Si ) ≤ α

q
X
k=i

10

w(Jkopt )

for i = 1, . . . , q. Then we get
2α

X

wj Cjπ

opt

=

j∈J

≥

≥

q
X
(2α) · 2i−2 w(Jiopt )
i=2
q
X
i=2
q
X

α · 2i−2 w(Jiopt ) + α

≥

2−j 2i−2 w(Jiopt )

j=1

α2i−2

i=2
q
X

∞
X

q
X

w(Jkopt )

k=i

2i−2 w(Si ),

i=2

thus the approximation ratio follows.
The theorem follows from the two claims.

4.3

PTAS for constant q

The aim of this section is to give a PTAS for the case when the number of resource arrival times
is a constant. The algorithm is a generalization of a well known PTAS for the knapsack problem,
and will be used later as a subroutine in the PTAS for an arbitrary number of resource arrival
times. The idea is to choose a number k ∈ Z+ , guess the k heaviest jobs that are processed at
each resource arrival time ti , and then determine the remaining jobs that are scheduled at ti in
a greedy manner. Since we go over all possible sets containing at most k jobs for each resource
arrival time, there is an exponential dependence on the number q of resource arrival times in
the running time.
P
Theorem 5. There exists an (1 + kq )-approximation for 1|rm = 1, pj = 0| Cj wj with running
time O(nqk+1 ).
Proof. We claim that Algorithm 2 satisfies the requirements of the theorem. Let π opt be an
optimal schedule and define Jiopt = {j ∈ J : π opt (j) = i}. Let Siopt be the set of the k heaviest
jobs in Jiopt if |Jiopt | ≥ k, otherwise let Siopt = Jiopt . Let Ji = {j ∈ J : π(j) = i} denote the set
of jobs assigned to time ti in our solution. In each iteration of the for loop of Step 4, let ji be
the last job added to Ji if such a job exists.
Assume that we are at the iteration of the algorithm when the subpartition S1opt ∪ · · · ∪ Sqopt
is considered in Step 1. Let Wq−` denote the value of W at the end of the iteration of the for
loop corresponding to i = ` in Step 4. By Steps 3 and 9, we have
Wq−`

q
1X X
≤
wj .
k
opt
i=` j∈J
i

As our algorithm always picks the most inefficient job, we also have
q
X

X

wj ≤

q
X
X
i=` j∈J opt
i

i=` j∈Ji \{ji }

where Ji \ {ji } = Ji if ji is not defined for i.

11

wj ,

Algorithm 2 PTAS for 1|rm = 1, pj = 0|

P

Cj wj when q is a constant.

Input: Jobs J with |J| = n, resource requirements aj , weights wj , resource arrival times
t1 ≤ . . . ≤ tq and resource quantities b1 , . . . bq .
Output: A feasible schedule π.
for all subpartitions S1 ∪ · · · ∪ Sq ⊆ J with |Si | ≤ k for i > 1 do
Set A = 0.
Set W = 0.
for i from 0 to q − 2 do
for j ∈ Sq−i do
π(j) = q − i
A ← A + aj

1:
2:
3:
4:
5:
6:
7:

if |Sq−i | = k then
W ← max{W, min{wj : j ∈ Sq−i }}
while A < Bq−i do
if there exists an unassigned job j with wj ≤ W then
Let j be an unassigned job with wj ≤ W minimizing wj /aj .
π(j) = q − i
A ← A + aj
else
break
For all remaining jobs set π(j) = 1.
Let π be the best schedule found.
return π

8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:

Combining these two observations, for ` = 1, . . . , q we get
q X
X

wj =

i=` j∈Ji

≤

q
X

X

wj +

i=` j∈Ji \{ji }
q
X
X

q
X

wj i

i=`

wj + (q − ` + 1) · W`

i=`

j∈Jiopt

q
q X X
wj ,
≤ (1 + )
k
opt
i=` j∈J
i

where the first inequality follows from the fact that wji ≤ Wi ≤ W` whenever i ≥ `. This proves
that the schedule that we get is a (1 + kq )-approximation.
We get a factor of nqk in the running time for guessing the sets Sk . Assigning the remaining
jobs can be done in linear time by ordering the jobs and using AVL-trees, thus we get an
additional factor of n. In order to get a PTAS, we set k = qε , concluding the proof of the
theorem.

4.4

PTAS for arbitrary q

We turn to the proof of the main result of the paper. As in Section 4.2, we shift resource arrival
times; here we use powers of 1 + ε, for a suitably
P small ε.
Let I be an instance of 1|rm = 1, pj = 0| j Cj wj . We assume that resource arrival
P times
0
are integer, and that t1 = 0, t2 = 1. We define a new instance I of 1|rm = 1, pj = 0| j Cj wj
12

with shifted resource arrival times as follows. Set
(
0
if i = 1,
0
ti =
i−2
(1 + ε)
for i = 2, . . . , dlog1+ε (tq )e + 2,
and
b0i

(
bi
= P
[bi : ti ∈ ((1 + ε)i−3 , (1 + ε)i−2 ] ]

if i = 1, 2,
for i = 3, . . . , dlog1+ε (tq )e + 2.

The proof of the following claim is the same as that of Claim 12.
Claim 14. A solution to I with weighted sum of completion times W can be transformed into
a solution of I 0 with weighted sum of completion times at most (1 + ε)W . Furthermore, any
feasible schedule for I 0 also is a feasible schedule for I.
Due to the claim, we may assume that the positive arrival times are powers of 1 + ε. For
convenience of notation, in this section we will assume that the largest arrival time is 1, and
arrival times are indexed in decreasing order, starting with t0 = 1. That is, ti = (1 + ε)−i
(i = 0, . . . , q − 2), and tq−1 = 0. We will also assume that for a given constant r, bq−r−1 = · · · =
bq−2 = 0. This can be achieved by adding r dummy arrival times.
P
Theorem 6. There exists a PTAS for 1|rm = 1, pj = 0| Cj wj .
Proof. Let us fix an even integer r and ε > 0; we will later assume that r is very large compared
to ε−1 . We assume that resource arrival times are as described above, and are indexed in
decreasing order.
In the algorithm, we fix jobs at progressively decreasing arrival times, by using the PTAS of
the previous section for r + 1 arrival times on different instances except for the first step, when
we may use the PTAS for less than r + 1 arrival times. We will run our algorithm r/2 times
with slight modifications, and pick the best result. Each run is characterized by a parameter
` ∈ {1, . . . , r/2}.
In the first step, we consider arrival times t0 , t1 , . . . , tr/2+`−1 , 0. We move the resources
arriving before tr/2+`−1 to 0, and use the PTAS for r/2 + ` + 1 arrival times on this instance.
We fix the jobs that are scheduled at arrival times t0 , t1 , . . . , t`−1 .
Consider now the jth step for some j ≥ 2. Define s = (j −2)r/2+` and consider arrival times
ts , ts+1 , . . . , ts+r−1 , 0. Move the resources arriving before ts+r−1 to 0, and decrease bs , bs+1 , . . .
in this order as needed, so that the total requirement of unfixed jobs equals the total resource.
Use the PTAS for r + 1 arrival times on this instance. Fix the jobs that are scheduled at arrival
times ts , ts+1 , . . . , ts+r/2−1 .
The algorithm runs while s + r − 1 ≤ q − 2, i.e., jr/2 + ` ≤ q − 1. Since the smallest r arrival
times (except for 0) are dummy arrival times, the algorithm considers all resource arrivals.
The schedule given by the algorithm is clearly feasible, because when jobs at ti are fixed,
the total resource requirement of jobs starting no earlier than ti is at least the total amount
of resource arriving no earlier than ti . To analyze the approximation ratio, we introduce the
following notation: Wi is the total weight that the algorithm schedules at ti ; Wi0 is the weight
that the algorithm temporarily schedules at ti when i is in the interval [ts+r/2 , ts+r−1 ] (or, in
the first step, in the interval [t` , t`+r/2−1 ]); Wi∗ is the total weight scheduled at ti in the optimal
solution.
Since we use the PTAS for r/2 + ` + 1 arrival times in the first step, we have
`+r/2−1
`+r/2−1
`−1
X
X
X
(1 + ε)−i Wi +
(1 + ε)−i Wi0 ≤ (1 + ε)
(1 + ε)−i Wi∗ ,
i=0

i=0

i=`

13

as the right-hand side is (1 + ε) times the objective value of the feasible solution obtained from
the optimal solution by moving jobs arriving before t`+r/2−1 to 0.
For s = jr/2 + `, we compare the output of the PTAS with a different feasible solution:
we schedule total weight Wi0 at ti for i = s, s + 1, . . . , s + r/2 − 1, total weight Wi∗ at ti for
i = s + r/2 + 1, . . . , s + r − 1, and at ts+r/2 we schedule all jobs that are no earlier than ts+r/2 in
the optimal schedule but are no later than ts+r/2 in the PTAS schedule. We get the inequality
(j+1)r/2+`−1

(j+2)r/2+`−1

X

X

(1 + ε)−i Wi +

i=jr/2+`

(1 + ε)−i Wi0

i=(j+1)r/2+`



(j+1)r/2+`−1

(j+2)r/2+`−1

X

X

≤ (1 + ε) 

(1 + ε)−i Wi0 +

i=jr/2+`

(1 + ε)−i Wi∗

i=(j+1)r/2+`
(j+1)r/2+`−1

+(1 + ε)−(j+1)r/2−`

X


Wi∗  .

i=0

The sum of these inequalities gives
q−2
q−2
q−2
X
X
X
−i
−i
0
(1 + ε) Wi ≤ ε
(1 + ε) Wi + (1 + ε)
(1 + ε)−i Wi∗
i=0

i=0

i=`

+ (1 + ε)

q−2
X




X


i=0

(1 − ε)−(jr/2+`)  Wi∗ .

(3)

j:jr/2+`>i

To bound the first term on the right hand side of (3), first we observe that
r/2+`−1

r/2+`−1

X

X

(1 + ε)−i Wi0 ≤ (1 + ε)

(1 + ε)−i Wi∗ ,

i=0

i=`

because the left side is at most the value of the PTAS in the first step, while the right side is
(1 + ε) times the value of a feasible solution. Similarly,
(j+2)r/2+`−1

X

(1 + ε)−i Wi0 ≤

i=(j+1)r/2+`



(j+2)r/2+`−1

jr/2+`−1

X

X

(1 + ε) 

(1 + ε)−i Wi∗ + (1 + ε)−jr/2−`


Wi∗  ,

i=0

i=jr/2+`

because the left side is at most the value of the PTAS in the (j + 1)-th step, and the right side
is (1 + ε) times the value of the following feasible solution: take the optimal solution, move jobs
scheduled before t(j+2)r/2+`−1 to 0, and move jobs scheduled after tjr/2+` to tjr/2+` . Adding

14

these inequalities, we get
q−2
X
ε
(1 + ε)−i Wi0 ≤
i=`






q−2
q−2
X
X

ε(1 + ε) 2
(1 + ε)−i Wi∗ +
i=0


ε(1 + ε) 2

i=0

q−2
X

(1 + ε)−i Wi∗ +

i=0

q−2
X



X

(1 + ε)−jr/2−`  Wi∗  ≤

j:jr/2+`>i



∞
X



(1 + ε)−jr/2−1  (1 + ε)−i Wi∗  =


i=0

j=0

q−2
q−2
X
(1 + ε)r/2−1 X
ε(1 + ε) 2
(1 + ε)−i Wi∗ +
(1 + ε)−i Wi∗
r/2 − 1
(1
+
ε)
i=0
i=0



ε 2(1 + ε) +



(1+ε)r/2
(1+ε)r/2 −1

!
=

q−2
X
(1 + ε)−i Wi∗ .
i=0

The last expression is at most 4ε times the optimum value if r is large enough.
The last term of the right side of (3) is too large to get a bound that proves a PTAS.
However, we can bound the average of these terms for different values of `. The average is


r/2 q−2
X
X
X

(1 + ε) 2r
(1 − ε)−(jr/2+`)  Wi∗ ≤
`=1 i=0

j:jr/2+`>i



q−2 X
q−2
∞
X
2 X
−j 
−i
∗
2

(1 + ε) r
(1 + ε)
(1 − ε) Wi = (1 + ε)
(1 − ε)−i Wi∗ ,
rε
i=0

j=1

i=0

which is at most ε times the optimum if r is large enough. To summarize we obtained that
for large enough r, the average objective value of our algorithm for ` = 1, 2, . . . , r/2 is upper
bounded by
q−2
q−2
q−2
q−2
X
X
X
X
−i
∗
−i
∗
−i
∗
4ε
(1 + ε) Wi + (1 + ε)
(1 + ε) Wi + ε
(1 + ε) Wi = (1 + 6ε)
(1 + ε)−i Wi∗ ,
i=0

i=0

i=0

i=0

which is (1+6ε) times the objective value of the optimal solution. This proves that the algorithm
that chooses the best of the r/2 runs is a PTAS.

4.5

Undetermined resource arrival times

AP
question one might ask is the following: Given α > 1 and an instance of 1|rm = 1, pj =
0| j Cj wj , is there a schedule π such that the set Si = {j : π(j) ≥ i} is an α-approximation
to the problem of finding a minimum weight job set S ⊆ J consuming at least Bi resources for
i = 1, . . . , q? The motivation is that such a solution would also give an α-approximation for the
instance. The greedy algorithm of Section 4.1 shows that the answer to the question is yes if
α ≥ 6.
Let us consider now a variant of the problem where the arriving resource quantities are
given, but the resource arrival times are not known in advance. Then the smallest α for which
the answer is ‘YES’ in the above problem is the best approximation ratio we can achieve.

15

P
Theorem 7. There exists a (4+ε)-approximation for 1|rm = 1, pj = 0, ti unkown| Cj wj with
running time polynomial in 1/ε and the input length. Moreover, there is no (4−ε)-approximation
algorithm for the problem for any ε > 0.
Proof. Our approximation algorithm is based on the following claim.
Claim 15. There exists a schedule π such that for each i the set Si = {j : π(j) ≥ i} is a
4-approximation for the problem of finding a minimum weight job set S ⊆ J consuming at least
Bi resources.
Proof. For i = 1, . . . , q, let Ji be an optimal solution to the problem of finding a minimum
weight job set S ⊆ J consuming at least Bi resources. Define f (i) = min{k : w(Jk ) ≤ 2w(Ji )}
for i = 2, . . . , q and let us consider the following procedure.
Algorithm 3 Subroutine for (4 + ε)-approximation to 1|rm = 1, pj = 0, ti unkown|

1:
2:
3:
4:
5:
6:

P

C j wj .

Input: Jobs J with |J| = n, resource requirements aj , weights wj , resource quantities
b1 , . . . bq .
Output: A feasible schedule π.
Set i = q.
while i ≥ 1 do
Set Si+1 = {j : π(j) > i}.
Set π(j) = i for j ∈ Jf (i) \ Si+1 .
i ← f (i) − 1
return π

It is not difficult to see that π fulfills the resource requirements. We prove by induction that
w(Si ) ≤ 4w(Ji ) holds for i = 1, . . . , q. As Sq = Jf (q) , the inequality w(Sq ) ≤ 4w(Jq ) clearly
holds. Assume now that i ≤ q − 1. If no jobs are assigned to ti , then w(Si ) = w(Si+1 ) ≤
4w(Ji+1 ) ≤ 4w(Ji ). Otherwise i = f (i0 ) − 1, where i0 is the index considered in the previous
iteration of the while loop in Step 2. Observe that no jobs are assigned to time points between
the ith and the i0 th ones. By induction, we get
w(Si ) = w(Jf (i) ∪ Si0 ) ≤ w(Jf (i) ) + w(Si0 ) ≤ 2w(Ji ) + 4w(Ji0 ) ≤ 4w(Ji ).
Here the second inequality holds by induction and by the definition of f , while the last inequality
follows from the fact that i < f (i0 ) which implies w(Ji ) > 2w(Ji0 ).
P
Algorithm 3 provides a (4+ε)-approximation for 1|rm = 1, pj = 0, ti unkown| Cj wj which
has running time polynomial in the input size and 1ε as follows. Using either an FPTAS for the
knapsack problem or the FPTAS of Kis [12], we determine an approximation the sets Ji . Then
we apply Algorithm 3 to schedule the jobs. This concludes the proof of the first part of the
theorem.
The following set of instances shows that α is at least 4. We are given (n − 1)m jobs denoted
by 1, 2, . . . , (n − 1)m with weights wi = n − mi and ai = 2−i . Furthermore, we have (n − 1)m
resource arrival times that are unknown. The resource quantities are given by bq = 2−q and
bi = 2−i − Bi+1 = 2−i−1 for i < q. In order to fulfill the resource requirements, the set of
jobs scheduled at or after time ti has to contain at least one of the jobs j ≤ i. Observe that
the optimal solution of finding a minimum weight job set Ji consuming at least Bi resources
consists of the single job i.
Let j1 be the job processed at time t1 . Now we create a sequence starting with j1 . Since
the jobs that are greater or equal than j1 have total resource requirements less than Bj1 −1 , we
16

have to schedule at least one job j2 < j1 at or after tj1 −1 . This argument can be iterated to
find a job j3 < j2 which is scheduled at or after tj2 −1 , and so on.
Claim 16. For any β < 4, there exist n and m such that for the sequence j1 , j2 , . . . constructed
as above, there is some i with
i+1
X
βwji −1 <
wj k .
k=1

Proof. Suppose to the contrary
that there is no triple n, m, i satisfying the requirements of the
P
for all n, m, i. If m is large enough, then wji and wji −1 are
w
claim. Then βwji −1 ≥ i+1
j
k
k=1
1
very close to each other, i.e. if m
≤ εm for some εm then wji −1 ≤ wji + εm . Thus we get
βwji −1 ≤ βwji + βεm . By increasing n, the length of our sequence increases as well. Indeed, by
the indirect assumption, we have
wji+1 ≤

i+1
X

wjk ≤ βwji −1 < 4wji −1 < 4wji + 4εm .

k=1

number of elements
Since we also have wj1 ≤ 4 and wj ≥ 1 for all jobs j, this implies that
Pthe
i−1
in the sequence is at least log5 n. Let us define zi = wji and zi0 = k=1
zk . By the indirect
1
0 , thus we have
assumption, β(zi + m
) ≥ zi+1 + zi+1
(β − 1)zi − zi0 + 4εm ≥ zi+1 .
z0

z0

≥ γ zii for some γ > 1
We omit the εm for now to keep the reasoning simple. We claim that zi+1
i+1
which only depends on β. We have (β − 1)zi − zi0 − zi+1 ≥ 0, and thus we get 3zi > zi0 assuming
z0
β < 4. Observe that zii is minimal if (β − 1)zi − zi0 = zi+1 . By transforming the equation
γ

z0
zi0
zi + zi0
,
= i+1 =
zi
zi+1
(β − 1)zi − zi0

we get
γ=

zi2 + zi zi0
.
(β − 1)zi zi0 − zi02

(4)

Using (zi − zi0 )2 ≥ 0, (β − 2) < 2 and zi zi0 > 0 we get
zi2 + zi02 > 2zi zi0
or equivalently
zi2 + zi zi0 > 3zi zi0 − zi02 ≥ 3zi zi0 −
Thus γ >

3
β−1 .

3
3
z 02 =
((β − 1)zi zi0 − zi02 ).
β−1 i
β−1

It follows that there exists some N such that

0
zN
zN

> 3 and thus we get

0
βzN < 4zN ≤ zN + zN
,

contradicting the indirect assumption.
P
By Claim 16, there exists a time point ti with j:π(j)≥i wj > βBi . By setting ti0 = 0 (or
very close to 0) for i0 < i and ti0 = 1 (or very close to 1) for i0 ≥ i, the schedule can only be a
(β − ε)-approximation if we do not know the resource arrival times in advance.
17

Acknowledgement
The authors are grateful to Erika Bérczi-Kovács and to Matthias Mnich for the helpful discussions. Kristóf Bérczi was supported by the János Bolyai Research Fellowship of the Hungarian
Academy of Sciences and by the ÚNKP-19-4 New National Excellence Program of the Ministry for Innovation and Technology. Project no. NKFI-128673 has been implemented with the
support provided from the National Research, Development and Innovation Fund of Hungary,
financed under the FK 18 funding scheme. Tamás Király was supported by the Hungarian
National Research, Development and Innovation Office – NKFIH, grant number K120254. This
research was supported by Thematic Excellence Programme, Industry and Digitization Subprogramme, NRDI Office, 2019.

References
[1] J. Carlier. Problèmes d’ordonnancement à contraintes de ressources: algorithmes et complexité. Université Paris VI-Pierre et Marie Curie, Institut de programmation, 1984.
[2] E. R. Gafarov, A. A. Lazarev, and F. Werner. Single machine scheduling problems with
financial resource constraints: Some complexity results and properties. Mathematical Social
Sciences, 62(1):7–13, 2011.
[3] M. R. Garey and D. S. Johnson. Computers and intractability. A Guide to the Theory of
NP-Completeness, 1979.
[4] R. L. Graham, E. L. Lawler, J. K. Lenstra, and A. R. Kan. Optimization and approximation
in deterministic sequencing and scheduling: a survey. In Annals of discrete mathematics,
volume 5, pages 287–326. Elsevier, 1979.
[5] A. Grigoriev, M. Holthuijsen, and J. Van De Klundert. Basic scheduling problems with
raw material constraints. Naval Research Logistics (NRL), 52(6):527–535, 2005.
[6] P. Györgyi. A ptas for a resource scheduling problem with arbitrary number of parallel
machines. Operations Research Letters, 45(6):604–609, 2017.
[7] P. Györgyi and T. Kis. Approximation schemes for single machine scheduling with nonrenewable resource constraints. Journal of Scheduling, 17(2):135–144, 2014.
[8] P. Györgyi and T. Kis. Approximability of scheduling problems with resource consuming
jobs. Annals of Operations Research, 235(1):319–336, 2015.
[9] P. Györgyi and T. Kis. Reductions between scheduling problems with non-renewable resources and knapsack problems. Theoretical Computer Science, 565:63–76, 2015.
[10] P. Györgyi and T. Kis. Approximation schemes for parallel machine scheduling with nonrenewable resources. European Journal of Operational Research, 258(1):113–123, 2017.
[11] P. Györgyi and T. Kis. Minimizing the maximum lateness on a single machine with raw
material constraints by branch-and-cut. Computers & Industrial Engineering, 115:220–225,
2018.
[12] T. Kis. Approximability of total weighted completion time with resource consuming jobs.
Operations Research Letters, 43(6):595–598, 2015.

18

[13] R. Slowiński. Preemptive scheduling of independent jobs on parallel machines subject to
financial constraints. European Journal of Operational Research, 15(3):366–373, 1984.
[14] A. Toker, S. Kondakci, and N. Erkip. Scheduling under a non-renewable resource constraint.
Journal of the Operational Research Society, 42(9):811–814, 1991.
[15] J. Xie. Polynomial algorithms for single machine scheduling problems with financial constraints. Operations Research Letters, 21(1):39–42, 1997.

19

