Nakamoto Consensus with Verifiable Delay
Puzzle

arXiv:1908.06394v4 [cs.DC] 23 Aug 2020

Jieyi Long and Ribao Wei
Theta Labs, San Jose CA 95128, USA
jieyi@thetalabs.org

Abstract. This paper presents a new consensus protocol based on verifiable delay function. First, we introduce the concept of verifiable delay
puzzle (VDP), which resembles the hashing puzzle used in the PoW
mechanism but can only be solved sequentially. We then present a VDP
implementation based on the continuous verifiable delay function. Further, we show that VDP can be combined with the Nakamoto consensus
in a proof-of-stake/proof-of-delay hybrid protocol. We analyze the persistence and liveness of the protocol, and show that compared to PoW, our
proposal consumes much less energy; compared to BFT leader-election
based consensus algorithms, our proposal achieves better resistance to
long-range attacks and DoS attacks targeting the block proposers.
Keywords: Nakamoto consensus, verifiable delay puzzle, energy efficiency, decentralization

1

Introduction

Since the debut of Bitcoin [1] in 2009, the energy consumption of its proof-of-work
(PoW) consensus protocol has been growing at a stunning pace. It is estimated
that the electricity demand of Bitcoin has already surpassed that of a small country such as Denmark. This has motivated researchers to investigate alternative
consensus protocols that are more energy efficient and environmentally friendly.
Among different replacement candidates, the proof-of-stake (PoS) mechanism
has attracted widespread attention [2,3,4,5,6,7,8,9,10]. Instead of spending intensive computational resources on solving hashing puzzles, PoS protocols typically run a computationally inexpensive process to randomly select the next
block proposer based on the stake of each node.
There are two major camps in PoS mechanism design. The first is the chainbased PoS which simulates the PoW process for leader election. While this approach is energy-efficient, some of the early works were insecure. In particular,
they were vulnerable to the “nothing-at-stake” attack since the cost for simulating PoW is minimal [9]. Later protocols including Ouroboros address such
concerns [10]. However, the leader election in Ouroboros employs a secure multiparty computation based coin-tossing scheme that incurs a relatively large overhead. This scalability bottleneck is addressed in Ouroboros Praos [11] via a more
efficient leader election scheme. A recent improvement, Ouroboros Genesis [12]

further allows offline parties to safely bootstrap the blockchain when they come
back online. The second type of design stems from the traditional Byzantine
Fault Tolerant (BFT) research [13,14,15,16]. Algorithms such as Tendermint,
Casper FFG, Algorand, and HotStuff fall into this category [4,9,6,7,8,17]. The
BFT based approaches usually have proven mathematical properties. For example, under the assumption that more than 2/3 stake are held by honest participants, the safety property can typically be guaranteed even with an asynchronous
network [16]. Moreover, in the BFT based algorithms, the aforementioned attacks can be mitigated with the “slashing condition” introduced by the Casper
FFG [9]. However, due to communication complexity, traditional BFT based algorithms are less scalable. Typically they only allow a relatively small number
(usually less than 100) of nodes to participate in the consensus process, which
limits the level of decentralization, making them less attractive for permissionless public chains. Algorand [6,7,8] improves the scalability with the introduction
of cryptographic sortition to select a relatively small committee for each round,
and runs the BFT consensus only within the committee. HotStuff [17], on the
other hand, reduces the communication complexity by signature aggregation and
pipelining the voting phases.
Although these state-of-the-art PoS protocols effectively reduces the energy
consumption, they are potentially more vulnerable to the so-called “long-range
attack” compared to the PoW alternative. In a long-range attack, the adversary
forks the blockchain starting from a past block, and adding blocks to his private
branch in order to overtake the longest public chain [18]. PoS-based blockchains
are generally more susceptible to long-range attacks, since unlike PoW, minting a
block is almost costless in PoS. A particular threat to the PoS blockchain is “posterior corruption”, a special form of long-range attack [18]. If an adversary can
accumulate the majority stake at a certain past block height through posterior
corruption, from that block he can fabricate an alternative fork indistinguishable from the longest public chain in a short amount of time, since generating
a block requires minimal computational effort. Ouroboros Praos and Genesis
[11,12] proposed to use key evolving signature schemes [19] as a countermeasure,
but it assumes that without incentive, the nodes would voluntarily delete their
ephemeral private keys after each use, which is not necessary practical.
A question thus arises: Can we combine the merits of PoW and PoS? To
be more specific, our goal is to design a consensus protocol which has good resistance to the long-range attacks, and yet consumes low amount of energy. In
the paper we will present a new proof-of-stake/proof-of-delay hybrid protocol based on the concept of verifiable delay puzzle (VDP), which can hopefully
achieve these goals. In this framework, VDP resembles the hashing puzzle used
in the PoW schemes but can only be solved sequentially. Our VDP construction
is based on recent advancements of the verifiable delay functions (VDF) research
[20,21,22,23,24]. VDF is a type of function that requires a specified number of
sequential steps to evaluate, and produces a unique output that can be publicly and efficiently verified [20]. At the first glance, such difficult-to-evaluate
but easy-to-verify asymmetry is very similar to the PoW hashing puzzle, mak2

ing VDF a perfect drop-in replacement for the PoW hashing puzzle. However,
different from the hashing puzzle, a VDF function in its original form has no
intrinsic randomness. Given the same input, a VDF function always outputs the
same result regardless of who computes it. To fully emulate the hashing puzzle,
unpredictability needs to be somehow injected into the VDF to create the lottery
effect to determine the next block proposer. Furthermore, to achieve the energy
saving goal, the consensus protocol also needs to be designed in a way such that
unlike in PoW, equipping with more VDF solvers does not give a node proportional advantage. Later in the paper, we will show how these properties can be
achieved altogether. Incorporating VDP also makes the consensus protocol more
resilient to the long-range attacks than the existing PoS designs, since proposing
a block requires solving a VDP, which takes non-negligible amount of time even
on a parallel computer.
Our contributions. Aside from introducing the concept of VDP, we also make
the following novel contributions:
• We present a VDP construction based on the continous VDF design [24],
and incorporate the VDP into the Nakamoto consensus in a PoS blockchain.
To create the lottery effect, we propose to leverage the verifiable random
function (VRF) to pseudorandomly assign different verifiable delay puzzles
to the nodes competing to propose the next block. The parameters of the
puzzle for a new block are fully determined by the private key of the node
and the parent block. As a result, each node could take a different amount of
time to solve its assigned puzzle instance, and thus randomness arises. Such
a combination of VDF and VRF also makes it very efficient for other nodes
to verify that a node has indeed solved its assigned puzzle instance.
• We propose a set of slashing rules and show that with these rules, an economically rational validator node is worse-off if it publishes blocks on multiple
forks. Thus, the “nothing-at-stake” attack can be mitigated by our protocol.
• We analyze the protocol backbone and derive three basic properties, namely,
chain growth, chain quality, and common prefix. From these properties we
prove that our protocol can achieve persistence and liveness.
• The last but not the least, we analyze the protocol’s energy consumption
and its resistance to various forms of long-range attacks, and thus show that
the proposed protocol achieves our design goals.
Related works. We note that there are other attempts to incorporate VDF in
consensus protocols, including using VDF for creating random beacons, and for
validator shuffling in blockchain sharding. Among these works, a protocol called
Chia proposed by Cohen et al., combines proofs-of-space with VDF [25,26]. In
their proposal, a space miner (called “farmer” in [26]) can generate a proof which
demonstrates that it has access to a certain amount of disk space. The miner then
maps the space proof to a random integer τ in a way that a larger disk space has
a higher likelihood to generate a smaller τ . The miner then evaluates VDF for τ
iterations. The first miner that successfully computes the VDF can broadcast its
3

block. Similar to our proposal, this process mimics the random delay weighted
by the disk space possessed. However, since τ is explicitly calculated, a miner
might be reluctant to compute the VDF if its τ is too large or could perform
some kinds of grinding attack with this information. This could create bias and
weaken the security of the system. In contrast, in our VDP based approach, a
node cannot estimate the time to solve the assigned delay puzzle until it actually
solves it, which is more akin to the hashing puzzle in PoW. Furthermore, our
approach is based on proof-of-stake instead of proof-of-space, which does not
require the time-consuming storage setup phase. Proof-of-stake also has less
moving parts and thus is simpler to analyze and implement. Finally, our analysis
shows that our protocol only requires economically rational nodes to control the
super majority stake, instead of honest nodes as required by Chia. This makes
our protocol more suitable for real world applications such as cryptocurrencies.
Ethereum 2.0 plans to employ RANDAO, a VDF based public randomness
beacon for block proposer election [27,28]. While the RANDAO design can generate unbiased randomness, the public nature of the beacon indicates that everyone
in the network can predict the next or even the next few block proposers. The
adversary could exploit this information to launch targeted attacks. In contrast,
our protocol is driven by private randomness similar to Algorand [6]. Hence the
adversary does not know which node will become the block proposer until the
next block gets published. This makes our protocol more resilient to DoS attacks.

2

Verifiable Delay Puzzle

In this section we introduce the concept of verifiable delay puzzle, and present
a construction based on the continuous verifiable delay function [24].
Definition 1. A Verifiable Delay Puzzle (VDP) asks for an integer t that satisfies inequality f (t) ≤ M , where f : X → Y is a function that maps a nonnegative integer to another integer, such that
• Sequentiality: Any algorithm takes at least O(t) sequential steps to solve the
puzzle, even on a parallel computer with a polynomial number of processors.
• Efficient verifiability: Along with t, the puzzle solution should also contain
a proof π, with which anyone can verify that f (t) ≤ M efficiently, i.e., in
O(poly(log(t)) steps.
One interesting aspect of this definition is that the number of steps O(t)
needed to solve the puzzle is unknown before the puzzle is solved. This property
is crucial for preventing grinding attacks.
VDP construction based on continuous VDF. Pietrzak and Wesolowski
separately proposed two simple VDF constructions based on repeated squaring
[21,22]. However, both constructions require that the total number of VDF evaluation cycles is known when initializing the VDF. Very recently, Ephraim et al.
presented a continuous VDF design which is also based on repeated squaring,
4

but allows efficient proofs of any intermediate t during the VDF evaluation [24].
A VDP can thus be constructed based on the continuous VDF: Given input r
and a constant γ, find solution (t, d, π d ), such that
d = H(r)2

t

K(d) ≤ γ · M

(1)
(2)

Here H(·) is a hash function acting as a random oracle. And the constant γ
is a threshold which controls the difficulty of the puzzle. K(·) is a one-way hash
function which maps its input to a non-negative integer, and M is the maximum
value of the hash function.
Theorem 1. The puzzle defined above is a verifiable delay puzzle.
Proof. To see why this is a verifiable delay puzzle, first we note that since d
is required to be a part of the solution, solving this VDP involves explicitly
t
calculating the d value and generating π d which proves that d = H(r)2 . If t
is the smallest
integer that satisfies (1) and (2), then solving the puzzle takes
√
O((1 + 2/ t)t) sequential steps, since it is at least as hard as computing the
repeated squaring VDF [21,24]. On the other hand, to check if a tuple (t, d, π d ) is
indeed the solution to the VDP, any third party just needs to verify 1) π d proves
t
d = H(r)2 , and 2) K(d) ≤ M . Continuous VDF allows verification of condition
1) for any t value in O(poly(log(t)) [24], and verification of condition 2) takes
O(1) time. Thus, the entire verification can obviously be done in O(poly(log(t))
time. Therefore, this construction conforms to our definition of a VDP.

3
3.1

Nakamoto Consensus with VDP
Basic Design

For simplicity, let us first consider a blockchain with a fixed set of validators
who are eligible to propose new blocks. Now, let us see how to can leverage VDP
to create the “lottery effect” to pseudorandomly select a validator to propose the
next block. We note that in Formula (1) the VDP takes an input r. With different
values of r, the amount of time needed to solve the VDP varies. This is where we
can inject the randomnes. In particular, we can leverage the verifiable random
function (VRF) [7,8] to pseudorandomly determine the r for each validator. As
formulated in Formula (3), a VRF typically takes a private key sk of a node and
a seed as input, and uniquely generates a pseudorandom random value r and
the corresponding proof π r . The proof π r enables anyone that knows the node’s
public key pk to check that r indeed corresponds to the seed, without having to
know the private key sk.
(r, π r ) ← V RFsk (seed)
5

(3)

Assume the block at the tail end of the chain has height i − 1 as shown in
Fig. 1. Validator u wants to propose a block for height i. To do this it first needs
to solve the following VDP instance:
(ri , πir ) ← V RFsku (seed = di−1 )
(ti , di , πid )

← V DP (r = ri )

(4)
(5)

Fig. 1. Validators compete to solve VDPs. Each validator node is assigned a VDP
instance fully determined by the d value recorded in the parent block and the private
key of the node. The VDP solution tuple is embedded in the header of the blocks.

In Formula (4), sku is the private key of validator u. We note that the VRF
takes di−1 as the seed. It is the d value in the VDP solution for the parent block
at height i − 1. The VRF generates ri , which is then used as the input for the
VDP in Formula (5). We note that since each validator node has its own private
key sk, the pseudorandom value ri generated by Formula (4) is unique for each
validator. Thus, each validator needs to solve a different VDP instance specified
by Formula (5) which could require a different number of VDF evaluation cycles.
This is where the randomness arises. Moreover, it is worth pointing out the seed
di−1 does not depend on the content of the block (i.e. the transactions included
in the block). This means for a validator, if it has decided to “mine” on top
of a block, the VDP instance it needs to solve is fully determined. Hence,
a validator cannot grind by changing the transactions in a block to gain extra
advantages.
Similar to Bitcoin, in our protocol, to propose the next block, a validator
needs to first solve its VDP. Fig. 1 illustrates the process where the validators
compete to solve VDPs. Once the assigned VDP is solved, a validator can broadcast a block. The header of the new block should contain the following tuple
(pk, ri , πir , ti , di , πid )
6

(6)

Besides, the block header should also contain σsk (Bi ), the validator’s signature of the entire block (which includes the above tuple and all the transactions).
With the signature, if a validator tries to fork the chain by proposing multiple
blocks with the same VDP solution but different sets of transactions, it can be
detected by others and get punished (see the slashing rules in Section 3.3).
As soon as a node receives a new block, it should first verify (ri , πir ) against
the block proposer’s public key pk and seed di−1 . This is to confirm whether the
block proposer was indeed solving the VDP instance assigned by the VRF. If the
check is passed, the node then verifies the VDF puzzle solution (ti , di , πid ). Also
the node verifies the signature σsk (Bi ) to make sure the block is proposed by the
validator with public key pk. If all checks are passed, and all the transactions
contained in the block are valid, the validator can append this block to the block
tree in its local view.
The incentive structure is similar to Bitcoin. Each block comes with block
reward for the block proposer in the form of newly minted tokens. Also each
transaction may carry a certain amount of fees that the block proposer can
collect. To resolve forks, we adopt the Nakamoto longest chain rule. Bitcoin
requires a number of block confirmations (typically 6 confirmations) to ensure a
transaction is safe. Similarly, we have the following definition:
Definition 2. A validator considers a block as settled if on its local view, the
block is on a chain where there are least κsettle valid blocks on the chain after it,
where κsettle is a security parameter.
Compared to some of the BFT-based PoS protocols that publicly elect one or
a small set of leaders each round to propose blocks [4,17], our proposed protocol
also has the unique advantage that it is much more immune to targeted DoS
attacks to the block proposers. This is because, similar to Bitcoin, anyone solves
its assigned VDP instance is eligible to propose a new block. A DoS attacker
might be able to shut down a portion of the network, but the remainder nodes
can still execution the protocol to extend the blockchain.
3.2

Permissionless Blockchain

Now we can extend the discussion to a permissionless proof-of-stake blockchain
where any node can become a validator after putting down some stake. To
be more specific, to become a validator, first a node needs to generate a private/public key pair (sk, pk), and then stake a certain number of tokens to its
public key. To prevent sybil attack and also to avoid power concentration, we
require each validator stakes a fixed amount of tokens S. For example, S
can be set to 1/10000 of the total token supply so the system can accommodate
up to 10, 000 validators. We also require the staked tokens to be locked for a
certain duration (e.g. at least four weeks) before they can be unlocked.
With this protocol enhancement, any user with S amount of stake can run
a validator node. If a user possesses more than S amount of stake, he can run
multiple validators with his stake divided. We note that compared to the BFT
7

voting based consensus mechanisms [4,17], the chain-based consensus mechanism
eliminates explicit voting and the associated communication cost. Thus, our
approach is as scalable as Bitcoin in terms of the number of validators that can
participate in the consensus protocol, and thus can achieve a very higher level
of decentralization.
3.3

Slashing Rules

To deter economically rational validators from forking the chain, we introduce
the following rules inspired by Ethereum [5] and SpaceMint [29]:
• If a validator publishes two blocks with the same parent block, its entire
stake deposit will be slashed.
• If a validator publishes blocks on multiple forks, then on a particular fork,
its deposit will be deducted by (1 + ) · R for each block on other forks, where
R is the block reward, and 0 <   1. The deducted (1 + ) · R tokens are
burnt completely.
• As an incentive, the submitter of the slashing transaction gets  · R newly
minted tokens as submitter reward for each block.
Here the term slashing transaction refers to a special type of transaction that
can carry the proof that a certain validator has signed and published blocks on
conflicting forks. It also contains the public key and signature of the submitter
for it to claim the  · R submitter reward. Note that for the same block, only the
first reporter gets the submitter reward.
We note that most Proof-of-Stake protocols do not slash a validator for publishing blocks on multiple forks. Thus, at the first glance, our proposed slashing
rules seem to pose more risks for the validators. However, it is worth pointing
out that the Proof-of-Work mechanism also implicitly penalizes the miners that
extend multiple forks. This is because only one single fork will win in the end,
and hence all the electricity spent mining on the other forks is wasted.
Moreover, if we tune the VDP parameters properly (setting the value of γ in
Formula (2) to a small value), the probability that two or more validators solve
their assigned puzzle within one block propagation time can be made very small,
similar to Bitcoin. Under such conditions, we can prove the following theorem,
which states that a rational node should only propose new blocks on one chain,
i.e. the longest public chain. The proof will be provided in Appendix A.
Theorem 2. For a rational node, proposing new block only on a fork that is
most likely to win (i.e. the longest public chain in its local view) is a dominant
strategy. Thus, the proposed protocol with the slashing rules is immune to the
“nothing-at-stake” attacks.

4
4.1

Protocol Analysis
System Model

Before diving into the protocol analysis, we note that different VDP solvers
might have different speeds. A faster VDP solver could give a node advantage
8

over others. Considering the speed variation, The analysis in this section will
revolve around the concept of speed-weighted stake, regarding which we have
the following lemma (proof provided in Appendix B).
P
Lemma 1. Define speed-weighted stake W = v∈V ηv · S, where S is required
amount of stake per validator, ηv is the VDF solver speed of validator v, and V
is the set of validators a party controls. Then, following the honest behavior, the
aggregated block production rate λ of these validators is proportional to W .
1
≈ 73.1% of
Validator model: We assume that strictly more than 1 − 1+e
the total speed-weighted stakes are controlled by economically rational validator
1
nodes, where e is the Euler’s constant. The 1 − 1+e
bound is derived from
Theorem 3 which will be presented later in the section. Theorem 2 indicates
that a rational validator should execute the protocol as prescribed. Thus we
will use the term honest rational validators interchangeably with economically
rational validators, or simply honest validators.
Attacker model: We assume powerful attackers. They can corrupt many
targeted nodes, and have access to an unlimited number of VDP solvers. How1
of the total speedever, we assume that they can control no more than 1+e
weighted stakes. For example, the attackers might have VDP solvers that are
3 times as fast as the average of the rational nodes. Yet if they controls less
than 10% of the total stake, their speed-weighted stake fraction is 0.25 (=
1
10% · 3/(10% · 3 + 90% · 1)), which is still less than 1+e
. Also, we assume the
attackers are computationally bounded. For instance, they cannot forge fake
signatures, and cannot invert cryptographic hashes.
Timing and communication model: To focus on the core problems, in
this section we analyze our proposed protocol in an ideal setting where the
participants operate in a synchronous communication network with zero latency.
We do not assume a direct message channel between all pairs of validators.
Messages between them might need to be routed through other nodes, some of
which could be byzantine nodes.

4.2

The Protocol Backbone Analysis

Taking inspiration from Garay et al.’s analysis of the Bitcoin protocol [30], we
introduce the backbone of our proposed protocol, and analyze its three important
properties: chain growth, chain quality, and common prefix. From these
properties we can further derive the persistence and liveness of our protocol
using Garay et al.’s framework.
Before proving these three properties, we would like to remark on one important difference between the PoW puzzle and VDP. It is well-known that for a
PoW miner, splitting the hashing power on multiple forks is inferior to concentrating all the hashing power on a single fork. However there is a subtle approach
to solve multiple VDPs in parallel to speed up the chain growth. If a party control multiple validators, he can potentially perform a breadth-first-search to
find a fork that can outgrow the longest public chain. This approach is illustrated in Fig. 2. In this example, the adversary controls two validators, and has
9

a large number of VDP solvers available. At height i, the adversary can create
two forks, each by one valiator. Then at height i + 1, he creates four forks, two
from each fork at height i. The adversary can secretly expand such forks into a
tree structure without being punished by the slashing rules. He then publishes
the fastest growing fork if it is longer than the longest public chain.

Fig. 2. Breadth-first-search to find the fastest growing fork. Assume the adversary
controls two validators v1 and v2 , and has an unlimited number of VDP solvers. He
can expand the “search tree” rooted at block B and identify the fastest growing branch
(marked in gray). All the VDPs at the same tree depth can be solved in parallel.

Fortunately, even with this strategy, the growth rate of the longest branch (in
terms of block height) of the tree is bounded compared to the honest behavior
as prescribed by the protocol. We can apply the branching random walks analysis
as in Bagaria et al. [31] to bound the growth rate of the longest adversarial branch
and that of the longest public chain with the following lemma:
Lemma 2. Assume that the adversary builds a block tree rooted at a block B on
the longest public chain for T amount of time. Let Da (T ) represents the number
of blocks on the longest branch of the adversarial block tree, and λa represents the
block production rate if adversary follows the honest behavior, then the following
inequality holds true, where e ≈ 2.718 is the Euler’s constant:
P r(Da (T ) > eλa T + x) ≤ e−x

(7)

This lemma is equivalent to Lemma 4 in Bagaria et al. [31], and the proof is
omitted here. It indicates that with the same amount of speed-weighted-stake,
the probability that the breadth-first-search approach can identify a chain with
the expected growth rate at most e times as high as that of the honest strategy. In
10

fact, following the arguments in [31], we can prove that regardless of what block
proposal strategy the adversarial parties might employ, the bound in Lemma 2
holds true. Next, we provide the following two lemmas to characterize the longest
chain growth. The proofs for both lemmas are provided in Appendix B.
Lemma 3. Denote the block production rate of the honest parties by λh . Assume
that within T amount of time, Nh (T ) honest blocks are proposed, then for any
δ ∈ (0, 1), we have:
P r(Nh (T ) < (1 − δ)λh T ) ≤ 2e−λh T δ

2

/3

(8)

Lemma 4. Denote the block production rate of the honest parties by λh . Assume
that after T amount of time, the longest chain grows by Dh (T ) blocks, then for
any δ ∈ (0, 1), we have:
P r(Dh (T ) < (1 − δ)λh T ) ≤ 2e−λh T δ

2

/3

(9)

The theorem below indicates that with high probability, the gap between the
longest public chain and the longest adversarial private chain increases linearly
with the block height. The proof for the theorem is provided in Appendix B.
Theorem 3. Assume starting from the genesis block, the honest rational parties
1
≈ 73.1% fraction of the total speedalways control strictly more than 1 − 1+e
weighted-stake. Consider the longest public chain and the longest fork generated
by the adversary. Assume block B is the forking point. Let Nh (T ) represent the
number honest blocks proposed during T amount of time after block B added to
the chain. Let Dh (T ) represent the number of blocks on the longest public chain
starting from block B. And let Da (T ) represents the number of blocks on the
longest adversarial fork after B. There exists a constant ζ > 0, such that:
P r(Nh (T ) − Da (T ) >

1
(λh − eλa )T ) ≥ (1 − 2e−ζT )2
3

(10)

P r(Dh (T ) − Da (T ) >

1
(λh − eλa )T ) ≥ (1 − 2e−ζT )2
3

(11)

Next, we prove that the three basic properties, i.e. chain growth, chain quality, and common prefix are guaranteed with high probability. For the proofs, we
define a round as a fixed time interval ∆ > 0.
Chain Growth. The chain growth property says that if an honest rational
validator currently has a chain C, then after sufficiently large s ∈ N consecutive
rounds, the validator will adopt a chain that is at least τ · s blocks longer than
C, where τ > 0 is a chain growth parameter. Here “adopting a chain C” means
that chain C in the longest public chain in the local view of the validator.
Lemma 5. The chain growth property holds for τ = λh ∆(1 − δ).
11

Proof. According to Theorem 3, if the honest rational parties controls more than
1
1− 1+e
speed-weighted-stake, no adversarial fork can have a higher expected rate
of growth than the longest public chain. Moreover, based on the zero-latency
assumption, a block proposed by an honest rational node will be delivered to
all honest nodes instantly. Thus, once an honest validator proposes a new block,
the longest public chain grows by at least one block. Hence the longest public
chain will grow indefinitely. Since a honest rational validator always adopts the
longest chain, in must adopt a chain at least as long as the longest public chain.
On the other hand, according to Lemma 4, P r(Dh (s∆) > λh ∆(1 − δ) · s) ≥
2
1 − 2e−λh s∆δ /3 . Note that the right hand side approaches 1 exponentially as
s approaches infinity, which means the chain growth property holds for high
probability.
Chain Quality. This property says that if an honest validator has adopted
chain C, then in any sufficiently large l ∈ N consecutive blocks of C, the ratio
of honest blocks is at least µ, where µ ∈ (0, 1] is the chain quality parameter.
Lemma 6. The chain quality property holds with µ > 0.
Proof. Again, based on the zero-latency assumption, an honest rational validator
always adopts the longest public chain. Let us analyze the chain quality of the
longest public chain. Assume there is no µ > 0 such that the chain quality
property holds true, then for any l ∈ N, there exists a point in time when the
last l consecutive blocks of the longest public chain contain no honest block.
Let us prove this is highly unlikely. Denote ν = 31 (λh − eλa ). According to
Lemma 1, λh > eλa , and thus ν > 0 (see also the proof for Theorem 3). Let Bh
represent the last honest block on the longest public chain, i.e. the l adversarial
blocks appends to the chain after Bh . Assume these l consecutive adversarial
blocks takes T time to generate. For convenience, we also introduce tb = T /l
to represent the average block time of these l adversarial blocks. Denote the
number of honest blocks proposed after Bh by Nh (tb · l). Also note that by
definition, Da (T ) = Da (tb · l) = l. Then, according to Theorem 3, P r(Nh (T ) <
l(1 + νtb )) = P r(Nh (tb · l) < l(1 + νtb )) = P r(Nh (tb · l) < Da (tb · l) + l · νtb ) =
P r(Nh (tb · l) − Da (tb · l) < +l · νtb ) ≤ 1 − (1 − 2e−ζtb ·l )2 . Thus, as l approaches
infinity, P r(Nh (tb · l) < l(1 + νtb )) approaches zero. In other words, with high
probability, the number of honest blocks produced is at least l(1 + νtb ) > l.
Due to the zero-latency assumption, no two honest blocks share the same block
height. Thus, there must be a public fork after block Bh with at least l(1 + νtb )
blocks. This contradicts with the statement that the longest public chain contains
l consecutive adversarial blocks after Bh .
Common Prefix. Given a chain C, let us define len(C) as the length of the
chain. Also, denote the subchain formed by block i to j by C[i, j]. Consider
two two chains C1 and C2 . The common prefix property says if C1 and C2 are
adopted by two honest rational validators at round r respectively, then there
exists a k ∈ N such that C1 [0, len(C1 ) − k] must be a prefix of C2 . Likewise,
C2 [0, len(C2 ) − k] is a prefix of C1 .
12

Lemma 7. The common prefix property holds with sufficiently large k.
Proof. First, we note that under the zero network latency assumption, two honest blocks will not be proposed for the same height. This is because once an
honest block is proposed, all the other honest rational validators will receive
the block immediately. Then, the honest rational validators will stop solving the
VDP for the current height and move to the next height. Thus, all the honest
blocks must be generated for different heights.
Now we can prove the common prefix property by contradiction. If the common fix property does not hold, for the last k block heights, C1 and C2 must
be completely disjoint. Assume out of these k block heights, there are y honest
blocks were generated. As discussed above, there y honest blocks are generated
for different heights. To keep C1 and C2 disjoint for k block heights, the number
of adversarial blocks z must be at least as large as y, such that the adversarial blocks can completely override all the honest blocks on either C1 or C2 .
However, this contradicts with Theorem 3, which implies P (z ≥ y) decreases
exponentially with k. Thus, with high probability, the common prefix property
holds for a sufficiently large k.
Persistence and Liveness. Persistence means that once a block is settled for all
honest rational validators, the probability that it can be reverted is negligible as
the chain grows. Liveness means that a valid transaction submitted to an honest
validator will eventually be included in a block settled on all honest rational
validators. The main result of Garay et al. is that the above three properties, i.e.
chain growth, chain quality, and common prefix implies persistence and liveness
[30,31]. Thus, we have the following theorem. The proof is omitted here since it
essentially follows the arguments of Garay et al. [30].
Theorem 4. Our proposed protocol achieves both persistence and liveness.
4.3

Energy Efficiency

1
fraction of the toTheorem 3 indicates that without owning more than 1+e
tal speed-weighted-stake, a private chain has negligible chance to outgrow the
longest public chain. Thus, investing in extra VDP solvers brings little return.
Hence, purchasing VDP solvers to grow a private chain is worst off than following the protocol as prescribed. Thus, unlike Bitcoin, our protocol can disincentive users from trapping into the hashing power arms race, and is therefore
much more energy efficient while attains a high degree of decentralization.

4.4

Long-Range Attack Resistance

One category of common attacks to PoS blockchains is the “long-range attack”,
where the adversary forks the blockchain starting from a distant past (e.g. the
genesis block), with the hope that the private branch will take over the longest
public chain at some point. Due to the sequential dependency of the VDPs (i.e.
13

the VDP for block height l + 1 depends on the VDP solution contained in the
block for height l), our protocol significantly increases the difficulty of long-range
attack, since minting a chain requires solving VDPs sequentially. In particular,
we have the following theorem (proof provided in Appendix C):
1
fraction of
Theorem 5. If an adversary is never able to acquire more than 1+e
the total speed-weighted-stake, then the probability that he can successfully launch
a long-range attack is negligible.

However, as discussed in the introduction, there is a more advanced form
of long-range attack called the posterior courruption attack. PoS protocols are
constructed based on a assumption that stakeholders are motivated to keep
the system running correctly since they have skins in the game. However, if
a stakeholder has sold off his tokens, he no longer has this incentive. Once a
sufficient portion of stakeholders from a point in time in the past are divested,
there is a chance that they are willing to sell their private keys to an adversary.
As the adversary acquires more past stakes, his private chain could grow faster.
Theorem 5 handles the basic case where an adversary is never able to acquire
1
fraction of total speed-weighted-stake at any block height. Below
more than 1+e
we discuss more general cases.
1
If an adversary is able to acquire more than 1+e
fraction of total speedweighted-stake, his private fork might indeed grow faster than the longest public
chain. However, depending on the speed-weighted-stake he acquired, his private
fork might not grow much faster than the longest public chain, and thus could
take a long time before it catches up. For quantitative analysis, let us model the
validator staking events as a Poisson process where at each block height, any
node has ps probability to stake tokens to become a validator. Then, we have
the following result (proof provided in Appendix C):
Theorem 6. Assume the honest parties controls αh fraction of stake at the
latest settled block whose height is lc . Then, at block height la < lc , through
posterior corruption, the expected maximum fraction of stake an adversary can
potentially control is bounded by ps (lc − la )αh + (1 − αh ).
For simplicity, let us analyze the scenario where the honest and adversary
party have the same VDP solving speed. The more general cases can be analyzed
similarly. Assume the adversary launches the posterior corruption based longrange attack from block height la . In the meanwhile, to increase the winning
chance, he stops proposing blocks on the longest public chain. Thus, the longest
chain only grows with average rate λh . On the other hand, the growth rate of the
h +(1−αh )
longest adversary fork is bounded by e · ps (lc −la )α
· λh . Let Ta represent
αh
the minimum amount of time needed for the adversary fork to outgrow the
longest public chain, the following condition needs to hold true:
la + e ·

ps (lc − la )αh + (1 − αh )
· λh Ta > lc + λh Ta
αh
14

From this inequality, it is straightforward to derive that if the following inequality
holds true, then the posterior corruption long-range attack from block height la
would have negligible chance to succeed.
αh > (1 + 1/e − ps (lc − la ))−1

(12)

Otherwise, the attack would take at least
Ta >

lc − la
λh (eps (lc − la ) + e/αh − e − 1)

(13)

amount of time to execute. To get a more concrete sense, let us plug in some
numbers. Assume λh = 144 blocks/day (i.e. 10 minutes average block time similar to Bitcoin), and the honest stake fraction αh = 0.9, and ps = 1.903 × 10−5
(i.e., on average an honest node stakes tokens for one year before unstaking,
which is a reasonable estimation based on data points from a couple public PoS
blockchains). Given these parameters, Inequality (12) holds true if lc − la <
13495, which means the posterior corruption attack forking from any block less
than 13495 blocks ago (approximately 93.7 days) would fail. Moreover, according
to Inequality (13), an attack forking from lc − la > 13495 blocks ago would take
−la
1
= 0.00745−100.507/(l
≥ 1/0.00745 ≈ 134.2
at least Ta > 0.00745(lclc−l
a )−100.507
c −la )
days. For example, if the adversary forks from 50,000 blocks ago, the fork will
take approximately 183.8 days to catch up the the longest public chain, which
is a relatively long time. In comparison, for a PoS protocol without VDP, generating 50,000 consecutive blocks could just take minutes, if not seconds. Base
on the analysis above, we can thus conclude that VDP effectively improves the
long-range attack resistance for the consensus protocol.

5

Conclusions and Future Works

In this paper we introduced the concept of verifiable delay puzzle and proposed a
new proof-of-stake/proof-of-delay hybrid consensus protocol built on top of it. It
has the advantage of low energy consumption and can scale to accommodate tens
of thousands of validators nodes similar to Bitcoin. It is also more resilient to
the long-range attacks compared to existing PoS protocol proposals. However, we
also recognize that there are large room for improvement. In particular, Security
analysis of the protocol under more types of attacks such as the selfish-mining
attack [32,33] also needs to be conducted. Another extension is to incorporate
other types fork choice rules such as the GHOST rule [34]. Finally, transaction
throughput improvement via alternative data structures like subchains [35] and
DAG [36,37,38] would be an interesting area to explore.

References
1. Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.

15

2. Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryptocurrencies without proof of
work. CoRR, abs/1406.5694, 2014.
3. Phil Daian, Rafael Pass, and Elaine Shi. Snow white: Provably secure proofs of
stake. Cryptology ePrint Archive, Report 2016/919, 2016. https://eprint.iacr.
org/2016/919.
4. Ethan Buchman, Jae Kwon, and Zarko Milosevic. The latest gossip on BFT consensus. CoRR, abs/1807.04938, 2018.
5. Vitalik Buterin. Ethereum proof of stake faq. https://github.com/ethereum/
wiki/wiki/Proofof-StakeFAQ, 2016.
6. Jing Chen, Sergey Gorbunov, Silvio Micali, and Georgios Vlachos. Algorand agreement: Super fast and partition resilient byzantine agreement. Cryptology ePrint
Archive, Report 2018/377, 2018. https://eprint.iacr.org/2018/377.
7. Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zeldovich.
Algorand: Scaling byzantine agreements for cryptocurrencies. In Proceedings of the
26th Symposium on Operating Systems Principles, pages 51–68. ACM, 2017.
8. Silvio Micali.
ALGORAND: the efficient and democratic ledger.
CoRR,
abs/1607.01341, 2016.
9. Vitalik Buterin and Virgil Griffith. Casper the friendly finality gadget. CoRR,
abs/1710.09437, 2017.
10. Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov”.
Ouroboros: A provably secure proof-of-stake blockchain protocol. In Jonathan
Katz and Hovav Shacham”, editors, Advances in Cryptology – CRYPTO 2017,
pages 357–388, Cham, 2017. Springer International Publishing.
11. Bernardo David, Peter Gaži, Aggelos Kiayias, and Alexander Russell. Ouroboros
praos: An adaptively-secure, semi-synchronous proof-of-stake protocol. Cryptology
ePrint Archive, Report 2017/573, 2017. https://eprint.iacr.org/2017/573.
12. Christian Badertscher, Peter Gazi, Aggelos Kiayias, Alexander Russell, and Vassilis
Zikas. Ouroboros genesis: Composable proof-of-stake blockchains with dynamic
availability. Cryptology ePrint Archive, Report 2018/378, 2018. https://eprint.
iacr.org/2018/378.
13. Leslie Lamport, Robert Shostak, and Marshall Pease. The byzantine generals
problem. ACM Trans. Program. Lang. Syst., 4(3):382–401, July 1982.
14. Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. Impossibility of
distributed consensus with one faulty process. J. ACM, 32(2):374–382, April 1985.
15. Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. Consensus in the presence
of partial synchrony. J. ACM, 35(2):288–323, April 1988.
16. Miguel Castro and Barbara Liskov. Practical byzantine fault tolerance. In Proceedings of the Third Symposium on Operating Systems Design and Implementation,
OSDI ’99, pages 173–186, Berkeley, CA, USA, 1999. USENIX Association.
17. Ittai Abraham, Guy Gueta, and Dahlia Malkhi. Hot-stuff the linear, optimalresilience, one-message BFT devil. CoRR, abs/1803.05069, 2018.
18. Evangelos Deirmentzoglou, Georgios Papakyriakopoulos, and Constantinos Patsakis. A survey on long-range attacks for proof of stake protocols. IEEE Access,
PP, 02 2019.
19. Matt Franklin. A survey of key evolving cryptosystems. Int. J. Security and
Networks, 1, 2006.
20. Dan Boneh, Joseph Bonneau, Benedikt Bünz, and Ben Fisch. Verifiable delay functions. In Annual International Cryptology Conference, pages 757–788. Springer,
2018.
21. Krzysztof Pietrzak. Simple verifiable delay functions. Cryptology ePrint Archive,
Report 2018/627, 2018. https://eprint.iacr.org/2018/627.

16

22. Benjamin Wesolowski. Efficient verifiable delay functions. Cryptology ePrint
Archive, Report 2018/623, 2018. https://eprint.iacr.org/2018/623.
23. Dan Boneh, Benedikt Bünz, and Ben Fisch. A survey of two verifiable delay
functions. Cryptology ePrint Archive, Report 2018/712, 2018. https://eprint.
iacr.org/2018/712.
24. Naomi Ephraim, Cody Freitag, Ilan Komargodski, and Rafael Pass. Continuous
verifiable delay functions. In Anne Canteaut and Yuval Ishai, editors, Advances in
Cryptology – EUROCRYPT 2020, pages 125–154, Cham, 2020. Springer International Publishing.
25. Bram Cohen. Proofs of space and time - removing waste. Blockchain Protocol
Analysis and Security Engineering, 2017. https://cyber.stanford.edu/sites/
default/files/bramcohen.pdf.
26. Bram Cohen and Krzysztof Pietrzak. The chia network blockchain. https://www.
chia.net/assets/ChiaGreenPaper.pdf, 2019.
27. Justin Drake. Minimal VDF randomness beacon. https://ethresear.ch/t/
minimal-vdf-randomness-beacon/3566, 2018.
28. Justin Drake. VDF-based RNG with linear lookahead. https://ethresear.ch/
t/vdf-based-rng-with-linear-lookahead/2573, 2018.
29. Sunoo Park, Krzysztof Pietrzak, Albert Kwon, Joël Alwen, Georg Fuchsbauer,
and Peter Gazi. Spacemint: A cryptocurrency based on proofs of space. Financial
Cryptography and Data Security, 2018.
30. Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Elisabeth Oswald and Marc Fischlin, editors,
Advances in Cryptology - EUROCRYPT 2015, pages 281–310, Berlin, Heidelberg,
2015. Springer Berlin Heidelberg.
31. Vivek Bagaria, Amir Dembo, Sreeram Kannan, Sewoong Oh, David Tse, Pramod
Viswanath, Xuechao Wang, and Ofer Zeitouni. Proof-of-stake longest chain protocols: Security vs predictability, 2019.
32. Ittay Eyal and Emin Gün Sirer. Majority is not enough: Bitcoin mining is vulnerable. CoRR, abs/1311.0243, 2013.
33. Arthur Gervais, Ghassan O Karame, Karl Wüst, Vasileios Glykantzis, Hubert Ritzdorf, and Srdjan Capkun. On the security and performance of proof of work
blockchains. In Proceedings of the 2016 ACM SIGSAC conference on computer
and communications security, pages 3–16. ACM, 2016.
34. Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in
bitcoin. In International Conference on Financial Cryptography and Data Security,
pages 507–527. Springer, 2015.
35. Peter R Rizun. Subchains: A technique to scale bitcoin and improve the user
experience. Ledger, 1:38–52, 2016.
36. Vivek Bagaria, Sreeram Kannan, David Tse, Giulia Fanti, and Pramod Viswanath.
Deconstructing the blockchain to approach physical limits. Cryptology ePrint
Archive, Report 2018/992, 2018. https://eprint.iacr.org/2018/992.
37. Lei Yang, Vivek Bagaria, Gerui Wang, Mohammad Alizadeh, David Tse, Giulia Fanti, and Pramod Viswanath. Prism: Scaling bitcoin by 10, 000x. ArXiv,
abs/1909.11261, 2019.
38. Chenxing Li, Peilun Li, Wei Xu, Fan Long, and Andrew Chi-Chih Yao. Scaling nakamoto consensus to thousands of transactions per second.
CoRR,
abs/1805.03870, 2018.

17

Appendix A

Analysis of the Slashing Rules

In this Appendix, we will prove that as stated by Theorem 2 in Section 3.3,
for the rational nodes, when there are forks, extending all the forks is never the
best strategy. Instead, the dominant strategy is to only extend the longest fork
in its local view. This result indicates that our protocol is robust against the
“nothing-at-stake” attacks.
A Simple Example

Fig. 3. Simple example with two forks. Validator v can choose to publish 6 blocks
(blocks in gray) on F ork1 , and 4 blocks on F ork2 . Or it can just stick to one single
fork.

First, let us use the simple case in Fig. 3 to demonstrate our slashing rules.
In this example, the blockchain has two forks. The probability that F ork1 wins
is 0.7, and hence the probability that F ork2 wins is 0.3. A validator v can mine
on both forks, where F ork1 contains 6 blocks it mines, while F ork2 contains 4
blocks. Alternatively, it can publish 6 blocks on F ork1 and no block on F ork2 .
It can also just mine 4 blocks on F ork2 only.
If it mines on both forks, based on our proposed slashing rules, the expected
reward is 0.7·(6R−4(1+)R)+0.3·(4R−6(1+)R) = (0.8−4.6)R. To maximize
the total reward, validator v should try to submit the slashing transactions by
itself on both forks to claim the submitter reward. This is a bit counter-intuitive,
but if v does not submit the slashing transactions, someone else will do so, and v
is worst off. Hence, its expected maximum total reward by mining on both forks
is 0.8R. Yet if he only mines on F ork1 , his expected maximum total reward will
be 0.7 · 6R + 0.3 · (−6R) = 2.4R. Clearly, in this example, validator v is better
off if he only publishes blocks on F ork1 .
The General Two Forks Case
Fig. 4 illustrates a scenario similar to Fig. 3, but does not give the concrete
winning probably of each fork. When validator v sees the two forks, it can have
three strategies:
18

Fig. 4. The general two forks scenario. Similarly, validator v has the options to publish
on both forks, or stick to just one fork.

• Strategy 0. Publish blocks on both forks, assume for the next N block
heights, it can mine y1 blocks on F ork1 , and y2 blocks on F ork2 .
• Strategy 1. Publish y1 blocks on F ork1 only.
• Strategy 2. Publish y2 blocks on F ork2 only.
Let us calculate the expected reward for each strategy. Suppose p is the
probability that F ork1 becomes the winning chain. Then the probability that
F ork2 wins will be (1 − p). For Strategy 0, its total expected reward after the
forking point is
p · (y1 − y2 (1 + )) · R + (1 − p) · (y2 − y1 (1 + )) · R

(14)

This is because if F ork1 wins, v gets y1 · R block rewards, but its deposit
gets slashed by y2 (1 + ) · R. Similarly if F ork2 wins, v gets y2 · R block rewards,
and yet its deposit gets deducted by y1 (1 + ) · R. Similar to the simple example,
to maximize the total reward, validator v should try to submit the slashing
transactions by itself on both forks. Thus, for Strategy 0, after simplifying
Formula (14), the maximum total expected reward is
E0 [Rtotal ] = (2p − 1) · (y1 − y2 ) · R

(15)

For Strategy 1, since v only mines on F ork1 , if F ork1 wins, it gets y1 · R
block rewards with no deposit slash. However, if F ork2 wins, it obtains no block
reward and yet gets slashed by y1 (1 + ) · R. If v also submits the slashing
transaction to claim the submitter reward, the maximum total expected reward
will be (p · y1 − (1 − p) · y1 ) · R, which simplifies to
E1 [Rtotal ] = (2p − 1) · y1 · R

(16)

Similarly, the maximum total expected reward for Strategy 2 can be calculated by
E2 [Rtotal ] = (1 − 2p) · y2 · R

(17)

Notice that according to Formula (15-17), E0 [Rtotal ] = E1 [Rtotal ]+E2 [Rtotal ].
On the other hand, E1 [Rtotal ] · E2 [Rtotal ] = −(2p − 1)2 · y1 · y2 · R2 ≤ 0. This
means that E1 [Rtotal ] and E2 [Rtotal ] can not be positive at the same time. Hence
19

E0 [Rtotal ] ≤ max {E1 [Rtotal ], E2 [Rtotal ]}

(18)

Thus, mining on both forks is not the best strategy for validator v. This
results can be extended to the cases with more than two forks easily with
similar reasoning.
Multiple Disjoint Forks with Blocks Already Published

Fig. 5. The general multiple disjoint forks case. The light gray blocks represent the
blocks validator v has already published. And the dark gray blocks represent the blocks
v can choose to publish.

Fig. 5 depicts a more general case where there are k disjoint forks, and
validator v has already mined xi blocks on F orki . Now it has the following k + 1
strategies:
• Strategy 0. Publish blocks on all forks, assume for the next N block heights,
it can mine yi more blocks on F orki , in addtion to the xi blocks it already
published on F orki .
• Strategy i . Publish yi more blocks on F orki only.
Let us first analyze Strategy 0. Assuming the winning probability of F orki
is pi , the maximum total expected reward can be calculated by
E0 [Rtotal ] =

k
X

pi · (xi + yi − (X − xi + Y − yi )) · R

(19)

i=1

Here X =

Pk

i=1

xi , and Y =

E0 [Rtotal ] =

2

Pk

k
X

i=1

yi . Formula (19) can be simplified as
!

pi · (xi + yi ) − (X + Y )

i=1

20

·R

(20)

On the other hand, the maximum total expected reward of Strategy i can
be calculated by




Ei [Rtotal ] = pi · (xi + yi − (X − xi )) +

X

pj · (xj − yi − (X − xj )) · R

j6=i

(21)
Simplifying this formula gets us

Ei [Rtotal ] = 2

k
X





pj · (xj + yj ) − X + 2

j=1

X

pj · yj + yi  · R

(22)

j6=i

Thus we have


X
Ei [Rtotal ] − E0 [Rtotal ] = 
(1 − 2pj ) · yj  · R

(23)

j6=i

If pj < 1/2 for all j = 1, 2, .., k, obviously

P

j6=i


(1 − 2pj ) · yj · R ≥ 0 for

any i. Hence, for Ei [Rtotal ] ≥ E0 [Rtotal ] for any i. Otherwise, if there
P is a i such
that pi ≥ 1/2, then for all j 6= i, we must have pj ≤ 1/2, since j=1 pj = 1.
P

Thus, for this i,
j6=i (1 − 2pj ) · yj · R ≥ 0. Therefore, in any case, there must
be a Strategy i whose maximum total expected reward is at least as large as the
mining-on-all-forks strategy. This means when there are multiple disjoint forks,
even if a validator has already published some blocks on multiple forks, the best
strategy is still to mine only on the fork with the largest winning probability.

Appendix B

Proofs for the Protocol Backbone Analysis

Below we prove Lemma 1:
Proof. Recall that the honest behavior can be viewed as a greedy strategy. The
validators compete to solve the assigned VDP for the current block height. If
one validator solves its assigned VDP for the current height and publish a new
block, all other validators give up on the current VDP and move to VDP for the
next block height. Note that such a VDP solving based block production process
can be modeled as a Poisson process, where the success rate of each trial of t is γ
per Formula 2. Thus, similar to Bitcoin mining, equipping with a solver η times
as fast as others is equivalent to have η validators working in parallel, which
increase the block production rate by η times. Hence, as a Poisson process, the
aggregated block production rate λ (i.e. the total number
P of blocks proposed by
all validators in a unit time) is proportional to W = v∈V ηv · S.
Below we prove Lemma 3:
21

Proof. First we note that with the zero-latency assumption, the VDP solving
process can be modeled as independent Bernoulli trials. Thus, the adversarial
block production does not affect the honest block production. Thus, the honest
block production process can be modeled as a Poisson process with rate λh . Thus,
by using the Chernoff bound, it is straightforward to derive that P r(Nh (T ) <
2
(1 − δ)λh T ) ≤ 2e−λh T δ /3 .
Below we prove Lemma 4:
Proof. Assume for a moment that all the adversarial parties stop producing
blocks after block B. In this case, the honest block production process can be
modeled as a Poisson process with rate λh . And the proposed honest blocks will
form a chain. Using the Chernoff bound, it is straightforward to derive that for
2
this hypothetical honest chain, P r(Dh0 (T ) < (1 − δ)λh T ) ≤ 2e−λh T δ /3 , where
Dh0 (T ) is the number of block after block B on this hypothetical chain after time
period T .
On the other hand, due to the zero-network latency assumption, even in the
presence of adversarial validators, two honest blocks will never share the same
block height. This is because once a honest validator publish a new block, all
other honest validators will receive it instantly. Then, all these honest validators
move to solve the VDP for the next block height. Hence, the longest chain should
grow at least as fast as the hypothetical chain. Thus, P r(Dh (T ) < (1−δ)λh T ) ≤
2
P r(Dh0 (T ) < (1 − δ)λh T ) ≤ 2e−λh T δ /3 .
Below we prove Theorem 3:
1
, we have
Proof. First, since the honest speed-weighted-stake Wh > 1 − 1+e
1
1
Wh /Wa > (1 − 1+e )/(1 − (1 − 1+e )) = e, meaning the speed-weighted-stake
controlled by honest rational parties is at least e time as much as that controlled
by the adversarial parties. Therefore, according to Lemma 1, we have λh > eλa .
Further, let us denote constant ν = 13 (λh − eλa ). Then, we have the following

P r(Nh (T ) − Da (T ) > νT )
≥ P r({Nh (T ) > λh T − νT } ∧ {Da (T ) < eλa T + νT })
= P r(Nh (T ) > λh T − νT ) · P r(Da (T ) < eλa T + νT )
= (1 − P r(Nh (T ) < λh T − νT )) · (1 − P r(Da (T ) > eλa T + νT ))
− 3λ1 ν 2 T

≥ (1 − 2e

h

) · (1 − e−νT )

≥ (1 − 2e−ζT )2
where ζ = max{ 3λ1h ν 2 , ν} is a positive constant. In the above derivation, the first
step is because the joint event {Nh (T ) > λh T − νT } ∧ {Da (T ) < eλa T + νT } is a
sufficient condition for event {Nh (T )−Da (T ) > νT }. Moreover, {Nh (T ) > λh T −
νT } and {Da (T ) < eλa T + νT } are independent events since the adversarial
fork after B does not contain any honest block. This yields the second step.
22

We then apply Inequality (9) and (7). The last step is obviously since e−x is a
homogeneously decreasing function of x. This proves Inequality (10).
For Inequality (11), we just need to note that as discussed earlier, due to
the zero-latency assumption, no two honest blocks share the same block height.
Thus, during time T , the longest public chain must have grown by at least
Nh (T ) blocks, i.e. Dh (T ) > Nh (T ). Hence, we have P r(Dh (T ) − Da (T ) > νT ) ≥
P r(Nh (T ) − Da (T ) > νT ) ≥ (1 − 2e−ζT )2 . This proves Inequality (11).
Thus, if the adversary forks the chain from a certain block, with high probability, the gap between the longest public chain and the longest adversarial
private fork increases with time.

Appendix C

Proofs for the Long-Range Attack Analysis

Below we prove Thereom 5:
Proof. This theorem can be derived directly from Theorem 3, which states
P r(Dh (T ) − Da (T ) > 31 (λh − eλa )T ) ≥ (1 − 2e−ζT )2 . Assume an adversary
tries to launch a long-rage attack from a block generated T time ago, then the
probability that his private fork is longer than the the longest public chain decreases exponentially with T .
Below we prove Thereom 6:
Proof. We make the reasonable assumption that if a validator staked before
height la and remain staked at lc , then the adversary cannot acquire its private
key, since otherwise the adversary would have control to the tokens the validator
currently owns. Let us calculate the expected fraction of stake that were staked
before l and remain staked at lc out of the αh fraction of stake the honest parties currently controlled. For the calculation, we introduce random variable nv,l ,
which is 1 if honest validator v conducted the staking at block height l, and 0
otherwise. Then the total number
honest staking events between height la and
Plc −1ofP
lc can be calculated by Ns = l=l
v∈Vh nv,l , where Vh is the set of honest vala
Plc −1 P
idators at height lc . Thus, the expected number E[Ns ] = E[ l=l
v∈Vh nv,l ] =
a
Plc −1 P
Plc −1 P
l=la
v∈Vh E[nv,l ] =
l=la
v∈Vh ps = ps (lc − la )Nh . Here Nh = |Vh | is the
number of honest validators at height lc . On the other hand, since at height lc
the honest validators controls αh fraction of stake, the total fraction of stake
s]
that the adversary can potentially acquire is at most E[N
Nh · αh = ps (lc − la )αh
(“at most” because if a node v stakes and unstakes the same token twice during
la to lc , the adversary can only acquire one token). This, plus the 1 − αh fraction
of stake the adversary already owned without bribing at height la , gets us the
ps (lc − la )αh + (1 − αh ) bound.

23

