Comparisons of Pooling Matrices for Pooled
Testing of COVID-19

arXiv:2010.00060v1 [q-bio.PE] 30 Sep 2020

Yi-Jheng Lin, Che-Hao Yu, Tzu-Hsuan Liu, Cheng-Shang Chang, Fellow, IEEE,
and Wen-Tsuen Chen, Life Fellow, IEEE
Abstract—In comparison with individual testing, group testing
(also known as pooled testing) is more efficient in reducing
the number of tests and potentially leading to tremendous cost
reduction. As indicated in the recent article posted on the US
FDA website [1], the group testing approach for COVID-19 has
received a lot of interest lately. There are two key elements
in a group testing technique: (i) the pooling matrix that directs
samples to be pooled into groups, and (ii) the decoding algorithm
that uses the group test results to reconstruct the status of
each sample. In this paper, we propose a new family of pooling
matrices from packing the pencil of lines (PPoL) in a finite
projective plane. We compare their performance with various
pooling matrices proposed in the literature, including 2D-pooling
[2], P-BEST [3], and Tapestry [4], [5], using the two-stage definite
defectives (DD) decoding algorithm. By conducting extensive
simulations for a range of prevalence rates up to 5%, our
numerical results show that there is no pooling matrix with the
lowest relative cost in the whole range of the prevalence rates. To
optimize the performance, one should choose the right pooling
matrix, depending on the prevalence rate. The family of PPoL
matrices can dynamically adjust their column weights according
to the prevalence rates and could be a better alternative than
using a fixed pooling matrix.

Keywords: group testing, perfect difference sets, finite
projective planes.
I. I NTRODUCTION
COVID-19 pandemic has deeply affected the daily life of
many people in the world. The current strategy for dealing
with COVID-19 is to reduce the transmission rate of COVID19 by preventive measures, such as contact tracing, wearing
masks, and social distancing. One problematic characteristic
of COVID-19 is that there are asymptomatic infections [6]. As
those asymptomatic infections are unaware of their contagious
ability, they can infect more people if they are not yet been
detected [7]. As shown in the recent paper [8], massive
COVID-19 testing in South Korea on Feb. 24, 2020, can
greatly reduce the proportion of undetectable infected persons
and effectively reduce the transmission rate of COVID-19.
Massive testing for a large population is very costly if it is
done one at a time. For a population with a low prevalence
rate, group testing (or pool testing, pooled testing, batch
testing) that tests a group by mixing several samples together
can achieve a great extent of saving testing resources. As
indicated in the recent article posted on the US FDA website
Y.-J. Lin, C.-H. Yu, T.-H. Liu, C.-S. Chang, and W.-T. Chen
are with the Institute of Communications Engineering, National
Tsing Hua University, Hsinchu 30013, Taiwan, R.O.C. Email:
s107064901@m107.nthu.edu.tw;
chehaoyu@gapp.nthu.edu.tw;
carina000314@gmail.com; cschang@ee.nthu.edu.tw; wtchen@cs.nthu.edu.tw.

[1], the group testing approach has received a lot of interest
lately. Also, in the US CDC’s guidance for the use of pooling
procedures in SARS-CoV-2 [9], it defines three types of tests:
(i) diagnostic testing that is intended to identify occurrence at
the individual level and is performed when there is a reason
to suspect that an individual may be infected, (ii) screening
testing that is intended to identify occurrence at the individual
level even if there is no reason to suspect an infection, and (iii)
surveillance testing includes ongoing systematic activities,
including collection, analysis, and interpretation of healthrelated data. The general guidance for diagnostic or screening
testing using a pooling strategy in [9] (quoted below) basically
follows the two-stage group testing procedure invented by
Dorfman in 1943 [10]:
“If a pooled test result is negative, then all specimens can
be presumed negative with the single test. If the test result is
positive or indeterminate, then all the specimens in the pool
need to be retested individually.”
The Dorfman two-stage algorithm is a very simple group
testing strategy. Recently, there are more sophisticated group
testing algorithms proposed in the literature, see, e.g., [2]–
[5]. Instead of pooling a sample into a single group, these
algorithms require diluting a sample and then pooling the
diluted samples into multiple groups (pooled samples). Such
a procedure is specified by a pooling matrix that directs
each diluted sample to be pooled into a specific group. The
test results of pooled samples are then used for decoding
(reconstructing) the status of each sample. In short, there are
two key elements in a group testing strategy: (i) the pooling
matrix, and (ii) the decoding algorithm.
As COVID-19 is a severe contagious disease, one should
be very careful about the decoding algorithm used for reconstructing the testing results of persons. Though decoding algorithms that use soft information for group testing,
including various compressed sensing algorithms in [3]–[5],
[11], [12], might be more efficient in reducing the number
of tests, they are more prone to have false positives and
false negatives. A false positive might cause a person to be
quarantined for 14 days, and thus losing 14 days of work.
On the other hand, a false negative might have an infected
person wandering around the neighborhood and cause more
people to be infected. In view of this, it is important to have
group testing results that are as “definite” as individual testing
results (in a noiseless setting).
Following the CDC guidance [9], we use the decoding
algorithm, called the definite defectives (DD) algorithm in the

literature (see Algorithm 2.3 of the monograph [13]), that can
have definite testing results. The DD algorithm first identifies
negative samples from a negative testing result of a group (as
advised by the CDC guidance [9]). Such a step is known as
the combinatorial orthogonal matching pursuit (COMP) step
in the literature [13]. Then the DD algorithm identifies positive
samples if they are in a group with only one positive sample.
Not every sample can be decoded by the DD algorithm. As the
Dorfman two-stage algorithm, samples that are not decoded
by the DD algorithm go through the second stage, and they are
tested individually. We call such an algorithm the two-stage
DD algorithm.
One of the main objectives of this paper is to compare
the performance of various pooling matrices proposed in
the literature, including 2D-pooling [2], P-BEST [3], and
Tapestry [4], [5], using the two-stage DD decoding algorithm.
In addition to these pooling matrices, we also propose a new
construction of a family of pooling matrices from packing the
pencil of lines (PPoL) in a finite projective plane. The family
of PPoL pooling matrices has very nice properties: (i) both
the column correlation and the row correlation are bound by
1, and (ii) there is a freedom to choose the column weights
to optimize performance. To measure the amount of saving of
a group testing method, we adopt the performance measure,
called the expected relative cost in [10]. The expected relative
cost is defined as the ratio of the expected number of tests
required by the group testing technique to the number of
tests required by the individual testing. We then measure the
expected relative costs of these pooling matrices for a range
of prevalence rates up to 5%. Some of the main findings of
our numerical results are as follows:
(i)

(ii)

(iii)

(iv)

There is no pooling matrix that has the lowest
relative cost in the whole range of the prevalence
rates considered in our experiments. To optimize the
performance, one should choose the right pooling
matrix, depending on the prevalence rate.
The expected relative costs of the two pooling matrices used in Tapestry [4], [5] are high compared to
the other pooling matrices considered in our experiments. Its performance, in terms of the expected
relative cost, is even worse than the (optimized)
Dorfman two-stage algorithm. However, Tapestry is
capable of decoding most of the samples in the first
stage. In other words, the percentages of samples
that need to go through the second stage are the
smallest among all the pooling matrices considered
in our experiments.
P-BEST [3] has a very low expected relative cost
when the prevalence rate is below 1%. However, its
expected relative cost increases dramatically when
the prevalence rate is above 1.3%.
2D-pooling [2] has a low expected relative cost
when the prevalence rate is near 5%. Unlike Tapestry
and P-BEST that rely on robots for pipetting, the
implementation of 2D-pooling is relatively easy by

humans.
There is a PPoL pooling matrix with column weight
3 that outperforms the P-BEST pooling matrix for
the whole range of the prevalence rates considered in
our experiments (up to 5%). We suggest using that
PPoL pooling matrix up to the prevalence rate of
2% and then switch to other PPoL pooling matrices
with respect to the increase of the prevalence rate.
The detailed suggestions are shown in Table III of
Section V.
The paper is organized as follows: in Section II, we briefly
review the group testing problem, including the mathematical
formulation and the DD decoding algorithm. In Section III, we
introduce the related works that are used in our comparison
study. We then propose the new family of PPoL pooling
matrices in Section IV. In Section V, we conduct extensive
simulations to compare the performance of various pooling
matrices using the two-stage DD algorithm. The paper is
concluded in Section VI, where we discuss possible extensions
for future works.
(v)

II. R EVIEW OF GROUP TESTING
A. The problem statement
Consider the group testing problem with M samples
(indexed from 1, 2, . . . , M ), and N groups (indexed from
1, 2, . . . , N ). The M samples are pooled into the N groups
(pooled samples) through an N × M binary matrix H =
(hn,m ) so that the mth sample is pooled into the nth group if
hn,m = 1 (see Figure 1). Such a matrix is called the pooling
matrix in this paper. Note that a pooling matrix corresponds
to the biadjacency matrix of an N × M bipartite graph. Let
x = (x1 , x2 , . . . , xM ) be the binary state vector of the M
samples and y = (y1 , y2 , . . . , yN ) be the binary state vector
of the N groups. Then
y = Hx,

(1)

where the matrix operation is under the Boolean algebra (that
replaces the usual addition by the OR operation and the usual
multiplication by the AND operation). The main objective of
group testing is to decode the vector x given the observation
vector y under certain assumptions. In this paper, we adopt
the following basic assumptions for binary samples:
(i)
Every sample is binary, i.e., it is either positive (1)
or negative (0).
(ii)
Every group is binary, and a group is positive (1) if
there is at least one sample in that group is positive.
On the other hand, a group is negative (0) if all the
samples pooled into that group are negative.
If we test each sample one-at-a-time, then the number of
tests for M samples is M , and the average number of tests
per sample is 1. The key advantage of using group testing is
that the number of tests per sample can be greatly reduced.
One important performance measure of group testing, called
the expected relative cost in [10], is the ratio of the expected
number of tests required by the group testing technique to the

Fig. 1. Pooled testing represented by a bipartite graph.

number of tests required by the individual testing. The main
objective of this paper is to compare the expected relative
costs of various group testing methods.
B. The definite defectives (DD) decoding algorithm
In this section, we briefly review the definite defectives
(DD) algorithm (see Algorithm 2.3 of [13]). The DD algorithm first identifies negative samples from a negative testing
result of a group. Such a step is known as the combinatorial
orthogonal matching pursuit (COMP) step. Then the DD
algorithm identifies positive samples if they are in a group
with only one positive sample. The detailed steps of the DD
algorithm are outlined in Algorithm 1.
ALGORITHM 1: The definite defectives (DD) algorithm
for binary samples
Input An N × M pooling matrix H and a binary
N -vector y of the group test result.
Output an M -vector for the test results of the M
samples.
0: Initially, every sample is marked “un-decoded.”
1: If there is a negative group, then all the samples
pooled into that group are decoded to be negative.
2: The edges of samples decoded to be negative in the
bipartite graph are removed from the graph.
3: Repeat from Step 1 until there is no negative group.
4: If there is a positive group with exactly one
(remaining) sample in that group, then that sample is
decoded to positive.
5: Repeat from Step 4 until no more samples can be
decoded.
In Figure 2, we provide an illustrating example for Algorithm 1. In Figure 2 (a), the test result of G2 is negative,
and thus the three samples S1, S4 and S5, are decoded to
be negative. In Figure 2 (b), the edges that are connected to
the samples S1, S4 and S5, are removed from the bipartite

graph. In Figure 2 (c), the test results of the two groups G1
and G3 are positive. As S2 is the only sample in G3, S2 is
decoded to be positive.
Note that one might not be able to decode all the samples
by the above decoding algorithm. For instance, if a particular
sample is pooled into groups that all have at least one positive
sample, then there is no way to know whether that sample is
positive or negative. As shown in Figure 3, the sample S3
cannot be decoded by the DD algorithm as the test results of
the three groups are the same no matter if S3 is positive or
not.
As shown in Lemma 2.2 of [13], one important guarantee
of the DD algorithm is that there is no false positive.
Proposition 1: ( [13], Lemma 2.2) Assume that all the
testing results are correct. Then (i) all the samples that are
decoded to be negative in Step 1 of Algorithm 1 are definite
negatives, and (ii) all the samples that are decoded to be
positive in Step 4 of Algorithm 1 are definite positives. As
such, there are no false positives in Algorithm 1.
In order to resolve all the “un-decoded” samples, we
add another stage by individually testing each “un-decoded”
sample. This leads to the following two-stage DD algorithm
in Algorithm 2.
ALGORITHM 2: The two-stage definite defectives
(DD2) algorithm for binary samples
Input An N × M pooling matrix H and a binary
N -vector y of the group test result.
Output an M -vector for the test results of the M
samples.
1: Run the DD algorithm in Algorithm 1.
2: For those “un-decoded” samples, test them one at a
time.

III. R ELATED WORKS
In [14]–[16], it was shown that a single positive sample can
still be detected even in pools of 5-32 samples for the standard
RT-qPCR test of COVID-19. Such an experimental result
provides supporting evidence for group testing of COVID19. In the following, we review four group testing strategies
proposed in the literature for COVID-19.
The Dorfman two-stage algorithm [17]: For the case that
N = 1, i.e., every sample is pooled into a single group,
the DD2 algorithm is simply the original Dorfman two-stage
algorithm [10], i.e., if the group of M samples is tested
negative, then all the M samples are ruled out. Otherwise,
all the M samples are tested individually. Suppose that the
prevalence rate is r1 . Then the expected number of tests to
decode the M samples by the Dorfman two-stage algorithm
is 1 + (1 − (1 − r1 )M )M . As such, the expected relative cost
(defined as the ratio of the expected number of tests required
by the group testing technique to the number of tests required
by the individual testing in [10]) is MM+1 − (1 − r1 )M . As
shown in Table I of [10], the optimal group size M is 11

(a) Step 1: All the samples pooled into
that negative groups are decoded to be
negative.

(b) Step 2: The edges of negative
samples are removed.

(c) Step 4: Exactly one sample in a
positive group is decoded to be positive.

Fig. 2. An illustration for the DD algorithm.

pooling matrix in [4], [5], each sample is pooled into 3 groups
(in their experiments, some samples are only pooled into 2
groups). As such, it is sparser than that used by P-BEST, and
it is claimed to be viable not just with low (< 4%) prevalence
rates, but even with moderate prevalence rates (5%-10%). One
of the restrictions for the pooling matrices constructed from
the Kirkman triples is that the column weights must be 3. Such
a restriction limits its applicability to optimize its performance
according to the prevalence rate.
IV. PP O L CONSTRUCTIONS OF POOLING MATRICES

Fig. 3. An un-decoded sample.

with the expected relative cost of 20% when the prevalence
rate r1 is 1%.
2D-pooling [2]: On a 96-well plate, there are 8 rows and
12 columns. Pool the samples in the same row (column)
into a group. This results in 20 groups for 96 samples. One
advantage of this simple 2D-pooling strategy is to minimize
pipetting errors.
P-BEST [3]: P-BEST [3] uses a 48 × 384 pooling matrix
constructed from the Reed-Solomon code [18] for pooled
testing of COVID-19. For the pooling matrix, each sample
is pooled into 6 groups, and each group contains 48 samples.
In [3], the authors proposed using the Gradient Projection
for Sparse Reconstruction (GPSR) algorithm for decoding.
Though it is claimed in [3] that the GPSR algorithm can detect
up to 1% of positive carriers, there is no guarantee that every
decoded sample (by the GPSR algorithm) is correct.
Tapestry [4], [5]: The Tapestry scheme [4], [5] uses the
Kirkman triples to construct their pooling matrices. For the

In this section, we propose a new family of pooling matrices
from packing the pencil of lines (PPoL) in a finite projective
plane. Our idea of constructing PPoL pooling matrices was
inspired by the constructions of channel hopping sequences
in the rendezvous search problem in cognitive radio networks
and the constructions of grant-free uplink transmission schedules in 5G networks (see, e.g., [19]–[21]).
A pooling matrix is said to be (d1 , d2 )-regular if there are
exactly d1 (resp. d2 ) nonzero elements in each column (resp.
row). In other words, the degree of every left-hand (resp.
right-hand) node in the corresponding bipartite graph is d1
(resp. d2 ). The total number of edges in the bipartite graph is
d1 M = d2 N for a (d1 , d2 )-regular pooling matrix H. Define
the (compressing) gain
M
d2
= .
N
d1
A. Perfect difference sets and finite projective planes
G=

(2)

As our construction of the pooling matrix is from packing
the pencil of lines in a finite projective plane, we first briefly
review the notions of difference sets and finite projective
planes.
Definition 2: (Difference sets) Let Zp = {0, 1, . . . , p − 1}.
A set D = {a0 , a1 , . . . , ak−1 } ⊂ Zp is called a (p, k, λ)difference set if for every (` mod p) 6= 0, there exist at least

λ ordered pairs (ai , aj ) such that ai − aj = (` mod p), where
ai , aj ∈ D. A (p, k, 1)-difference set is said to be perfect if
there exists exactly one ordered pair (ai , aj ) such that ai −
aj = (` mod p) for every (` mod p) 6= 0.
Definition 3: (Finite projective planes) A finite projective
plane of order m, denoted by P G(2, m), is a collection of
m2 + m + 1 lines and m2 + m + 1 points such that
(P1) every line contains m + 1 points,
(P2) every point is on m + 1 lines,
(P3) any two distinct lines intersect at exactly one point,
and
(P4) any two distinct points lie on exactly one line.
When m is a prime power, Singer [22] established the
connection between an (m2 + m + 1, m + 1, 1)-perfect difference set and a finite projective plane of order m through
a collineation that maps points (resp. lines) to points (resp.
lines) in a finite projective plane. Specifically, suppose that
D = {a0 , a1 , . . . , am } is an (m2 + m + 1, m + 1, 1)-perfect
difference set with
a0 = 0 < a1 = 1 < a2 < . . . , < am < m2 + m + 1.

(3)

Let {0, 1, . . . , m2 + m} be the m2 + m + 1 points.
Let p = m2 +m+1 and D` = {(a0 +`) mod p, (a1 +
`) mod p, . . . , (am +`) mod p}, ` = 0, 1, 2, . . . , p−1
be the m2 + m + 1 lines.
Then these m2 + m + 1 points and m2 + m + 1 lines form a
finite projective plane of order m.
(i)
(ii)

B. The construction algorithm
In this section, we propose the PPoL algorithm for constructing pooling matrices. For this, one first constructs
an (m2 + m + 1, m + 1, 1)-perfect difference set, D =
{a0 , a1 , . . . , am } with
a0 = 0 < a1 = 1 < a2 < . . . , < am < m2 + m + 1.

(4)

Let p = m2 + m + 1 and
D` = {(a0 +`) mod p, (a1 +`) mod p, . . . , (am +`) mod p},
(5)
` = 0, 1, 2, . . . , p − 1 be the p lines in the corresponding finite
projective plane.
It is easy to see that the m + 1 lines in the corresponding finite projective plane that contain point 0 are
D0 , Dp−a1 , Dp−a2 , . . . , Dp−am . These m + 1 lines are called
the pencil of lines that contain point 0 (as the pencil point). As
the only intersection of the m + 1 lines is point 0, these m + 1
lines, excluding point 0, are disjoint, and thus can be packed
into Zp . This is formally proved in the following lemma.
0
Lemma 4: Let Dp−a
= Dp−ai \{0}, i = 1, 2, . . . , m. Then
i
0
0
{D0 , Dp−a1 , . . . , Dp−a
} is a partition of Zp .
m
Proof. First, note that {D0 , Dp−a1 , . . . , Dp−am } are the m+
1 lines that contain point 0. As any two distinct lines intersect
at exactly one point, we know that for i 6= 0,
0
D0 ∩ Dp−a
= ∅,
i

and that for i 6= j,
0
0
Dp−a
∩ Dp−a
= ∅.
i
j

Thus, they are disjoint.
0
As there are m + 1 points in D0 and m points in Dp−a
,
i
0
0
2
D0 ∪ Dp−a1 ∪ . . . ∪ Dp−am contains m + 1 + m points. These
m + 1 + m2 points are exactly the set of m2 + m + 1 points
in the finite projective plane of order m.
In Algorithm 3, we show how one can construct a pooling
matrix from a finite projective plane. The idea is to first
construct a bipartite graph with the line nodes on the left and
the point nodes on the right. There is an edge between a point
node and a line node if that point is in that line. Then we start
trimming this line-point bipartite graph to achieve the needed
compression ratio. Specifically, we select the subgraph with
the m2 line nodes that does not contain point 0 (on the left)
and the d1 m point nodes in the union of d1 pencil of lines
(on the right).
ALGORITHM 3: The PPoL algorithm
Input The number of samples M = m2 with m being a
prime power, and the degree of each sample
1 ≤ d1 ≤ m.
Output An N × M binary pooling matrix H with
M = m2 and N = d1 m.
1: Let p = m2 + m + 1 and construct a perfect
difference set D = {a0 , a1 , . . . , am } in Zp (with
a0 = 0 and a1 = 1).
2: For ` = 0, 1, . . . , p − 1, let
D` = {(a0 +`) mod p, (a1 +`) mod p, . . . , (am +`) mod p}
be the p lines.
3: Construct a bipartite graph with the p lines on the left
and the p points on the right. Add an edge between a
point node and a line node if that point is in that line.
4: Remove point 0 and line 0 from the bipartite graph
(and the edges attached to these two nodes). Let
G = (gn,` ) be the (m2 + m) × (m2 + m) biadjacency
matrix of the trimmed bipartite graph with gn,` = 1 if
point n is in D` .
0
5: Let Dp−a
= Dp−ai \{0}, i = 1, 2, . . . , m, be the m
i
pencil of lines that contain point 0.
th
6: Remove the (p − ai ) column, i = 1, 2, . . . , m, in G
2
to form an (m + m) × m2 biadjacency matrix G̃. Note
that these m columns correspond to the m lines
containing point 0.
0
1
7: Let B = ∪di=1
Dp−a
(select the first d1 pencil of lines
i
that contain point 0). Remove rows of G̃ that are not in
B to form a d1 m × m2 biadjacency matrix H.
Proposition 5: The degree of a line node is d1 and the
degree of a point node is m.
Proof. As the remaining lines are the lines not containing
0
point 0, each line then intersects with Dp−a
at exactly one
i

point. Since there are d1 pencil of lines that contain point 0,
0
1
Dp−a
at exactly d1
each line then intersects with B = ∪di=1
i
points. On the other hand, each of the points in B is in a line
that contains point 0. As the lines that contain point 0 are
removed, each point in B is in m lines of the remaining m2
lines.
Proposition 6: There is at most one common nonzero
element in two rows (resp. columns) in the pooling matrix H
from Algorithm 3, i.e., the inner product of two row vectors
(resp. column vectors) is at most 1.
Proof. This is because the bipartite graph with the biadjacency matrix H is a subgraph of the line-point bipartite graph
corresponding to a finite projective plane. From (P3) and (P4)
of Definition 3, any two distinct lines intersect at exactly one
point, and any two distinct points lie on exactly one line. Thus,
there is at most one common nonzero element in two rows
(resp. columns) in H from Algorithm 3.
Corollary 7: The girth (the minimum length of a cycle) of
the bipartite graph with biadjacency matrix H is at least 6.
Proof. As the length of a cycle in a bipartite graph must be
an even number. It suffices to show that there does not exist a
cycle of length 4. We prove this by contradiction. Suppose that
there is a cycle of length 4. Suppose that this cycle contains
two line nodes L1 and L2 and two point nodes P1 and P2 .
Then the intersection of the two lines L1 and L2 contains two
points L1 and L2 . This contradicts (P3) in Definition 3.
Theorem 8: Consider using the d1 m × m2 pooling matrix
H from Algorithm 3 for a binary state vector x in a noiseless
setting. If the number of positive samples in x is not larger
than d1 − 1, then every sample can be correctly decoded by
the DD algorithm in Algorithm 1.
Proof. Suppose that there are at most d1 −1 positive samples.
We first show that every negative sample can be correctly
decoded by the DD algorithm in Algorithm 1. Consider a
negative sample. Since there are at most d1 − 1 positive
samples that can be pooled into the d1 groups of this negative
sample, and two different samples can be in a common group
at most once (Proposition 6), there must be at least one group
without positive samples. Thus, every negative sample can be
correctly decoded.
Now consider a positive sample. Since there are at most
d1 − 2 positive samples that can be pooled into the d1 groups
of this positive sample, and two different samples can be in
a common group at most once (Proposition 6), there must be
at least one group in which this positive sample is the only
positive sample. Thus, every positive sample can be correctly
decoded.
We note that there are other methods that can also generate
bipartite graphs that satisfy the property in Proposition 6. For

Fig. 4. Computing the conditional probability p0 by the tree evaluation
method.

instance, in the recent paper [23], Täufer used the shifted
traversal design to generate “mutlipools” (in Definition 1 of
[23]) that satisfy the property in Proposition 6 when m is a
prime. Both the PPoL constructions and the constructions of
“multipools” in [23] are closely related to orthogonal Latin
squares [24]. Also, pooling matrices that satisfy the decoding
property in Theorem 8 are known as the superimposed codes
in [25].
C. Probabilistic analysis of the PPoL pooling matrices
In this section, we conduct a probabilistic analysis of the
PPoL pooling matrices. We make the following assumption:
(A1) All the samples are i.i.d. Bernoulli random variables.
A sample is positive (resp. negative) with probability
r1 (resp. r0 ). The probability r1 is known as the
prevalence rate in the literature.
Note that r1 +r0 = 1. Also, let q1 (resp. q0 ) be the probability
that the group end of a randomly selected edge is positive
(resp. negative). Excluding the randomly selected edge, there
are d2 − 1 remaining edges in that group, and thus
q0
q1

=
=

(r0 )d2 −1 ,
d2 −1

1 − (r0 )

(6)
.

(7)

Let p0 be the conditional probability that a sample cannot
be decoded, given that the sample is a negative sample. Note
that a negative sample can be decoded if at least one of its
edges is in a negative group, excluding its edge (see Figure 4).
Consider a negative sample, called the tagged sample. Since
the girth of the bipartite graph of the pooling matrix is 6
(as shown in Corollary 7), the samples in the d1 groups of
the subtree of the tagged sample are distinct (see the tree
expansion in Figure 4). Thus,
p0 = (q1 )d1 = (1 − (r0 )d2 −1 )d1 .

(8)

Let p̂0 be the conditional probability that the sample end of
a randomly selected edge cannot be decoded, given that the
sample end is a negative sample. Note that the excess degree
of a sample (excluding the randomly selected edge) is d1 − 1.
Analogous to the argument for (8) (see the bottom subtree of
the tree expansion in Figure 5), we have
p̂0 = (q1 )d1 −1 = (1 − (r0 )d2 −1 )d1 −1 .

(9)

gains over the Dorfman two-stage algorithm. Unfortunately,
not every optimal (d1 , d2 )-regular pooling matrix in Table I
can be constructed by using the PPoL algorithm in Algorithm
3. In the next section, we will look for suboptimal pooling
matrices that have small performance degradation.
TABLE I
T HE (d1 , d2 )- REGULAR POOLING MATRIX WITH THE LOWEST EXPECTED
RELATIVE COST FROM (11).

Fig. 5. Computing the conditional probability p1 by the tree evaluation
method.

Let p1 be the conditional probability that a sample cannot
be decoded given that the sample is a positive sample. Note
that a positive sample can be decoded if at least one of its
edges is in a group in which all the edges are removed except
the edge of the positive sample. Since an edge is removed if
its sample end is a negative sample and that sample end is
decoded to be negative, the probability that an edge is removed
is (1 − p̂0 )r0 . If the tree expansion in Figure 5 is actually a
tree, then
p1 = (1 − (r0 (1 − p̂0 ))d2 −1 )d1 .
(10)
We note that the tree expansion in Figure 5 may not be a
tree for a PPoL pooling matrix generated from Algorithm 3,
the identity in (10) is only an approximation. A sufficient
condition for the tree expansion in Figure 5 to be a tree is that
the girth of the bipartite graph is larger than 8. Unfortunately,
the girth of a PPoL pooling matrix can only proved to be at
least 6.
Since a sample cannot be decoded with probability r0 p0 +
r1 p1 , the average number of tests needed for the DD2
algorithm in Algorithm 2 to decode the M samples is
N + M (r0 p0 + r1 p1 ). The expected relative cost for the DD2
algorithm with an N × M pooling matrix is
N + M (r0 p0 + r1 p1 )
1
=
+ r0 p0 + r1 p1 ,
(11)
M
G
where G = M/N is the (compressing) gain of the pooling
matrix in (2). Note that for a (d1 , d2 )-regular pooling matrix,
we have from (2) that G = d2 /d1 . Thus, we can use (8),
(10) and (11) to find the (d1 , d2 )-regular pooling matrix that
has the lowest expected relative cost (though (10) is only
an approximation for the pooling matrices constructed from
the PPoL algorithm). In Table I, we use grid search to find
the (d1 , d2 )-regular pooling matrix with the lowest expected
relative cost for various prevalence rates r1 up to 10%. The
search regions for the grid search are 2 ≤ d1 ≤ 8 and
d1 ≤ d2 ≤ 31. In the last column of this table, we also show
the expected relative cost of the Dorfman two-stage algorithm
(Table I of [10]). As shown in this table, using the DD2
algorithm (with the optimal pooling matrices) has significant

r1
1%
2%
3%
4%
5%
6%
7%
8%
9%
10%

d1
3
4
4
4
3
3
3
2
2
2

d2
31
29
22
17
12
11
10
7
6
6

cost (11)
0.1218
0.1881
0.2545
0.3147
0.3678
0.4166
0.4627
0.5035
0.5416
0.5760

Dorfman [10]
0.20
0.27
0.33
0.38
0.43
0.47
0.50
0.53
0.56
0.59

V. N UMERICAL RESULTS
In this section, we compare the performance of various
pooling matrices by using the DD2 algorithm in Algorithm
2. The first four pooling matrices are constructed by using
the PPoL algorithm in Algorithm 3 with the parameters
(m, d1 ) = (31, 3), (23, 4), (13, 3), and (7, 2), respectively.
The fifth pooling matrix is the pooling matrix used in PBEST [3]. The sixth matrix is the 15 × 35 pooling matrix
constructed by the Kirkman triples. The next two pooling
matrices are used in Tapestry [4], [5]. The last pooling matrix
is the 2D-pooling matrix in [2]. In Table II, we show the
basic information of these pooling matrices. The size of an
N × M pooling matrix indicates that the number of groups is
N , and the number of samples is M . The parameter d1 is the
number of groups in which a sample is pooled. On the other
hand, d2 is the number of samples in a group. Note that there
are some pooling matrices that are not (d1 , d2 )-regular. For
instance, in the 2D-pooling matrix, there are 8 groups with
12 samples, and 12 groups with 8 samples. Also, both the
16 × 40 matrix and the 24 × 60 matrix used in Tapestry are
not (d1 , d2 )-regular. The column marked with row cor. (resp.
col. cor.) is the maximum of the inner product of two rows
(resp. columns) in a pooling matrix. For a pooling matrix, the
column marked with girth is the minimum length of a cycle
in the bipartite graph corresponding to that pooling matrix.
The column marked with (comp.) gain is the compressing
gain G of a pooling matrix, which is the ratio of the number
of columns (samples) to the number of rows (groups), i.e.,
G = M/N . As shown in Table II, both the row correlation
and the column correlation of the pooling matrices constructed
from the PPoL algorithm in Algorithm 3 are 1. So are the
15 × 35 pooling matrix constructed by the Kirkman triples.
Such a correlation result is expected from Proposition 6. On
the other hand, the row correlation and the column correlation
of the pooling matrix in P-BEST [3] are 6 and 2, respectively.
Also, the girth of the pooling matrix in P-BEST is only

1

0.6
PPoL-(31,3)
PPol-(23,4)
PPoL-(13,3)
PPoL-(7,2)
P-BEST Matrix
Kirkman Matrix 15×35
Tapestry Matrix 16×40
Tapestry Matrix 24×60
2D-pooling Matrix

p0

0.4
0.3

0.8
0.6

p1

0.5

0.2

0.2

0

0.1
0

PPoL-(31,3)
PPol-(23,4)
PPoL-(13,3)
PPoL-(7,2)
P-BEST Matrix
Kirkman Matrix 15×35
Tapestry Matrix 16×40
Tapestry Matrix 24×60
2D-pooling Matrix

0.4

0

1

2

3

4

5

r1 (%)

0

1

2

3

4

5

Fig. 7. The conditional probability p1 (that a sample cannot be decoded given
it is a positive sample) as a function of the prevalence rate r1 for various
pooling matrices.

r1 (%)
Fig. 6. The conditional probability p0 (that a sample cannot be decoded
given it is a negative sample) as a function of the prevalence rate r1 for
various pooling matrices.

PPoL-(31,3)
PPol-(23,4)
PPoL-(13,3)
PPoL-(7,2)
P-BEST Matrix
Kirkman Matrix 15×35
Tapestry Matrix 16×40
Tapestry Matrix 24×60
2D-pooling Matrix

4, which is smaller than the other four matrices. The girth
of the 16 × 40 pooling matrix in Tapestry is also 4. This
shows that the pooling matrices from the PPoL algorithm are
more “spread-out” than the pooling matrix in P-BEST and the
16 × 40 pooling matrix in Tapestry.

H

size

d1

d2

93 × 961
92 × 529
39 × 169
14 × 49
48 × 384
15 × 35
16 × 40
24 × 60
20 × 96

3
4
3
2
6
3
2-3
2-3
2

31
23
13
7
48
7
6-9
6-7
12(8)

row
cor.
1
1
1
1
6
1
3
1
1

col.
cor.
1
1
1
1
2
1
2
1
1

girth
6
6
6
8
4
6
4
6
8

0.6
0.4
0.2

TABLE II
BASIC INFORMATION OF SOME POOLING MATRICES .

PPoL-(31,3)
PPoL-(23,4)
PPoL-(13,3)
PPoL-(7,2)
P-BEST Matrix [3]
Kirkman Matrix 15 × 35
Tapestry Matrix 16 × 40 [4]
Tapestry Matrix 24 × 60 [4]
2D-pooling Matrix [2]

r0p 0+r1p 1

0.8

(comp.)
gain
10.33
5.75
4.33
3.5
8
2.33
2.5
2.5
4.8

To compare the performance of these pooling matrices, we
conduct 10,000 independent experiments for each value of the
prevalence rate r1 , ranging from 0% to 5%. Each numerical
result is obtained by averaging over these 10,000 independent
experiments. In Figure 6, we show the (measured) conditional
probability p0 (that a sample cannot be decoded given it is a
negative sample) for these pooling matrices. For the PPoL
pooling matrices, the measured p0 ’s match extremely well
with the theoretical results from (8). As shown in this figure,
the Kirkman matrix and the two matrices in Tapestry have
the best performance. This is because their d2 ’s (the number
of samples in a group) are small (below 9 for these three
matrices). As such, the probability that a group is tested
negative is higher than the other pooling matrices. Note that
these three matrices also have low (compressing) gains, 2.332.5. On the other hand, P-BEST has the worst performance
for p0 as the number of samples in a group for that matrix is
48, which is the largest among all these pooling matrices.
In Figure 7, we show the (measured) conditional probability
p1 (that a sample cannot be decoded given it is a positive
sample) for these pooling matrices. Once again, the Kirkman

0

0

1

2

3

4

5

r1 (%)
Fig. 8. The probability r0 p0 + r1 p1 (that a sample cannot be decoded at the
first stage and should be tested individually at the second stage) as a function
of the prevalence rate r1 for various pooling matrices.

matrix and the two matrices in Tapestry have the best performance. This is mainly due to the low (compressing) gains of
these three matrices. Though not shown in Figure 7, we note
that the measured p1 ’s are very close to those from (10), and
thus the tree expansion in Figure 5 is actually tree-like.
As discussed in Section IV-C, the probability that a sample
cannot be decoded is r0 p0 +r1 p1 . Such a probability is also the
probability that a sample needs to go through the second stage
for individual testing. In Figure 8, we show the probability
r0 p0 + r1 p1 as a function of the prevalence rate r1 for various
pooling matrices. As shown in this figure, the Kirkman matrix
and the two matrices in Tapestry have the best performance.
Once again, this is mainly due to the low (compressing) gains
of these three matrices. We note that it takes time to do the
second test. The numerical results in Figure 8 imply that using
the Kirkman matrix (or the two matrices in Tapestry) has the
shortest expected time to obtain a testing result.
A fair comparison of these pooling matrices is to measure
their expected relative costs (defined in [10]). Recall that the
expected relative cost is the ratio of the expected number of

To optimize the performance, one should choose the right
pooling matrix, depending on the prevalence rate. However,
this might be difficult as the exact prevalence rate of a new
outbreak of COVID-19 in a region might not be known in
advance. Our suggestion is to use suboptimal PPoL matrices
for a range of prevalence rates, as shown in Table III. As
shown in this table, the costs computed from the theoretical
approximations in (11) and the costs measured from simulations are very close, and they are within 2% of the minimum
costs for (d1 , d2 )-regular pooling matrices in Table I. From
our numerical results in Figure 9, we suggest using the PPoL
matrix with d1 = 3 and d2 = 31 when the prevalence
rate r1 is below 2%. In this range of prevalence rates, its
expected relative cost is even smaller than that of P-BEST.
Moreover, it can achieve an 8-fold reduction in test costs when
the prevalence rate is near 1% (as shown in Table III), and
most samples can be decoded in the first stage (as shown in
Figure 8). When the prevalence rate r1 is between 2%-4%, we
suggest using the PPoL matrix with d1 = 4 and d2 = 23. In
this range of prevalence rates, using such a pooling matrix can
still achieve (at least) a 3-fold reduction in test costs. Roughly,
17% of samples need to go through the second stage when
the prevalence rate is near 4% (as shown in Figure 8). When
the prevalence rate r1 is between 4%-7%, we suggest using
the PPoL matrix with d1 = 3 and d2 = 13, and it can still
achieve (at least) a 2-fold reduction in test costs. When the
prevalence rate r1 is between 7%-10%, we suggest using the
PPoL matrix with d1 = 2 and d2 = 7. Though its expected
relative cost is still lower than that of the Dorfman two-stage
algorithm, the difference is small.

1

The expected relative cost

tests required by the group testing technique to the number
of tests required by the individual testing. In Figure 9, we
show the (measured) expected relative costs for these pooling
matrices. In this figure, we also plot the curve for the Dorfman
two-stage algorithm (the black curve) with the optimal group
size M chosen from Table 1 of [10] for the prevalence rates,
1%, 2%, . . . , 5%. To our surprise, the curves for the Kirkman
matrix and the two matrices in Tapestry are above the black
curve. This means that the expected relative costs of these
three matrices are higher than the (optimized) Dorfman twostage algorithm. Thus, if the additional amount of time to go
through the second stage is not critical, using other pooling
matrices could lead to more cost reduction than using these
three matrices. There are several pooling matrices that have
very low relative costs when the prevalence rates are below
1%. The P-BEST pooling matrix is one of them. However,
the relative cost of the P-BEST pooling matrix increases
dramatically when the prevalence rates are above 1.3%. Moreover, the P-BEST pooling matrix has a higher relative cost
than the (optimized) Dorfman two-stage algorithm when the
prevalence rate is above 2.5%. On the other hand, 2D-pooling
has a very low relative cost when the prevalence rates are
above 2.5%. To summarize, there does not exist a pooling
matrix that has the lowest relative cost in the whole range of
the prevalence rates considered in our experiments.

PPoL-(31,3)
PPol-(23,4)
PPoL-(13,3)
PPoL-(7,2)
P-BEST Matrix
Kirkman Matrix 15×35
Tapestry Matrix 16×40
Tapestry Matrix 24×60
2D-pooling Matrix
The Dorfman two-stage algorithm

0.8
0.6
0.4
0.2
0

0

1

2

3

4

5

r1 (%)
Fig. 9. The expected relative cost as a function of the prevalence rate r1 for
various pooling matrices.
TABLE III
S UBOPTIMAL PP O L POOLING MATRICES .
r1
1%
2%
3%
4%
5%
6%
7%
8%
9%
10%

d1
3
4
4
3
3
3
2
2
2
2

d2
31
23
23
13
13
13
7
7
7
7

cost (11)
0.1218
0.1973
0.2552
0.3170
0.3685
0.4243
0.4651
0.5035
0.5422
0.5809

cost (sim)
0.12
0.20
0.25
0.32
0.37
0.42
0.47
0.50
0.54
0.58

Dorfman [10]
0.20
0.27
0.33
0.38
0.43
0.47
0.50
0.53
0.56
0.59

VI. C ONCLUSION
In this paper, we proposed a new family of PPoL polling
matrices that have maximum column correlation and row
correlation of 1 for a wide range of column weights. Using
the two-stage definite defectives (DD2) decoding algorithm,
we compare their performance with various pooling matrices
proposed in the literature, including 2D-pooling [2], P-BEST
[3], and Tapestry [4], [5]. Our numerical results showed no
pooling matrix with the lowest expected relative cost in the
whole range of the prevalence rates. To optimize the performance, one should choose the right pooling matrix, depending
on the prevalence rate. As the family of PPoL matrices can
dynamically adjust their column weights according to the
prevalence rates, it seems that using such a family of pooling
matrices might lead to better cost reduction than using a fixed
pooling matrix.
There are several research directions for future works:
(i)

Other decoding algorithms: in this paper, we only
evaluated the performance of pooling matrices using
the DD2 algorithm. To probe further, we are currently investigating the possibility of using other decoding algorithms, in particular, the GPSR algorithm
in [3] and the belief propagation (BP) algorithm in
[26].

(ii)

(iii)

Noisy decoding: The DD2 algorithm works very
well in the noiseless setting. However, it is not
clear whether it can continue to perform well in
a noisy setting. There are several noise models
proposed in the literature (see, e.g., the monograph
[13]). Among them, the dilution noise model is of
particular interest to us.
Ternary samples: in this paper, we only considered
binary samples. For ternary samples, there are three
test outcomes: negative (0), weakly positive (1), and
strongly positive (2). It seems possible to extend the
DD2 algorithm for binary samples to the setting with
ternary samples by using successive cancellations.
R EFERENCES

[1] “Pooled
sample
testing
and
screening
testing
for
covid-19,”
Aug
2020.
[Online].
Available: https://www.fda.gov/medical-devices/coronavirus-covid-19-andmedical-devices/pooled-sample-testing-and-screening-testing-covid-19
[2] N. Sinnott-Armstrong, D. Klein, and B. Hickey, “Evaluation of group
testing for sars-cov-2 rna,” medRxiv, 2020.
[3] N. Shental, S. Levy, V. Wuvshet, S. Skorniakov, B. Shalem, A. Ottolenghi, Y. Greenshpan, R. Steinberg, A. Edri, R. Gillis et al., “Efficient
high-throughput sars-cov-2 testing to detect asymptomatic carriers,”
Science Advances, p. eabc5961, 2020.
[4] S. Ghosh, A. Rajwade, S. Krishna, N. Gopalkrishnan, T. E. Schaus,
A. Chakravarthy, S. Varahan, V. Appu, R. Ramakrishnan, S. Ch et al.,
“Tapestry: A single-round smart pooling technique for covid-19 testing,”
medRxiv, 2020.
[5] S. Ghosh, R. Agarwal, M. A. Rehan, S. Pathak, P. Agrawal, Y. Gupta,
S. Consul, N. Gupta, R. Goyal, A. Rajwade et al., “A compressed sensing approach to group-testing for covid-19 detection,” arXiv preprint
arXiv:2005.07895, 2020.
[6] “Coronavirus disease (covid-19) outbreak,” Jan 2020. [Online]. Available: https://www.who.int/emergencies/diseases/novelcoronavirus-2019
[7] H. Nishiura, T. Kobayashi, T. Miyama, A. Suzuki, S.-m. Jung,
K. Hayashi, R. Kinoshita, Y. Yang, B. Yuan, A. R. Akhmetzhanov et al.,
“Estimation of the asymptomatic ratio of novel coronavirus infections
(covid-19),” International journal of infectious diseases, vol. 94, p. 154,
2020.
[8] Y.-C. Chen, P.-E. Lu, C.-S. Chang, and T.-H. Liu, “A timedependent sir model for covid-19 with undetectable infected persons,” IEEE Transactions on Network Science and Engineering, DOI:
10.1109/TNSE.2020.3024723, 2020.
[9] “Interim guidance for use of pooling procedures in sars-cov2 diagnostic, screening, and surveillance testing,” June 2020.
[Online]. Available: https://www.cdc.gov/coronavirus/2019-ncov/lab/
pooling-procedures.html
[10] R. Dorfman, “The detection of defective members of large populations,”
The Annals of Mathematical Statistics, vol. 14, no. 4, pp. 436–440,
1943.
[11] J. Yi, R. Mudumbai, and W. Xu, “Low-cost and high-throughput
testing of covid-19 viruses and antibodies via compressed sensing: System concepts and computational experiments,” arXiv preprint
arXiv:2004.05759, 2020.
[12] A. Heidarzadeh and K. R. Narayanan, “Two-stage adaptive pooling with
rt-qpcr for covid-19 screening,” arXiv preprint arXiv:2007.02695, 2020.
[13] M. Aldridge, O. Johnson, and J. Scarlett, “Group testing: an information
theory perspective,” arXiv preprint arXiv:1902.06002, 2019.
[14] S. Lohse, T. Pfuhl, B. Berkó-Göttel, J. Rissland, T. Geißler, B. Gärtner,
S. L. Becker, S. Schneitler, and S. Smola, “Pooling of samples for
testing for sars-cov-2 in asymptomatic people,” The Lancet Infectious
Diseases, 2020.
[15] B. Abdalhamid, C. R. Bilder, E. L. McCutchen, S. H. Hinrichs, S. A.
Koepsell, and P. C. Iwen, “Assessment of specimen pooling to conserve
sars cov-2 testing resources,” American journal of clinical pathology,
vol. 153, no. 6, pp. 715–718, 2020.

[16] I. Yelin, N. Aharony, E. Shaer-Tamar, A. Argoetti, E. Messer, D. Berenbaum, E. Shafran, A. Kuzli, N. Gandali, T. Hashimshony et al.,
“Evaluation of covid-19 rt-qpcr test in multi-sample pools,” MedRxiv,
2020.
[17] C. Gollier and O. Gossner, “Group testing against covid-19,” Covid
Economics, vol. 2, 2020.
[18] I. S. Reed and G. Solomon, “Polynomial codes over certain finite fields,”
Journal of the society for industrial and applied mathematics, vol. 8,
no. 2, pp. 300–304, 1960.
[19] C.-S. Chang, W. Liao, and C.-M. Lien, “On the multichannel rendezvous
problem: Fundamental limits, optimal hopping sequences, and bounded
time-to-rendezvous,” Mathematics of Operations Research, vol. 40,
no. 1, pp. 1–23, 2015.
[20] C.-S. Chang, D.-S. Lee, and C. Wang, “Asynchronous grant-free uplink
transmissions in multichannel wireless networks with heterogeneous qos
guarantees,” IEEE/ACM Transactions on Networking, vol. 27, no. 4, pp.
1584–1597, 2019.
[21] C.-S. Chang, J.-P. Sheu, and Y.-J. Lin, “On the theoretical gap of
channel hopping sequences with maximum rendezvous diversity in the
multichannel rendezvous problem,” arXiv preprint arXiv:1908.00198,
2019.
[22] J. Singer, “A theorem in finite projective geometry and some applications to number theory,” Transactions of the American Mathematical
Society, vol. 43, no. 3, pp. 377–385, 1938.
[23] M. Täufer, “Rapid, large-scale, and effective detection of covid-19 via
non-adaptive testing,” BioRxiv, 2020.
[24] L. Euler, Recherches sur une nouvelle espece de quarres magiques.
Zeeuwsch Genootschao, 1782.
[25] W. Kautz and R. Singleton, “Nonrandom binary superimposed codes,”
IEEE Transactions on Information Theory, vol. 10, no. 4, pp. 363–377,
1964.
[26] D. Sejdinovic and O. Johnson, “Note on noisy group testing: Asymptotic
bounds and belief propagation reconstruction,” in 2010 48th Annual
Allerton Conference on Communication, Control, and Computing (Allerton). IEEE, 2010, pp. 998–1003.

