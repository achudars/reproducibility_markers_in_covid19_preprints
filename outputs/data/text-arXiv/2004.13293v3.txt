Epione: Lightweight Contact Tracing with Strong Privacy
Ni Trieu∗

Kareem Shehata†

Prateek Saxena‡

Reza Shokri‡

Dawn Song§¶

arXiv:2004.13293v3 [cs.CR] 2 May 2020

Abstract
Contact tracing is an essential tool in containing infectious diseases such as COVID-19. Many
countries and research groups have launched or announced mobile apps to facilitate contact
tracing by recording contacts between users with some privacy considerations. Most of the
focus has been on using random tokens, which are exchanged during encounters and stored
locally on users’ phones. Prior systems allow users to search over released tokens in order to
learn if they have recently been in the proximity of a user that has since been diagnosed with
the disease. However, prior approaches do not provide end-to-end privacy in the collection and
querying of tokens. In particular, these approaches are vulnerable to either linkage attacks by
users using token metadata, linkage attacks by the server, or false reporting by users.
In this work, we introduce Epione, a lightweight system for contact tracing with strong privacy
protections. Epione alerts users directly if any of their contacts have been diagnosed with the
disease, while protecting the privacy of users’ contacts from both central services and other
users, and provides protection against false reporting. As a key building block, we present a
new cryptographic tool for secure two-party private set intersection cardinality (PSI-CA), which
allows two parties, each holding a set of items, to learn the intersection size of two private sets
without revealing intersection items. We specifically tailor it to the case of large-scale contact
tracing where clients have small input sets and the server’s database of tokens is much larger.

1

Introduction

Contact tracing is an important method to curtail the spread of infectious diseases. The goal of
contact tracing is to identify individuals that may have come into contact with a person that has
been diagnosed with the disease, so they can be isolated and tested, and thus prevent the spread of
the disease any further.
In the ongoing COVID-19 pandemic, recording of individuals in close proximity has been facilitated by mobile apps that detect nearby mobile phones using Bluetooth. Several countries have
been developing contact tracing apps. Such large-scale collection of personal contact information is
a significant concern for privacy [18, 44].
The main purpose of contact tracing applications—recording the fact that two or more individuals were near each other at a certain moment of time—seems to be at odds with their privacy. The
app must record information about the individual’s personal contacts and should be able to reveal
this information (possibly, on demand) to some authorities. Indeed, in a fully untrusted environment
one should expect any participant to behave adversarially with the goal to exploit others’ personal
information. Further, both end users of tracing apps as well as the authorities using the collected
data can become victims of security attacks, which can allow powerful adversaries to misuse the
information collected by the app.
∗

UC Berkeley, nitrieu@berkeley.edu
kareem@shehata.ca
‡
National University of Singapore, {prateeks, reza}@comp.nus.edu.sg
¶
UC Berkeley and Oasis Labs, dawnsong@berkeley.edu
†

1

Multiple ways have been proposed to protect the users’ private proximity data, offering different
privacy guarantees and coming at different implementation costs. For instance, in the recently
released BlueTrace protocol used by the Singapore Government [34], users are guaranteed privacy
from each other, but this model places complete trust in certain operating entities for protecting user
information. We analyze the BlueTrace proposal and other approaches in more detail in Section 2.1.
We consider a model where the government authorities do not store any identifying user information (e.g. phone numbers and social contacts). Databases of such sensitive information are
lucrative targets for cyber-attackers, and in many countries the collection of contact information
conflicts with privacy regulations and public concerns, which may create a barrier to the usage of the
tracing service. This is important, as privacy concerns may hinder adoption in some jurisdictions
and contact tracing is expected to be effective only when participation is high (e.g. 60% or more of
the population [26]).
In our model, the health authorities maintain a database of tokens corresponding to users which
have been diagnosed with the disease. The user’s tracing app periodically checks an untrusted
server to check if the user is potentially at risk in such a way that the server cannot deduce any
information about the user which is not implied by the desired functionality and the user learns no
information beyond whether they may have been exposed to the disease.
Our model can also be contrasted to several other decentralized mobile contact tracing system/protocols, which will also be analyzed in Section 2.1. As we will see through that analysis,
existing proposals or launched systems are vulnerable to one or more of the following privacy attacks:
(1) Infection status / exposure source by users: If tokens of users diagnosed positive are publicly
released, Alice can determine which publicly-posted tokens matches the log on her phone.
This could reveal the time, for example, when Alice and the user diagnosed positive with the
disease were in close proximity, enabling her to identify Bob. Such identification is undesirable
as people have been reported to harass individuals suspected to be the source of exposure to
the disease [5], leading to the so-called "vigilante" problem.
(2) Infection status by server: If the server can determine which users have been diagnosed with
the disease, this leaks the infection status of users to the server operator. This may not be
a concern in jurisdictions where the server is operated by the health authority which already
knows this information. However, in jurisdictions where the server is operated by another
party that does not or should not have this information, this form of linkage can be a serious
privacy threat.
(3) Social graph exposure and user tracking: If a central database is used to collect both sent and
received tokens as in [3], or it is possible to infer the source of a sent token as in the case of [6],
then the operator of this server is able to deduce all of the social connections of a user that is
reported positive for the disease, including when and for how long each contact was made.
This linkage can also be used to track a user’s movements via Bluetooth beacons. Bluetooth
has protections against tracking users over time introduced in Bluetooth 4.0 Low Energy
[46]. With solutions such as [1, 15] it is possible to link previously seen Bluetooth device
(MAC) addresses despite these protections via exchanged contact tokens once the seeds used
to generate the tokens are released1 , producing a similar attack to [10].
(4) False claims by users: Users may falsely claim to be diagnosed positive or may claim to be in
contact with someone by modifying their app logs. For example, a user who has recovered after
1

As internet users have already pointed out https://twitter.com/moxie/status/1248707315626201088

2

System

System Req.
Trusted
#
Server

TraceTogether [34]
Baseline*
Private Messaging [18]
Epione

Yes
No

1
1
3
2

Privacy Protection Against
Infection Status
Social False-positive
By User By Server Graph
User
Yes
No
No
Yes

No
No
Yes
Yes

No
Most
Yes
Yes

Yes
Some
No
Yes

Client
Comm.
Cost
O(n)
O(N )
O(n log(N ))

Table 1: Comparison of contact tracing systems with respect to security, privacy, required computational infrastructure, and client communication cost. Baseline systems include Private Kit [44],
Covid-watch [3], CEN [2], DP-3 [4], and PACT’s baseline system [15]. Some of these systems provide
a limited level of false-positive claim protection with an additional server (or healthcare provider),
and most provide protection from social graph discovery. N is the total number of contact tokens
from users diagnosed positive with the disease, n is the number of contact tokens recorded by an
average user that need to be checked for disease exposure (Note that N
n is typically the number of
new positive diagnoses per day, thus n << N ).
being diagnosed positive may threaten to retroactively add a user not currently diagnosed with
the disease to their contact log, unless they are paid a ransom. Similarly, a user not diagnosed
may falsely claim to be in contact with a user diagnosed positive whose tokens have been
revealed, for example, to qualify for a diagnostic test.
Table 1 provides a brief comparison of different contact tracing systems with respect to different
security/privacy properties, required computational infrastructure and client’s communication cost,
all of which are important for real-world contact tracing. Details of the systems compared will be
discussed in Section 2.1.

1.1

Our Contribution

In this work, we introduce Epione, a new system for decentralized contact tracing with stronger
privacy protections than the strongest models currently found in related work. As a key primitive
enabling Epione, we introduce a new private set intersection cardinality or PSI-CA, which is used
to check how many tokens held by a user (client) match the tokens in a set stored on a server,
without the user revealing their tokens. More formally, PSI-CA allows two parties, each holding
a private set of tokens, to learn the size of the intersection between their sets without revealing
any additional information. Our PSI-CA primitive is designed to be efficient for a large server-side
database and a small client-side database, as is the case for contact tracing applications. Our new
PSI-CA constructions allow us to meet all of our privacy goals. With several other optimizations
in our system design, we show that PSI-CA can make privacy-preserving contact tracing practical.
In summary, we make the following contributions:
• We design Epione, an efficient high-performance contact tracing system that provides strong
privacy guarantees, specifically that user contact information is not revealed beyond what is
desired to any party and that the diagnosis status is revealed only to health authorities. The
system prevents all important attacks, such as linkage attacks (e.g. infection status, social
graph exposure), and false-positive claims, to which current models underpinning related work
are vulnerable.
• We propose a new semi-honest private set intersection cardinality (PSI-CA) primitive for
asymmetric sets. Our PSI-CA protocol has communication complexity linear in the size of
3

the smaller set (n), and logarithmic in the larger set size N . More precisely, if the set sizes
are n << N , we achieve a communication overhead of O(n log N ).

1.2

System Overview

Figure 1 shows an overview of the Epione system. Users of Epione want to be notified if any of the
people they have been in contact with are later diagnosed with the disease. They do not want to
reveal to other users their identity, reveal whether they have been diagnosed positive, be tracked
over time, or reveal their contacts to any other organization.
We use a short-range network (such as Bluetooth) to detect when two users are within close
range and exchange a randomly generated “contact token”. All of the sent and received contact
tokens are stored securely on the user’s phone in the “sent token list” and “received token list”,
respectively. The received token list never leaves the user’s phone in a form that can be used by
anyone else, and the sent token list is only revealed to a healthcare provider on a positive diagnosis
and with the user’s consent. In Section 5, we explain in detail how to generate and store the tokens.
In Epione, we assume that there is an untrusted service provider, which we call the Epione Server
(or the backend server or just “server” for simplicity when it isn’t ambiguous), which can collect the
transmitted contact tokens from all users tested positive with the disease. The Epione server allows
users to check whether they have received a token from a user who has since been diagnosed with
the disease, without revealing to the server their tokens (and thus their contacts) and without the
server revealing any information to the user about the tokens of users diagnosed positive beyond the
count of contact tokens in common. We use secure computation techniques, particularly PSI-CA,
for private matching. This prevents the Epione server from inferring linkages between users, as well
as preventing users from inferring the diagnosis status of other users, or the source of any exposure
to the disease.
It is assumed that a healthcare provider (such as a hospital) is aware of the identity of the
user whom it diagnoses as having the disease. Thus, exposing the identity of the user diagnosed
positive from the provider is not considered as a threat. It is also assumed that the healthcare
provider keeps a local database of positively diagnosed users, to be able to verify if a user was
legitimately diagnosed positive. The healthcare provider collects (with the user’s consent) the list
of “sent tokens” from a positively diagnosed user’s app and sends it to the Epione server, which the
latter adds to a database of contact tokens from such users.
Note that in this model the server does not know the identity of the user diagnosed positive. It
is not hard to imagine collusion between the healthcare database and the backend server for Epione,
say by a state actor or attacker within the healthcare provider. Even then, the sent tokens are
not useful for identifying any contacts or any other private information. Since tokens are randomly
generated, the attacker would need to know which users received those tokens to re-identify them.
We will show later that the Epione server never learns the received tokens of any user and thus
linkage is not possible.

2

Related Work

We begin by discussing previous approaches to contact tracing, and then current approaches to
secure computation and private set intersection, which will form the basis for our own PSI-CA used
in Epione.

4

Figure 1: Overview of our Epione system. When a person is diagnosed with the disease, the
healthcare provider collects their sent tokens and forwards them to the Epione server encrypted
under the server’s public key (actually, the PRG seed is collected to reduce communication costs).
The Epione server decrypts the received ciphertexts from the healthcare provider and obtains the
transmitted tokens of all patients diagnosed positive. Next, each user’s app uses PSI-CA to compare
their set of received tokens with the set of sent tokens stored on the Epione server. If the intersection
size is more than zero, then the user is alerted that they may have been exposed to the disease.

2.1

Contact Tracing Approaches

Due to the rapid spread of the COVID-19 pandemic and the importance of contact tracing, many
research groups have been developing tools to improve contact tracing. Most schemes either (1) rely
on and expose data to a trusted third-party, such as TraceTogether [34], or (2) uses a decentralized/public list approach such as COVID-Watch [3], PACT [15], or Google/Apple [1] that allows
users to infer linkages such as exposure sources. We divide existing contact tracing systems into
Trusted Central Authority and Untrusted Centralized / Distributed approaches.
2.1.1

Trusted Third-Party (Centralized) Approaches

The primary example of a trusted third party approach is introduced in the TraceTogether app
by the Singapore Government, released on March 20, 2020 [6]. Based on its underlying Bluetrace
protocol specification, the protocol abstractly works as follows. Let Alice and Bob be users of the
app, and let Grace be the government server (or other central authority).
1. Setup. Alice and Bob both install the app on their smartphones. During the setup process,
both Alice and Bob register a phone number with Grace and are each assigned a unique
identifier (i.e., IDA for Alice, and IDB for Bob). Grace stores the phone numbers and ID
numbers registered in a database.
2. Token Generation Grace assigns to Alice and Bob a set of contact tokens2 that are to be
used at different times. Tokens are generated by concatenating the user’s ID, the start time of
2

In Bluetrace, tokens are called "TempIDs". We have kept the term token here for comparison with other systems.

5

the token, and the end time of the token, and then encrypting with AES-256-GCM with a key
known only to Grace. Tokens are thus expressed as: Ti = EAES (k, ID||tstart ||tend ). Tokens
are sent in batches along with validity times to users’ devices in case they are not able to fetch
new tokens on demand3 .
3. Contact. When Alice and Bob meet, they exchange tokens valid for the current time window.
Both devices keep a list of received tokens.
4. Diagnosis. Some time later, Bob is confirmed to have contracted the disease. Bob sends his
received tokens list (i.e. the list that contains TA received from Alice) to Grace. Grace verifies
that Bob does in fact have a positive test result (this can be done either by matching Bob in
a separate database of test results, or by providing Bob with a certificate that validates his
positive result).
5. Follow-up. Grace then decrypts each token received from Bob using her key. This reveals
the user ID and time of each contact along with other metadata. Grace can then look up each
user’s (e.g. Alice’s) phone number and directly follow up with them.
Clearly, this model places trust in the government health authority (Grace). When Bob is
diagnosed with the disease and submits his tokens, Grace learns all of Bob’s contacts, including
when and for how long they were in contact. If Grace’s key is compromised by an attacker, it could
be used to track all users via Bluetooth (similar to [10]). The Bluetrace whitepaper has explained
the rationale for the proposed model and alluded to concerns with it.
2.1.2

Untrusted Third-Party or Decentralized Approaches

Nearly all of the proposed or launched contact tracing schemes that do not rely on a trusted authority
use a scheme as follows, with minor variations:
1. Alice and Bob, two users of the contact tracing scheme, download and install the app.
2. Alice and Bob both generate contact tokens that rotate over time and cannot be used to reveal
their identity directly or track them over time.
3. When Alice and Bob meet, they exchange contact tokens, for example via Bluetooth4 . Alice
and Bob both keep a list of received tokens and sent tokens.
4. Bob is later diagnosed with the disease. Bob submits his tokens to an untrusted server. This
can be either the list of received tokens, the list of sent tokens, or both. Alternatively, Bob
can submit the secret used to generate tokens from his sent list.
5. A list of tokens from users diagnosed with the disease is then maintained either in a private
database to which users can submit queries or published in a public list so that users can
check for intersections on their device.
6. If a user finds they have tokens in common with the public list, or via querying a central
database, they may have been exposed to the disease and should be notified to seek appropriate
next steps.
3

Note that tokens are generated by Grace mainly to reduce computational load on client devices. This scheme is
equivalent to having clients produce tokens by encrypting with a public key for Grace with the same information.
4
in GPS or geolocation based systems, Alice and Bob independently generate tokens as a function of location and
time, for example by hashing a grid square and time quantum.

6

Covid-watch [3], Private Kit [44]5 , PACT’s baseline design [15], and Google/Apple [1] are all
variations on this design. Some use pseudo-random number generators, and upload seeds for the sent
token lists to reduce communication and storage costs at the expense of greater cost for comparisons,
but this has no impact on privacy implications. All of these designs are susceptible to linkage attack
by either users, the server, or both. Some offer protection against false positive claims.
In all of the above systems, each phone has to compare the publicly posted contact tokens against
their own history, which requires to them download all public tokens. This requires significant
bandwidth and places a burden on mobile devices.
2.1.3

Privacy Improvements

Private Messaging. To reduce the linkage information learned by a central server, [18] proposes
to use two or more non-colluding servers operating as a private messaging network between users
and the central server operated by the government (Grace). Concretely, assume that Grace stores
a collection of mailboxes, one for each token that Alice and Bob exchange, and there are two noncolluding communication servers Frank and Fred. Frank forwards messages to/from Fred, and Fred
forwards messages to/from Grace, all in such a way that Grace cannot know the source or destination
of any messages. When Alice and Bob are in close contract, they exchange tokens. At fixed time
points, both parties send a message which contains their current diagnosis status to each other via
Frank, Fred, and Grace. For example, Bob addresses the message to Alice encrypted using Alice’s
public key, and gives the message to Grace (via Frank and Fred), who puts it in Alice’s mailbox.
Alice checks all of the mailboxes through Frank and Fred to learn whether she has been exposed to
the virus. Since Alice sees Bob’s message in her mailbox, Alice might be able to infer who Bob is
based on the time they are nearby. Moreover, Grace needs to maintain all tokens (messages) of all
users, which requires storage.
Re-randomization of tokens. An alternative approach presented in PACT [15] aims to
prevent linkage attacks by users by re-randomizing tokens. Their proposed solution is based on the
DDH assumption, and works with the following changes compared to their baseline system:
• Alice generates a token in the form Ta = (g ri , g ri sA ), where sA is a key that Alice never shares,
and ri is a nonce used only for this token
• When Alice and Bob meet, Alice gives Ta to Bob
• When Bob is diagnosed positive, he chooses a random r0 . If Ta = (x, y), he submits the pair
0
0
Ta0 = (xr , y r ) to the server
• Alice can determine whether she is at risk by checking all of the tokens in the public list to
find one that satisfies y = xsA
While generating tokens is almost free in our Epione, PACT with token re-randomization requires
two group elements for each token’s generation. Moreover, as mentioned by the authors, the privacy
benefit inherently relies on each user re-using the same secret key (sA in this case), and they cannot
force a malicious user to comply. Using a different sA for different encounters allows Alice to
determine which encounter caused her exposure to the disease. In contrast, this malicious action
does not happen in our Epione.

2.2

Secure Computation and Private Set Intersection

Private set intersection (PSI) refers to a cryptographic protocol that allows two parties holding
private datasets to compute the intersection of these sets without either party learning any addi5

PrivateKit claims that in V3 they will introduce strong privacy protections, but as of writing this paper the
protocol to do so has not been announced.

7

tional information about the other’s dataset. PSI has been motivated by many privacy-sensitive
real-world applications. Consequently, there is a long list of publications on efficient secure PSI
computation [17, 30, 37, 38, 40, 41]. However, PSI only allows the computation of the intersection
itself. In many scenarios it is preferable to compute some function of the intersection rather than
reveal the elements in the intersection, such as whether intersection size is more than a given threshold f , as in contact tracing. Limited work has focused on this so-called f -PSI problem. Further,
most prior works assume sets of comparable size that can be communicated in their entirety to the
other party. In this section we focus on protocols [16, 30, 32, 41–43] that support f -PSI as well as
PSI-CA.
GC-based f -PSI.
Huang, Katz, and Evans [30] presented techniques for using the generic
garbled-circuit approach for f -PSI, which is based on their efficient sort-compare-shuffle circuit
construction. Later Pinkas et al [42, 43] improved a circuit-PSI using several hashing techniques.
The main bottleneck in the existing circuit-based protocols is the number of string comparisons
and computing the statistics (e.g, count) of the associated values that are done inside a generic
circuit-based secure two-party computation, which is communication-expensive.
HE-based f -PSI. Similar to GC-based f -PSI, the protocol of [16] uses HE-based PSI to return
additive secret share of the common items, which can be forwarded as input to a secondary generic
circuit-based protocol. While their protocol has the communication complexity logorithmic in the
larger set size, it requires at least two more interactive rounds and a certain amount of cost to
implement the second MPC protocol. Therefore, the current Diffie-Hellman Homomorphic encryption approach of [32] is still preferable in many real-world applications6 , due to their reasonable
communication complexity of f -PSI protocols. However, the protocol of [32] has communication
complexity linear in set size, which is still communication-expensive in client-server settings.

3

Problem Statement and Security Goal

Here we define the problem of contact tracing that we intend to solve, and our security goals for
Epione.

3.1

Problem Definition

We define the problem of contact tracing based on token exchange as follows. Various clients
communicate with each other and with a contact tracing service. The service is provided by one or
more servers. The overall system consists of the following procedures:
• Generate(κ) → t: Client uses the Generate function to generate contact tokens, t, to be
exchanged with other users. The function takes a security parameter κ as input.
• Exchange(ta ) → tb : The client (client a) uses the Exchange function to exchange tokens with
another user (client b). The client’s token ta is sent to the other user, and the client receives
tb from the other user. The client (client a) stores tb in the “received tokens list”. Similarly,
the other user (client b) stores ta in their “received tokens list”.
• Query(TR , S) → a: With a set TR of received tokens from Exchange, the client uses the Query
function to query the server S and get answer a indicating how many of their tokens came
from users diagnosed positive for the disease.
6

https://security.googleblog.com/2019/06/helping-organizations-do-more-without-collecting-more-data.
html

8

3.2

Security Definition and Goal

We consider a set of parties who have agreed upon a single function f to compute (such as contact
tracing) and have also consented to give f ’s final result to some particular party. At the end of
the computation, nothing is revealed by the computational process except the final output. In the
real-world execution, the parties often execute the protocol in the presence of an adversary A who
corrupts a subset of the parties. In the ideal execution, the parties interact with a trusted party
that evaluates the function f in the presence of a simulator Sim that corrupts the same subset of
parties. There are two classical security models.
• Colluding model: This is modeled by considering a single monolithic adversary that captures
the possibility of collusion between the dishonest parties. The protocol is secure if the joint
distribution of those views can be simulated.
• Non-colluding model: This is modeled by considering independent adversaries, each captures
the view of each independent dishonest party. The protocol is secure if the individual distribution of each view can be simulated.
There are also two adversarial models.
• Semi-honest model (or honest-but-curious): The adversary is assumed to follow the protocol,
but attempts to obtain extra information from the execution transcript.
• Malicious model: The adversary may follow any arbitrary polynomial-time strategy to deviate
from the protocol, such as supplying inconsistent inputs, or executing different computation.
For simplicity, we assume there is an authenticated secure channel between each pair of clients,
and client-server pair (e.g., with TLS). In this work, we consider a model with non-colluding servers.
We formally present the security definition considered in this work, which follows the definition
of [35, 39].
Real-world execution. The real-world execution of protocol Π takes place between users
(P1 , . . . , Pn ), servers (Pn+1 , . . . , PN ) and adversaries (A1 , . . . , Am ), where m < N . Let H ⊆ [n]
denote the honest parties, I ⊆ [n] denote the set of corrupted and non-colluding parties and C ∈ [n]
denote the set of corrupted and colluding parties.
At the beginning of the execution, each user Pi∈[n] receives its input xi , an auxiliary input zi
and random tape ri , while each server Pi∈[n+1,N ] receives only an auxiliary input zi and random
tape ri . Each adversary Ai∈[m−1] receives an index i ∈ I that indicates the party it corrupts, while
adversary Am receives C indicating the set of parties it corrupts.
For all i ∈ H, let OUTi denote the output of honest party Pi and, let OUT0i denote the view of
corrupted party Pi for i ∈ I ∪ C during the execution of Π. The ith partial output of a real-world
execution of Π between parties (P1 , . . . , PN ) in the presence of adversaries A = (A1 , . . . , Am ) is
defined as
def

REALiΠ,A,I,C,zi ,ri (k, xi ) = {OUTj | j ∈ H} ∪ OUT0i
Ideal-world execution. In the ideal-world execution, all the parties interact with a trusted
party that evaluates a function f . Similar to the real-world execution, the ideal execution begins
with each user Pi∈[n] receiving its input xi , an auxiliary input zi , and random tape ri . Each server
Pi∈[n+1,N ] receives only an auxiliary input zi and random tape ri .
Each user Pi∈[n] sends x0i to the trusted party, where x0i is equal to xi if this user is semi-honest,
and is an arbitrary value if he is malicious. If any semi-honest server sends an abort message (⊥),
the trusted party returns ⊥ to all users. The trusted party then returns f (x01 , . . . , x0n ) to all the
parties.
9

For all i ∈ H, let OUTi denote the output returned to the honest party Pi by the trusted party,
and let OUT0i denote some value output by corrupted party Pi for i ∈ I ∪C. The ith partial output of
a ideal-world execution of Π between parties (P1 , . . . , PN ) in the presence of independent simulators
S = (S1 , . . . , Sm ) is defined as
def

IDEALiΠ,S,I,C,zi ,ri (k, xi ) = {OUTj | j ∈ H} ∪ OUT0i
Definition 1. (Security) Suppose f is a deterministic-time n-party functionality, and Π is the
protocol. Let xi be the parties’ respective private inputs to the protocol. Let I ∈ [N ] denote the
set of corrupted and non-colluding parties and C ∈ [N ] denote the set of corrupted and colluding
parties. We say that protocol Π(I, C) securely computes deterministic functionality f with abort in
the presence of adversaries A = (A1 , . . . , Am ) if there exist probabilistic polynomial-time simulators
Simi∈m for m < n such that for all x̄, z̄, r̄ ← {0, 1}? , and for all i ∈ [m],
i
{REALiΠ,A,I,C,z̄,r̄ (k, x̄)={IDEAL
e
Π,Sim,I,C,z̄,r̄ (k, x̄)}

Where S = (S1 , . . . , Sm ) and S = Simi (Ai )
Desirable Security/Privacy Properties.
A desirable contract tracing system would make
an honest user’s actions perfectly indistinguishable from actions of all other honest users as well as
servers. Thus, an ideal security system property would guarantee that executing the system in the
real model is equivalent to executing this system in an ideal model with a trusted party as presented
in the above definition 1.
Based on this definition of security, we consider the following attacks in the context of contact
tracing.
• Linkage attacks: A linkage attack attempts to match anonymized records with non-anonymized
records in a different dataset [25]. For contract tracing there are two types of linkage attacks:
by users and by the server.
The adversarial server aims to link users and re-identify their contact history by observing
tokens it receives. For example, if the server is able to deduce that Alice and Bob had come
in contact, regardless of frequency or duration, that is a linkage attack, referred to in the
Introduction as a social graph exposure.
Even without connecting two users, if the server operator is able to track a single user over
time, say by using Bluetooth beacons, that would also constitute a linkage attack.
On the user side, most users are aware of who they are in contact with for at least some
amount of time, thus linkage to tokens is not useful. Instead, we consider any other use of the
anonymized information, such as identifying other users they do not already know, finding
out about other users’ contacts, the infection status of other users, or the source of their own
exposure to the disease. Note that if a user was only near one individual during the infection
period, and if she gets an alert of having been in contact with a confirmed case, then she knows
who it was. This case cannot be avoided while providing the functionality of the application.
• False-positive claim: A malicious user may claim to have been diagnosed with the disease
when in reality, they are not. This would spread false information and panic other users, and
reduce trust in the system.
As we will demonstrate in the following sections, Epione provably provides all of the functions
of contact tracing while protecting against the attacks above.
10

4

Preliminaries

This section introduces the notations and cryptographic primitives used in later sections.

4.1

Notation

In this work, the computational and statistical security parameters are denoted by κ, λ, respectively.
For n ∈ N, we write [n] to denote the set of integers {1, . . . , n}. We use ‘||’ to denote string
concatenation. We use party to refer to either a server or a user in the system.

4.2
4.2.1

Cryptographic building blocks
Decisional Diffie–Hellman

Definition 2. [22] Let G(κ) be a group family parameterized by security parameter λ. For every
probabilistic adversary A that runs in polynomial time in λ, we define the advantage of A to be:
|Pr[A(g, g a , g b , g ab ) = 1] − Pr[A(g, g a , g b , g c ) = 1]|
Where the probability is over a random choice G from G(λ), random generator g of G, random
a, b, c ∈ [|G|] and the randomness of A. We say that the Decisional DiffieâĂŞHellman assumption
holds for G if for every such A, there exists a negligible function  such that the advantage of A is
bounded by (λ).

4.3

Pseudorandom Number Generator

Definition 3. [36] A pseudorandom number generator (PRG) is a function that, once initialized
with some random value (called the seed), outputs a sequence that appears random, in the sense that
an observer who does not know the value of the seed cannot distinguish the output from that of a
(true) random bit generator.

4.4

Discrete Log Zero-Knowledge Proof

Discrete Log Zero-Knowledge Proof (DLZK) is a cryptographic protocol, which allows Alice to
convince Bob that she has k for known y = g k in the cyclic group G = hgi without revealing
the value of k. One of the simplest and frequently used proofs of knowledge for discrete log is
Schnorr protocol, which incurs communication of 2 group elements, and computation of 3 modular
exponentiations in a cyclic group.

4.5

Garbled Circuits

Garbled Circuit (GC) is currently the most common generic technique for two-party secure computation (2PC), which was first introduced by Yao [47] and Goldreich et al. [29]. The ideal functionality
of GC is to take each party’s inputs, x and y respectively, and compute some function f on them.
We denote this garbled circuit by z ← GC(x, y, f ). GC has seen dramatic improvements in recent
years. Modern GC protocols [45, 48] evaluate two million AND gates per second on a 1Gbps LAN.
In our protocols, we use the “subtraction" and “less than" circuits.

11

4.6

Private Information Retrieval

Private Information Retrieval (PIR) allows a client to query information from one or multiple
servers in a such way that the servers do not know which information the client requested. Recent
PIR [7, 9, 14, 23, 27] reduces communication cost to logarithmic in the database size.
In PIR, the server(s) hold a database DB of N strings, and the client wishes to read item DB[i]
without revealing i.
4.6.1

1-Server PIR

In general, 1-server PIR construction [8, 9, 24] consists of the following algorithms:
• PIR.Gen(κ) → (pk, sk): takes a security parameter and generates an additively homomorphic
public and secret key pair (pk, sk).
• PIR.Query(pk, i) → k: a randomized algorithm that takes index i ∈ [N ] and public√key pk as
d
input and outputs a (short and unexpanded) key k of size O(log(N )) bits or O(dd pN e) bits,
where d is typically 2 or 3, and p is typically 2048 or 4096.
• PIR.Expand(pk, k) → K: takes a short key k and public key pk as input and outputs a long
expanded key K ∈ {0, 1}N .
• PIR.Answer(pk, K, DB) → d: takes an expanded key K, public key pk, and a database DB as
input, returns an answer d encrypted under pk.
• PIR.Extract(sk, d) → DB[i]: takes a secret key sk and answer d as input, returns DB[i].
With these algorithms defined, PIR generally proceeds as follows.
1. The client generates a public and secret key pair with PIR.Gen. This is generally done once
at setup and then reused.
2. The client uses PIR.Query to generate a query key k for the desired item, and sends both k
and pk to the server.
3. The server uses PIR.Expand to expand k to the much larger K, and then uses PIR.Answer to
generate the answer d, which is transmitted to the client.
4. The client then reconstructs DB[i] using PIR.Extract.
PIR is generally implemented such that if (k) ← PIR.Query(i), then K ← PIR.Expand(k) is
the encryption of a binary string of zero everywhere except for a 1 in the ith bit under public
key pk. PIR.Answer then consists of iterating over all of the items in the database and computing
def LN
d=
j=1 K[j] · DB[j]. Thus, d is the encryption of DB[i] under the public key pk.
Most single-server
PIR constructions [8, 9, 24, 28] have communication cost of either O(log(N ))
√
d
N
bits or O(dd p e) bits, where d is typically 2 or 3, and p is typically 2048 or 4096. Depending on
the implementation chosen, the latter may actually be faster for the application due to the size of
d, p, and constant values. Single-server PIR requires computation of O(N ) additive homomorphic
operations on the server. There is also a tradeoff between communication and computation costs,
as discussed in [8], which must be evaluated for optimal performance in the application. We provide
more analysis of performance in Section 7.
12

Parameters: Two parties: server and client; and upper bound on the input set size.
Functionality:
• Wait for input set X from the server
• Wait for input set Y from the client
• Give server nothing
• Give client |X ∩ Y |
Figure 2: The PSI-CA Functionality.
4.6.2

2-Server PIR

The O(N ) homomorphic operations required for single server PIR can be very expensive for large
databases and serving large userbases. In order to reduce the computational overhead on the server’s
side, some PIR schemes use multiple servers with the assumption that not all of them collude [12,13].
So-called 2-server PIR replaces homomorphic encryption with symmetric encryption (typically
AES) and bit operations, making the following changes to the single server scheme:
1. PIR.Query uses a PRF (such as AES) to produce two query keys, k1 , k2 , each of size O(log(N )),
which the client sends to server 1 and server 2 respectively.
2. Each server then expands their key by Ki ← PIR.Expand(ki ). An important property of the
keys is that K = K1 ⊕ K2 is zero everywhere except for position i which is 1. Since each
server only has one of the two Ki values, and assuming the two servers do not collude, they
cannot determine the value of K or i.
L
def
3. Both servers then locally compute the inner product di = Ki · DB = N
j=1 Ki [j] · DB[j], and
then send the result to the client.
4. The client can then reconstruct d = d1 ⊕d2 = (K1 ·DB)⊕(K2 ·DB) = (K1 ⊕K2 )·DB = DB[i]
In 2-server PIR [12,13], the communication cost is O(log(N )) bits and the computation requires
O(N ) symmetric key operations which is much faster than additive homomorphic operations.
4.6.3

Keyword PIR

Chor, et al. [19] define a variant of PIR called keyword PIR, in which the client has an item x, the
server has a set S, and the client learns whether x ∈ S. This variant of PIR has been used for the
password checkup problem [8], where a client aims to check whether their password is contained in
breached data, without revealing the password itself. One implementation of keyword PIR is based
on PIR with Cuckoo hashing [28], which requires approximately three times the costs of regular
PIR. Another solution [8] relies on bucketing which we describe more detail in Section 7.2. In this
paper, we are interested in Keyword PIR based on both 1-server PIR [8,9] and 2-server PIR [12,13].

4.7

Private Set Intersection Cardinality

Private set intersection cardinality (PSI-CA) is a two-party protocol that allows one party to learn
the intersection size of their private sets without revealing any additional information [30,32,41–43].
The PSI-CA functionality is presented in Figure 2.

13

Our Epione System

5

We now present the Epione system in detail, the construction of which closely follows the high-level
overview presented in Section 1.2. Recall that Epione aims to alert any users who have, within the
infection window (e.g. 14 days for COVID-19), come into contact with another user who has been
diagnosed positive with an infectious disease.

5.1

System Phases

Epione’s design combines several different cryptographic primitives. In this section we will describe
how Epione uses these primitives to obtain the goals described in Section 3. Please refer to Section 4.2
and Section 6 for more details on the cryptographic gadgets used here. The Epione system consists
of four phases as follows.
5.1.1

Agreement and Setup Phase

The first phase requires all parties (including users, the healthcare provider, and the Epione server)
to agree to perform the objective function (e.g. contact tracing) over their joint data, and security
parameters for MPC. The parties should also agree to release the computed result to each user.
This agreement might happen before the user installs Epione on their phone.
The Epione server takes a security parameter λ as input, and outputs a public-private key
pair (pk, sk), and shares the public key with every user. Each user/client ui generates a random
PRG seed si which it uses to generate contact tokens in the next phase. As long as the server’s
configuration does not change, this phase does not need to be re-run. Whenever a new user registers
with Epione, they only needs to generate their own PRG seed, and the server shares the public key
with the new user.
5.1.2

Token Generation

Similar to most recent contract tracing systems [2, 3, 15, 18], we use Bluetooth to exchange contact
tokens whenever two users are in close proximity. The Generate(su , di , j) → tu,i,j function is used
to generate tokens of κ bits each to be sent by user u on day i and timeslot j. The precise details of
the token generation are left as an implementation detail, so long as the following criteria are met:
• Tokens are indistinguishable from random by anyone not in possession of the user’s seed su .
In other words, the Generate function acts as a PRG as defined in Section 4.3.
• Tokens can be deterministically generated for the given day di , and time slot j using a secret
seed, su , such that when a user gives their seed to the Epione server, the server is able to
regenerate the tokens sent by the user.
• All users and the Epione server agree on the method used to generate tokens, the time intervals,
and day numbering.
5.1.3

Contact

As illustrated in Figure 3 part I, when two users, say Alice and Bob, enter within close proximity, Epione detects this condition with a short range network such as Bluetooth, and then uses that network
to exchange tokens using the function Exchange. Alice generates token ta ← Generate(sa , di , j),

14

Figure 3: Epione System Design without Agreement and Setup Phase. (I) Tokens are exchanged
when two users are in close proximity. (II) When a user is diagnosed with the disease, the user
encrypts their PRG seed using the public key of the Epione server, and gives the encrypted value
to the healthcare provider, who then transmits it to the Epione server. Using its private key, the
Epione server decrypts the received ciphertexts and obtains the PRG seeds of diagnosed users. The
Epione server generates the sent tokens of users diagnosed positive using the PRG. (III) Each user
invokes a secure matching algorithm with the Epione server, where the user’s input is their received
tokens and the server’s input is the database of tokens from users diagnosed with the disease. The
user learns only whether (or how many) tokens there are in common between the two sets, while
the Epione server learns nothing.
where sa is Alice’s private seed, di is the current day, and j is the current time slot. Similarly Bob
generates token tb ← Generate(sb , di , j). Alice sends ta to Bob, and Bob send tb to Alice.
Alice then adds the token received from Bob, tb , to her set of received tokens, TR,A , and Bob
adds ta to TR,B . We use TS,A to represent the set of tokens Alice has sent to other users (which
includes ta ), though Alice does not actually store such a list since it can be regenerated at any
time from her private seed. Alice and Bob discard received tokens that are older than the infection
window (e.g. 14 days for COVID-19).
5.1.4

Positive Diagnosis and Token Collection

When a user (ui in general) is diagnosed with the disease, the user encrypts their PRG seed using the
public key of the Epione server and gives that to the healthcare provider (provided the user consents
to this, of course). The healthcare provider gathers the seeds from several users diagnosed positive,
shuffles them, and transmits the set of seeds over a secure channel to the Epione server. Using its

15

private key, the Epione server decrypts the received values to obtain the secret PRG seeds. The
Epione server can then generate all of the tokens for the infection window sent by users diagnosed
b S . The token collection process is shown in part II of Figure 3.
positive with the disease, T
Two servers are used at this phase to prevent any one server from knowing both the diagnosis
status of a user and their sent tokens. This is useful in the case that the Epione server is operated
by an untrusted party, such as a commercial provider, that should not have access to sensitive
information such as a user’s diagnosis. If such protection is not needed, for example if the Epione
server is operated by a health authority that already has access to the infection status of users and
can be trusted not to try to discern a user’s diagnosis status from the token collection process, then
both services can be provided by the same server.
Alternatively, the healthcare provider could provide a token to the user that the user then
provides the Epione server when they upload their tokens to prove that they have a legitimate
positive diagnosis. This would allow the Epione server to verify that the user’s claim is legitimate,
but does not protect the user from the server linking them to a positive diagnosis.
5.1.5

Query

Recall from the contact phase that each user ui keeps a list of tokens received from other users they
have been in contact with within the infection window, TR,ui . The query phase aims to securely
compare the user’s received contact tokens TR,ui with the Epione server’s set of tokens sent by
b S . If there are any tokens in common, then user ui has
users diagnosed positive with the disease, T
come into contact with an individual diagnosed positive within the infection window, and should
be notified that they are at risk of having contracted the disease. This process is illustrated in part
III of Figure 3.
The comparison of tokens is done by calling the Query function, which we implement using PSICA. We describe PSI-CA in detail in Section 6. Note that revealing the intersection size is acceptable
in the contact tracing application we consider, however, it is possible hide the intersection size as
we discuss in Section 6.3.1.

5.2

Security Discussion

In this section we consider the security of Epione, starting from a general theorem and then considering specific attacks and protections as defined in Section 3.1.
5.2.1

Security Theorem

The security of Epione follows in a straightforward way from the security of its building blocks (e.g.
PSI-CA) and the PRG scheme. Thus, we omit the proof of the following theorem.
Theorem 1. The Epione construction securely implements the contact tracing functionality defined
in Section 3.1 in the semi-honest setting, given the PSI-CA primitive described in Figure 2 and a
secure pseudo-random number generator (PRG) as defined in Section 4.3.
5.2.2

Defense against linkage attacks

As defined in Section 3.2, a linkage attack is any attempt to link an anonymized record with any
identifying information. Epione successfully defends against all important linkage attacks.

16

Linkage attacks by server.
The Epione server has only the tokens sent by users who have
been diagnosed with the disease. It cannot identify which users have been diagnosed with the
disease without colluding with the healthcare provider (the latter is assumed to already know such
information, and is responsible for verifying that the user’s diagnosis is legitimate). Similarly, the
healthcare provider does not have access to even randomized contact tokens without colluding with
the Epione server.
Even if the Epione server is able to link a user to specific tokens or seeds in its database, the
server does not gain any further information. This limits the amount of exposure in the event of
collusion or a breach of the database.
By using PSI-CA, Epione prevents any kind of social graph exposure. The Epione server has only
a set of randomized sent contact tokens, and does not know which users have received those tokens.
With PSI-CA, users query for the number of tokens they have in common between the Epione server
set and their own received tokens set, without the server gaining any knowledge of their received
tokens.
Linkage attacks by users.
Because users only learn the number of contact tokens they have
received from users since diagnosed with the disease and not the tokens themselves, semi-honest
users cannot link their exposure to the disease to any particular user.
User tracking and identification.
Because tokens appear random, users cannot be tracked
using Bluetooth beacons, whether by other users or the Epione server. It’s also impossible to identify
a user based solely on a token received from that user without extra information.
5.2.3

Malicious User Queries

If a malicious user, Mallory, can deviate from the protocol by submitting arbitrary queries to the
Epione server, it is possible for her to craft queries in such a way as to perform a search, and find
which token(s) in her set are also in the server’s set. If Mallory also records the time, place, and
who she was with for the tokens she has received, she can later use this information to glean which
user(s) have been diagnosed with the disease.
There are several ways to mitigate the threat of arbitrary queries. First, we could require that
users submit a cryptographic hash (e.g. by computing a Merkle root7 ) of their local token list
periodically to the Epione server, say once every day. When Mallory queries the server, her query
includes the cryptographic hash of the set used in the query. The hash ensures that the entire set of
tokens obtained by Mallory at a particular point in time is used in the query, and not some chosen
subset. Because the query items are encrypted8 , the Epione server cannot directly verify that the
hash is correct. Instead, Mallory must also provide a zero knowledge proof that the query items
correspond to the hash submitted, such as the SNARK method proposed in [11]. Using this, the
Epione server verifies that the query matches the hash.
Periodic commitment to cryptographic hashes of a user’s token set mitigates the threat of false
claims as well. Users cannot retroactively add tokens to their local lists without being detected by
the Epione server.
7
The following details ensure that the committed hash value is randomized and defeats any dictionary attacks by
the server: We first permute the local tokens randomly, add a dummy random value in the list, and then compute a
Merkle tree. The Merkle root is committed as the cryptographic hash of the list. The adversary does not know the
dummy value or the permuted order and hence is unable to forge a Merkle proof.
8
Either under DDH for token transformations, or homomorphic encryption for 1-server PIR, or AES for 2 server
PIR, depending on at which step the check is done

17

Note that the contact tracing functionality itself reveals whether there is a match within Mallory’s full set of tokens. This is not a linkage attack, but a direct implication of the desired functionality of the application. Mallory, or any benign user, may have had contact with only one other user
during the infection window, in which case they can deduce the infection status of the other user
when they query the Epione server for intersection cardinality. This is fundamentally unavoidable
as it is part of the benign functionality of the application.
A second complementary mitigation is rate limiting users to a few queries per day, and requiring
a minimum number of tokens per query. By itself that would slow Mallory down, but not prevent
the attack completely. With enough queries, Mallory will eventually deduce with high probability
the source of her exposure.
Lastly, using Digital Rights Management (DRM) protocols such as Android SafetyNet and
Apple DeviceCheck will make it much harder for Mallory to submit such queries and is highly
recommended. When combined with rate limits and a minimum token set size, these protocols
make crafting queries to find the exposure source impractical, though again not impossible.

6

Cryptographic Gadgets

This section provides more detail on the cryptographic tools we use to implement Epione, with a
specific emphasis on our PSI-CA design and PIR, as well as extensions to those tools.

6.1

PSI cardinality (PSI-CA) for asymmetric set sizes

In this section, we present our PSI-CA construction, the functionality of which is described in
Figure 2 and used as a core component of Epione.
6.1.1

Our technique

We start with a private set intersection (PSI) in the semi-honest setting, where two parties want to
learn the intersection of their private set, and nothing else. The earliest protocols for PSI were based
on the Diffie-Hellman (DH) assumption in cyclic groups. Currently, DH-based PSI protocols [31]
are still preferable in many real-world applications due to their low communication cost.
DH-based PSI Assume that the server has input X = {x1 , . . . , xN } and client has input Y =
{y1 , . . . , yn }. Given a random oracle H : {0, 1}∗ → G, and a cyclic group G in which the DDH
assumption holds, the basic DH-based PSI protocol is shown in Figure 4.
Intuitively, the client sends {H(yi )r }yi ∈Y for some random, secret exponent r. The server raises
each of these values to the k power, and the client can then raise these results to the 1/r power to
obtain {H(yi )k }yi ∈Y as desired9 .
From DH-based PSI to PSI cardinality (PSI-CA). If the client uses the same r for every
item, it is possible to extend the basic PSI algorithm to compute functions such as intersection set
size (cardinality) without revealing the intersection items by having the server shuffle the items. This
observation was suggested by [31] and recently was incorporated into private intersection sum [32],
which allows two parties to compute the sum of payloads associated with the intersection set of two
private datasets, without revealing any additional information. Clearly, PSI-CA is a special case of
private intersection sum, where the payload is constant and equal to 1.
9

Alternatively, the client can raise each H(xi )k to the r power and compare to the H(yi )kr values. However, the
variant where the client raises H(yi )kr to the 1/r power is compatible with further optimizations.

18

Parameters: cyclic group G of order p; random oracle H.
Inputs: Server has input X = {x1 , . . . , xN }; client has input Y = {y1 , . . . , yn }.
Protocol:
1. Client chooses r ← Zp , for each yi ∈ Y sends mi = H(yi )r to the server.
2. Server chooses k ← Zp and for each i ∈ [n], sends m0i = mki to the receiver in a randomly permuted order .
3. For each i ∈ [n], the client computes vi = (m0i )1/r .
4. For each xi ∈ X, the server computes ui = H(xi )k and sends U = {ui | xi ∈ X}
(randomly permuted) to the client.
5. [PSI -CA output] The client outputs | {i ∈ [n] | vi ∈ U } | .
Figure 4: DH-based PSI protocol and extension to PSI-CA with changes highlighted .
Figure 4 also shows the extension to PSI-CA with the highlighted changes. The key idea to
transform PSI into PSI-CA is that instead of sending m0i in step 2 of Figure 4 in order, the server
shuffles the set in a randomly permuted order. Shuffling means the client can count how many
items are in the intersection (PSI-CA) by checking whether vi ∈ U , but learns nothing about which
specific item was in common (e.g. which vi corresponds to the item yj ). Thus, the intersection set
is not revealed.
From PSI-CA to PSI-CA for asymmetric sets.
In many applications, including contact
tracing, the two parties (client and server) have sets of extremely different sizes. A typical client
has less than 500 new tokens per day, while the server may have millions of tokens in its input set.
In PSI, most work is optimized for the case where two parties have sets of similar size, and as such
their communication and computation costs scale with the size of the larger set. For contact tracing,
it is crucial that the client’s effort (especially communication cost) be sub-linear in the server’s set
size. More practically, we aim for communication of at most a few megabytes in a setting where
the client is a mobile device.
We observe that the last two steps of Figure 4 are similar to the function performed by keyword
PIR, which is communication-efficient in the conventional client-server setting. Keyword PIR allows
clients to check whether their item is contained in a set held by a server, without revealing the
actual item to the server. Therefore, step 4 and 5 of Figure 4 can be replaced by keyword PIR.
Concretely, after step 3, the client has an input set V = {v1 , . . . , vn } and the server has input set
U = {u1 , . . . , uN }. The client sends a multi-query keyword PIR request with all of the elements in
V to be queried against U on the server. From the PIR response, the client can count the number
of vi ∈ U to find the set size, without revealing to the server the actual values in V and without
the client learning any more information about U .
6.1.2

Protocol

Our semi-honest PSI-CA protocol is presented in Figure 5, following closely the description in the
previous subsection. The client runs keyword PIR searches for each vi∈[n] in a set U held by the
19

server. For communication and computation efficiency, the values of both ui and vi can be truncated,
and the protocol will still be correct as long as there are no spurious collisions. We can limit the
probability of such a collision to 2−λ by truncating to length λ + log(N ) bits. In Figure 5, we use
a truncation function τ (z) which takes z as input and returns the most significant λ + log(N ) bits
of z.
Parameters: cyclic group G of order p; random oracle H, Multi-query Keyword PIR primitive
(Section 4.6), a truncate function τ (z) takes z as input and returns first λ + log(N ) bits of z.
Inputs: Server 1 has input X = {x1 , . . . , xN }; client has input Y = {y1 , . . . , yn };
Server 2 has no input
Protocol:
1. Server 1 chooses k ← Zp , and computes dataset U = {τ H(xi )k
Server 1 sends U to Server 2



| i ∈ [N ]}.

2. Client chooses r ← Zp , and sends mi = H(yi )r for each yi ∈ Y to the server 1 .
3. Server 1 chooses a random permutation π : [n] → [n]. For each i ∈ [n], sends m0i =
(mπ(i) )k to the client.

4. For each i ∈ [n], the client computes vi = τ (m0i )1/r .
5. Parties invoke Multi-query Keyword-PIR with 2 servers :
• Server 1 acts as Keyword-PIR server 1 with dataset U
• Server 2 acts as Keyword-PIR server 2 with dataset U
• Client acts as Keyword-PIR client with V = {vi | i ∈ [n]}
• Client learns whether vi ∈ U, ∀i ∈ [n]
6. Client outputs |V ∩ U |
Figure 5: Our semi-honest PSI-CA protocol for asymmetric sets, and extension to 2-server PIR
based PSI-CA with changes highlighted

Theorem 2. The PSI-CA construction of Figure 5 securely implements the PSI-CA functionality defined in Figure 2 in semi-honest setting, given the Multi-query Keyword PIR described in
Section 4.6.
Sketch of proof:
The security of the PSI-CA protocol follows from the fact that {H(z1 )k , . . . , H(zn )k } are indistinguishable from random, for distinct zi , if H is a random oracle and the DDH assumption holds
in G. To see why, consider a simulator that receives a DDH challenge g k , g a1 , . . . , g an , g c1 , . . . , g cn
where each ci is either random or ci = ai k. The simulator programs the random oracle so that
H(zi ) = g ai and then simulates the outputs as {g c1 , . . . , g cn }. It is easy to see that these messages
are distributed as specified by F if the ci ’s are distributed as ai k, but are distributed uniformly
otherwise, with the difference being indistinguishable by the DDH assumption.
We consider two cases, corresponding to each party being corrupt.
20

• A corrupt server first sees {H(yi )r }yi ∈Y . By our observation above, these values are pseudorandom. A corrupt server also sees PIR transcripts. Because pseudorandomness guarantees
of PIR, the client’s message to the server can be simulated as a random message.
• A corrupt client sees {H(yπ(i) )rk = (H(yπ(i) )k )r }yπ(i) ∈Y and PIR response (as the extra PSI
message), along with its private randomness r and any random oracle queries/responses that
it made. Consider modifying this view, replacing each H(z)k term with an independently
random group element for each z ∈ X ∪ Y (each distinct, by definition). This change will be
indistinguishable, by the reasoning above. Now it is not necessary to know the identities of
xi ∈ X \Y as well as xi ∈ X ∪Y , as their corresponding H(xi )k values have been replaced with
random group elements that are independent of everything else, and the secret permutation
π hides the common items. In other words, this is a distribution that can be generated by the
simulator, with knowledge of only Y and |X ∩ Y |.

6.1.3

PSI-CA Cost

In our PSI-CA protocol, communication cost is O(n log(N )) while the client’s computation is O(n)
and the server’s computation is O(nN ). More specifically,
• The server and client must communicate (1) O(n) group elements, (2) O(n) homomorphically
encrypted selection vectors for Keyword-PIR. If Keyword-PIR uses O(log(N )) bits for each
vector10 , the total communication cost is O(n log(N )) bits. We provide more analysis of
performance in Section 7.
• The client’s computation cost consists of: (1) O(n) group elements, (2) O(n) homomorphic
encryptions and decryptions for encoding the Keyword-PIR queries and decoding the results.
• The server’s computation cost consists of: (1) O(n) group elements, (2) O(nN ) additive
homomorphic encryption operations for finding the answer to the Keyword-PIR query.
The two-server PIR model can be used to speed up the server side computation by avoiding
homomorphic encryption operations.

6.2

PSI-CA with 2-server PIR

Recall that the client and server invoke Keyword PIR in step 5 of Figure 5. To speed up the
computational overhead on the server side, we introduce a second, independently operated server.
The primary server sends the dataset U to the second server after it has been computed. By DDH,
the second server learns nothing about the item xi from ui .
The client sends PIR queries with keyword vi to both servers, and learns whether vi ∈ U and
nothing else. Neither PIR server learn anything about the client’s query as long as the two servers
do not collude.
With 2-server PIR, the computation cost of PIR contains only symmetric-key operations, using
approximately 2N PRF calls, and the communication cost of PIR is O(log(N )) bits. The highlights
in Figure 5 shows the changes in PSI-CA to go from single-server to 2-server PIR.
10

there is a tradeoff between communication and computation complexity in PIR/Keyword-PIR as discussed in [8].
Traditional PIR is O(log(N )) for query vectors, but some schemes trade slightly higher communication complexity
for reduced computational complexity.

21

6.3

PSI-CA Extensions

Here we discuss two extensions to our PSI-CA protocol to provide additional protections.
6.3.1

Potential approach from PSI-CA into threshold PSI-CA (t-PSI)

Revealing the intersection size is acceptable in the contact tracing application we consider. However,
it is possible that in other settings, knowing the size of the intersection is undesirable leakage.
Threshold PSI-CA is an extension of PSI where parties learn the intersection size (or even the
intersection items) if it is greater than a given threshold. In our t-PSI definition, the client learns
whether two input sets have any common items and nothing else (e.g. t = 0).
A simple solution is to pad both input sets with dummy elements. The two parties decide on a
PRG seed s which is used to generate common dummy elements. Each party randomly chooses a
number of dummy elements, n0 and N 0 for client and server respectively such that n0 > N 0 . This
can be done by performing the following steps:
1. Parties randomly choose n0 and N 0
2. Parties invoke a garbled circuit to check whether n0 > N 0
3. Repeat this process until the “if” condition is true
The client and server then use the agreed PRG and seed s to generate n0 and N 0 fake items,
respectively, and add them to their input sets. The resulting intersection set size over the original
and common dummy elements will be σ = |X ∩ Y | + N 0 . The client learns σ at the end of PSI-CA,
but does not know N 0 , and thus has limited knowledge of |X ∩ Y |.
The parties then invoke a garbled circuit to securely remove the term N 0 in σ and check whether
0
|X ∩ Y | > t.
 The circuit takes as input N from the server and σ from the client, computes
0
f = σ − N > t?, and returns the result to the client.
There remains an important concern in this approach: how to choose n0 and N 0 , so that σ
informationally hides the actual intersection size. Since the range of intersection size is from 0 to n,
the bound of information leakage is O(log(n)) bits. Therefore, it is sufficient to choose n0 and N 0 to
be O(2log(n) ), which is essentially O(n). However, it is not clear what the coefficient value behind
the big O needs to be to prevent leakage of the actual intersection size. For example, the client can
infer the lower bound of the intersection size by knowing that |X ∩ Y | = σ − N 0 > σ − n0 . Further
analysis needs to be done to prove if this method provides sufficient bits to prevent information
leakage.
6.3.2

Potential approach for extending to malicious client

In the context of contact tracing, a malicious client seeks to obtain information about the server’s
database (set X in this case). Thus, they attempt to compute mi = H(yi )r incorrectly, since in
step 3 of Figure 5 the server returns m0i = (mπ(i) )k and it may be possible to learn part or all of
the value of k. With that, the client can determine which values of vi map to which values of uj ,
and thus learn which items from its set exist on the server.
One solution to prevent this is to augment the protocol with a zero-knowledge proof [21,33] that
the mi ’s were computed correctly. This adds the following step to the protocol:
(2a) Client performs a zero-knowledge proof of knowledge of r such that ∀i ∈ [n] : mi = (yi )r . The
server aborts if the proof does not verify.
22

This modification is enough to guarantee security against a malicious client for the DH-based
PSI protocol.
Achieving a PSI-CA or t-PSI protocol resilient to a malicious client requires more work because
the construction of the client’s message involves more building blocks, namely keyword PIR and
garbled circuit. The solution is to use versions of these building blocks resilient to such one-side
malicious attacks. Moreover, to verify that the client uses the correct values for vi for step 5 of
Figure 5 in the keyword PIR query, we employ a consistent check such as MACs from the SPDZ
protocol [20]. We will explore more detail in this direction.

7

Implementation Choices and Performance Estimates

In this section we consider some important implementation decisions and estimate the performance
of Epione in order to show that the system is feasible in practice. While some performance optimizations are assumed in order to make the system realistic, we aim to be conservative with our estimates
in order to give a loose upper bound to what can be expected for a practical implementation of the
system.
The computation cost of our solution is dominated by the PSI-CA algorithm, which itself is
dominated by (1) token transforms (exponentiation) and (2) keyword PIR [8, 9]. We’ll first propose
the parameters of our estimation in the following subsection, then analyze the performance of PIR
in single-server operation, PIR in two-server operation, token transforms, and finally summarize the
overall system performance.

7.1

Parameters and token storage

Assuming that a contact token is generated every 15 minutes for approximately 20 hours a day,
then each user sends 80 distinct 128-bit tokens per day. If we assume that a user also receives
approximately the same number of tokens and the infectious period is 14 days for COVID-19, then
each client receives a total of n = 1120 over 14 days. If there are 5,000 new cases per day, the server
receives N = 1120 × 5000 = 5.6 × 106 new tokens per day.
In Epione, the server maintains a list of tokens from positive patients for the duration of the
infectious window. When a user is diagnosed positive for the disease, they give all of their sent
contact tokens for the infection window (or the seeds to generate them) to the server. Rather than
storing these by day they were exchanged, it’s both more efficient and improves privacy for the
server to store them by the day the server received the tokens. This way clients can query only for
new tokens that have arrived since they last checked, rather than querying against the entire set.
More concretely, imagine the client did a query yesterday with all of their received tokens, TR,C ,
b S , and found no tokens in common. Today the client
against the sent tokens on the server, set T
0
has the received tokens set TR,C + TR,C , where T0R,C is the set of tokens received since the last
bS + T
b 0 , where T
b 0 is the set of tokens received
query was performed. Similarly, the server has set T
S
S
b S cannot contain any tokens
by the server from users diagnosed positive since yesterday. The set T
b 0 can contain tokens from either TR,C or T0 . Therefore, the client only needs
in T0R,C , but set T
S
R,C
b 0 has any intersection with TR,C + T0 . Thus, if the server keeps the database by
to check if T
S
R,C
day received, clients query with their entire received token set (TR,C + T0R,C ) against the server set
b 0 ).
only for the most recent day (T
S

Client’s token storage.
Storing both sent and received tokens requires 35 KiB of storage on
the client (this can be reduced to 18 KiB if sent tokens are generated with a PRG and only the seed
23

needs to be stored).
Server’s token storage.
Assuming the server needs to keep 15 days of tokens in case clients
are offline, the total storage for tokens needed is 1.25 GiB.

7.2

Implementation optimization: Database shape

The bottleneck for scaling PSI-CA to serve a large dataset to a large number of users is PIR. In
order to scale up PIR, we propose using a bucket system similar to the password checkup design
in [8]. First, the database will be split into nshards shards (sometimes referred to as megabuckets).
Transformed tokens will be grouped into buckets, each bucket holding the same number of tokens,
with dummies added as needed. Rather than performing keyword PIR, normal PIR with a bucket
address is used. Since tokens are expected to have a uniform distribution (both before and after
transformation), tokens should be uniformly distributed across shards and buckets. As such, the
bucket addresses can simply be the first log2 (nshards nbuckets ) most significant bits of the transformed
token itself. Alternatively, a fast hash of the transformed token into the number of bits needed can
be used. Recall that each transformed token is truncated to 74 bits before being stored in the
database. We use the top bits of the token to be the database index and bucket address, and only
store the remaining bits.
For example, if there are 5.6 million tokens in the server’s set, the database can be sharded
into 8 sets each with approximately 700,000 tokens (again, assuming a uniform distribution of
tokens). If each shard holds 218 buckets, then each bucket will hold d 700,000
e = 3 transformed
218
tokens, with dummies added as necessary to pad buckets to the required length. The first three
most significant bits of the transformed token are used as the shard number, and the following 18
bits of the transformed token are then the bucket address. Since each transformed token is stored
as 74 − 3 − 18 = 53 bits, each bucket will be 20 bytes.
Security.
While the server does learn the first log2 (nshards ) bits of the tokens being queried
by the client, we consider that because the tokens (both before and after transformation) should
be uniformly distributed across the token space, and that the numbers of tokens being queried is
much larger than the number of shards (1120 vs 8 in the example above), in most cases the client
will be querying all of the shards, therefore the server learns very little. This can also be scaled
automatically by the server. If very few tokens are received on a given day, then the number of
shards can be decreased. If a much larger number of tokens is received on a particular day, then
the number of shards can be increased automatically.
The client learns the values of the other transformed tokens in the bucket and its size. Since the
tokens have been transformed and truncated, and the client cannot reverse the transformation, the
client doesn’t learn anything useful as a result.
7.2.1

Single Server PIR Performance

Using the parameters from the example above, let us estimate the performance of such a configuration. As described in Section 7.1, we assume the client has 1120 tokens that must be compared
against the set of new tokens received by the server since the last query, and that the client completed a query yesterday. If previous days need to be checked, each day will take approximately the
same time.

24

Based on the performance figures for multi-query PIR in [9, Figure 12]11 , with a database of
220 items of 288 bytes each, and a batch size of 256 queries, PIR.Query and PIR.Extract require 4.92
ms and 2.70 ms per query item on the client respectively. The communication cost of PIR.Query
is 96 KiB. The Server’s PIR.Expand and PIR.Answer take 0.12 s and 0.08 s respectively, amortized
across the batch, with a one-time preprocessing of the database of 4.26 s. The communication cost
of PIR.Answer is 384 KiB. Assuming all of the database parameters scale appropriately, we estimate
the performance of single-server PIR as applied to Epione as follows:
• Server
– Pre-processing. The server requires a one-time pre-processing data phase which takes
1.06 seconds per shard. The shards can likely be processed in parallel.
– PIR.Expand. 1120 × 0.12s ×
– PIR.Answer. 1120 × 0.08s ×

218
220
218
220

= 33.6 seconds
×

20
288

= 1.6 seconds

• Client
– PIR.Query. 1120 × 4.92ms ×

218
220

= 1.4 seconds

– Key Caching If the keys from previous days are cached (on either the server or client),
then the client only needs to query 80 new items every day, this produces a computation
18
time of 80 × 4.92ms × 2220 = 98 milliseconds.
– PIR.Extract. 1120 × 2.70 ×

20
288

= 210 milliseconds
18

log(2 )
• Communication. The client sends to the server a query for 1120 items, each of 96× log(2
20 ) =
86.4 KiB, for a total query size of 94.5 MiB. It then receives the same number of answers,
20
each of 384 × 288
= 26.7 KiB, for a total answer size of 29 MiB. The total communication cost
is approximately 124 MiB .

• Communication with caching. If server can cache the queries sent for the previous day,
then only 80 items need to be added to the query. The query size is thus reduced to 7 MiB,
and the total communication cost is reduced to 36 MiB.
7.2.2

2-Server PIR Performance

If 2 independently operated servers are available such that there will not be collusion between them,
then the 2-server PIR model may offer performance benefits. The best two-server PIR is currently
based on the distributed point function [12,13], in which PIR.Query and PIR.Expand require 2N AES
calls, where N is the size of the server dataset. We omit the cost of PIR.Answer and PIR.Extract in
this PIR construction since they contain only bitwise operations. Using hardware-accelerated AESNI as the underlying PRF, both PIR.Query and PIR.Expand take approximately 31.1 milliseconds
for a database of 5.6 million entries12 . If implemented using keyword PIR based on cuckoo hashing
(approximately three times the cost of regular PIR), this would require approximately 104 s for
3 × 1120 PIR.Query on the client without catching. Note that client can store their (short) keys
from PIR.Query of previous days, thus the client only needs to do 3 × 80 new PIR.Query per day,
which requires 7.42 s. We require another 104 seconds for PIR.Expand on the server.
11
PIR servers on H16 instances (16-core 3.6 GHz Intel Xeon E5-2667 and 112 GB RAM), and clients on F16s
instances (16-core, 2.4 GHz Intel Xeon E5-2673 and 32 GB RAM)
12
10 cycles per AES, thus 360 AES per microsecond using 3.6 Ghz machine

25

Similar to single-server PIR, this can be improved by sharding the database and using buckets.
If we use a similar configuration to the single-server model presented in the previous subsection
(8 database shards, each with 218 buckets containing 3 transformed tokens), then the time for
10
PIR.Expand becomes 1120 × 2 × 218 × 3.6×10
9 = 1.63 seconds on the server’s side. The time for
10
PIR.Query with and without caching is 80 × 2 × 218 × 3.6×10
9 = 0.11 seconds and 1.63 seconds,
respectively.
Since the communication cost of the short keys is small and we consider any single server
untrusted, we recommend caching the (short) keys on the client. Each key has 832 bits, which
requires 2 × (1120 − 80) × 832 (bits) = 210 KiB of storage.
Communication.
The client needs to query both servers with 1120 (short) keys, each of
κ log(N ) = 832 bits, transmitting 2 × 1120 × 832 (bits) = 227.5 KiB. The client then receives
1120 answers from both servers, each of size 3 × 53 bits (since each bucket contains 3 tokens),
receiving 2 × 1120 × 3 × 53 (bits) = 43 KiB. This produce a total network bandwidth of 288 KiB.
We consider caching of the query keys on the server impractical, as both servers would have to
independently maintain a set of caches per user. This could lead to consistency or security problems
for a relatively small gain in bandwidth. The client’s query would be reduced from 227.5 KiB to
16 KiB, a savings of 211.5 KiB. For the rest of the discussion here we will consider that caches in
2-server PIR are kept on the client only.

7.3

Token Transforms

The PSI-CA algorithm transforms tokens through exponentiation as a way of blinding tokens. As
a basis for estimation, we assume that a single exponentiation calculation using libsodium takes
approximately 54 microseconds13 .
If the server reuses the exponent k (step 1, Figure 5) across queries and users, then it can
precompute all of the values H(xi )k and store the results in a table. Thus the server only needs to
compute N = 5.6 × 106 exponentiations per day, which can be done offline and not during a query.
From our benchmarks, this takes approximately 5 minutes. For each user, the online portion of
the exponentiation computations takes approximately 60 milliseconds. This can be reduced to 4.3
milliseconds if values from previous days are cached.
Assuming the client caches previously transformed tokens, the client must compute 80 new
exponentiations in the preproceessing phase and another 80 exponentiations in the online phase,
which we estimate will take approximately 4.32 milliseconds for each phase.
In terms of security, reusing the value of k means that a client can obtain the transformed value
of a particular token by first asking for the transforms of a set of tokens that doesn’t include the
desired token, and then asking for the transforms of the same set with the addition of the desired
token, and finding the difference between the sets. A client could then use that to determine if
that particular token is in the database by inspecting the results of the PIR query. However, this
is indistinguishable from a client crafting arbitrary queries to the entire protocol as described in
Section 5.2. It is still not possible for a client to determine the value of k, nor does it assist a
malicious user to determine which token is the source of their infection any more efficiently than
already possible in the design of the system.
13

In [40, Table 2] it was found that 221 exponentiations took 1148.1 seconds in a single thread using the miracl
library. Since libsodium is approximately 10× faster, we estimate the time per exponentiation as 1148.1s/221 /10 =
54us. Experiments were done on a server with an Intel(R) Xeon(R) E5-2699 v3 2.30GHz CPU and 256 GB RAM

26

All values in ms
Token Transforms
PIR.Query
PIR.Expand
PIR.Answer
PIR.Extract
Total

1-Server
No Cache
Cache
Client Server Client Server
60
60
4
4
1,378
98
33,600
33,600
1,556
1,556
210
210
1,648 35,216
313 35,160

2-Server
No Cache
Cache
Client Server Client Server
60
60
4
4
1,631
117
1,631
1,631
neg
neg
neg
neg
1,692
1,692
121
1,635

Table 2: Estimated (online) running time for elements of PSI-CA across different implementation
options. The client’s running time does not include the waiting time for server’s response. All times
in milliseconds. “neg" indicates the cost of bitwise operations in the 2-server PIR construction [12,13]
All values in KiB
Token Transforms
Query
Answer
Total

1-Server
No Cache Cache
77
6
96,768
6,912
29,867 29,867
126,712 36,784

2-Server
No Cache Cache
77
6
228
228
43
43
348
277

Table 3: Network costs for PSI-CA implementation options. All numbers in KiB. Note that for
2-Server PIR all caches are kept on the client, as keeping caches across two servers is considered
impractical.
Communication. The client sends and receives 1120 group elements twice. Using Koblitz K-283
elliptic curves, each element is 283 bits, for a total of 2 × 1120 × 283 bits = 77.4 KiB.
If the client caches the transformed tokens from previous days, the client sends and receives
2 × 80 group elements which, for a total of 5.5 KiB.

7.4

Caching and Security

In several of the options discussed in this section, caching previous values has been presented. While
this can produce a savings in computation and communication, it does present a potential leakage of
information. Because randomized values are not regenerated, it becomes possible for the server (or
an observer at the right location) to determine which values are the same and which have changed.
As such, the server can deduce which of the transformed tokens were in yesterday’s set, which are
new, and which values have been removed. It still cannot deduce the value of the tokens themselves,
but this allows the server to guess at how many tokens have been exchanged on a particular day.
This could be more (or less) interactions with others, or longer (or shorter) interactions with the
same people, or a combination of the two.
Note that the server always knows the total number of tokens being queried, and thus can always
guess at changes from one day to the next, but this allows more precise estimation of token volume.
If this leakage is important, then dummies can be added to ensure that all days have the same
number of items queried, or a random number of dummies added to mask the true size of the query.
Or caching can be dropped entirely if this risk is considered too great. For this reason we present
both options.

27

7.5

Overall PSI-CA Performance Estimates

The performance estimates for the overall PSI-CA algorithm are shown in Table 2 for computation
and Table 3 for communication, each showing the effect of the implementation options discussed
in this section. The 2-server approach reduces both server computational load and produces a
large savings in network bandwidth, but requires an independent party and thus may increase
infrastructure costs.
We also believe that single-server PIR is feasible. If the query is done in the background without
the user waiting on a response, then the query can be done in the cloud as a lower-priority batch
processing job. Thus the approximately 35 seconds required to complete the query is a non-issue,
and server resources can be scaled up to meet the number of users required. This was an intentional
tradeoff for network efficiency. If the server does some caching of the query keys, then only 37 MiB
of network traffic is needed.
Alternatively, the number of database shards can be increased. This does reveal slightly more
information about the client’s tokens to the server, but this may be acceptable depending on the
number of tokens and performance requirements.
We believe that the Epione solution proposed is feasible in practice. The database parameters
can be tuned for different tradeoffs of network and computation usage. This will be studied further
at implementation to determine the optimal configuration.

Acknowledgments
We thank Min Suk Kang, Ilya Sergey, Jun Han, Xiaoyuan Liu, and Duong Hieu Phan for helpful
discussion. This material is in part based upon work supported by the National Science Foundation(NSF) under Grant No. TWC-1518899, DARPA under Grant No. N66001-15-C-4066, Center
for Long-Term Cybersecurity (CLTC), and IC3 industry partners. Any opinions, findings, and
conclusions or recommendations expressed in this material are those of the author(s) and do not
necessarily reflect the views of NSF, DARPA, CLTC or IC3.

References
[1] Apple and google partner on covid-19 contact tracing technology. https://www.apple.com/
newsroom/2020/04/apple-and-google-partner-on-covid-19-contact-tracing-technology/.
[2] Cen. https://github.com/Co-Epi/CEN.
[3] Covid-watch. https://www.covid-watch.org/.
[4] Dp-3t. https://github.com/DP-3T/documents.
[5] ’more
scary
than
coronavirus’:
South
korea’s
health
alerts
expose
private
lives.
https://www.theguardian.com/world/2020/mar/06/
more-scary-than-coronavirus-south-koreas-health-alerts-expose-private-lives.
[6] Tracetogether. https://www.tracetogether.gov.sg/.
[7] Carlos Aguilar-Melchor, Joris Barrier, Laurent Fousse, and Marc-Olivier Killijian. Xpir :
Private information retrieval for everyone. Proceedings on Privacy Enhancing Technologies,
2016(2):155 – 174, 2016.

28

[8] Asra Ali, Tancrède Lepoint, Sarvar Patel, Mariana Raykova, Phillipp Schoppmann, Karn Seth,
and Kevin Yeo. Communication–computation trade-offs in PIR. Cryptology ePrint Archive,
Report 2019/1483, 2019. https://eprint.iacr.org/2019/1483.
[9] Sebastian Angel, Hao Chen, Kim Laine, and Srinath T. V. Setty. PIR with compressed queries
and amortized query processing. In 2018 IEEE Symposium on Security and Privacy, pages
962–979. IEEE Computer Society Press, May 2018.
[10] Johannes Becker, David Li, and David Starobinski. Tracking anonymized bluetooth devices.
Proceedings on Privacy Enhancing Technologies, 2019:50–65, 07 2019.
[11] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive
zero knowledge for a von neumann architecture. In Kevin Fu and Jaeyeon Jung, editors,
USENIX Security 2014, pages 781–796. USENIX Association, August 2014.
[12] Elette Boyle, Niv Gilboa, and Yuval Ishai. Function secret sharing. In Elisabeth Oswald and
Marc Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 337–367.
Springer, Heidelberg, April 2015.
[13] Elette Boyle, Niv Gilboa, and Yuval Ishai. Function secret sharing: Improvements and extensions. In Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and
Shai Halevi, editors, ACM CCS 2016, pages 1292–1303. ACM Press, October 2016.
[14] Christian Cachin, Silvio Micali, and Markus Stadler. Computationally private information
retrieval with polylogarithmic communication. In Jacques Stern, editor, EUROCRYPT’99,
volume 1592 of LNCS, pages 402–414. Springer, Heidelberg, May 1999.
[15] Justin Chan, Shyam Gollakota, Eric Horvitz, Joseph Jaeger, Sham Kakade, Tadayoshi Kohno,
John Langford, Jonathan Larson, Sudheesh Singanamalla, Jacob Sunshine, and Stefano Tessaro. Pact: Privacy sensitive protocols and mechanisms for mobile contact tracing, 2020.
[16] Hao Chen, Zhicong Huang, Kim Laine, and Peter Rindal. Labeled PSI from fully homomorphic
encryption with malicious security. In David Lie, Mohammad Mannan, Michael Backes, and
XiaoFeng Wang, editors, ACM CCS 2018, pages 1223–1237. ACM Press, October 2018.
[17] Hao Chen, Kim Laine, and Peter Rindal. Fast private set intersection from homomorphic
encryption. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors,
ACM CCS 2017, pages 1243–1255. ACM Press, October / November 2017.
[18] Hyunghoon Cho, Daphne Ippolito, and Yun William Yu. Contact tracing mobile apps for
covid-19: Privacy considerations and related trade-offs, 2020.
[19] Benny Chor, Niv Gilboa, and Moni Naor. Private information retrieval by keywords. Cryptology
ePrint Archive, Report 1998/003, 1998. http://eprint.iacr.org/1998/003.
[20] Ivan Damgαrd, Valerio Pastro, Nigel P. Smart, and Sarah Zakarias. Multiparty computation
from somewhat homomorphic encryption. In Reihaneh Safavi-Naini and Ran Canetti, editors,
CRYPTO 2012, volume 7417 of LNCS, pages 643–662. Springer, Heidelberg, August 2012.
[21] Emiliano De Cristofaro, Jihye Kim, and Gene Tsudik. Linear-complexity private set intersection
protocols secure in malicious model. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477
of LNCS, pages 213–231. Springer, Heidelberg, December 2010.
29

[22] W. Diffie and M. Hellman. New directions in cryptography. IEEE Trans. Inf. Theor., 22(6):644–
654, September 2006.
[23] Changyu Dong and Liqun Chen. A fast single server private information retrieval protocol with
low communication cost. In Miroslaw Kutylowski and Jaideep Vaidya, editors, ESORICS 2014,
Part I, volume 8712 of LNCS, pages 380–399. Springer, Heidelberg, September 2014.
[24] Changyu Dong and Liqun Chen. A fast single server private information retrieval protocol
with low communication cost. In Mirosław Kutyłowski and Jaideep Vaidya, editors, Computer
Security - ESORICS 2014, pages 380–399, Cham, 2014. Springer International Publishing.
[25] Cynthia Dwork and Aaron Roth. The algorithmic foundations of differential privacy. Found.
Trends Theor. Comput. Sci., 9(3âĂŞ4):211âĂŞ407, August 2014.
[26] Luca Ferretti, Chris Wymant, Michelle Kendall, Lele Zhao, Anel Nurtay, Lucie Abeler-Dorner,
Michael Parker, David G Bonsall, and Christophe Fraser. Quantifying sars-cov-2 transmission
suggests epidemic control with digital contact tracing. medRxiv, 2020.
[27] Craig Gentry and Zulfikar Ramzan. Single-database private information retrieval with constant
communication rate. In Luís Caires, Giuseppe F. Italiano, Luís Monteiro, Catuscia Palamidessi,
and Moti Yung, editors, ICALP 2005, volume 3580 of LNCS, pages 803–815. Springer, Heidelberg, July 2005.
[28] Craig Gentry and Zulfikar Ramzan. Single-database private information retrieval with constant communication rate. In Proceedings of the 32nd International Conference on Automata,
Languages and Programming, ICALPâĂŹ05, page 803âĂŞ815. Springer-Verlag, 2005.
[29] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or A completeness theorem for protocols with honest majority. In Alfred Aho, editor, 19th ACM STOC,
pages 218–229. ACM Press, May 1987.
[30] Yan Huang, David Evans, and Jonathan Katz. Private set intersection: Are garbled circuits
better than custom protocols? In NDSS 2012. The Internet Society, February 2012.
[31] Bernardo A. Huberman, Matt Franklin, and Tad Hogg. Enhancing privacy and trust in electronic communities. In Proceedings of the 1st ACM Conference on Electronic Commerce, EC
’99, pages 78–86. ACM, 1999.
[32] Mihaela Ion, Ben Kreuter, Ahmet Erhan Nergiz, Sarvar Patel, Mariana Raykova, Shobhit Saxena, Karn Seth, David Shanahan, and Moti Yung. On deploying secure computing commercially: Private intersection-sum protocols and their business applications. Cryptology ePrint
Archive, Report 2019/723, 2019. https://eprint.iacr.org/2019/723.
[33] Stanislaw Jarecki and Xiaomin Liu. Fast secure computation of set intersection. In Juan A.
Garay and Roberto De Prisco, editors, SCN 10, volume 6280 of LNCS, pages 418–435. Springer,
Heidelberg, September 2010.
[34] Bay Jason, Kek Joel, Tan Alvin, Sheng Hau Chai, Yongquan Lai, Tan Janice, and Tang Anh
Quy. Bluetrace: A privacy-preserving protocol for community-driven contact tracing across
borders. https://bluetrace.io/.

30

[35] Seny Kamara, Payman Mohassel, and Ben Riva. Salus: A system for server-aided secure
function evaluation. Cryptology ePrint Archive, Report 2012/542, 2012. http://eprint.
iacr.org/2012/542.
[36] François Koeune. Pseudorandom Number Generator, pages 995–996. Springer US, Boston,
MA, 2011.
[37] Vladimir Kolesnikov, Ranjit Kumaresan, Mike Rosulek, and Ni Trieu. Efficient batched oblivious PRF with applications to private set intersection. In Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai Halevi, editors, ACM CCS 2016,
pages 818–829. ACM Press, October 2016.
[38] Vladimir Kolesnikov, Naor Matania, Benny Pinkas, Mike Rosulek, and Ni Trieu. Practical
multi-party private set intersection from symmetric-key techniques. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 2017, pages 1257–1272.
ACM Press, October / November 2017.
[39] Goldreich Oded. Foundations of Cryptography: Volume 2, Basic Applications. Cambridge
University Press, USA, 1st edition, 2009.
[40] Benny Pinkas, Mike Rosulek, Ni Trieu, and Avishay Yanai. SpOT-light: Lightweight private
set intersection from sparse OT extension. In Alexandra Boldyreva and Daniele Micciancio,
editors, CRYPTO 2019, Part III, volume 11694 of LNCS, pages 401–431. Springer, Heidelberg,
August 2019.
[41] Benny Pinkas, Thomas Schneider, Gil Segev, and Michael Zohner. Phasing: Private set intersection using permutation-based hashing. In Jaeyeon Jung and Thorsten Holz, editors,
USENIX Security 2015, pages 515–530. USENIX Association, August 2015.
[42] Benny Pinkas, Thomas Schneider, Oleksandr Tkachenko, and Avishay Yanai. Efficient circuitbased PSI with linear communication. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part III, volume 11478 of LNCS, pages 122–153. Springer, Heidelberg, May
2019.
[43] Benny Pinkas, Thomas Schneider, Christian Weinert, and Udi Wieder. Efficient circuitbased PSI via cuckoo hashing. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part III, volume 10822 of LNCS, pages 125–157. Springer, Heidelberg,
April / May 2018.
[44] Ramesh Raskar, Isabel Schunemann, Rachel Barbar, Kristen Vilcans, Jim Gray, Praneeth
Vepakomma, Suraj Kapa, Andrea Nuzzo, Rajiv Gupta, Alex Berke, Dazza Greenwood, Christian Keegan, Shriank Kanaparti, Robson Beaudry, David Stansbury, Beatriz Botero Arcila,
Rishank Kanaparti, Vitor Pamplona, Francesco M Benedetti, Alina Clough, Riddhiman Das,
Kaushal Jain, Khahlil Louisy, Greg Nadeau, Vitor Pamplona, Steve Penrod, Yasaman Rajaee, Abhishek Singh, Greg Storm, and John Werner. Apps gone rogue: Maintaining personal
privacy in an epidemic, 2020.
[45] Xiao Wang, Alex J. Malozemoff, and Jonathan Katz. Faster secure two-party computation
in the single-execution setting. In Jean-Sébastien Coron and Jesper Buus Nielsen, editors,
EUROCRYPT 2017, Part III, volume 10212 of LNCS, pages 399–424. Springer, Heidelberg,
April / May 2017.
31

[46] Martin Woolley. Bluetooth technology protecting your privacy. https://www.bluetooth.com/
blog/bluetooth-technology-protecting-your-privacy/, 2015.
[47] Andrew Chi-Chih Yao. How to generate and exchange secrets (extended abstract). In 27th
FOCS, pages 162–167. IEEE Computer Society Press, October 1986.
[48] Samee Zahur, Mike Rosulek, and David Evans. Two halves make a whole - reducing data
transfer in garbled circuits using half gates. In Elisabeth Oswald and Marc Fischlin, editors,
EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 220–250. Springer, Heidelberg, April
2015.

32

