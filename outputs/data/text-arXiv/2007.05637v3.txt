JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, DECEMBER 7, 2020

1

Dynamic Graph Streaming Algorithm for
Digital Contact Tracing
arXiv:2007.05637v3 [cs.DS] 4 Dec 2020

Gautam Mahapatra, Priodyuti Pradhan, Ranjan Chattaraj and Soumya Banerjee
Abstract—Digital contact tracing of an infected person, testing the possible infection for the contacted persons, and
isolation play a crucial role in alleviating the outbreak. Here, we design a dynamic graph streaming algorithm that can trace
the contacts under the control of the Public Health Authorities (PHA). Our algorithm receives proximity data from the mobile
devices as contact data streams and uses a sliding window model to construct a dynamic contact graph sketch.
Prominently, we introduce the edge label of the contact graph as a binary contact vector, which acts like a sliding window
and holds the latest D days (incubation period) of temporal social interactions. Notably, the algorithm prepares the direct
and indirect (multilevel) contact list from the contact graph sketch for a given set of infected persons. Finally, the algorithm
also uses a disjoint set data structure to construct the infection pathways for the trace list. The present study offers the
design of algorithms with underlying data structures for digital contact trace relevant to the proximity data produced by
Bluetooth enabled mobile devices. Our analysis reveals that for COVID-19 close contact parameters, the storage space
requires maintaining the contact graph of ten million users; having 14 days of close contact data in the PHA server takes 55
Gigabytes of memory and preparation of the contact list for a given set of the infected person depends on the size of the
infected list. Our centralized digital contact tracing framework can also be applicable for other relevant diseases
parameterized by an incubation period and proximity duration of contacts.
Index Terms—Contact graph, streaming algorithm, sliding window model, Bluetooth, disjoint set, COVID-19.

✦

1

I NTRODUCTION

D

E laying in the vaccine or drug design increases
the rapid spread of the COVID-19 disease. The
current COVID-19 pandemic is caused by the dropletbased human to human transmission of SARS-CoV-2
[1]. At present, the whole human society is anxiously
waiting for a possible new normal state of living.
Almost every country adopted the social distancing
and lockdown to mitigate the pandemic [2]. Although
complete lockdown reduced the risk of spread, extending the lockdown created severe problems for the
economy and the social life of the countries [3]. Also, as
the pandemic stays a long time in a country, it becomes
challenging to maintain the lockdown. Many countries eased the lockdown in terms of alternating and
intermittent lockdown strategies to balance between

•

•
•
•

Gautam Mahapatra is associated with Department of Computer
Science, Asutosh College, University of Calcutta, Kolkata, West
Bengal, India and Department of Computer Science and Engineering, Birla Institute of Technology, Mesra, Off-Campus Deoghar,
Jharkhand, India. E-mail: gsp2ster@gmail.com
Priodyuti Pradhan is associated with Complex Network Dynamics
Lab, Department of Mathematics, Bar-Ilan University, RamatGan, Israel. E-mail: priodyutipradhan@gmail.com
Ranjan Chattaraj is associated with Department of Mathematics,
Birla Institute of Technology, Mesra, Off-Campus Deoghar, Jharkhand, India. E-mail: chattaraj6@gmail.com
Soumya Banerjee is associated with Inria EVA, Paris,
France & Director Innovation Smart City EU. E-mail:
dr.soumyabanerjee@ieee.org

infection spread and economy [3], [4]. In this scenario,
currently developed smartphone-based digital contact
tracing becomes a promising approach to control the
pandemic [1], [5], [6]. A recent study shows that highly
effective contact tracing and case isolation are good
strategies to control a new outbreak of COVID-19 [7].
Another study suggests to get normality, which takes
at least a couple of years, and at the same time, we
should prepare for the next pandemic [8].
Contact tracing was a common and successful step
to control several infectious diseases (e.g., Zika, HIV,
influenza, Ebola viruses) [9], [10]. The World Health
Organisation (WHO) defines contact tracing as the
identification and follow-up of persons who may contact an infected person [9]. For COVID-19, two persons
are in close contact if they are exposed to each other for
at least fifteen minutes within one meter of distance
[9]. The goal of contact tracing is to reduce a disease’s
effective reproductive number (R0 ) by identifying people who have been exposed to the virus through the
said close contact with an infected person and listing
them for immediate quarantine or isolation. It has
been reported that 46% contribution to R0 comes from
the presymptomatic individual (before showing symptoms) for COVID-19 [11]. On the other hand, COVID19 infection is mostly asymptomatic in nature. Hence,
highly effective direct and indirect contact tracing is
a mandatory task and plays a crucial role in early

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, DECEMBER 7, 2020

infection detection and reduces the peak burden on
the healthcare system. Due to higher uncertainties in
social relations, manual contact tracing to find the
contact structure is very complicated for the PHA [12].
Recently, digital contact tracing uses low power radio
frequency-based Bluetooth enabled mobile devices to
overcome the problems in manual contact tracing. The
success of TraceTogether of Singapore Government
[13], COVID-Watch of Stanford University [14], [15],
PACT of MIT [16], Exposure Notification forthcoming
App of Apple-Google [17], Arogya Setu of MoHFA,
Government of India [18] are all recent developments
based on the Bluetooth technology to prepare the
contact list more effectively to mitigate the COVID-19
pandemic [11], [19], [20], [21], [22], [23].
Although digital contact tracing substantially reduces human efforts of manual contact tracing, most
smartphone apps store data locally in the device
memory to maintain privacy [10]. Hence, the central
authority has no control over the contact data. After
detecting an infected person, PHA requests the person
to donate the app data to make the trace list. As
we know, a country’s public health infrastructure is
a national asset for which the government is responsible, and no pandemic can be addressed without a
functional health system of the country [24]. On the
other hand, the existing app provides only the direct
contact tracing facility, but indirect contact tracing also
plays a vital role in mitigating the spread and reducing
the death rate [25]. Hence, to automate the trace list
preparation in a regular interval, all proximity data
should be automatically fetched by the PHA server
from the registered devices and immediately store in
the form of ready to process structure. However, in
the pandemic period, the vital question is how does
the centralized control system store a large number
of device data as well as prepare direct and indirect
contact lists about which little is known and remains
elusive [26].
This article provides a one-pass dynamic graph
streaming algorithm with a sophisticated data structure to automate the multi-level digital contact tracing
more accurately and efficiently by having centralized
control under the PHA. After receiving the proximity
data stream from the mobile devices, the algorithm
uses a sliding window model to process the proximity
data and dynamically evolves a close contact graph
sketch (Fig. 1). The nodes in the close contact graph
are the individual users, and an edge is included if
there exists an interaction between a pair of people for
more than τ minutes (proximity duration) in D days
(incubation period) [27]. Importantly, we introduce an
edge label (interactions) between a pair of the individual in the contact graph as a fixed-sized binary firstin-first-out (FIFO) contact vector to store the temporal
information in the last D days, and earlier data are au-

2

Fig. 1. Schematic representation of close contact graph (G ). We
introduce edge label of G as binary vector (c). Here, D is the
incubation period, τ is the time slot for exposure. For COVID-19,
D = 14 and τ = 15 minutes. We set ck to be 1, when a close
contact is detected at the k th time slot duration and 0 otherwise.

tomatically leaving from the system storage. In other
words, during a pandemic, the contact graph stores
the latest D days of continuous close contact data in a
discrete form inside contact vectors. Finally, the system
prepares the contact list for the given infected persons
from the contact graph. We wish to emphasize that
our algorithm prepares the direct and indirect (multilevel) contact list of the infected persons and stores it
in disjoint sets to find the infection pathways. We use
the index file structure to store the large contact graph
for fast accessing. The system’s salient feature is that
it automatically removes the inactive edge when the
D days over and updates the graph through a sliding
window model over the contact vectors. We provide
implementation details and analysis of our devised
streaming algorithm. Remarkably, our analysis reveals
that for COVID-19 contact trace parameters, to store
the contact graph for 14 days for 107 , users take 55 GB
of memory space. Besides, the preparation of the contact list for a given set of infected persons depends on
the size of the infected list. Our algorithm is simple and
easy to implement. By considering the location and
time-independent binary contact vectors and making
centralized control by the PHA, our algorithm maintains the individuals’ privacy. We expect it to be an
attractive choice to deploy in the application of digital
contact traces in real-world pandemic situations.
We fabricate the article as follows: Section 2 discusses the problem formulation and methodology of
the digital contact tracing process. Section 3 provides
implementation detail of our dynamic graph streaming algorithm with sliding window model. Section 4
contains the space complexity of the contact graph and
analyzes the contact trace algorithm. Finally, Section
5 summarizes our work and discusses various open
problems for further investigations.

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, DECEMBER 7, 2020

Symbols and Notations
τ, D
c(P,P ′ )
σ
′
P
P
G
Σ, I , Γ, and χ
δ
Ω and W
T and t
L
F

3

Description
Close contact parameters – minimum time duration spend for close contact (proximity duration)
and latest observation period in days (incubation period)
′
Contact vector – between individuals P and P .
Contact trace operator – a binary operator for indirect (multi-level) contact tracing.
′
flow of infection elements from P to P
Close contact graph – having two components (i) (G.Φ) stores addresses of the close contact
vectors (ii) G.Θ stores close contact vectors.
population having smartphones, infected persons, suspected individuals or contact trace list,
directed edges for infection transmission pathways
sampling time interval for smartphone.
Data stream – received from smartphones to PHA server and sliding window
System start time and beginning time of the proximity contacts data in Ω.
Levels of indirect contact tracing
Disjoint set data structure for efficient representation of the infection transmission that are
determined by contact trace operation (χ) on the contact graph G .
TABLE 1
List of symbols and notations.

2

M ETHODOLOGY AND R ESULTS

Infectious diseases caused by microscopic germs such
as bacteria or viruses are called the infection elements that get into the human body and cause health
problems. Infectious diseases that spread from person to person are said to be contagious. One of
the essential non-pharmaceutical methods to mitigate
the outbreak of infectious disease is contact tracing [28]. Contact tracing means identifying everyone
who comes directly or indirectly with an infected
(symptomatic/asymptomatic) person. These contacts
are then identified and monitored for D days to see
if they start showing symptoms. Suppose a contact
begins to show any disease symptoms. In that case, the
person is immediately isolated, quarantined, tested,
provided care, and the cycle starts again. All of the
new infected persons’ contacts must be distinguished
and monitored for D days for disease symptoms to see
if they become infected. The process repeats until there
are no new infections found. For instance, incubation
period for Ebola D = 21, Influenza D = 5, and for
COVID-19, D = 14 [28], [29].
For the digital contact tracing system, a population
(Σ), is a set of individuals under a particular Public
Health Authority (PHA) who use their smartphones.
For human nature of social interactions, any two in′
dividuals P, P ∈ Σ, we define P is in close contact
′
′
of P or P is in close contact of P , if during last D
′
days, P and P are in proximity of contact within d
meters of distance for at least τ minutes [27]. For a
particular contagious disease, d (proximity distance),
τ (proximity duration), and D (incubation period) are
parameters of close contact, respectively. Importantly,
′
when P and P come in close contact, they have no
symptoms of the disease but may carry infection elements. Even they do not know each other, i.e.; privacy
should be maintained during a close contact. On the

Fig. 2. Illustration of direct and Indirect contact tracing.

other hand, they also meet with each other several
′
times; thus, several close contacts between P and P
in D days. If anyone has the infection, it will show
the symptoms within the next D days. Therefore, it is
essential to hold the temporal information of the close
contact for the next D days to find the contact list for
an infected person.
To illustrate close contact, we consider three in′
′′
dividuals (P , P , and P ) and their possible close
′
contacts (Fig. 2 (a-d). One can observe that if P is
′
detected as an infected person (I = {P }) within D
′′
days of the close contact then P and P belongs to
′′
the close contact trace list denoted as ΓP ′ = {P, P } of
′
′′
P (Fig. 2(b) and (d)). Here, {P, P } are represented
′
as direct contact of an infected person P . We wish to
show another complex situation, which is also very
important to trace and help to reduce the spread of
the disease [25]. Suppose in Fig. 2 (c) and (e), P is
′
detected as an infected person, then P should be in
′
the direct contact list of P i.e., ΓP = {P }. How′′
ever, whether P should be in the contact list of P
or not? To decide, we should analyze the temporal

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, DECEMBER 7, 2020
′

′

′′

information between (P, P ) and (P , P ) and which
is challenging due to store all close contacts for the
last D days and accurate analysis of ordering. We refer
′′
′′
P as indirect contact
for P . Here, P will be in the
′′
′
trace list ΓP , if P has a close contact with P during
′
or after the close contact between P and P within
D days. To capture the direct and indirect contact
tracing, we store the temporal information inside the
circular queue working like a serial-in-serial-out shift
register to hold all close contacts only for the latest
D days, and we refer to it as a close contact vector.
Importantly, to decide there is any indirect contact or
not? we introduce a binary operator refer to as close
contact trace operator denote as σ which operates on
′
′
′′
two contact vector between (P, P ) and (P , P ) and
returns a TRUE/FALSE decision. Hence, formally a contact tracing system for a contagious disease must store
all close contact information of the whole population Σ
for the last D days. Thus, at any time for a given set
of infected individuals (I ), the system can determine
the close contact trace list or suspected persons (Γ). For
simplicity, we assume once an individual is detected as
a laboratory-confirmed infected person, immediately
contact tracing is carried out and infected, as well as all
suspected individuals are being isolated so that they
are not contacting further.
There are two major components of the contact
tracing system: module 1 (mobile app) – data acquisition by smartphones – continuous capturing of the
enormous asynchronous analog social contacts events
through Bluetooth enabled devices, subsequently conversion into discrete form and send to the server,
module 2 – computation on PHA server: a) analyze
the discrete mobile app data stream to identify close
contacts, (b) use the efficient storage representation to
hold all such close contact data for the last D days period, (c) design an effective contact tracing algorithm
working on such voluminous data to generate contact
trace results within a reasonable time, and (d) finally,
represent outputs in an efficient form so that it can be
used to show infection pathways.
We only focus on the algorithm and implementation of the contact tracing system on the PHA serverside (module 2). Note that in practical situations, all
individuals under PHA are not using smartphones
and hence not included in Σ. It is predicted that by
2021, there will be 3.8 billion of smartphone users for
the world population of 7.8 billion [30]. Therefore, we
can bring almost half of the world population under a
digital contact tracing system by efficiently implement
it. The following section discusses the digitization into
close contact vector, close contact graph construction,
and contact tracing processing in detail.

4

2.1 Digitization of Close Contacts
To identify close contacts between any pair of individ′
uals P and P , PHA server subdivides the D days
⌉ slots each of τ minutes coninto n = ⌈ 24×60×D
τ
secutive intervals and digitized as close contact vector
(c(P,P ′ ) = (cn−1 , . . . c1 , c0 )). Here, c′i s are different
consecutive time slots, c0 is the latest, and cn−1 is the
earliest (Fig. 1). Importantly, c(P,P ′ ) is a FIFO vector
because it has fixed n numbers of binary components,
and as time advances to the first slot of (D + 1)th
day, then the earliest slot at cn−1 exit to accommodate
a new input slot at c0 (Fig. 1). We associate one bit
for each slot in the digital form of the close contact
vector. By default all n bits are ZERO, and a bit is
′
set to ONE, if P and P come close to each other in
the past D days. It can also happen that several times
or for consecutive times, both are close to each other;
thus, several bits in c(P,P ′ ) are set to ONE. In brief, our
system converts continuous sensor data into discrete
close contact slots, and store in a binary form in PHA
server. For instance, To identify every close contact in
the COVID-19 pandemic, we subdivide the D = 14
days into τ = 15 minutes time slots (i.e., n slots)
and store one bit if there is a proximity contact in a
particular time slot.
Additionally, to maintain the privacy of the close
contact information between two individuals PHA
server distributes virtual IDs to the smartphone devices for proximity communications. All the sampled
discretized proximity-based contact data appear to the
PHA server in the form of a data stream and analyzed
by the PHA server to extract the actual user ID to
identify the close contacts. Finally, the PHA server
constructs the contact vectors and stores them in the
close contact graph. In the following section, we discuss contact vectors as temporal information on the
dynamic close contact graph sketch.
2.2 Contact Graph
To store all close contact information for last D days
among all the individuals, we introduce close contact graph G = (V, E). Here, vertices of G are the
smartphone-enabled individuals i.e. V = Σ, and if, in
last D days there is any close contact between two indi′
viduals, i.e., vertices P, P ∈ Σ then we have an edge,
′
ei = (P, P , c(P,P ′ ) ) between them, and store the temporal close contact information as bits inside contact
vector c(P,P ′ ) . Note that whenever we include/update
the edge relation and the associated contact vector,
the system does not know whether the individual
is infected or not. Hence, the edges of the contact
graph are always undirected (c(P,P ′ ) = c(P ′ ,P ) ). More
importantly, G only stores the close contact information
for D days as undirected edges with Contact vector as edge
label. The G is not holding any information about the

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, DECEMBER 7, 2020

5

Fig. 3. Contact graph (G ) annotated with the contact vectors (c) at D and D + τ time instance. Here, we consider N = 10 and size of
c is n = 5. One can observe that during the D days window, there is no close contact between P1 and P9 . However, as time progress
the data streams from the devices at D + τ , there is close contact between P1 and P9 ; thus, the algorithm sets one bit in c(P1 ,P9 ) .
Similarly, there is an edge between P6 and P8 during the D days window; however, at D + τ time slot, they have no close contact; thus
algorithm removes this edge and updates G . Further, for a given infected member P2 , from G by analyzing associated contact vector
we get first-level contact list as {P0 , P7 , P8 }, second-level as {P5 }, and third-level as {P3 } respectively.

infections and pathways of transmissions. Once a node
or set of nodes are tested to be infected within D days,
then the algorithm can trace the contact of the infected
person over the close contact data stored within the
contact vector in G . Therefore, a contact vector associated with an edge helps to trace the chances of a
person to person infection elements transmission.

For a sufficiently large population, due to social
relationships, everyone is not coming in close contact
with every other [31]. That means the average number
of close contact relationships q is small compared to
N (q ≪ N ), and hence G is highly sparse. On the
other hand, forming a close contact requires human
mobility and coming close to each other, which is
dynamic in nature. To store such sparse connectivity
and the dynamic nature of human behavior, we use
adjacency lists [32], [33], [34] to represent G under the
PHA server. Here, we use optimized index-based [35]
dynamic adjacency lists to maintain this fast access of
ready-to-use digital form of G so that fetching of direct
contacts for the generation of multi-level contact list
becomes easy and accurate.

2.3 Contact Tracing
Using edges of graph sketch G for a given infected
list I , we can easily generate all the direct contact trace
members in Γ. However, for indirect contact tracing we
use contact trace operator σ . Here, we illustrate the
contact tracing process with an example. Fig. 3 is a scenario of G with ten individuals Σ = {P0 , P1 , . . . , P9 }
with n = 5 (D = 5 and τ = 1 day). We show G for
5th and 6th days with the associated contact vector on
the edges (Fig. 3). More details of the contact graph
evolution process is portrayed in suppl. Fig. S1. Let us
assume upto 5th day, I = ø, hence, Γ = ø (Fig. 3). On
the 6th day P2 and P6 (marked as red in Fig. 3) are
identified as infected (I = {P2 , P6 }), hence, the PHA
server initiates the contact tracing process on G and
find the Γ = ΓP2 ∪ ΓP6 .
2.3.1 Direct Tracing
We can observe (Fig. 3) that P0 , P7 and P8 are in
direct close contact of P2 in latest D days window as
there are edges and corresponding contact vectors are
nonzero (P2
P0 , P2
P7 and P2
P8 ). Hence,
ΓP2 = {P0 .1, P7 .1, P8 .1} and similarly ΓP6 = {P1 .1}

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, DECEMBER 7, 2020

6

are the direct or first-level contact trace list of P2 and
P6 , respectively.

TRUE . Here, v1 = val(c(P0 ,P5 ) ) = 01001 = 9 and
v2 = val(c(P3 ,P5 ) ) = 11001 = 25, thus v2 > v1 .
Therefore, following Lemma 2 both the conditions are
satisfied, thus P3 gets infection from P2 via P0 and
P5 . Hence, by extending the transitivity relation P2
P0
P5
P3 , we can observe that P3 will be included in the third-level contact list (Fig. 3 and Suppl.
Fig. S3(b)). No further processing is possible and tracing stops with ΓP2 = {P0 .1, P7 .1, P8 .1, P5 .2, P3 .3},
and similarly ΓP6 = {P1 .1, P4 .2, P9 .2}. In this way,
algorithm can implement σ operator and use it to
prepare the indirect contact list easily and accurately
from G .
Additionally, from G during the contact
tracing process, one can also find the infection transmission pathways very easily and
here, we store inside χ as directed edges,
χP2 = {(P2 , P8 ), (P2 , P7 ), (P2 , P0 ), (P0 , P5 ), (P5 , P3 )}
and χP6 = {(P6 , P1 ), (P1 , P4 ), (P1 , P9 )}, where
(Pi , Pj ) represents Pi transmits infection to Pj (suppl.
Fig. S4). To handle large number of χ’s in an efficient
way, we use the disjoint set data structure and more
details is in section 3.4.

2.3.2 Indirect Tracing
To prepare the second-level (indirect) close contact
list of P2 , we observe that P3 and P5 are possible
candidates (Fig. 3). However, we can not confirm this
by observing only the presence of edges and nonzero contact vectors. Now, we need to analyze the
respective contact vectors. Remarkably, the listing and
pruning of second and higher-level contact list can be
prepared through numerical operations on the equivalent decimal integer values corresponds to the binary
contact vector where c0 as LSB and cn−1 as MSB
of the binary number. We know that for any binary
integer number, the weight of a higher significant
position (2i ) is always greater than the sum of all
weights at lower significant positions (i − 1 to 0) [32].
For this reason, if the decimal value of any binary
number (say v1 = val(c(P,P ′ ) )) is greater than equal
to decimal value of another non-zero binary number
(say v2 = val(c(P ′ ,P ′′ ) )), indicates that at least one
close contact occurs earlier for the close contact vector
corresponds to v1 than all close contacts corresponds to
v2 (Lemma 1 and 2 in suppl.). We use this clue to solve
the multilevel contact tracing in G by implementing σ .
From Fig. 3, the decimal integer values of v1 =
val(c(P0 ,P2 ) ) = c4 c3 c2 c1 c0 = 11000 = 24 and v2 =
val(c(P0 ,P5 ) ) = c4 c3 c2 c1 c0 = 01001 = 9 at D + τ time
are respectively. These two bit patterns implies that at
first time slot both P0 and P2 comes close to each other
and have an close contact, but P0 and P5 do not have
any close contact. However, on the second time slot
in between (P0 , P2 ) and (P0 , P5 ) bits are 1, indicates
they three are altogether. Hence, infection can transmit
from the P2 to P5 via P0 (suppl. Fig. S2). Here, v1 > v2
says at least one contact between P2 and P0 (P2
P0 )
occurred earlier than the contact between P0 and P5
(P0
P5 ). Hence, P5 may get infection from P2 via P0
(Lemma 1 in suppl.) and thus included in the secondlevel contact list (P2
P0
P5 or c(P2 ,P0 ) σc(P0 ,P5 )
evaluates to TRUE).
There are two ways P3 can get the infection indirectly either from P7 or from P8 . From the contact
vectors v1 = val(c(P2 ,P7 ) ) = 00100 = 4 and v2 =
val(c(P3 ,P7 ) ) = 01000 = 8 and thus, v2 > v1 (Suppl.
Fig. S3(a)). Similarly, from v1 = val(c(P2 ,P8 ) ) = 8
and v2 = val(c(P3 ,P8 ) ) = 16, hence again v2 > v1 .
However, from Lemma 2 third condition fails and
hence P2
P7 6 P3 or c(P2 ,P7 ) σc(P3 ,P7 ) is FALSE,
and also P2
P8 6 P3 or c(P2 ,P8 ) σc(P3 ,P8 ) is FALSE.
Hence, inclusion of P3 into the second level contact list
is not required.
Now, we test for the third level contact of P2 .
During the latest D days window, P3 comes in contact
with P5 , and we already know P2
P0
P5 is

3

I MPLEMENTATIONS

A particular jurisdiction has one PHA server that
maintains all computations of the automated contact
tracing process. We consider PHA employs Bluetooth
enabled smartphones as the representatives of individuals for the automated data acquisition operations
to implement the digital close contact trace system.
On initialization, the PHA server creates an empty
G along with I = ø, Γ = ø and having population
Σ = {P0 , P1 , . . . , PN −1 }. To maintain privacy (phone
numbers is not shareable) during local Bluetooth based
communication, the smartphone uses randomly generated virtual IDs distributed by the PHA server (suppl.
section 2). Now each device individually shares the
send/receive virtual IDs with a timestamp as a data
stream (Ω) to the PHA server for the identification of
close contact(s). As the smartphone uses the virtual
ID to communicate and resolve on the PHA serverside, the privacy of the user will be maintained. In
the following sections, we provide an implementation
detail of G .
3.1 Data Structure for Contact Graph Sketch
We represent G using adjacency lists having two components, index file (G.Ψ) and close contact vectors file
(G.Θ). The G.Ψ stores q number of index records with
two fields UserID and Pointer for each user (Fig. 4).
Here, q , the average degree of the G represents the
average number of distinct persons coming in close
contacts to a person during D days. Moreover, we
maintain one extra index record in G.Ψ to move into

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, DECEMBER 7, 2020

7

Fig. 4. Data Structure for the contact graph (G ). Here, G.Ψ is the index representation of adjacency lists of N persons as (UserID,
Pointer). The G.Θ holds fixed size contact vectors c of size n. Both are in the form of array. Here, (q + 1)st index record for each user
is assigned to enter into the respective overflow area.

the overflow area when contacts exceed the average
value of q for an individual.
′
We know for each pair of individuals P and P
there is an undirected edge having c(P,P ′ ) is the edge
label. Hence, we store c only once in G.Θ at A index
position or address which is used as pointer field of
′
′
records in G.Ψ. For an edge e = (P, P , c(P,P ′ ) ), P
′
will appear as one record (P , A) under adjacency list
of P in G.Ψ. Similarly, we keep another record (P, A)
′
under P . For a particular disease parameters, D and
τ are fixed, which implies, c(P,P ′ ) has a fixed length
(n). Also, we assume, on average for an user, there is a
q number of distinct close contacts during the D days
period. Therefore, we can access both G.Ψ and G.Θ
as an array with constant access time. Here, algorithm
uses G.Ψ[P (q + 1)] to access the starting contact record
of P . Similarly, G.Θ[A × n] to access the first bit of
c(P,P ′ ) . In addition, to access the overflow area we use
G.Ψ[P (2q+1)] [36]. Therefore, through G we can watch
every close contacts of the society for the latest D days,
and reflect as sliding watch window with all c0 is the
close contact front of the Σ.
3.2 Embedding data stream into contact graph
The PHA server receives the contact data stream (Ω)
from registered mobile devices (Fig. 5). The Ω contains
a header part and communication details with virtual
IDs. The header part holds the actual sender ID as P

in Ω.U ID and broadcast start time as Ω.StartT ime
as t. Further, communication details contain Ω.T ran
and Ω.Rec for transmitted and all received virtual
user IDs during proximity contact (Fig. 5). A valid
close contact requires τ min of continuous proximity
neighbors’ data. To improve the sampling accuracy we
split the τ in δ time interval i.e., τ = δ ×ρ min (ρ > 1 is
a positive integer). Hence, if someone is present nearby
with a person for a continuous ρ number of samples,
then there will be a close contact. Therefore, to detect
close contact during stream processing, the algorithm
uses a sliding window (W) of size ρ. For COVID-19,
one can set δ = 3 min, and thus, ρ = 5, and hence,
to ensure a close contact, one person should appear 5
times inside W.
To process stream data of mobile devices and detect
close contact, we use one sliding window (W). On
the other hand, contact vector (c), which always holds
the latest D days binary close contact data, is another
siding window. We implement the first window as
a simple FIFO queue, whereas the contact vector as
a circular queue (stored in a one-dimensional array),
and always inserts or en-queue of data at REAR and
removing or de-queue of an element from FRONT of
these queue structures [32]. Hence, maintaining G is
the interplay between two sliding windows. Here, next
latest slot (c0 at array index ν ← (ν + 1) mod n) of c
always appears at REAR and earliest slot (cn−1 ) at the
FRONT of the queue. For circular behavior of modulo-

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, DECEMBER 7, 2020

8

Fig. 5. Processing proximity data stream (Ω) and detect close contact through a watch window (W). The PHA server assigns virtual
IDs to the users P0 , P1 , . . ., PN−1 as πP0 = {1, 2}, πP1 = {3, 4}, . . . , πPN −1 = {2N − 1, 2N } (suppl. section 2). Individuals’
smartphones communicate through virtual IDs during the broadcast and appear in the T ran. and Rec. fields in Ω. For every user, Ω
begins with a start time (t) and the actual user ID of the sender. The W is a fixed size (ρ = 5) array of pointers which works as a FIFO
queue where data enters at the REAR and exits from FRONT . The window and holds proximity data for the latest ρ intervals. Each entry
of W holds the actual sender ID and the list of real receiver IDs in a linked list form. Receiver ID in W associates a communication
′
count value (̺) to count the appearance in ρ number of intervals. During removal from FRONT of W if the ̺ of any user P is equal to
′
ρ then it is a close contact between P and P . A pointer field is NULL , means there is no proximity communication in the next interval.

arithmetic, after initialization when queue becomes
full after passing D days, c0 returns to the ν = 0 array
index location and cn−1 appears at array index 1 and
so on (Fig. 4 and suppl. Fig. S5).
Now, we illustrate the functioning of sliding watch
windows (W) to detect close contact from the data
stream (Ω). From Fig. 5, one can observe that Ω is
the snapshot of two users’ sampled data (P2 and
P0 ) shared with the PHA server. After accessing the
header, the server realized that P2 start communicating with others at time t = 12 : 56 : 10 and uses
its own virtual ID 5 and 6. Now, from virtual user
IDs (4 and 8) in Ω.Rec field of the current sample
data associated with P2 , PHA server determines the
actual user IDs (e.g., P1 for 4, P3 for 8) of the receiver
from the ID mapping table and store temporarily
in a set say U = {P1 , P3 }. Therefore, (P2 , P1 ) and
(P2 , P3 ) are two proximity contacts in this current
sample interval and stored at W[0] in a linked list

form with associated communication count (̺) value
set to one (P1 .̺ = P3 .̺ = 1). Similarly, server get
the same situations for the next interval data, and
W[1] stores the corresponding linked list for P1 , P3 .
However, to indicate the twice appearance of users
P1 , P3 in W, ̺ value of the earlier communication
with persons in U are increased by one for record at
W[0] (P1 .̺ = P3 .̺ = 2). Similar, processing continues
until W is full. Now, to accommodate the next interval
data at REAR, algorithm removes elements from FRONT
at W[0]. After removal, the algorithm checks the ̺
value for a user. If it is equal to ρ, then it is a close
contact. Here, one can observe that for P1 .̺ = ρ (Fig.
5). Hence, P1 was in proximity contact for latest all
ρ number sample intervals leading to a close contact
with P2 . Therefore, we require to install into c0 slot of
the contact vector (c(P2 ,P1 ) ) in G . However, (P2 , P3 ) is
not a close contact as P3 .̺ 6= ρ and not to install.
Now, to embed the detected close contact in G ,

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, DECEMBER 7, 2020

9

Now, in Fig. 6, we show how ν and λ are used to idenAlgorithm 1 Process(G, Ω)

Fig. 6. Resolving the conflict between slot numbers (c1 and c0 )
of c for a detected close contact at c0 . The maximum part of the
close contact duration lies (a) in c1 slot and (b) in c0 slot.

we determine the array index number (ν ) for c0 of
c by synchronizing the start time (t) of P (P ≡ P2 )
with the system start time (T ) (Eq. 1). With the use
of this time synchronization it is possible to identify
every component of c and corresponding array index
ν where c0 will be located. Also, note that due to
unpredictable human nature, close contact may appear
at any time. That means the first sample interval of
close contact may be at any of ρ number of intervals in
the earlier slot, i.e., c1 and accordingly ends at any
of ρ number of sample intervals in c0 slot (Fig. 6).
In this situation, we select suitable one from c0 and
c1 depending on the most proximity contact intervals
(Fig. 6). Therefore, to make decision about c0 and c1 ,
we also synchronize t of P with T for the interval
number (λ) of the current array index ν (Eq. 1).

T
ν=
τ


′

′



T
mod n, λ =
δ


′



mod n

′

(1)

where T = (1440 × X.Days + 60 × X.Hrs + X.M in)
and X = T − t (date difference), here T is the
system deployment time, both t and T are in format
dd/mm/yyyy : hh : mm and date difference T − t is
′
⌋. Further,
in format Days/Hrs/M in, and n = ⌊ 1440D
δ
when there is no communication for one or more δ
time interval(s) between nearby Bluetooth devices, we
consider the next record in Ω is of Gx format, indicating that there is a communication gap for x(≥ 1)
number of δ time intervals. For Gx, we update ν and
λ for starting slot (c0 ) using Eq. (2) to skip x number
intervals.

 
x
ν= ν+
mod n, λ = (λ + x) mod ρ (2)
ρ

while (Buf f er(Ω) 6= φ) do
if (Ω.StartT ime 6= φ) then
t, P ← Ω.StartT ime, Ω.U ID
ν, λ, ρ, W ← Initialize(t)
end if
X ← GetN ext(Ω.Data)
if (X = Gx) then
ν, λ, W ← U pdate(ν, λ, x)
else
U ← GetU sers(X.Rec, t)
U.̺ ← 1
W ← U pdateCounters(W, U )
if (Size(W ) = ρ) then
′
W ← Delete(W, U )
′
′
for all (P in U ) do
′
if (P .̺ = ρ) then
′
G ← Install(G, P, P , ν, λ)
end if
end for
end if
if λ = ρ then
ν ← (ν + 1) mod n
end if
λ ← (λ + 1) mod ρ
W ← Insert(W, U )
end if
end while
return G
tify correct slot in c accordingly update the detected
close contact in G . Here, c[ν mod n] is equivalent to
c0 slot, and c[(ν − 1) mod n] is the immediate earlier
slot c1 .
Now, to understand the time synchronization, we
divide close contact duration τ = 15 min into ρ = 6,
number of sample intervals each of length δ = 15
6 =
2.5 min. Here, half of the number of sample intervals
is ⌊ ρ2 ⌋ = 3. In Fig. 6 (a), we show that current close
contact watch window ends before half of the number
intervals of c0 slot (λ = 2 ≤ ⌊ 2ρ ⌋). This indicates
most of the part of current close contact exists in the
immediate earlier slot, so c1 = 1. Similarly, in Fig.6 (b),
we show λ = 5(> ⌊ ρ2 ⌋), that means most of part of
current W exists in the latest slot, so c0 = 1. In this
way conflict for c1 and c0 is resolved.
Finally, we consider Set() function is used to perform these changes of c in G . The process will continue
for the whole contact data stream of the different users
(Algorithm 1). Algorithm 1 (suppl.) helps to install any
detected close contact (P, P ′ , ν, λ) into G during data
stream processing. To install the close contact for P ,
search starts from G.Ψ[P (q + 1)] location of the index
file. If it is successful, then updating is performed in

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, DECEMBER 7, 2020

the target slot. However, on an unsuccessful search,
the algorithm creates an empty contact vector c = 0
in G.Θ, and accordingly, we update the target slot.
New contact vector means new relation between P
′
and P and hence, we also update G.Ψ (Algorithm
1). As time passes, the social contact dynamics are
changing, and without any latest close contact, some
contacts are older than incubation duration D. Hence,
the PHA server removes the edge(s) along with contact
vector(s) from G .
3.3 Contact Tracing on G
The G maintains the digital form of the social contact
dynamics of Σ for the particular geopolitical area
under a PHA for the last D days. We assume that at
any time, the system has a contact trace list (Γ) for a
given set of infected persons (I ). Hence, the system
updates these lists using the following procedures for
incoming situations. Suppose at any time, one or more
individuals are detected as newly infected persons and
′
′
kept in I . After receiving I , system starts immediate
′
contact tracing on G where I , Γ, G and L are passed
as input parameters (Algorithm 2). Here, L ≥ 1 means
up to which level we require to trace the contacts.
The algorithm returns updated Γ, which contains first,
second, and other required higher levels of indirect
′
contacts along with respective edge list χ .
Finally, we update new infected list as I ← I ∪
′
I , and directed edge list to detect infection pathways
′
as χ ← χ ∪ χ . Person appears once in contact list,
Algorithm 2 automatically removes any redundancy.
The algorithm uses two queues Q1 and Q2 alternatively as processing and waiting of individuals
to trace close contact (Algorithm 2). Initially, we set
current contact level number l = 1 (direct or first-level
′
contact), and all members in I are in the processing
queue (Q1 ) and hence, Q2 is empty and working as
waiting queue. Now, for all members in the Q1 direct
contact list are generated from indexed adjacency list
in G.Ψ and stored in Γ as well as in the waiting queue
(Q2 ). For higher-level contact tracing we update l,
swap Q1 and Q2 , and call T raceOperator() method
(suppl. Algorithm 2).
In section 2.3, we explain the different such situations for filtering the second and higher-level contact
tracing for which bit-patterns of c and decimal values
are used to exclude or include the next member in the
contact list and also pruning of further processing. The
process will continue either no more individuals left
in the waiting queue or the target level (L) of indirect
contacts has been reached (Algorithm 2).
3.4 Disjoint Sets for Contact Trace Results
Practically the contact trace system provides suspected
(Γ) and also generates the directed edge list (χ) to

10
′

Algorithm 2 TraceContacts(G, I , Γ, L)
Create χ, Q1 , Q2 , l
′
for all P ∈ I do
A ← P (q + 1)
while G.Ψ[A].P ointer 6= N U LL do
′
P ← G.Ψ[A].U ID
′
if P ∈
/ Γ then
′
P .Level ←′ l
Γ←Γ∪P
′
χ ← χ ∪ Edge(P, P )
Q1 ← Insert(Q1 , A)
end if
A←A+1
end while
end for
l ←l+1
while ((l ≤ L) and not (IsEmpty(Q1 ) and
IsEmpty(Q2 ))) do
while (not IsEmpty(Q1 )) do
Q1 ← Delete(Q1, A)
P ← G.Ψ[A].U ID
′
A ← P (q + 1)
while G.Ψ[A′ ].P ointer 6= N U LL do
′
′
P ← G.Ψ[A ].U ID
c1 ← G.Θ[A]
′
c2 ← G.Θ[A ]
′
if P ∈
/ Γ and T raceOperator(c1 , c2 ) then
′
P .Level ←′ l
Γ←Γ∪P
′
χ ← χ ∪ Edge(P, P )
′
Q2 ← Insert(Q2 , A )
′
′
A ←A +1
end if
end while
end while
Q1 , Q2 ←→ Q2 , Q1
end while
return Γ, χ

maintain the infection pathways (Algorithm 2). There
are several general questions from the perspective of
management - how many clusters of infected groups,
list the members of these clusters, the order or pathways of infection spreading, i.e., infectious trees. Only
Γ is not sufficient to meet these requirements. We use
Disjoint Set Data structure (DSD) denoted as F to
address the above queries [32]. Initially, for Σ, F maintains N number of rooted single node disjoint trees all
marked with status ’Free’ and F .EdgeList is empty.
Algorithm of DSD uses the results from the contact
trace algorithm to update F . Here, the F .EdgeList of
the DSD stores all directed edges in χ (suppl. Algorithm 3). Now, using the union − f ind() operation of
DSD, all directed edges in χ are processed to form the

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, DECEMBER 7, 2020

11

final disjoint sets. Nodes are also marked according to
’Infected’ and ’Suspected’. For any individual, f ind()
returns the root of the infection tree, which means
the group or cluster to which the individual belongs.
Further, traversing this rooted tree provides the full
cluster, size of the cluster, and the order of spreading,
i.e., infectious tree. The number of such rooted trees
in the F is the count of the disjoint sets, i.e., the
number of clusters exists presently in the PHA. Each
such cluster is an infection zone with separate active
infections and suspected members under the isolation
process. In this way, when we use the contact tracing
result is stored in a DSD structure, then taking different
management decisions during a pandemic becomes
easy.

q are constant for a particular type of infection, and
hence, we get the space complexity of G is O(N log N ).
For COVID-19 outbreak, we assume for population
of N = 107 , the length of infectious period D = 14
days, minimum time of contact τ = 15 min. To
estimate q , we use statistics from a recent UK based
social contact survey [31]. It suggests that for COVID19 pandemic the average number of contacts (q ) over
14 days is 217. However, only 59 (27%) of contacts
are meeting close contact definition [12], [31]. With
this statistics, we choose q = 64. Hence, the estimated
storage requirements for G using Eq. (3) is:

4

P ERFORMANCE A NALYSIS

4.1 Space complexity analysis
Here, we calculate the space requirement to store the
graph sketch for the D days proximity data of N number of users as adjacency list representation (Fig. 4). We
know G has two parts G.Ψ for index store and G.Θ for
data store and space requirement is denoted as S(G.Ψ)
and S(G.Θ) respectively. We need b = ⌈log2 N ⌉ bits to
access ID of the N number of different users. Next, we
assume in an average there are q number of distinct
close contacts during a time period of D days or n
(n = ⌈ 1440D
⌉) number time slots of duration τ min.
τ
For each user, we store q + 1 number of direct index
records in G.Ψ and for these direct records qN
2 number
contact vectors each of (n + 1) bits (one extra bit for
deletion flag) are stored in G.Θ. To identify each such
contact vector, we require s = ⌈log2 qN
2 ⌉ bits index
in the pointer field of the index record. Therefore, the
space requirement for G.Ψ is

S(G.Ψ) = (q + 1)N (b + s)
= (q + 1)N (2 log N + log q − 1)
= O(N log N )
bits. Similarly, for

qN
2

number of records in G.Θ is

qN
(n + 1) = O(N )
2
bits. Hence, the total space requirement (in bits) is
S(G.Θ) =

S(G) = S(G.Ψ) + S(G.Θ)


q
= N (q + 1)(2 log N + log q − 1) + (n + 1)
2
= O(N log N )
(3)
Study shows that for a very small percentage of cases
overflow area is required [31]. Hence, the additional
memory requirement will be nominal. Here, D, τ , and

S(G) = 107 [(64 + 1)(2 log 107 + log 64 − 1)


1440 × 14
64
+
+1
] × 2−33 GB
15
2
≈ 55 GB as 1GB = 233 bits.
Note that for simplicity, we consider q as a constant,
which implies every node has the same degree. However, in real-world situations q follows a heterogeneous degree distribution [37]. To handle this degree
heterogeneity in the real-world implementations, we
maintain an overflow area in G .
4.2 Time complexity
The system has three parts for the operation - (a)
detecting and then storing of digital close contacts
during stream processing, (b) tracing of multi-level
contacts for a set of infected individuals, and (c) storing tracing results in the disjoint set data structure
to answer different standard management and control
operations.
To detect a close contact in Ω and installation into
G , requires maximum q number array index manipulations. We assume q is constant and independent of N ,
thus average number of computation required for the
processing of Ω is constant and hence, time complexity
is O(1). The G is a ready to use form for contact
tracing. Computation complexity for the preparation
of Γ has two parts - computation counts for direct
list preparation denoted as (Tdirect (q, L, n, N )) and for
indirect list as (Tindirect (q, L, n, N )). Now, we evaluate Tdirect (q, L, n, N ) for given I as follows. For any
infected person P in I , we access at most q number of
consecutive pointer field in G.Ψ array. We know that
one can reach to the beginning of the adjacency list of
P using G.Ψ[P (q + 1)] (section 3.1). Therefore, total
pointer comparison count takes

Tdirect (q, L, n, N ) = q × |I| = O(q|I|)

(4)

However, to prepare the second level contact list, we
perform n bits contact vector comparison to execute σ
for each members in the direct contact list of q × |I|
individuals (Algorithm 2) is q × (q × |I|) , and for

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, DECEMBER 7, 2020
2

third-level it is q × (q × |I|) and so on. Hence, the
total computation complexity for indirect levels is

Tindirect (q, L, n, N ) = n[q × (q × |I|) + q × (q 2 × |I|)
+ . . . + q × (q L−1 × |I|)]
(q L−1 − 1)
= q2 ×
× (|I| × n)
(q − 1)
= O(q L |I|)
Now, for both direct and indirect contact list tracing
computation takes

T (q, L, n, N ) = O(q L |I|)
Finally, for disjoint set representation having |Γ| of
contact trace members with |χ| number edges takes
O(|χ|α(|Γ|)) where α() is the Inverse Ackermann() function, α() ≤ 5 [32]. From the above analysis, we can
show that for COVID-19 contact trace parameters, to
prepare the contact list for a given I , it takes O(|I|)
when q and L are constant.

5

C ONCLUSION

In this article, we design a dynamic graph streaming
algorithm with sophisticated data structures for a digital contact tracing system to mitigate the spreading of
a contagious outbreak under the control of the Public
Health Authority of a country. After receiving the
data stream from the mobile devices, the algorithm
uses a sliding window model to convert continuous
proximity-based device data into the discrete close
contact slots and convert it into a fixed-length bit
pattern and stored in the contact vector. Finally, in the
server, all close contact vectors use to form an efficient
dynamic contact graph sketch. Once the server maintains the close contact graph sketch, our algorithm
prepares the direct and indirect (multilevel) contact
list of the infected persons and stores it in disjoint
sets. We use the index file structure to store the large
contact graph in an array. Here, we use two sliding
windows to process the stream data of mobile devices
and detection of close contacts and another sliding
window used to maintain the close contact vector over
D days period. The first one is implemented as a FIFO
queue, and the second one is implemented as a FIFO
circular queue. Our framework is relevant to general
contact-transmitted diseases like COVID-19 and can
trace digital contact for other relevant infectious diseases by changing the parameters of our algorithm (incubation period and proximity duration of contacts).
Heart of our algorithm is the contact trace operator,
which uses numerical computation over the binary
number stored inside the contact vector to decide the
multilevel contact trace list. Our analysis unveils that
for COVID-19 outbreak close contact parameters, the
storage space requires maintaining the contact graph

12
7

of 10 individuals having 14 days close contact data
in PHA server takes 55 Gigabytes of memory and
prepares the contact list for I takes O(|I|).
The binary representation of close contact is an integral part of our algorithm. Importantly, interactions
between a pair of the individual are annotated as a
binary circular vector to elucidate the communication
in a different time and capture a complete picture
of the social interactions. Therefore, dynamic contact
graph sketch reflects the population dynamics of the
jurisdiction and can be used for further study related
to epidemic dynamics to predict the trajectory of the
spread accurately [19]. Here, we develop the algorithm
relevant to the proximity data of Bluetooth enabled
mobile devices. However, we can easily extend the
algorithm for Global Positioning Systems (GPS) based
sensor data with some modification, and further research [20]. Although our goal is to provide a spaceefficient and easily accessible digital contact tracing
algorithm under the control of PHA and prepare
the direct as well as indirect contact list, however,
considering the virtual ID and binary contact vector,
the algorithm implicitly enforces the privacy of users.
For more details of the privacy concern of the digital
contact trace, we refer to the current articles [18], [38],
[39]. On the other hand, the sliding window model is
space-efficient and can have a further application from
the applied and theoretical perspectives to analyze the
streaming data [40]. We consider the mobility of users
under one PHA. Our model can be extended to design
hierarchical and distributed forms to make this more
manageable and concurrently operable.
The main objective of this Information Technology
(IT) based system is to make solutions feasible to computation, and that can control the further transmission
of diseases. However, as in practical situations, we
should also follow other pre-existing processes like
social distancing, partial lockdown, preventive measures like washing hands, and disinfection to control
infections.

ACKNOWLEDGMENT
Gautam Mahapatra acknowledges Post-graduate Division of Asutosh College, University of Calcutta for
financial support and computational resources. Priodyuti Pradhan acknowledges Bar-Ilan University for
providing Kolman-Soref postdoctoral fellowship.

R EFERENCES
[1] R. Hinch et al., Effective configurations of a digital contact
tracing App: A report to NHSX, 2020.
[2] Singh, Rajesh and Adhikari, Ronojoy, Age-structured impact
of social distancing on the COVID-19 epidemic in India,
arXiv preprint arXiv:2003.12055, 2020.
[3] Karin, Omer et al., Adaptive cyclic exit strategies from lockdown to suppress COVID-19 and allow economic activity,
medRxiv, Cold Spring Harbor Laboratory Press, 2020.

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, DECEMBER 7, 2020

13

[4] Meidan, Dror and Cohen, Reuven and Haber, Simcha and
[28] Ebola
and
Contact
Tracing,
Barzel, Baruch, An alternating lock-down strategy for sushttps://www.cdc.gov/cdctv/diseaseandconditions/outbreaks/ebola-contact-tra
tainable mitigation of COVID-19, Accepted Nature Commu[29] Influenza
(Avian
and
other
zoonotic)
nications, arXiv preprint arXiv:2004.01453, 2020.
https://www.who.int/news-room/fact-sheets/detail/influenza-(avian-and-othe
[5] Mark Zastrow, Coronavirus contact-tracing apps: can they [30] Statista, Smartphone users 2020, Data Access – 03.12.2020.
https://www.statista.com/statistics/330695/number-of-smartphone-users-worl
slow the spread of COVID-19?, Nature, 2020.
[6] Kelly Servick, COVID-19 contact tracing apps are coming to [31] Danon, Leon and Read, Jonathan M and House, Thomas A
and Vernon, Matthew C and Keeling, Matt J, Social encounter
a phone near you. How will we know whether they work?,
networks: characterizing Great Britain, Proceedings of the
Science, 2020.
Royal Society B: Biological Sciences, 280(1765), 2013.
[7] Hellewell, Joel et. al, Feasibility of controlling COVID-19
outbreaks by isolation of cases and contacts, The Lancet [32] Cormen, Thomas H and Leiserson, Charles E and Rivest,
Ronald L and Stein, Clifford, Introduction to algorithms,
Global Health, Elsevier, 2020.
2009, MIT press.
[8] Megan Scudellari, The Pandemic’s Future,Nature News Fea[33] West, Douglas Brent, Introduction to graph theory, 1996,
ture, 2020.
Prentice hall Upper Saddle River, NJ.
[9] World Health Organization and others, Coronavirus disease
[34] Deo, Narsingh, Graph theory with applications to engineer2019 (COVID-19): situation report, 107, World Health Orgaing and computer science, 2017, Courier Dover Publications.
nization, 2020.
[35] Silberschatz, Abraham and Korth, Henry F and Sudarshan,
[10] De Carli, A and Franco, M and Gassmann, A and Killer,
Shashank, Database system concepts, McGraw-Hill New
C and Rodrigues, B and Scheid, E and SchoenbaechYork, 1997.
ler, D and Stiller, B, WeTrace–A Privacy-preserving Mo[36] Garcia-Molina, Hector and Ullman, Jeffrey D and Widom,
bile COVID-19 Tracing Approach and Application, arXiv
Jennifer, Database system implementation, Prentice Hall Uppreprint arXiv:2004.08812, 2020.
per Saddle River, NJ, 2000.
[11] Ferretti, Luca and Wymant, Chris and Kendall, Michelle and
[37] A-L Barabási, Network Science, Cambridge University Press,
Zhao, Lele and Nurtay, Anel and Abeler-Dörner, Lucie and
(2016).
Parker, Michael and Bonsall, David and Fraser, Christophe,
[38] Bengio, Yoshua et. al, The need for privacy with public
Quantifying SARS-CoV-2 transmission suggests epidemic
digital contact tracing during the COVID-19 pandemic, The
control with digital contact tracing, Science 368 (6491), 2020.
Lancet Digital Health, Elsevier, 2020.
[12] Keeling, Matt J and Hollingsworth, T Deirdre and Read,
[39] Mello, Michelle M and Wang, C Jason, Ethics and goverJonathan M, The Efficacy of Contact Tracing for the Containnance for digital disease surveillance, Science 368(6494), 951ment of the 2019 Novel Coronavirus (COVID-19), medRxiv,
954, 2020.
Cold Spring Harbor Laboratory Press, 2020.
[40] McGregor, Andrew, Graph stream algorithms: a survey,
[13] T. TraceTogether, “How does TraceTogether work?”,
ACM SIGMOD Record 43(1), 9-20,
ACM New York, NY,
https://tracetogether:zendesk:com/hc/en-sg/articles/360043543473-How-does-TraceTogetherwork,2020,
USA, 2014.
accessed: 2020-03-23.
[14] , Covid Watch, urlhttps://www.covid-watch.org/, accessed: 2020-05-11, 2020.
[15] , Sydney Von Arx, Daniel Blank, Slowing the Spread of
Infectious Diseases Using Crowdsourced Data, Covid Watch,
2020.
[16] Rivest, R et. al, The PACT protocol specification, 2020.
[17] Privacy-Preserving
Contact
Tracing,
2020.
https://www.apple.com/covid19/contacttracing,accessed:2020-05-11
[18] Government of India, Aarogya Setu Mobile App, 2020.
https://www.mygov.in/aarogya-setu-app/,Accessed:09-05-2020
[19] Oliver, Nuria et. al, Mobile phone data for informing public
health actions across the COVID-19 pandemic life cycle,
American Association for the Advancement of Science, 2020.
[20] Hernández-Orallo, Enrique and Manzoni, Pietro and
Calafate, Carlos T and Cano, Juan-Carlos, Evaluating how
smartphone contact tracing technology can reduce the spread
of infectious diseases: the case of COVID-19, IEEE Access,
2020.
[21] Amit, Moran and Kimhi, Heli and Bader, Tarif and Chen,
Jacob and Glassberg, Elon and Benov, Avi, Mass-surveillance
technologies to fight coronavirus spread: the case of Israel,
Nature Medicine, 2020.
[22] Maxmen, Amy, Can tracking people through phone-call
data improve lives?, Nature, 569(7758), 2019.
[23] Ben
Lovejay,
Turing
algorithms
may
improve
accuracy of Apple/Google contact tracing API, 2020.
https://9to5mac.com/2020/06/29/turing-algorithms/,accessed:2020-06-29
[24] Allen, Danielle, Securing Justice, Health, and Democracy
against the COVID-19 Threat, 2020.
[25] Christina Potter, ’Zero COVID-19 Deaths in Vietnam’,
https://www.outbreakobservatory.org/outbreakthursday-1/7/9/2020/zero-covid-19-deaths-in-vietnam,accessed:2020-07-19
[26] Moneycontrol News, WHO warning on COVID-19:
’Not even close to being over. Worst is yet to come’, 2020.
https://www.moneycontrol.com/news/trends/health-trends/coronavirus-pandemic-worst-is-yet-to-come-who-wars-5480611.html,accessed:2020-0
[27] Bar-On, Yinon M and Flamholz, Avi and Phillips, Rob and
Milo, Ron, Science Forum: SARS-CoV-2 (COVID-19) by the
numbers, eLife 9, e57309 2020.

Supplementary Information: Dynamic Graph Streaming
Algorithm for Digital Contact Tracing
Gautam Mahapatra1,2, Priodyuti Pradhan3 , Ranjan Chattaraj2 , and Soumya Banerjee4

arXiv:2007.05637v3 [cs.DS] 4 Dec 2020

1. Computer Science, Asutosh College, University of Calcutta, Kolkata, West Bengal, India
2. Computer Science and Engineering, Birla Institute of Technology, Mesra, Off-Campus Deoghar, Jharkhand, India
3. Complex Network Dynamics, Department of Mathematics, Bar-Ilan University, Ramat-Gan, Israel
4. Inria EVA, Paris, France & Director Innovation Smart City EU.

Disclaimer: Our digital contact trace management software is in the developing phase. We have
implemented the server-side coding (module 2) as well as the prototype of the mobile app is also
developed. We are preparing a separate manuscript for the details of module 1. Please visit the
GitHub link to download the app and codes https://github.com/OTwo-DCT/OTwoAndroid.

1

Close contact graph evolution

Here, we illustrate the dynamic evolution of the close contact graph G by the sequence of diagrams in Fig.
S1 for Day-1 to Day-6 with five days contact vector. In Day-1 there is a close contact between P6 and P8 , so
queue rear at leftmost position or at zero index of the array and this is c0 . For Day-2, Day-1 is earliest and
Day-2 is the latest, so the Day-1 close contact is now c1 , and for Day-2 it is c0 . Here, array index advances
for one. This process continues up to Day-5. For Day-6, there is no space to store close contact data for this
day. However, we implement this for the latest five days, so the Day-1 contact information exiting from the
front, i.e., zero position of the array, and here latest close contact c0 is stored at this zero-index location and
′
all ci s are shifted one place right, so c4 now appears at array index one and so on. Also, on Day-6, we find
close contact between P6 and P8 is more than five days old and hence automatically disconnected from the
graph. It is also confirmed that P2 and P6 are detected as infected, and contact tracing on this close contact
data from the vectors shows the possible flow of the direct, first level, and second level indirect infection
transmission pathways. Note that P9 first time come in close contact on Day-6, and may get infection of P6
via P1 .

2

Virtual ID distribution by PHA server

A particular jurisdiction has one PHA server that maintains all processing of the automated contact tracing
process. We consider PHA employs Bluetooth enabled smartphones as the representatives of individuals for
the automated data acquisition to implement the digital close contact trace system. Every smartphone user
must have a unique phone number used as the identity of the phone calls and all other services. To maintain
privacy during local Bluetooth communications, it is not possible to know the assigned phone number of a
nearby person comes into social contacts [1]. Hence, our system uses virtual IDs for Bluetooth-based data
acquisitions. After deployment, in a regular interval, the PHA server randomly generates a set of virtual IDs
for whole populations Σ = {P0 , P1 , . . . , PN −1 }. For this purpose, PHA server sub-divided the non-negative
natural numbers (N) into N numbers of non-overlapping sets each of size r(≥ 1), i.e., π = {π1 , π2 , . . . , πN },
where πi = {k1 , k2 , . . . , kr }, πi ∩ πj = ø, |πi | = r, ki ∈ N. The PHA server assigns this pii to the different
′
members in Σ. Consider P and P are two distinct Bluetooth enabled smartphones. Let πP ≡ πi and
′
′
πP ′ ≡ πj assigned virtual IDs sets for P and P respectively. Next, P and P randomly choose ki ∈ πP
′
and kj ∈ πP ′ and used as virtual IDs. As both P and P are having multiple assigned IDs, in a specific
′
period, they can use separate ki and kj as their virtual IDs. Consider P and P are two distinct Bluetooth

enabled smartphones. Now, when both P and P ′ (or others) come in social contact with a minimum (d)
distance confirmed by the Bluetooth signals, respective devices broadcast messages using their virtual IDs
in δ time intervals [2]. During this communication, P receives messages from P ′ with a used virtual ID and
vice-versa. Now each device individually stores and share the send/receive virtual IDs with a timestamp as
a data stream (Ω) to the PHA server to identify the close contact(s). As smartphone uses the virtual id to
communicate, and this will be resolve in the PHA server-side; hence it maintains the users’ privacy.
2.1

Sampling of contacts by the smartphones

To improve the accuracy of the temporal proximity data acquisitions captured by the Bluetooth enabled
devices, the contact tracing system further subdivides each τ minutes time slots into ρ numbers of sampling
time intervals each of δ minutes (τ = δ × ρ, ρ > 1 is a nonzero positive integer). Therefore, for D days
′
n = ⌈ 1440D
⌉ number of data samples are to be processed. Note that close contact and data samples are
δ
different, which means the ρ number of consecutive samples implies one close contact. Now, when both
P and P ′ (or others) come in social contact with a minimum distance (d) confirmed by the Bluetooth
signals, respective devices broadcast messages using their virtual IDs in δ time intervals [2]. During this
communication, P receives messages from P ′ with a used virtual ID and vice-versa. These transmitted and
received messages are locally stored in the device memory and the send/receive timestamp. Finally, devices
pre-process the proximity data locally and send as data stream represented as Ω to the PHA server to
identify the close contact(s).

′

Algorithm 1 Install(G, P, P , ν, λ)
′

[Check for existing contact vector between P and P ]
′
A1 ← Search(G.Ψ, P, P )
if (A1 6= N U LL) then
A ← G.Ψ [A1 ].P ointer
else
[Get an empty contact vector for G.Θ ]
A, G.Θ ← GetContactV ector(G.Θ)
′
[Get an empty record for the edge (P, P ) under adjacency list of P ]
B1 , G.Ψ ← GetIndexRec(G.Ψ, P )
′
[Insert record for the edge (P, P ) ]
′
G.Ψ [B1 ].U ID ← P
G.Ψ [B1 ].P ointer ← A
′
′
[Get an empty record for the edge (P , P ) under adjacency list of P ]
′
B2 , G.Ψ ← GetIndexRec(G.Ψ, P )
′
[Insert record for the edge (P , P ) ]
G.Ψ [B2 ].U ID ← P
G.Ψ [B2 ].P ointer ← A
end if
G.Θ ← Set(G.Θ[A], ν, λ)
return G

3

Contact trace operator (σ)
′

′′

Let us consider c(P,P ′ ) and c(P ′ ,P ′′ ) are two stored contact vectors among three individuals P, P and P
′
(Fig. 2(c)). Now, if P comes outs as laboratory-confirmed infected person then P
P returns true, hence
′
′′
P appears as direct contact trace, but P appears as an indirect contact trace only when we can justify
2

′′

′

that there is possibility of transmission of infection elements from P to P via P . To make a decision, we
need both contact vectors c(P,P ′ ) and c(P ′ ,P ′′ ) . Here, σ act as a binary operator on c(P,P ′ ) and c(P ′ ,P ′′ ) i.e.,
′′
′
′
c(P,P ′ ) σc(P,P ′′ ) . If P has a close contact with P during or after the close contact between P and P within
′
′′
D days then σ returns true, otherwise false. This operator is equivalent to asking whether P
P
P
is true or not.
′

′

Lemma 1. Let c1 = c(P,P ′ ) = cn−1 . . . c0 and c2 = c(P ′ ,P ′′ ) = cn−1 . . . c0 are two nonzero binary
contact vectors. Suppose P is identified as an infection carrier, and val(c1 ) ≥ val(c2 ), then there is
′′
′
a possibility of infection transmission from P to P via P where val(·) returns the decimal value of
the binary contact vector.
Proof. We know that for a binary number weight of the mth bit position (2m ) is always greater than sum of
Pm−1
all weights ( i=0 2i = 2m − 1) at lower significant positions (0 to m − 1). So for the given contact vectors
we can write
cm 2 m >

m−1
X

ci 2i , cm = 1, ∀i, ci ∈ {0, 1}, 1 ≤ m ≤ n − 1

(S1)

i=0

This is also true for c2 . Now, given
val(c1 ) ≥ val(c2 )

(S2)
′′

′

we will show the possibility of infection transmit from P to P via P . If val(c1 ) = val(c2 ) 6= 0, then
′
′
ci = ci , ∀i = 0, . . . n − 1, and ∃i such that ci = ci = 1. This implies in the last D days period while P is in
′
′
′′
close contact with P , then P is also in close contact with P . Therefore, there is a possibility of infection
′′
′
transmission from P to P via P when val(c1 ) = val(c2 ). Now, for val(c1 ) > val(c2 ) (Eq. S2,), we have
two following cases:
Case I: Earliest or most significant m (0 ≤ m < n) number of slots or bits are one. Then considering Eq.
S1 and Eq. S2, we get the following formats for the contact vectors:
c1 = 1 . . . 1cn−m−2 . . . c0
′

′

c2 = 1 . . . 0cn−m−2 . . . c0
′

Now, if m = 0 then, after a close contact between P and P at the earliest slot i.e. at n − 1, there is at least
′
′′
one close contact between P and P at any slot in between 0th to (n − 2)th slot (as val(c2 ) 6= 0). Therefore
′′
′
′
infection transmission from P to P via P is possible. If m > 0 then, while P is in close contact of P , then
′
′′
P is also in close contact of P for one or more time slots, so said infection transmission is always possible.
Case II: Earliest or most significant m (0 ≤ m < n) number of slots or bits are zero. Then considering Eq.
S1 and Eq. S2 we get the following formats for the contact vectors:
c1 = 0 . . . 1cn−m−2 . . . c0
′

(S3)

′

c2 = 0 . . . 0cn−m−2 . . . c0
′

′′

As c2 is nonzero, so there is at least one close contact between P and P after the earliest close contact
′
′′
′
between P and P . Therefore infection transmission from P to P via P is always possible, and hence, the
statement of the lemma is true.
Example 1 – Application of Lemma 1. Let us consider P1 , P2 and P3 three individuals and there are
′
′
edges between (P1 , P2 ) and (P2 , P3 ). Respective nonzero contact vectors are c1 = c7 . . . c0 and c2 = c7 . . . c0
and all are 8 bits. Now using Lemma 1, we like to observe the situations for possible transmission of infection
from P1 to P3 using P2 as via or indirect path. Assume that P1 is detected as an infected person.
3

For (c1 = c2 ): Bit-wise both are equal, and at least for one place corresponding bit values is 1. Let us
consider a situation for this as follows:
c1 = c(P1 ,P2 ) = 10010010
c2 = c(P2 ,P3 ) = 10010010

(S4)

For these bit patterns we find that during time slots c7 , c4 and c1 while P1 is in close contact with P2 , then
P2 is also in close contact of P3 , so infection transmission from P1 to P3 via P2 is possible.
For (c1 > c2 ):
Case I. Earliest or most significant few bits are equal and all are ones. Let us consider a situation for this
as follows:
c1 = c(P1 ,P2 ) = 1110000

(S5)

c2 = c(P2 ,P3 ) = 1100010

For these bit patterns we observe that during time slots c7 and c6 while P1 is in close contact with P2 , then
P2 is also in close contact of P3 . Again, after an earlier close contact between P1 and P2 , at time slot c5
′
there is one latest close contact between P2 and P3 at time slot c1 . Therefore, through these close contacts
infection may transmit from P1 to P3 via P2 .
Case II. Earliest or most significant few bits are equal and all are zeros. Let us consider a situation for this
as follows:
c1 = c(P1 ,P2 ) = 0010001

(S6)

c2 = c(P2 ,P3 ) = 0000110

For these bit patterns we observe that after earliest close contact between P1 and P2 at time slot c5 , there
′
′
is two later close contacts between P2 and P3 at consecutive time slots c2 and c1 . Therefore, through these
close contacts infection may transmit from P1 to P3 via P2 .
By this example, we show that when c1 ≥ c2 then infection transmission is possible through the indirect or
via a path, and hence the Lemma 1.
′

′

′

Lemma 2. Let c1 = c(P,P ′ ) = cn−1 cn−2 . . . c0 and c2 = c(P ′ ,P ′′ ) = cn−1 cn−2 . . . c0 are two nonzero
contact vectors. Suppose P is identified as infection carrier. Then, there is no infection transmission
′′
′
between P and P via P i.e., c1 σc2 returns false, only when all three conditions (a) val(c2 ) >
val(c1 ), (b) earliest or most significant m (0 ≤ m < n) number of bits are equal and all are zeros,
′
′
and (c) there is no earlier close contact between P and P before the latest close contact between P
′′
and P are satisfied where val(·) returns the decimal value of the binary contact vector.
Proof. For nonzero contact vectors, with val(c1 ) < val(c2 ) (condition (a)), if earliest or most significant
′
m ≥ 1 bits are equal and all ones, then during earliest m time slots, while P and P are in close contact,
′
′′
′′
′
then P and P are also in close contact, and hence infection transmission from P to P via P is possible
and we stop here. For conditions (a) and (b), if earliest or most significant m (0 ≤ m < n) number of bits
are equal and all zero, then we may discard these bits. After discarding we get contact vectors of the form
c1 = 0cn−m−2 . . . c0
′

(S7)

′

c2 = 1cn−m−2 . . . c0
′

′′

′

in view of S1. Now, let at latest j th time slot there is a close contact between P and P . That means cj = 1,
′
′
and cj−1 . . . c0 = 0 . . . 0. Also, there is an earliest ith time slot where there is a close contact between P and
′
P . That means cn−m−2 . . . ci+1 = 0 . . . 0 and ci = 1. For ∀i, j ∈ {0, 1, . . . n − m − 2}. Now, if i ≥ j, then
′
′
the condition (c) fails, and after a close contact between P and P there is a close contact between P and
4

′′

′′

′

P , so infection transmission from P to P via P is possible. But, if i < j, then there is no close contact
′
′′
′
between P and P after any close contact between P and P . Therefore infection transmission from P to
′
P is not possible, and hence the Lemma statement is true.
Example 2 – Application of Lemma 2. Let us consider P1 , P2 and P3 three individuals, and there are
′
′
edges between (P1 , P2 ) and (P2 , P3 ). Respective nonzero contact vectors are c1 = c7 . . . c0 , and c2 = c7 . . . c0 ,
and all are 8 bits. Now using Lemma 2, we like to observe the situations for possible transmission of infection
from P1 to P3 using P2 as via or indirect path. Assume that P1 is detected as an infected person.
Conditions (a) val(c2 ) > val(c1 ) (b) earlier or most significant bits are equal and all are zeros.
Let us consider one such situation:
c1 = c(P1 ,P2 ) = 00000011
c2 = c(P2 ,P3 ) = 00100100

(S8)

For these bit patterns we observe that the latest close contact between P2 and P3 occurs at the time slot
′
c2 , and the earliest close contact between P1 and P2 occurs at c1 time slot, which is not before latest close
contact of P2 and P3 and hence condition (c) is satisfied for Lemma 2. Therefore, all three conditions are
satisfied, and transmission of infection from P1 to P2 via P2 is not possible. Again, let us consider another
such situation:
c1 = c(P1 ,P2 ) = 0001011
c2 = c(P2 ,P3 ) = 00100100

(S9)

Here, conditions (a) and (b) for Lemma 2 are true, whereas (c) fails, that means we get an earliest close
contact between P1 and P2 at time slot c3 which is before the latest close contact between P2 and P3 at the
′
time slot c2 , and hence infection transmission is possible from P1 to P3 via P2 .
Conditions (a) val(c2 ) > val(c1 ) (b) earlier or most significant bits are equal and all are ones.
then while P1 is in close contact with P2 , then P2 is also in close contact of P3 . Therefore, through these
close contacts infection may transmit from P1 to P3 via P2 . Therefore, through Lemma 2 it is possible to
know at which situation infection transmission via indirect path is not possible.
3.1

Implementation of σ

The pseudo-code (Algorithm 2) is the simple implementation of σ operator. Here c1 and c2 are two input
contact vectors passed as input parameters. Now, using these two contact vectors, our contact trace operator
′′
′
′′
decides whether P is getting an infection from P via P or not, and accordingly, we can include P into the
contact trace list (Γ ). This implementation of the σ operator uses the equivalent decimal integer values of
the binary contact vectors and then Lemma 1 and 2 for the processing. Here, v1 and v2 are respectively the
decimal equivalent of c1 and c2 . After conversion here we try to validate through the condition of Lemma
1, i.e. v1 ≤ v2 . If fails, then we apply the conditions for the Lemma 2. Here, earliest close contact for c1
(i.e. left most 1 in c1 ) and latest close contact for c2 (i.e. right most 1 in c2 ) both are determined by the
sequential traversal of the contact vectors. Finally, it returns either true or false. Note that if number is
negative then all most significant bits are ones, otherwise zeros. This can be used for the checking whether
most significant nth bit is 1 or not (here n is the length of the contact vector).

4

Security and Privacy Issues

For our system, the graph sketch (G) is holding individuals’ contact data in a binary encoded form (contact
vector - c). This encoded contact data is a location independent data model of the whole social contact
structure (Σ) under the custody of the concerned PHA. Using suitable private key cryptography, we can
easily protect the whole graph data from corruption. Locally captured discrete contact data is also not storing
5

Algorithm 2 TraceOperator(c1, c2 )
[Convert binary contact vectors c1 and c2 into equivalent decimal integers]
v1 ← val(c1 )
v2 ← val(c2 )
[Process the trivial indirect transmission]
if v1 ≥ v2 then
return true
end if
[Process the non-trivial indirect transmission]
if c1 [n − 1] = 1 and c1 [n − 1] = c2 [n − 1] then
return true
end if
[Sequentially process the earliest and latest close contacts from c1 and c2 ]
i ← Earliest Close Contact of c1
j ← Latest Close Contact of c2
if i > j then
return false
else
return true
end if

any location data and the actual time of contact. Our system only uses samples proximity-based presence
of two low-power Bluetooth enable mobile phones and captures as locally stored discrete contacts. It uses
randomly selected virtual-ID from a set of virtual-IDs assigned by the PHA server and updated regularly for
privacy reasons. With these brief descriptive views, we can justify the system’s reliability after maintaining
security and privacy measures.
Algorithm 3 BuildDisjointSet(F , χ, I, Γ )
[Process each directed edges in χ]
while (χ 6= φ) do
[Get next edge from input edge list]
ξ ← RemoveN ext(χ)
[Store the edge in the edge list of F]
A ← Insert(F.EdgeList, ξ)
[Use F ind() operation to locate the root nodes for both the nodes of the edge]
i ← F ind(F, ξ.P )
′
j ← F ind(F, ξ.P )
[Check for cycle formation]
if i 6= j then
[When there is no cycle, then use U nion() operation for merging the trees for the nodes of the edge]
F ← U nion(F, i, j, A)
end if
end while
return F

References

[1] T. TraceTogether, “How does TraceTogether work?”, https://tracetogether:zendesk:com/hc/en-sg/articles/360043543473-Ho
accessed: 2020-03-23.
[2] Zhong, Xin, Bluetooth Low Energy Application in home automation, 2019.

6

Fig. S1. Dynamic evolution of close contact graph for six days.

7

Fig. S2. Illustration of contact tracing!

8

(a)

(b)
Fig. S3. Illustration of contact tracing!

Fig. S4. Infection pathways. χP2 = {(P2 , P8 ), (P2 , P7 ), (P2 , P0 ), (P0 , P5 ), (P5 , P3 )} where (Pi , Pj ) represents Pi transmits infection to Pj , holds the infection transmission pathways. Similarly, χP6 = {(P6 , P1 ), (P1 , P4 ), (P1 , P9 )}.

9

Fig. S5. Illustration of the array-based circular queue implementation using modular-arithmetic for sliding window
of the contact vector c(P,P ′ ) in G. For simplicity, we consider D = 5 days, τ = 1 day, so size of the contact vector is
n = 5. After D days c(P,P ′ ) attends the full length. Here, c = 0 means there is no close contact during the latest D
days, so the possibility of infection transmission is nullified, and hence respective edge will be removed. However, they
may come in close contact again. A new contact vector will be formed after synchronization with system deployment
time.

10

