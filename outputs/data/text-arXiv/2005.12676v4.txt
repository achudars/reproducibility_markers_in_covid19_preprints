SNARKs to the rescue: proof-of-contact in zero knowledge

arXiv:2005.12676v4 [cs.CR] 20 Jul 2020

Zachary Ratliff and Joud Khoury
Raytheon BBN Technologies

Abstract

differing privacy guarantees. We refer the reader
to [3] for a recent survey. The systems fall into two
general categories based on their information flows:
decentralized vs centralized. With decentralized approaches, a user’s mobile device generates ephemeral
randomized tokens that are regularly broadcast to
(and received by) nearby mobile devices. Devices
save the tokens they broadcast and the ones they
receive for a defined period of time. Once an individual tests positive, she can opt to report all the
tokens her application generated. Reporting is done
with the help of the healthcare provider or some third
party. Other individuals who saw the token, and accordingly were in close physical proximity to the infected individual, learn they are at-risk and may seek
testing and/or quarantine as a result. Centralized
approaches are similar, except a central server generates the ephemeral tokens that users share with each
other and reporting involves the central server making the connections and alerting users.

This paper describes techniques to help with COVID19 automated contact tracing, and with the restoration efforts. We describe a decentralized protocol for
“proof-of-contact” in zero knowledge where a person
can publish a short cryptographic proof attesting to
the fact that they have been infected and that they
have come in contact with a set of people without
revealing any information about any of the people involved. More importantly, we describe how to compose these proofs to support broader functionality
such as proofs of nth-order exposure which can further speed up automated contact tracing. The cryptographic proofs are publicly verifiable, and places
the burden on the person proving contact and not
on third parties or healthcare providers rendering
the system more decentralized, and accordingly more
scalable.

1

Introduction

The majority of these existing proposals for automated contact tracing are slow to react and do not
adequately address exposure risk. Specifically, they
only alert the first level of individuals who have come
in close contact with the infected individual after the
latter tests positive. Such first order contact tracing
may not be fast enough to control the spread of the
virus in a timely manner given that there is a period
of time in which individuals can be asymptomatic but
contagious, and this period could be longer than the
virus incubation period. Consider for example the
following scenario. Alice is asymptomatic but contagious at time t0 and comes in contact with Bob. Bob
gets infected and comes in contact with Charlie at
time t1 ≥ t0 + PI where PI is the virus incubation
period. Alice starts showing symptoms and tests pos-

Contact tracing, identifying and notifying individuals who have been in close contact with an infected
person, is widely recognized as an essential tool in
protecting against the spread of the novel COVID19 virus. Automated approaches to contact tracing can help significantly scale the effort relative to
manual approaches alone which tend to be slower
and more labor intensive. Implementations of automated contact tracing systems must however address
the privacy concerns of individuals in order to enjoy
widespread adoption, something that early straightforward attempts failed to do [1, 2].
There is a large body of recent proposals for automated Bluetooth-based contact tracing systems with
1

itive at time t2 ≥ t1 , at which point Bob gets notified.
Bob may not show symptoms, may wait to get tested,
or may not even get tested. Even if Bob gets tested
at time t3 > t2 , there is a period of time (could be
several days) during which Charlie is not even aware
of the exposure risk, and is going about his business
as usual.
We propose a new protocol for privacy-preserving
contact tracing that does not suffer from these limitations. Our protocol permits an individual A who
tests positive to quickly furnish a cryptographic proof
attesting to the the following statements:

the virus” and so on, but nothing else such as who
the person is or where the interaction occurred (with
some caveats discussed later in the paper). Our approach is fully decentralized requiring little assistance
from the healthcare provider, and may be extended to
support broader functionality. We start by describing
the simple proof-of-contact protocol, and extend it to
support nth-order exposure by composing proofs of
contact using proof-carrying data (PCD) [4].
In summary, our protocol offers the following benefits:
• Efficiency is achieved using an efficient preprocessing zkSNARK construction and performing the signature verification outside the
SNARK to reduce prover cost [5]. In the case of
nth-order exposure proofs, signature verification
occurs inside the zkSNARK, however, an arithmetic circuit friendly digital signature scheme is
used to reduce circuit size.

1. individual A was in close proximity to individual
B at some time t
2. individual A tested positive for the virus at time
t0
3. t0 is within x days of t

• No trusted third parties or databases required.
The public registry need not be trusted. We only
require that the zkSNARK for the desired functionality is correctly setup.

in zero knowledge i.e., without leaking information
about A or B. A produces and publishes the proof.
Anyone, including, B can publicly verify the proof,
and seek testing if the proof checks and they are involved. Using this first proof, individual(s) B who
came in close proximity to A can then quickly publish a cryptographic proof attesting to the fact that
B was in close proximity to the individual who tested
positive (in this case A), and that B was in close proximity to other individual(s) C at t00 ≥ t + PI . This
allows individual(s) C who came in close proximity to
B to realize their exposure risk in a timely manner,
and act accordingly.
Our protocol relies on zero-knowledge succinct non-interactive arguments of knowledge (zkSNARKs) as the cryptographic building block. The
protocol builds on existing Bluetooth-based decentralized approaches and allows clients to provide a
cryptographic proof of proximity after a positive diagnosis. These cryptographic proofs are succinct,
consisting of only a few hundred bytes, and take just a
few milliseconds to verify. The zero knowledge property ensures that a person verifying these proofs only
learns the statement “I was close to someone who
tested positive for the virus” or “I was close to someone who was close to someone who tested positive for

• Strong end-to-end privacy guarantees. Proximity tokens are not shared; not with third parties
nor with healthcare providers.
• Correctness. A valid proof guarantees the authenticity of the user’s test results and the validity of the statement.
• Adoption/Practicality. A medical organization
only needs to sign records using an existentially unforgeable and publicly verifiable signature scheme. This is a simple task for the medical organization and it deters malicious (noninfected) users from seeking signatures.
• Decentralization. The burden is on the infected person to actually prove and publish.
This allows better scaling (instead of requiring
providers or third parties to centrally manage
patient proximity data) and potentially better
privacy since the user (the stakeholder) has full
control over their private data and can share at
will.
2

• nth-order exposure notifications. nth-order exposure risk is available in a timely manner
through proof composition. This allows users
who may have had secondhand contact (or beyond) with an infected individual, to learn in
zero-knowledge about this exposure.

2
2.1

A preprocessing zkSNARK for F-arithmetic circuit
satisfiability comprises three algorithms (G, P, V ),
corresponding to the Generator, the Prover, and the
Verifier.
G(λ, C) → (pk, vk) Given a security parameter λ and
the F-arithmetic circuit C, sample a keypair
comprising a public proving key pk and a public
verification key vk.

Background
Proximity Tokens

P (pk, x, a) → (π) Given the public prover key pk and
any (c, a) ∈ RC , generate a succinct proof π atContact tracing requires monitoring and recording
testing that x ∈ LC
physical interactions between clients. For example,
if Alice walks into a cafe where Bob is eating, a
method for detecting and measuring their proximity V (vk, x, π) → b ∈ {0, 1} checks that π is a valid proof
for x ∈ LC .
is needed. There have been several works proposing
various means of proximity sensing between mobile
phones, including using Bluetooth [6], WiFi [7], and
2.3 Proof-carrying data
audio [8] signals.
Regardless of the underlying technology, we asProof-carrying data (PCD) captures the security
sume a mobile phone frequently broadcasts proximguarantees necessary for recursively composing zkity tokens that are received by nearby phones. For
SNARKs.
Q More specifically, given a compliance predexample, within each epoch, the phone frequently
icate , a PCD system checks that a local compubroadcasts its unique token, and receives tokens from
tation involving a set of incoming messages z~in , prinearby phones. This simplified model has been
vate
local data zloc , and outgoing message zout , is
adopted by the majority of decentralized privacy- Q
-compliant.
preserving contact tracing protocols [3].
Formally, a proof-carrying data system consists
of three polynomial-time algorithms (G, P, V ) corre2.2 Preprocessing zkSNARK
sponding to the Generator, Prover, and Verifier.
We review the definitions of arithmetic circuits, preprocessing zero knowledge succinct non-interactive
arguments of knowledge (pp-zk-SNARKs) and we refer the reader to [9] for details.
First, we introduce arithmetic circuit satisfiability
in Field F. An F-arithmetic circuit C : Fn × Fh → Fl
is defined by the relation RC = {(x, a) : C(x, a) =
0l }. Here a is called the witness (auxiliary input)
and x is the public input and the output is 0l . The
language of the circuit is defined by LC = {x :
∃a, C(x, a) = 0l }. Here x ∈ Fn (i.e., x is represented
as n field elements), a ∈ Fh , and the output in Fl .
A hashing circuit for example takes the (private)
input/witness a and its hash x, and asserts that
H(a) = x.

Q
G(λ, ) → (pk, vk) Given a security
Q parameter λ
and the compliance predicate
expressed as a
F-arithmetic circuit, sample a keypair comprising a public proving key pk and a public verification key vk.
P (pk, z~in , π~in , zloc , zout ) → (zout , πout ) Given the
public prover key pk, a set of input messages
z~in along with compliance proofs π~in , local input
zloc , and output zout , generate
Q a succinct proof
πout attesting that zout is -compliant.
V (vk, z, π) → b ∈ {0, 1} checks that zout is
compliant.
3

Q
-

3

Proof-of-Contact Protocol

2. TA = H1 (S, t)
3. h = H2 (TA , TB , t)

Consider an existentially unforgeable signature
scheme S = (GS , SS , VS ) (e.g., ECDSA) with private
signing key vs and public verification key ps . Let
H, H1 , H2 be three collision-resistant hash functions,
and let (G, P, V ) be a pp-zk-SNARK. The baseline
protocol builds on [10] and works as follows:

4. t0 − t ≤ 14 days
• User A publishes tuple (π, h, hs , s) to some public registry. If the public registry already contains a tuple with the value h, then the user does
not upload these values (in order to prevent linkability). Several techniques may be used here for
network unlinkability (e.g., the user app can either use mixing or onion routing solutions, or
the provider can publish the material on behalf
of the user).

• Trusted setup phase: a trusted entity sets up
the system and runs the generator algorithm
G(λ, C) → (pk, vk); we describe the circuit C
in more detail shortly. During this phase, each
healthcare provider obtains a certificate for its
signing key signed by a trusted certification authority.

• User B checks the public registry periodically
to find a matching h and can quickly verify
the proof using V (vk, (h, hs ), π). If the proof
checks, user B verifies the signature VS (ps , s, hs )
given hs and the public verification key ps of the
healthcare provider.

• Each user generates a private random string S
• User A generates a random token every time
period t (the epoch e.g., 5 minute intervals) as
TA,t = H1 (S, t), and frequently broadcasts the
token. We omit the time subscript hereafter
whenever it is clear.

• User B seeks testing, and can show the proof-ofcontact to her healthcare provider to expedite
the process if needed.

• Whenever user A receives a proximity token from
user B at time t, she computes h = H2 (TA , TB , t)
and stores it for 14 days. User B computes the 3.1 Security Analysis
same output. Here we sort the tokens (e.g., lex- Linkability Tokens are never shared, or published.
icographically) before passing them to the hash
Only the hash of two tokens is published after
function.
a user tests positive. This means different tokens may not be linked as belonging to the same
0
• User A tests positive for the virus at time t ,
user. The same is true with linking different
and obtains a “COVID.positive” test result from
hashes. Recall when reporting a positive test,
a medical provider. User A computes hs =
user A publishes h = H2 (TA , TB , t) for all prox0
H(S, COVID.positive, t ) and requests signature
imity edges. Only user B or some dishonest user
s = SS (vs , hs ) from the healthcare provider
C who forms a clique with A and B at time t
where vs is the provider’s private signing key.
may learn h. Since user C is part of the clique,
Note that user A does not have to reveal her
h does not leak additional information. User C
secret S to the provider. User A may procannot use h to create valid proofs on behalf of A
vide hs only, and a cryptographic proof that
or B without knowledge of their private strings
0
hs = H(S, COVID.positive, t ) for some valid priS.
vate witness S.
• User A then generates a short cryptographic Identification After seeing a proof containing h, a
curious user B who keeps track of all physical
proof using P (pk, (h, hs ), (S, TA , TB , t0 )) → π atencounters can a posteriori identify the infected
testing to these facts
person in some form. This attack is common
1. hs = H(S, COVID.positive, t0 )
to the majority of the decentralized systems [3].
4

We observe that some form of this leakage is inherent to the protocol. For example, if user B
has only encountered one person before getting
alerted, user B will be able to identify the infected person no matter how privacy-preserving
the alert/protocol is. This may be acceptable in
some cases, for example, learning that the “tall
person in the dairy aisle at the grocery store”
tested positive. A more recent decentralized protocol that mitigates identification attacks has
been proposed using “parroting” [11]. We believe the general idea presented in this paper can
be applied to this class of protocols as well.

positive) and can quickly verify the proof using V (vk, (hi , hs ), π). If the proof checks, user B
verifies the signature VS (ps , s, hs ) given hs and
the public verification key ps of the healthcare
provider.
• User
B
then
generates
a
short
cryptographic
proof
using
P (pk2 , (hi , hj ), (S, TA , TB1 , TB2 , TC ))
→
π
attesting to these facts
1. hi = H2 (TA , TB1 , t1 )
2. hj = H2 (TB2 , TC , t2 )
3. t2 − t1 ≤ 3 days

4

• User B publishes tuple (π, hi , hj ) to the public
registry.

Transitive exposure proofs

As discussed earlier, it can be beneficial to provide
more granular nth order exposure risk data to users
to limit the spread of the virus. For example, a user
may want to know whether they have had transitive
exposure to a virus. Consider that Alice comes in
contact with both Bob and Charlie independently of
one another. Later, Bob tests positive for the virus,
and Alice is alerted that she is at risk. Although
Charlie did not directly come in contact with a carrier of the virus, he may find it useful to know that
someone he came in contact with has. This transitive
approach to contact tracing could enable more informative statistics for users such as a risk profile, i.e., a
risk score based on how many degrees of exposure an
individual has. Someone who is four transitive hops
away from a virus carrier would be at lower risk from
someone who is two hops away.
A strawman approach to extending the proof-ofcontact protocol for transitive proofs works as follows:

• User C checks the public registry periodically
to find a matching hj and can quickly verify
the proof using V (vk2 , (hi , hj ), π). If the proof
checks, user C can recursively verify the next
proof in the chain until eventually arriving at
the original proof. Finally, user C verifies the
original proof using V (vk, (hi , hs ), π).
Observe that in this case the zkSNARK includes
the constraint t2 − t1 ≤ 3, corresponding to the 3
day incubation period of COVID-19. This parameter is configurable, however, in general the time that
Bob comes in contact with Charlie should come after the time Bob came in contact with Alice plus the
incubation period. This will reduce the number of
false positives that arise when Bob alerts Charlie of
2nd-order exposure even though Bob could not have
possibly become contagious from Alice yet.

4.1

• As in the original protocol, a trusted entity sets
up the system and runs the generator algorithm
G(λ, C2 ) → (pk2 , vk2 ); here C2 is an additional
circuit with corresponding prover and verifier
keys (pk2 , vk2 ), for proving transitive exposure.

Transitive exposure using proofcarrying data

The above protocol suffers from a linkability flaw with
the uploaded (hi , hj ) pairs. An adversary observing
the public registry can deduce that whoever uploaded
the tuple (π1 , hi , hs , s) must have came in contact
with the person who uploaded the tuple (π2 , hi , hj ),
since hi is present in both tuples. In order to circumvent this drawback, we modify the protocol to

• User B checks the public registry periodically to
find a matching hi (from some user A who tested
5

use proof-carrying data (PCD). Using PCD, previous proofs in the chain are verified and a proof that
this verification was performed correctly is provided.
The PCD system hides the details of intermediate
proofs, while allowing a user to verify that the entire
chain is valid. Instead of uploading the pairs (hi , hj ),
transitive proofs consist only of single h values which
are indistinguishable from random.
For proof-of-contact,
we represent the compliance
Q
predicate
as the hospital signature verification al- Figure 1: Overview of proof-carrying data for transigorithm VS (ps , s, hs ), coupled with the steps neces- tive exposure
sary to prove that the randomness of hi is consistent with the randomness of some hj . More formally,
a user who tested positive can perform the 4.2 Proofs of surface transmission via
Q
PCD
-compliant computation M0 that takes as input
z~in = (hs , s, ps ), zloc = (S, t, t0 , TA , TB1 ) and outputs
In some cases, contact tracing by measuring proximhi satisfying the following constraints:
ity between users may not be sufficient for effectively
curbing the spread of a virus. A virus that lives for
1. hs = H(SA , COVID.positive, t0 )
extended periods on surfaces could transmit from one
2. TA = H1 (S, t)
user to another even though they have never been in
close contact. For example, if a contagious user Alice
3. hi = H2 (TA , TB1 , t)
sits on a park bench, Bob, who visits the park the
next day, may become infected from sitting on the
4. t0 − t ≤ 14 days
same bench. If Alice tests positive, it would be ideal
5. VS (ps , s, hs ) = 1
that users who are at risk from the surface spread of
the virus are alerted.
The user then uploads the value hi along with
Q
One approach is to place Bluetooth devices around
a cryptographic proof attesting that M0 is
public spaces, and have them participate in the concompliant.
tact tracing protocol. The devices could exchange
For proving transitive exposure, a user B who sees
tokens with users and verify proofs in the usual way.
the value hi along with the PCD proof
Q πi attest- After discovering a matching token in the public reging to first-hand exposure, performs the -compliant
istry, and verifying the corresponding proof, the decomputation M1 that takes as input z~in = (hi , πi ),
vice uploads a transitive proof of exposure, which
zloc = (t1 , t2 , TA , TB1 , TB2 , TC ) and outputs hj satisalerts users of the surface transmission risk.
fying the following constraints:
Suppose rather than using PCD, the Bluetooth device on the park bench simply uploads its secondary
1. hi = H2 (TA , TB1 , t1 )
tokens after a user Alice tests positive, i.e., the to2. hj = H2 (TB2 , TC , t2 )
kens exchanged with other users within 14 days of
Alice’s park visit. Although these users are alerted
3. t2 − t1 ≤ 3 days
of surface contact risk, they must trust that the park
Additionally, user B runs a verifier circuit bench device is acting honestly since there is no way
over πi and provides a cryptographic
proof that of verifying that Alice actually came in contact with
Q
V (vk, hj , πi ) = 1 and M1 is -compliant. Figure the park bench. By using PCD, the transitive proofs
1 illustrates the complete flow from proof-of-contact maintain the security and privacy guarantees from
the single-hop contact tracing protocol.
to proof of transitive exposure.
6

5

Implementation challenges

5.3

Choice of digital signature scheme
for transitive exposure proofs

In this section we describe the various challenges asEnabling nth-order exposure notifications requires
sociated with implementing our approach in a realencoding a digital signature scheme inside the comworld system.
pliance predicate. Without careful consideration of
the scheme used, this can significantly increase the
size of the compliance predicate, resulting in a pro5.1 Anonymization of network traffic hibitive proving time. For this reason, we choose the
RSA digital signature scheme which can be represented efficiently over Fp by choosing public expoA passive adversary that has the ability to view a
nent e = 3 and performing modular multiplication
√
large portion of network traffic may de-anonymize
via radix b pc arithmetic as suggested by Naveh and
users as they interact with the public registry. For
Tromer [5].
instance, if a user uploads their proofs from a home
router, an adversary may be able to determine which
individual tested positive based on network traffic
6 Performance Evaluation
analysis alone.
Similar to other works [10], we propose using Tor for efficient anonymization of the uploading/downloading of proofs. For more stringent privacy guarantees (such as those which would thwart
a nation state adversary), techniques from metadata
private messaging protocols could be used [12] [13]
[14] [15] [16] [17].

5.2

We implemented a simplified proof-of-contact zkSNARK (without recursive composition) using the
libsnark library [20]. The library uses the NPcomplete language R1CS to express the arithmetic
circuits representing the zkSNARK. The libsnark
library provides existing R1CS gadgets for performing useful functionality, such as comparisons
and collision-resistant hashing. Additionally, it includes an implementation of the subset-sum collisionresistant hashing gadget, which we use as an efficient
one-way hash.
We characterize the performance of our proof-ofcontact zkSNARK in terms of the running time and
key sizes for both the prover and verifier (Table 1).
Since the generator phase is only executed once during setup, we provide concrete numbers on the size of
the arithmetic circuit (3060 gates) but disregard the
time of the generator (166 ms). The circuit did not
account for sorting.

Trusted setup

A big question with pre-processing zero-knowledge
SNARKs, is which entity performs the trusted setup
(generator) phase. One approach is for several community organizations to perform a secure multi-party
computation (MPC) protocol. For example, the
World Health Organization (WHO), Massachusetts
General Hospital (MGH), and National Institute of
Health (NIH) could jointly compute the trustedsetup, and users would have high confidence in the
systems security - as long as they trust that these Table 1: Performance of pp-zk-SNARK implementaparties will not collude with one another.
tion on MacBook Pro with 2.9 GHz Intel core i9 and
Alternatively, we could instantiate the system with 32 GB RAM
Prover Verifier
a transparent zero-knowledge SNARK scheme such
Running time (ms)
65
9
as [18] [19]. These zkSNARKs do not require a
Key
size
(KB)
722
30
trusted setup, however, this benefit comes at the cost
of larger proof sizes.
7

7

Related Work

der the ReBabbler paradigm, we note that producing
individual proofs of contact requires work on behalf
of the person reporting infection. This is especially
true for proofs of nth-order exposure, where the cost
of producing a proof is further amplified. The computational burden of uploading many proofs of contact
may discourage sybil attacks while adhering to the
”upload what you’ve sent” architecture. Additionally, while we our protocol is built upon the “rebabbling” variant, we believe that the general idea is still
applicable to the more private “parroting” variant.
We leave this for future work.
All of the approaches described above provide different flavors of privacy and decentralization. However, each solution places an increased burden on the
healthcare providers relative to the zero-knowledge
SNARK technique we have outlined. Our approach
requires only that healthcare workers sign positive
diagnoses rather than generate one-time codes or upload tokens to a public registry. Additionally, our
approach is fully decentralized and supports broader
functionality such as proofs of nth-order exposure,
not currently supported by the other proposed solutions.

There has been a flurry of work on privacy-preserving
automated contact tracing [21] [22] [10] [11] [23] [24]
[25] [26] [27] [28] [29]. Although most of these works
suggest similar techniques for estimating and exchanging proximity information between users, the
underlying cryptographic protocols and their privacy
guarantees differ.
[10] [22] [24] use randomly generated pseudonyms
that nearby users can exchange over Bluetooth. Individuals who test positive for a virus can upload
their generated pseudonyms to a public registry, allowing other users to match the tokens they have collected with those in the registry. The authors suggest
that healthcare workers should be the ones to upload
users’ tokens to the public registry after giving a positive test diagnosis in order to prevent malicious polluting of the database. Similar to the protocol introduced in this work, mixing can be applied to prevent
linkability via traffic analysis.
Apple and Google have released a protocol specification [25] that closely resembles that of [10] [22]
[24]. Users generate a rolling pseudorandom identifier and some associated encrypted metadata, that
nearby users exchange over Bluetooth. The pseudorandom identifiers are derived using the current time
and temporary exposure keys, which get distributed
after a positive diagnosis.
[26] proposes partitioning GPS and time data
into discrete spatiotemporal points and obfuscating
these points using a one-way hash function. Infected
users upload their obfuscated location histories after
redacting personally identifiable information such as
the GPS coordinates that represent a home or work
address. Using private-set intersection (PSI), individuals can privately determine whether or not their
location history overlaps with that of infected users.
More recently, [11] performs a security analysis of
existing contact tracing approaches and groups [21]
[25] [10] [22] [28] [23] together under the ”upload
what you’ve sent” paradigm, or ReBabblers. These
approaches are overall less secure than a ”upload
what you’ve heard” (parroting) alternative presented
in [11], which prevents inverse sybil attacks [3] [28].
Although the scheme presented in this paper falls un-

References
[1] “Help
speed
up
contact
tracing
with
tracetogether,”
2020.
[Online].
Available:
https://www.gov.sg/article/
help-speed-up-contact-tracing-with-tracetogether
[2] H. Cho, D. Ippolito, and Y. W. Yu, “Contact tracing mobile apps for covid-19: Privacy
considerations and related trade-offs,” arXiv
preprint arXiv:2003.11511, 2020.
[3] S. Vaudenay, “Centralized or decentralized? the
contact tracing dilemma,” Cryptology ePrint
Archive, Report 2020/531, 2020, https://eprint.
iacr.org/2020/531.
[4] A. Chiesa and E. Tromer, “Proof-carrying data:
Secure computation on untrusted platforms
(high-level description),” The Next Wave: The
8

[5]

[6]

[7]

[8]

[9]

National Security Agency review of emerging [13] H. Corrigan-Gibbs, D. Boneh, and D. Mazières,
technologies, vol. 19, no. 2, pp. 40–46, 2012.
“Riposte: An anonymous messaging system
handling millions of users,” in 2015 IEEE SymA. Naveh and E. Tromer, “Photoproof: Cryptoposium on Security and Privacy. IEEE, 2015,
graphic image authentication for any set of perpp. 321–338.
missible transformations,” in 2016 IEEE Symposium on Security and Privacy (SP). IEEE, [14] A. Kwon, D. Lu, and S. Devadas, “{XRD}:
Scalable messaging system with cryptographic
2016, pp. 255–271.
privacy,” in 17th {USENIX} Symposium on
S. Liu, Y. Jiang, and A. Striegel, “Face-to-face
Networked Systems Design and Implementation
proximity estimationusing bluetooth on smart({NSDI} 20), 2020, pp. 759–776.
phones,” IEEE Transactions on Mobile Comput[15] L. Kissner, A. Oprea, M. K. Reiter, D. Song,
ing, vol. 13, no. 4, pp. 811–823, 2013.
and K. Yang, “Private keyword-based push and
P. Sapiezynski, A. Stopczynski, D. K. Wind,
pull with applications to anonymous communiJ. Leskovec, and S. Lehmann, “Inferring personcation,” in International Conference on Applied
to-person proximity using wifi signals,” ProceedCryptography and Network Security. Springer,
ings of the ACM on Interactive, Mobile, Wear2004, pp. 16–30.
able and Ubiquitous Technologies, vol. 1, no. 2,
[16] J. Van Den Hooff, D. Lazar, M. Zaharia, and
pp. 1–20, 2017.
N. Zeldovich, “Vuvuzela: Scalable private messaging resistant to traffic analysis,” in ProceedB. Thiel, K. Kloch, and P. Lukowicz, “Soundings of the 25th Symposium on Operating Sysbased proximity detection with mobile phones,”
tems Principles, 2015, pp. 137–152.
in Proceedings of the Third International Workshop on Sensing Applications on Mobile Phones,
[17] D. Lazar, Y. Gilad, and N. Zeldovich, “Karaoke:
2012, pp. 1–4.
Distributed private messaging immune to passive traffic analysis,” in 13th {USENIX} SympoE. Ben-Sasson, A. Chiesa, E. Tromer, and
sium on Operating Systems Design and ImpleM. Virza, “Scalable zero knowledge via cycles
mentation ({OSDI} 18), 2018, pp. 711–725.
of elliptic curves,” Algorithmica, vol. 79, no. 4,
pp. 1102–1160, 2017.
[18] A. Chiesa, D. Ojha, and N. Spooner, “Fractal:
Post-quantum and transparent recursive proofs
from holography,” in Annual International Conference on the Theory and Applications of Cryptographic Techniques. Springer, 2020, pp. 769–
793.

[10] R. Canetti, A. Trachtenberg, and M. Varia,
“Anonymous collocation discovery: Harnessing
privacy to tame the coronavirus,” 2020.

[11] R. Canetti, Y. T. Kalai, A. Lysyanskaya, R. L.
Rivest, A. Shamir, E. Shen, A. Trachten[19] S. Bowe, J. Grigg, and D. Hopwood, “Halo:
berg, M. Varia, and D. J. Weitzner, “PrivacyRecursive proof composition without a trusted
preserving automated exposure notification,”
setup,” Cryptology ePrint Archive, Report
Cryptology ePrint Archive, Report 2020/863,
2019/1021, Tech. Rep., 2019.
2020, https://eprint.iacr.org/2020/863.
[20] E. Ben-Sasson, A. Chiesa, D. Genkin, S. Kfir,
[12] S. Angel and S. Setty, “Unobservable commuE. Tromer, and M. Virza, “libsnark, 2014,”
nication over fully untrusted infrastructure,” in
https://github.com/scipr-lab/libsnark.
12th {USENIX} Symposium on Operating Systems Design and Implementation ({OSDI} 16), [21] T. Altuwaiyan, M. Hadian, and X. Liang, “Epic:
2016, pp. 551–569.
efficient privacy-preserving contact tracing for
9

infection detection,” in 2018 IEEE International
Conference on Communications (ICC). IEEE,
2018, pp. 1–6.
[22] R. L. Rivest, J. Callas, R. Canetti, K. Esvelt,
D. K. Gillmor, Y. T. Kalai, A. Lysyanskaya,
A. Norige, R. Raskar, A. Shamir et al., “The
pact protocol specification,” 2020.
[23] C. Troncoso, M. Payer, J.-P. Hubaux,
M. Salathé, J. Larus, E. Bugnion, W. Lueks,
T. Stadler, A. Pyrgelis, D. Antonioli et al.,
“Decentralized privacy-preserving proximity
tracing,” arXiv preprint arXiv:2005.12273,
2020.
[24] “Pan-european
privacy-preserving proximity tracing,”
https://github.com/pepp-pt/
pepp-pt-documentation, 2020.
[25] Apple and Google, “Privacy-preserving contact tracing,” https://www.apple.com/covid19/
contacttracing.
[26] A. Berke, M. Bakker, P. Vepakomma, R. Raskar,
K. Larson, and A. Pentland, “Assessing disease
exposure risk with location data: A proposal
for cryptographic preservation of privacy,” arXiv
preprint arXiv:2003.14412.
[27] R. Raskar, I. Schunemann, R. Barbar, K. Vilcans, J. Gray, P. Vepakomma, S. Kapa,
A. Nuzzo, R. Gupta, A. Berke et al., “Apps gone
rogue: Maintaining personal privacy in an epidemic,” arXiv preprint arXiv:2003.08567, 2020.
[28] J. Chan, S. Gollakota, E. Horvitz, J. Jaeger,
S. Kakade, T. Kohno, J. Langford, J. Larson, S. Singanamalla, J. Sunshine et al., “Pact:
Privacy sensitive protocols and mechanisms
for mobile contact tracing,” arXiv preprint
arXiv:2004.03544, 2020.
[29] N. Trieu, K. Shehata, P. Saxena, R. Shokri,
and D. Song, “Epione: Lightweight contact
tracing with strong privacy,” arXiv preprint
arXiv:2004.13293, 2020.

10

