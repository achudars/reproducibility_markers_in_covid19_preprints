Deep direct likelihood knockoffs

arXiv:2007.15835v1 [stat.ML] 31 Jul 2020

Mukund Sudarshan∗
Courant Institute of Mathematical Sciences
New York University
sudarshan@cims.nyu.edu

Wesley Tansey
Department of Epidemiology and Biostatistics
Memorial Sloan Kettering Cancer Center
tanseyw@mskcc.org

Rajesh Ranganath
Courant Institute of Mathematical Sciences
Center for Data Science
New York University
rajeshr@cims.nyu.edu

Abstract
Predictive modeling often uses black box machine learning methods, such as deep
neural networks, to achieve state-of-the-art performance. In scientific domains, the
scientist often wishes to discover which features are actually important for making
the predictions. These discoveries may lead to costly follow-up experiments and
as such it is important that the error rate on discoveries is not too high. ModelX knockoffs [2] enable important features to be discovered with control of the
false discovery rate (FDR). However, knockoffs require rich generative models
capable of accurately modeling the knockoff features while ensuring they obey
the so-called “swap” property. We develop Deep Direct Likelihood Knockoffs
(DDLK), which directly minimizes the KL divergence implied by the knockoff swap
property. DDLK consists of two stages: it first maximizes the explicit likelihood of
the features, then minimizes the KL divergence between the joint distribution of
features and knockoffs and any swap between them. To ensure that the generated
knockoffs are valid under any possible swap, DDLK uses the Gumbel-Softmax trick
to optimize the knockoff generator under the worst-case swap. We find DDLK has
higher power than baselines while controlling the false discovery rate on a variety
of synthetic and real benchmarks including a task involving a large dataset from
one of the epicenters of COVID-19.

1

Introduction

High dimensional multivariate datasets pervade many disciplines including biology, neuroscience,
and medicine. In these disciplines, a core question is which variables are important to predict the
phenomenon being observed. Finite data and noisy observations make finding informative variables
impossible without some error rate. Scientists therefore seek to find informative variables subject to a
specific tolerance on an error rate such as the false discovery rate (FDR).
Traditional methods to control to the FDR rely on assumptions on how the covariates of interest x may
be related to the response y. Model-X knockoffs [2] provide an alternative framework that controls
e, called knockoffs, that look like the original covariates,
the FDR by constructing synthetic variables x
but have no relationship with the response given the original covariates. Variables of this form can be
used to test the conditional independence of each covariate in a collection, with the response given
the rest of the covariates by comparing the association the original covariate has with the response
with the association the knockoff has with the response.
∗

Corresponding author

Preprint. Under review.

The focus on modeling the covariates shifts the testing burden to building good generative models
of the covariates. Knockoffs need to satisfy two properties: (i) they need to be independent of
the response given the real covariates, (ii) they need to be equal in distribution when any subset
of variables is swapped between knockoffs and real data. Satisfying the first property is trivial by
generating the knockoffs without looking using the response. The second property requires building
conditional generative models that are able to match the distribution of the covariates.
Related work. Existing knockoff generation methods can be broadly classified as either modelspecific or flexible. Model-specific methods such as hidden markov models (HMMs) [22] or AutoEncoding Knockoffs [15] make assumptions about the covariate distribution, which can be problematic if the data does not satisfy these assumptions. H MMs assume the joint distribution of the covariates
can be factorized into a markov chain. Auto-Encoding Knockoffs use variational auto-encoders
e. VAEs assume x lies near a low dimensional manifold,
(VAEs) to model x and sample knockoffs x
whose dimension is controlled by a latent variable. Covariates that violate this low-dimensional
assumption can be better modeled by increasing the dimension of the latent variable, but risk retaining
more information about x, which can reduce the power to select important variables.
Flexible methods for generating knockoffs such as KnockoffGAN [10] or Deep Knockoffs [20] focus
on likelihood-free generative models. KnockoffGAN uses generative adversarial network (GAN)based generative models, which can be difficult to estimate [18] and sensitive to hyperparameters
[21, 8, 17]. Deep Knockoffs employ maximum mean discrepancys (MMDs), the effectiveness of which
often depends on the choice of a kernel which can involve selecting a bandwidth hyperparameter.
Ramdas et al. [19] show that in several cases, across many choices of bandwidth, MMD approaches
0 as dimensionality increases while KL divergence remains non-zero, suggesting MMDs may not
reliably generate high-dimensional knockoffs. Deep Knockoffs also prevent the knockoff generator
from memorizing the covariates by explicitly controlling the correlation between the knockoffs and
covariates. This is specific to second order moments, and may ignore higher order ones present in the
data.
We propose deep direct likelihood knockoffs (DDLK), a likelihood-based method for generating
knockoffs without the use of latent variables. D DLK is a two stage algorithm. The first stage
uses maximum likelihood to estimate the distribution of the covariates from observed data. The
second stage estimates the knockoff distribution with likelihoods by minimizing the Kullback–Leibler
divergence (KL) between the joint distribution of the real covariates with knockoffs and the joint
distribution of any swap of coordinates between covariates and knockoffs. D DLK expresses the
likelihoods for swaps in terms of the original joint distribution with real covariates swapped with
knockoffs. Through the Gumbel-Softmax trick [9, 16], we optimize the knockoff distribution under
the worst swaps. By ensuring that the knockoffs are valid in the worst cases, DDLK learns valid
knockoffs in all cases. To prevent DDLK from memorizing covariates, we introduce a regularizer
to encourage high conditional entropy for the knockoffs given the covariates. We study DDLK
on synthetic, semi-synthetic, and real datasets. Across each study, DDLK controls the FDR while
achieving higher power than competing GAN-based, MMD-based, and autoencoder-based methods.

2

Knockoff filters

Model-X knockoffs [2] is a tool used to build variable selection methods. Specifically, it facilitates
the control of the FDR, which is the proportion of selected variables that are not important. In this
section, we review the requirements to build variable selection methods using Model-X knockoffs.
Consider a data generating distribution q(x)q(y | x) where variables x ∈ Rd , response y only
depends on xS , S ⊆ [d], and xS is a subset of the variables. Let Ŝ be a set of indices identified by a
variable selection algorithm. The goal of such algorithms is to return an Ŝ that maximizes the number
of indices in S while maintaining the FDR at some nominal level:


|{j
:
j
∈
Ŝ
\
S}|

 .
FDR = E 
max |{j : j ∈ Ŝ}|, 1
e, and (b) a
To control the FDR at the nominal level, Model-X knockoffs requires (a) knockoffs x
knockoff statistic wj to assess the importance of each feature xj .
2

e are random vectors that satisfy the following properties for any set of indices H ⊆ [d]:
Knockoffs x
d

e] = [x, x
e]swap(H)
[x, x
e | x.
y⊥x

(1)
(2)

e] is invariant under any swap. A
The swap property eq. (1) ensures that the joint distribution of [x, x
ej . For example, when
swap operation at position j is defined as exchanging the entry of xj and x
e]swap(H) = [e
e 3 , x1 , x
e2 , x3 ]. Equation (2) ensures that
x = [x1 , x2 , x3 ], and H = {1, 3}, [x, x
x1 , x2 , x
e given the original features x.
the response y is independent of the knockoff x
A knockoff statistic wj must satisfy the flip-sign property. This means if xj ∈ S, wj must be positive.
Otherwise, the sign of wj must be positive or negative with equal probability.
e and knockoff statistics {wj }dj=1 , exact control of the FDR at level p can be obtained
Given knockoff x
by selecting variables in x such that wj > τp . The threshold τp is given by:


1 + |{j : wj ≤ −t}|
τp = min t :
≤p .
(3)
t>0
|{j : wj ≥ t}|
While knockoffs are a powerful tool to ensure that the FDR is controlled at the nominal level, the
choice of method to generate knockoffs is left to the practitioner.
Existing methods for knockoffs include model-specific approaches that make specific assumptions
about the covariate distribution, and flexible likelihood-free methods. If the joint distribution of x
cannot be factorized into a markov chain [22] or if x does not lie near a low-dimensional manifold
[15], model-specific generators will yield knockoffs that are not guaranteed to control the FDR.
Likelihood-free generation methods that use GANs [10] or MMDs [20] make fewer assumptions about
e, but can be difficult to estimate [18], sensitive to hyperparameters [21, 8, 17], or suffer from low
x
power in high dimensions [19]. In realistic datasets, where x can come from an arbitrary distribution
and dimensionality is high, it remains to be seen how to reliably generate knockoffs that satisfy
eqs. (1) and (2).

3

Deep direct likelihood knockoffs

We motivate DDLK with the following observation. The swap property in eq. (1) is satisfied if the KL
divergence between the original and swapped distributions is zero. Formally, let H be a set of indices
e], w = [x, x
e]swap(H) . Then under any such H ⊆ [d]:
to swap, and z = [x, x


qz (z)
KL(qz k qw ) = Eqz (z) log
= 0.
(4)
qw (z)
A natural algorithm for generating valid knockoffs might be to parameterize each distribution above
and solve for the parameters by minimizing the LHS of eq. (4). However, modeling qw for every
possible swap is difficult and computationally infeasible in high dimensions. Theorem 3.1 provides a
useful solution to this problem.
Theorem 3.1. Let µ be a probability measure defined on a measurable space. Let fH be a swap
function using indices H ⊆ [d]. If v is a sample from µ, the probability law of fH (v) is µ ◦ fH .
As an example, in the continuous case, where qz and qw are the densities of z and w respectively,
qw evaluated at a sample v is simply qz evaluated at the swap of v. We show the direct proof of this
example and theorem 3.1 in appendix A. A useful consequence of theorem 3.1 is that DDLK needs to
only model qz , instead of qz and every possible swap distribution qw . To derive the DDLK algorithm,
we first expand eq. (4):




qz (z)
q(x)q(e
x | x)
Eqz (z) log
= Eq(x) Eq(ex|x) log
,
(5)
qw (z)
q(u)q(e
u | u)
e ] = [x, x
e]swap(H) . D DLK models the RHS by parameterizing q(x) and q(e
where [u, u
x | x) with
q̂joint (x; θ) and q̂knockoff (e
x | x; φ) respectively. The parameters θ and φ can be optimized separately in
two stages.
3

Stage 1: Covariate distribution estimation. We model the distribution of x using q̂joint (x; θ).
The parameters of the model θ are learned by maximizing Ex∼DN [log q̂joint (x; θ)] over a dataset
DN := {x(i) }N
i=1 of N samples.
Stage 2: Knockoff generation. For any fixed swap H, minimizing the KL divergence between the
following distributions ensures the swap property eq. (1) required of knockoffs:
KL(q̂joint (x; θ)q̂knockoff (e
x | x; φ) k q̂joint (u; θ)q̂knockoff (e
u | u; φ)).

(6)

Fitting the knockoff generator q̂knockoff (e
x | x; φ) involves minimizing this KL divergence for all
possible swaps H. To make this problem tractable, we use several building blocks that help us (a)
sample swaps with the highest values of this KL and (b) prevent q̂knockoff from memorizing x to
trivially satisfy the swap property in eq. (1).
3.1

Fitting DDLK

Knockoffs must satisfy the swap property eq. (1) for all potential sets of swap indices H ⊆ [d]. While
this seems to imply that the KL objective in eq. (6) must be minimized under an exponential number
of swaps, swapping every coordinate suffices [3]. More generally, showing the swap property for a
collection of sets where every coordinate can be represented as the symmetric difference of members
of the collection is sufficient. See appendix A.4 more more details.
Sampling swaps. Swapping d coordinates can be expensive in high dimensions, so existing methods resort to randomly sampling swaps [20, 10] during optimization. Rather than sample each
coordinate uniformly at random, we propose parameterizing the sampling process for swap indices
H so that swaps sampled from this process yields large values of the KL objective in eq. (6). We do
so because of the following property of swaps, which we prove in appendix A.
Lemma 3.2. Worst case swaps: Let q(H; β) be the worst case swap distribution. That is, the
distribution over swap indices that maximizes
EH∼q(H;β) KL(q̂joint (x; θ)q̂knockoff (e
x | x; φ) k q̂joint (u; θ)q̂knockoff (e
u | u; φ))

(7)

with respect to β. If eq. (7) is minimized with respect to φ, knockoffs sampled from q̂knockoff will satisfy
the swap property in eq. (1) for any swap H in the power set of [d].
Randomly sampling swaps can be thought of as sampling from d Bernoulli random variables {bj }dj=1
with parameters β = {βj }dj=1 respectively, where each bj indicates whether the jth coordinate is
to be swapped. A set of indices H can be generated by letting H = {j : bj = 1}. To learn a
sampling process that helps maximize eq. (7), we optimize the values of β. However, since score
function gradients for the parameters of Bernoulli random variables can have high variance, DDLK
uses a continuous relaxation instead. For each coordinate j ∈ d, DDLK learns the parameters for a
Gumbel-Softmax [9, 16] distribution q̂gumbel (βj ).
Entropy regularization. Minimizing the the KL objective in eq. (6) over the worst case swap
distribution will generate knockoffs that satisfy the swap property eq. (1). However, a potential
solution in the optimization of q̂knockoff (e
x | x) is to memorize the covariates x, which reduces the
power to select important variables.
e
To solve this problem, DDLK introduces a regularizer based on the conditional entropy, to push x
to not be a copy of x. This regularizer takes the form −λE[− log q̂knockoff (e
x | x; φ)], where λ is a
hyperparameter.
Including the regularizer on conditional entropy, and Gumbel-Softmax sampling of swap indices, the
final optimization objective for DDLK is:
min max EH∼q̂gumbel (β) Ex∼DN Exe∼q̂knockoff (ex|x;φ) log
φ

β

q̂joint (x; θ)q̂knockoff (e
x | x; φ)1+λ
q̂joint (u; θ)q̂knockoff (e
u | u; φ)

(8)

e ] = [x, x
e]swap(H) . We show the full DDLK algorithm in algorithm 1. D DLK fits q̂joint
where [u, u
by maximizing the likelihood of the data. It then fits q̂knockoff by optimizing eq. (8) with noisy
gradients. To do this, DDLK first samples knockoffs conditioned on the covariates and a set of swap
4

Algorithm 1 DDLK
Input: DN := {x(i) }N
i=1 , dataset of covariates; λ, regularization parameter; αφ , learning rate for
q̂knockoff ; αβ , learning rate for q̂gumbel
Output: θ, parameter for q̂joint , q̂knockoff , parameter for q̂knockoff
PN
θ = arg maxθ N1 i=1 log q̂joint (x(i) ; θ)
while q̂knockoff not converged do
e(i) ∼ q̂knockoff (e
Sample {e
x(i) }N
x | x(i) ; φ)
i=1 , where x
Sample swap H ∼ q̂gumbel (β)
e (i) )}N
e (i) ] = [x(i) , x
e(i) ]swap(H)
Create {(u(i) , u
, where [u(i) , u
PN i=1
1
(i)
Let A(φ) = N i=1 log q̂joint (x ; θ) + (1 + λ) log q̂knockoff (e
x(i) | x(i) ; φ)
P
N
Let B(φ, β) = N1 i=1 log q̂joint (u(i) ; θ) + log q̂knockoff (e
u(i) | u(i) ; φ)
φ ← φ − αφ ∇φ (A(φ) − B(φ, β))
β ← β + αβ ∇β (A(φ) − B(φ, β))
end
return θ, φ, β
gaussian
FDP

mixture
Power

0.50

FDP

1.0

0.4

0.5

0.25
0.2

0.8
0.0

Nominal FDR

Power

0.6

0.50

0.25

0.5

FDP

0.50

0.25
0.00
0.0

gene
Power

0.5

Nominal FDR

ddlk

0.00
0.0

0.0
0.0

0.5

Nominal FDR

0.5

Nominal FDR

deepknockoffs

aek

0.00
0.0

0.5

Nominal FDR

0.0

0.5

Nominal FDR

knockoffgan

Figure 1: DDLK controls FDR at the nominal rate and achieves highest power on a variety of
benchmarks. For each benchmark, we show the false discovery proportion (FDP) and power of each
knockoff method.
coordinates, then computes Monte-Carlo gradients of the DDLK objective in eq. (8) with respect to
parameters φ and β. In practice DDLK can use stochastic gradient estimates like the score function or
reparameterization gradients for this step. The q̂joint and q̂knockoff models can be implemented with
flexible models like MADE [7] or mixture density networks [1].

4

Experiments

We study the performance of DDLK on several synthetic, semi-synthetic, and real-world datasets. We
compare DDLK with several non-Gaussian knockoff generation methods: Auto-Encoding Knockoffs
(AEK) [15], KnockoffGAN [10], and Deep Knockoffs [20].2
Each experiment involves three stages. First, we fit a knockoff generator using a dataset of covariates
{x(i) }N
i=1 . Next, we fit a response model q̂response (y | x; γ), and use its performance on a held-out set
to create a knockoff statistic wj for each feature xj . We detail the construction of these test statistics
in appendix E. Finally, we apply a knockoff filter to the statistics {wj }dj=1 to select features at a
nominal FDR level p, and measure the ability of each knockoff method to select relevant features
while maintaining FDR at p. For the synthetic and semi-synthetic tasks, we repeat these three stages
30 times to obtain interval estimates of each performance metric.
In our experiments, we assume x to be real-valued with continuous support and decompose the
Qd
models q̂joint and q̂knockoff via the chain rule: q(x | ·) = q(x1 | ·) j=2 q(xj | ·, x1 , . . . , xj−1 ). For
each conditional distribution, we fit a mixture density network [1] where the number of mixture
components is a hyperparameter. In principle, any model that produces an explicit likelihood value
can be used to model each conditional distribution.
2
For all comparison methods, we downloaded the publicly available implementations of the code (if available)
and used the appropriate configurations and hyperparameters recommended by the authors. See appendix D for
code and model hyperparameters used.

5

40
20
0

0

20
data

40

0

20
ddlk

40

0
20
40
deepknockoffs

0

20
aek

40

0
20
40
knockoffgan

Figure 2: D DLK closely models the modes, covariances, and mixture proportions of the
mixture dataset. Auto-Encoding Knockoffs also capture every mode, but does so by overfitting to the covariates. Deep Knockoffs are able to match the first two moments, but fail to capture
every mode. KnockoffGAN suffers from mode collapse and fails to capture every mode.
Fitting q̂joint involves using samples from a dataset, but fitting q̂knockoff involves sampling from q̂knockoff .
This is a potential issue because the gradient of the DDLK objective eq. (8) with respect to φ is
difficult to compute as it involves integrating q̂knockoff , which depends on φ. To solve this, we use an
implicit reparameterization [5] of mixture densities. Further details of this formulation are presented
in appendix B.
Across each benchmark involving DDLK, we vary only the λ entropy regularization parameter based
on the amount of dependence among covariates. The number of parameters, learning rate, and all
other hyperparameters are kept constant. To sample swaps H, we sample using a straight-through
Gumbel-Softmax estimator [9]. This allows us to sample binary values for each swap, but use
gradients of a continuous approximation during optimization. For brevity, we present the exact
hyperparameter details for DDLK in appendix C.
We run each experiment on a single CPU with 4GB of memory. D DLK takes roughly 40 minutes in
total to fit both q̂joint and q̂knockoff on a 100-dimensional dataset.
Synthetic benchmarks. Our tests on synthetic data seek to highlight differences in power and FDR
between each knockoff generation method. Each dataset in this section consists of N = 2000 samples,
100 features, 20 of which are used to generate the response y. We split the data into a training set
(70%) to fit each knockoff method, a validation set (15%) used to tune the hyperparameters of each
method, and a test set (15%) for evaluating knockoff statistics.
[gaussian]: We first replicate the multivariate normal benchmark of Romano et al. [20]. We
sample x ∼ N (0, Σ), where Σ is a d-dimensional covariance matrix whose entries Σi,j = ρ|i−j| .
This autoregressive Gaussian data exhibits strong correlations between adjacent features, and lower
correlations between features that are further apart. We generate y | x ∼ N (hx, αi, 1), where
100
· Rademacher(0.5). In our experiments,
coefficients for the important features are drawn as αj ∼ √
N
we set ρ = 0.6. We let the DDLK entropy regularization parameter λ = 0.1. Our model q̂response for
y | x is a 1-layer neural network with 200 parameters.
[mixture]: To compare each method on its ability to generate non-Gaussian knockoffs, we use
a mixture of autoregressive Gaussians. This is a more challenging benchmark as each covariate
PK
is multi-modal, and highly correlated with others. We sample x ∼ k=1 πk N (µk , Σk ), where
|i−j|
each Σk is a d-dimensional covariance matrix whose (i, j)th entry is ρk . We generate y | x ∼
100
N (hx, αi, 1), where coefficients for the important features are drawn as αj ∼ √
·Rademacher(0.5).
N
In our experiments, we set K = 3, and (ρ1 , ρ2 , ρ3 ) = (0.6, 0.4, 0.2). Cluster centers are set to
(µ1 , µ2 , µ3 ) = (0, 20, 40), and mixture proportions are set to (π1 , π2 , π3 ) = (0.4, 0.2, 0.4). We let
the DDLK entropy regularization parameter λ = 0.001. Figure 2 visualizes two randomly selected
dimensions of this data.
Results. Figure 1 compares the average FDP and power (percentage of important features selected)
of each knockoff generating method. The average FDP is an empirical estimate of the FDR. In the
case of the gaussian dataset, all methods control FDR at or below the the nominal level, while
achieving 100% power to select important features. The main difference between each method is in
the calibration of null statistics. Recall that a knockoff filter assumes a null statistic to be positive or
negative with equal probability, and features with negative statistics below a threshold are used to
control the number of false discoveries when features with positive statistics above the same threshold
6

are selected. D DLK produces the most well calibrated null statistics as evidenced by the closeness of
its FDP curve to the dotted diagonal line.
Figure 1 also demonstrates the effectiveness of DDLK in modeling non-Gaussian covariates. In the
case of the mixture dataset, DDLK achieves significantly higher power than the baseline methods,
while controlling the FDR at nominal levels. To understand why this may be the case, we plot the joint
distribution of two randomly selected features in fig. 2. D DLK and Auto-Encoding Knockoffs both
seem to capture all three modes in the data. However, Auto-Encoding Knockoffs tend to produce
knockoffs that are very similar to the original features, and yield lower power when selecting variables,
shown in fig. 1. Deep Knockoffs manage to capture the first two moments of the data – likely due to
an explicit second-order term in the objective function – but tend to over-smooth and fail to properly
estimate the knockoff distribution. KnockoffGAN suffers from mode collapse, and fails to capture
even the first two moments of the data. This yields knockoffs that not only have low power, but also
fail to control FDR at nominal levels.
Robustness of DDLK to entropy regularization. To provide guidance on how to set the entropy
regularization parameter, we explore the effect of λ on both FDR control and power. Intuitively, lower
values of λ will yield solutions of q̂knockoff that may satisfy eq. (1) and control FDR well, but may also
memorize the covariates and yield low power. Higher values of λ may help improve power, but at
the cost of FDR control. In this experiment, we again use the gaussian dataset, but vary λ and the
correlation parameter ρ. Figure 3 highlights the performance of DDLK over various settings of λ and
ρ. We show a heatmap where each cell represents the RMSE between the nominal FDR and mean
FDP curves over 30 simulations. In each of these settings DDLK achieves a power of 1, so we only
visualize FDP. We observe that the FDP of DDLK is very close to its expected value for most settings
where λ ≤ 0.1. This is true over a wide range of ρ explored, demonstrating that DDLK is not very
sensitive to the choice of this hyperparameter. We also notice that data with weaker correlations see a
smaller increase in FDP with larger values of λ. In general, checking the FDP on synthetic responses
generated conditional on real covariates can aid in selecting λ.
Semi-synthetic benchmark. [gene]: In order to evaluate the FDR and power of each knock0.05
off method using covariates found in a genomics
0.25
context, we create a semi-synthetic dataset. We
0.1
0.20
use RNA expression data of 963 cancer cell lines
0.3
0.15
from the Genomics of Drug Sensitivity in Can0.10
0.6
cer study [24]. Each cell line has expression
0.05
levels for 20K genes, of which we sample 100
0.9
such that every feature is highly correlated with
at least one other feature. We create 30 indepenEntropy regularization parameter
dent replications of this experiment by repeating
Figure 3: DDLK is robust to choices of entropy the following process. We first sample a gene x1
regularization parameter λ. For most choices of uniformly at random, adding it to the set X . For
λ ≤ 0.1, DDLK achieves FDP very close to that of xj , j > 1, we sample xk uniformly at random
the nominal FDR rate. This figure shows the RMSE from X and compute the set of 50 genes not in
X with the highest correlation with xk . From
between the expected and actual FDP curves.
this set of 50, we uniformly sample a gene xj
and add it to the feature set. We repeat this process for j = 2, . . . , 100, yielding 100 genes in total.
1.0

0.5

0.1

0.05

0.01

0.005

0.001

0.0005

0.0001

Correlation parameter

RMSE(FDP - FDR)

We generate y | x using a nonlinear response function adapted from a study on feature selection in
neural network models of gene-drug interactions [14]. The response consists of a nonlinear term, a
second-order term, and a linear term. For brevity, appendix F contains the full simulation details. We
let DDLK entropy regularization parameter λ = 0.001.
Results. Figure 1 (right) highlights the empirical FDP and power of each knockoff generating
method in the context of gene. All methods control the FDR below the nominal level, but the
average FDP of DDLK at FDR thresholds below 0.3 is closer to its expected value. This range of
thresholds is especially important as nominal levels of FDR below 0.3 are most used in practice. In
this range, DDLK achieves power on par with Deep Knockoffs at levels below 0.1, and higher power
everywhere else. Auto-Encoding Knockoffs and KnockoffGAN achieve noticeably lower power
across all thresholds. Deep Knockoffs perform well here likely due to a lack of strong third or higher
7

Absolute Neutrophil Count

0.1

0.0

0

10

20

30
data

0
10
ddlk

20
30
deepknockoffs

0

10
aek

20

30
0
knockoffgan

10

20

30

Figure 4: DDLK learns the marginals of COVID-19 data better than competing baselines. We
plot the marginal distribution of a feature in a COVID-19 dataset, and the corresponding marginal of
samples from each knockoff method.
Feature
Eosinophils count
Eosinophils percent
Blood urea nitrogen
Ferritin
O2 Saturation
Heart rate
Respiratory rate
O2 Rate
On room air
High O2 support
Age

DDLK Deep Knockoffs AEK KnockoffGAN Validated
3
3
3
3
3
3
3
3
3
3
7

7
3
7
7
7
7
3
3
3
3
7

7
7
7
7
7
7
7
3
3
3
3

7
7
7
7
7
7
7
3
3
3
3

3
7
3
7
3
3
3
3
3
3
7

Table 1: D DLK selects 10/37 features, 8 of which were found to be meaningful by doctors
at a large metropolitan hospital. Here we show the union of covid-19 features selected by
each knockoff method at a nominal FDR of 0.2. Deep Knockoffs, Auto-Encoding Knockoffs, and
KnockoffGAN exhibit lower power to select important features.

moments of dependence between features. We attribute the success of DDLK and Deep Knockoffs to
their ability to model highly correlated data.
COVID-19 adverse events. [covid-19]: The widespread impact of COVID-19 has led to the
deployment of machine learning models to guide triage. Data for COVID-19 is messy because of
both the large volume of patients and the changing practice for patient care. Establishing trust in
models for COVID-19 involves vetting the training data to ensure it does not contain artifacts that
models can exploit. Conditional independence tests help achieve this goal in two ways: (a) they
highlight which features are most important to the response, and (b) they prune the feature set for
a deployed model, reducing the risk of overfitting to processes in a particular hospital. We apply
each knockoff method to a large dataset from one of the epicenters of COVID-19 to understand the
features most predictive of adverse events.
We use electronic health record data on COVID-positive patients from a large metropolitan health
network. Our covariates include demographics, vitals, and lab test results from every complete blood
count (CBC) taken for each patient. The response y | x is a binary label indicating whether or not
a patient had an adverse event (intubation, mortality, ICU transfer, hospice discharge, emergency
department representation, O2 support in excess of nasal cannula at 6 L/min) within 96 hours of
their CBC. There are 17K samples of 37 covariates in the training dataset, 5K in a validation set,
and 6K in a held-out test set. We let the DDLK entropy regularization parameter λ = 0.1. In this
experiment, we use gradient boosted regression trees [6, 11] as our q̂response (y | x; γ) model, and
expected log-likelihood as a knockoff statistic. We also standardize the data in the case of Deep
Knockoffs since MMDs that use the radial basis function (RBF) kernel with a single bandwidth
parameter work better when features are on the same scale.
Results. As COVID-19 is a recently identified disease, there is no ground truth set of important
features for this dataset. We therefore use each knockoff method to help discover a set of features
at a nominal FDR threshold of 0.2, and validate each feature by manual review with doctors at a
large metropolitan hospital. Table 1 shows a list of features returned by each knockoff method, and
indicates whether or not a team of doctors thought the feature should have clinical relevance.
8

We note that DDLK achieves highest power to select features, identifying 10 features, compared to 5
by DeepKnockoffs, and 4 each by Auto-Encoding Knockoffs and KnockoffGAN. To understand why,
we visualize the marginal distributions of each covariate in, and the respective marginal distribution
of samples from each knockoff method, in fig. 4.
We notice two main differences between DDLK and the baselines. First, DDLK is able to fit asymmetric
distributions better than the baselines. Second, despite the fact that the implementation of DDLK
using mixture density networks is misspecified for discrete variables, DDLK is able to model them
better than existing baselines. This implementation uses continuous models for x, but is still able
approximate discrete distributions well. The components of each mixture appear centered around
a discrete value, and have very low variance as shown in fig. 5. This yields a close approximation
to the true discrete marginal. We show the marginals of every feature for each knockoff method in
appendix G.

5

Conclusion

D DLK is a generative model for sampling knockoffs that directly minimizes a KL divergence implied
by the knockoff swap property. The optimization for DDLK involves first maximizing the explicit
likelihood of the covariates, then minimizing the KL divergence between the joint distribution of
covariates and knockoffs and any swap between them. To ensure DDLK satisfies the swap property
under any swap indices, we use the Gumbel-Softmax trick to learn swaps that maximize the KL
divergence. To generate knockoffs that satisfy the swap property while maintaining high power
to select variables, DDLK includes a regularization term that encourages high conditional entropy
of the knockoffs given the covariates. We find DDLK to outperform various baselines on several
synthetic and real benchmarks including a task involving a large dataset from one of the epicenters of
COVID-19.

Broader Impact
There are several benefits to using flexible methods for identifying conditional independence like
DDLK . Practitioners that care about transparency have traditionally eschewed deep learning, but
methods like DDLK can present a solution. By performing conditional independence tests with
deep networks and by providing guarantees on the false discovery rate, scientists and practitioners
can develop more trust in their models. This can lead to greater adoption of flexible models in
basic sciences, resulting in new discoveries and better outcomes for the beneficiaries of a deployed
model. Conditional independence can also help detect bias from data, by checking if an outcome like
length of stay in a hospital was related to a sensitive variable like race or insurance type, even when
conditioning on many other factors.
While we believe greater transparency can only be better for society, we note that interpretation
methods for machine learning may not exactly provide transparency. These methods visualize
only a narrow part of a model’s behavior, and may lead to gaps in understanding. Relying solely
on these domain-agnostic methods could yield unexpected behavior from the model. As users of
machine learning, we must be wary of too quickly dismissing the knowledge of domain experts. No
interpretation technique is suitable for all scenarios, and different notions of transparency may be
desired in different domains.

References
[1] Christopher M Bishop. Mixture density networks. Technical report, Aston University, Birmingham, UK, 1994.
[2] E. Candes, Y. Fan, L. Janson, and J. Lv. Panning for Gold: Model-X Knockoffs for Highdimensional Controlled Variable Selection. ArXiv e-prints, October 2016.
[3] Emmanuel Candes, Yingying Fan, Lucas Janson, and Jinchi Lv. Panning for gold:‘modelx’knockoffs for high dimensional controlled variable selection. Journal of the Royal Statistical
Society: Series B (Statistical Methodology), 80(3):551–577, 2018.
[4] WA Falcon. Pytorch lightning. GitHub. Note: https://github. com/williamFalcon/pytorchlightning Cited by, 3, 2019.
9

[5] Mikhail Figurnov, Shakir Mohamed, and Andriy Mnih. Implicit reparameterization gradients.
In Advances in Neural Information Processing Systems, pages 441–452, 2018.
[6] Jerome H Friedman. Stochastic gradient boosting. Computational statistics & data analysis, 38
(4):367–378, 2002.
[7] Mathieu Germain, Karol Gregor, Iain Murray, and Hugo Larochelle. MADE: masked autoencoder for distribution estimation. CoRR, abs/1502.03509, 2015. URL http://arxiv.org/
abs/1502.03509.
[8] Ishaan Gulrajani, Faruk Ahmed, Martín Arjovsky, Vincent Dumoulin, and Aaron C. Courville.
Improved training of wasserstein gans. CoRR, abs/1704.00028, 2017. URL http://arxiv.
org/abs/1704.00028.
[9] Eric Jang, Shixiang Gu, and Ben Poole. Categorical reparameterization with gumbel-softmax.
CoRR, abs/1611.01144, 2016. URL http://arxiv.org/abs/1611.01144.
[10] James Jordon, Jinsung Yoon, and Mihaela van der Schaar. KnockoffGAN: Generating knockoffs for feature selection using generative adversarial networks. In International Conference on Learning Representations, 2019. URL https://openreview.net/forum?
id=ByeZ5jC5YQ.
[11] Guolin Ke, Qi Meng, Thomas Finley, Taifeng Wang, Wei Chen, Weidong Ma, Qiwei Ye, and
Tie-Yan Liu. Lightgbm: A highly efficient gradient boosting decision tree. In Advances in
neural information processing systems, pages 3146–3154, 2017.
[12] Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint
arXiv:1412.6980, 2014.
[13] Durk P Kingma, Tim Salimans, and Max Welling. Variational dropout and the local reparameterization trick. In Advances in neural information processing systems, pages 2575–2583,
2015.
[14] Faming Liang, Qizhai Li, and Lei Zhou. Bayesian neural networks for selection of drug sensitive
genes. Journal of the American Statistical Association, 113(523):955–972, 2018.
[15] Ying Liu and Cheng Zheng. Auto-encoding knockoff generator for fdr controlled variable
selection. arXiv preprint arXiv:1809.10765, 2018.
[16] Chris J. Maddison, Andriy Mnih, and Yee Whye Teh. The concrete distribution: A continuous
relaxation of discrete random variables. CoRR, abs/1611.00712, 2016. URL http://arxiv.
org/abs/1611.00712.
[17] Lars Mescheder, Sebastian Nowozin, and Andreas Geiger. The numerics of gans. In Advances
in Neural Information Processing Systems, pages 1825–1835, 2017.
[18] Lars Mescheder, Andreas Geiger, and Sebastian Nowozin. Which training methods for gans do
actually converge? arXiv preprint arXiv:1801.04406, 2018.
[19] Aaditya Ramdas, Sashank Jakkam Reddi, Barnabás Póczos, Aarti Singh, and Larry Wasserman.
On the decreasing power of kernel and distance based nonparametric hypothesis tests in high
dimensions. In Twenty-Ninth AAAI Conference on Artificial Intelligence, 2015.
[20] Yaniv Romano, Matteo Sesia, and Emmanuel J. Candès. Deep knockoffs, 2018.
[21] Tim Salimans, Ian Goodfellow, Wojciech Zaremba, Vicki Cheung, Alec Radford, and Xi Chen.
Improved techniques for training gans. In Advances in neural information processing systems,
pages 2234–2242, 2016.
[22] Matteo Sesia, Chiara Sabatti, and Emmanuel J Candès. Gene hunting with knockoffs for hidden
markov models. arXiv preprint arXiv:1706.04677, 2017.
[23] Wesley Tansey, Victor Veitch, Haoran Zhang, Raul Rabadan, and David M Blei. The holdout randomization test: Principled and easy black box feature selection. arXiv preprint
arXiv:1811.00645, 2018.
[24] Wanjuan Yang, Jorge Soares, Patricia Greninger, Elena J Edelman, Howard Lightfoot, Simon
Forbes, Nidhi Bindal, Dave Beare, James A Smith, I Richard Thompson, et al. Genomics of
drug sensitivity in cancer (gdsc): a resource for therapeutic biomarker discovery in cancer cells.
Nucleic acids research, 41(D1):D955–D961, 2012.

10

Appendix
A
A.1

Proofs
Proof of theorem 3.1

Let µ be a probability measure defined on a measurable space. Let fH be a swap function using
indices H ⊆ [d]. If v is a sample from µ, the probability law of fH (v) is µ ◦ fH .
e] swaps coordinates in the following manner: for each j ∈ H,
Proof. The swap operation fH on [x, x
the jth and (j + d)th coordinates are swapped. Let (E, E) be a measurable space, where elements
of E are 2d-dimensional vectors, and E is a σ-algebra on E. Let (F, F) also be a measurable
space where each element of F is an element of E but with the jth coordinate swapped with the
(j + d)th coordinate for each j ∈ H. Similarly, let F be constructed by applying the same swap
transformations to each element of E. F is a σ-algebra as swaps are one-to-one transformations, and
E is a σ-algebra.
We first show that fH is a measurable function with respect to E and F. This is true by construction
−1
of the measurable space (F, F). For every element B ∈ F, fH
(B) ∈ E.
−1
We can now construct a mapping µ ◦ fH
(B) for all B ∈ F. This is the pushforward measure of µ
under transformation fH , and is well defined because fH is measurable.
−1
Using the fact that a swap applied twice is the identity, we get fH = fH
. With this, we see that the
−1
probability measure on (F, F) is µ ◦ fH = µ ◦ fH .

A.2

Alternative derivation of theorem 3.1 for continuous random variables

In this section we derive theorem 3.1 for continuous random variables in an alternative manner. Let
e be a set of knockoffs. Let z = [x, x
e], and w = [x, x
e]swap(H) where
x be a set of covariates, and x
e. Recall that a swap operation on z is an affine
H is a set of coordinates in which we swap x and x
transformation w = Az, where A is a permutation matrix. Using this property, we get:


∂A−1 w
qw (z) = det
· qz (A−1 z) = qz (A−1 z) = qz (Az) = qz (w).
∂w
The first step is achieved by using a change of variables, noting that A is invertible, and z = A−1 w.
The determinant of the Jacobian here is just the determinant of A−1 . A−1 is a permutation matrix
whose parity is even, meaning its determinant is 1, and that A−1 = A. I.e. the density of the swapped
variables evaluated at z is equal to the original density evaluated at w.
A.3

Proof of lemma 3.2

Recall lemma 3.2:
Worst case swaps: Let q(H; β) be the worst case swap distribution. That is, the distribution over
swap indices that maximizes
EH∼q(H;β) KL(q̂joint (x; θ)q̂knockoff (e
x | x; φ) k q̂joint (u; θ)q̂knockoff (e
u | u; φ))
with respect to β. If this quantity is minimized with respect to φ, knockoffs sampled from q̂knockoff
will satisfy the swap property in eq. (1) for any swap H in the power set of [d].
Proof. If
EH∼q(H;β) KL(q̂joint (x; θ)q̂knockoff (e
x | x; φ) k q̂joint (u; θ)q̂knockoff (e
u | u; φ))
(9)
is minimized with respect to φ but maximized with respect to β, then for any other distribution
q(H; β 0 ), eq. (9) will be lesser. Minimizing eq. (9), which is non-negative, with respect to φ implies
e sampled from q̂knockoff ,
that for any swap H sampled from q(H; β) and for any knockoff x
d

e] = [x, x
e]swap(H) .
[x, x
As eq. (9) is also maximized with respect to β, swaps H 0 drawn from all other distributions q(H 0 ; β 0 )
e] will be invariant
will only result in lower values of eq. (9). Therefore, the joint distribution [x, x
under any swap H 0 in the power set of [d].
11

A.4

Sufficient sets for swap condition expectation

Recall the swap property required of knockoffs highlighted in eq. (1):
d

e] = [x, x
e]swap(H)
[x, x
where H ⊆ [d] is a set of coordinates under which we swap the covariates and knockoffs. For valid
knockoffs, this equality in distribution must hold for any such H. One approach to check if knockoffs
are valid is to verify this equality in distribution for all singleton sets {j} ⊂ [d] [20, 10]. To check
if the swap property eq. (1) holds under any H = {j1 , . . . , jk }, it suffices to check if eq. (1) holds
under each of {j1 }, . . . , {jk }.
We can generalize this approach to check the validity of knockoffs under other collections of indices
besides singleton sets using the following property. Let H1 , H2 ⊆ [d] and
d

e] = [x, x
e]swap(H1 )
[x, x
d

e] = [x, x
e]swap(H2 ) .
[x, x
Then,

d 
e]swap(H1 ∆H2 ) = [x, x
e]swap(H1 ) swap(H
[x, x

d

2)

d

e]swap(H2 ) = [x, x
e]
= [x, x

where H1 ∆H2 is the symmetric difference of H1 and H2 . Swapping the indices in H1 ∆H2 is
equivalent to swapping the indices in H1 , then the indices in H2 . If ∃j ∈ H1 ∧ j ∈ H2 , swapping j
twice will negate the effect of the swap.
We can extend this property to K sets and define sufficient conditions to check if the swap property
holds. Let {Ak }K
k=1 be a sequence of sets where each Ak ⊆ [d]. Let
A∗1 = A1
∀k ∈ [K], A∗k = Ak ∆A∗k−1
A∗K = {j}.
Checking the swap property eq. (1) under a sequence of swaps {Ak }K
k=1 is equivalent to checking
eq. (1) under the singleton set {j}. Therefore, the swap property must also hold under the singleton
set {j}.
If collection of sets of swap indices A contains a sub-sequence {Ak }K
k=1 such that their sequential
symmetric difference is the singleton {j} for each j ∈ [d], then a set of knockoffs that satisfies the
swap property under each Ak ∈ A, will also satisfy the swap property under each singleton set, which
is sufficient to generate valid knockoffs.

B

Implicit reparameterization of mixture density networks

In our experiments, we decompose both q̂joint and q̂knockoff via the chain rule:
q(x | ·) = q(x1 | ·)

d
Y

q(xj | ·, x1 , · · · , xj−1 ).

j=2

We model each conditional q(xj | ·) using mixture density networks [1] which take the form
q(xj | ·) =

K
X

πk (·; ψk )N (µk (·; ηk ), σk2 (·; ωk ))

k=1
K
{µk }k=1 , and {σk }K
k=1 characterize a univariate
functions are [ψ1 , . . . , ψK , ν1 , . . . , νK , ω1 , . . . , ωK ].

{πk }K
k=1 ,

where functions
parameters of these

gaussian mixture. These

Fitting q̂joint . Let θ, the parameters of q̂joint contain parameters for every conditional q(xj |
x1 , . . . , xj−1 ). The optimization of θ is straightforward:
θ = arg max L(θ) = arg max
θ

θ

only requires taking the derivative of L(θ).
12

N
1 X
log q̂joint (x(i) ; θ)
N i=1

Fitting q̂knockoff . Let φ, the parameters of q̂knockoff contain parameters for every conditional q(e
xj |
e1 , . . . , x
ej−1 ). Recall the loss function L(φ, β)
x1 , . . . , xd , x
L(φ, β) = EH∼q̂gumbel (β) Ex∼DN Exe∼q̂knockoff (ex|x;φ) log

q̂joint (x; θ)q̂knockoff (e
x | x; φ)1+λ
.
q̂joint (u; θ)q̂knockoff (e
u | u; φ)

The optimization of φ requires ∇φ L(φ, β), which involves the derivative of an expectation with
respect to to q̂knockoff (e
x | x; φ). We use implicit reparameterization [5]. The advantage of implicit
reparameterization over explicit reparameterization [13] is that an inverse standardization function
Sφ−1 – which transforms random noise into samples from a distribution parameterized by φ – is not
needed. Using implicit reparameterization, gradients of some objective Eq(z;φ) [f (z)] can be rewritten
as
Eq(z;φ) [∇φ f (z)] = Eq(z;φ) [∇z f (z)∇φ z]
= Eq(z;φ) [−∇z f (z)(∇z Sφ (z))−1 ∇φ Sφ (z)].
We use this useful property to reparameterize gaussian mixture models. Let q(z; φ) be a gaussian
mixture model:
q(z; φ) =

K
X

πk N (z; µk , σk2 )

k=1

where φ = [π1 , . . . , πK , µ1 , . . . , µK , σ1 , . . . , σK ]. Let the standardization function Sφ be the CDF
of q(z; φ):


K
X
z − µk
Sφ (z) =
πk Φ
σk
k=1

where Φ is the standard normal gaussian CDF. We use this to compute the gradient of z with respect
to each parameter:
∇πk z = −

k
Φ( z−µ
σk )

q(z; φ)
πk · N (z; µk , σk2 )
∇µk z =
q(z; φ)


k
πk · z−µ
· N (z; µk , σk2 )
σk
∇σk z =
.
q(z; φ)
Putting it all together, we use the implicit reparameterization trick to implement each conditional
distribution in q̂joint and q̂knockoff .

C

Implementation details and hyperparameter settings for DDLK
experiments

We decompose q̂joint and q̂knockoff into the product of univariate conditional distributions using the
product rule. We use mixture density networks [1] to parameterize each conditional distribution.
Each mixture density network is a 3-layer neural network with 50 parameters in each layer and a
residual skip connection from the input to the last layer. Each network outputs the parameters for a
univariate gaussian mixture with 5 components. We initialize the network such that the modes are
evenly spaced within the support of training data.
Using q̂gumbel , we sample binary swap matrices of the same dimension as the data. As we require
discrete samples from the Gumbel-Softmax distribution, we implement a straight-through estimator
[9]. The straight-through estimator facilitates sampling discrete indices, but uses a continuous
approximation during backpropagation.
The q̂joint model is optimized using Adam [12], with a learning rate of 5 × 10−4 for a maximum of
50 epochs. The q̂knockoff model is optimized using Adam, with a learning rate of 1 × 10−3 for φ and
13

1 × 10−2 for β for a maximum of 250 epochs. We also implement early stopping using validation
loss using the PyTorch Lightning framework [4].
Our code can be found online by installing:
pip install -i https://test.pypi.org/simple/ ddlk==0.2
Compute resources. We run each experiment on a single CPU core using 4GB of memory. Fitting
q̂joint for a 100-dimensional dataset with 2000 samples requires fitting 100 conditional models, and
takes roughly 10 minutes. Fitting q̂knockoff for the same data takes roughly 30 minutes.
Fitting DDLK to our covid-19 dataset takes roughly 15 minutes in total.

D

Baseline model settings

For Deep Knockoffs and KnockoffGAN, we use code from each respective repository:
https://github.com/msesia/deepknockoffs
https://bitbucket.org/mvdschaar/mlforhealthlabpub/
and use the recommended hyperparameter settings.
At the time of writing this paper, there was no publicly available implementation for Auto-Encoding
Knockoffs. We implemented Auto-Encoding Knockoffs with a VAE with a gaussian posterior q(z |
x) ≈ N (z; µz (x), σz (x)) and likelihood p(x | z) ≈ N (x; µx (z), σx (z)). Each of µz , σz , µx .σx is
a 2-layer neural network with 400 units in the first hidden layer, 500 units in the second, and ReLU
activations. The outputs of networks σz , σx are exponentiated to ensure variances are non-negative.
The outputs of network µz and σz are of dimension dz , and the outputs of µx and σx are of dimension
d, the covariate dimension. For each dataset, we choose the dimension dz of latent variable z that
maximizes the estimate of the ELBO on a validation dataset. In our experiments, we search for dz
over the set {dz : 10 ≤ dz ≤ 200, dz mod 10 = 0}. For each dataset, we use the following dz :
1.
2.
3.
4.

gaussian: 20
mixture: 140
gene: 30
covid-19: 60.

The neural networks are trained using Adam [12], with a learning rate of 1 × 10−4 for a maximum
of 150 epochs. To avoid very large gradients, we standardize the data using the mean and standard
e, we use the same approach prescribed by Liu
deviation of the training set. To generate knockoffs x
and Zheng [15]. We first sample the latent variable z conditioned on the covariates using the posterior
distribution:
z ∼ N (z; µz (x), σz (x)) .
e using the likelihood distribution:
This sample of z is then used to sample a knockoff x
e ∼ N (x; µx (z), σx (z)) .
x
e are standardized, we re-scale them by the the training mean and standard deviation.
Since these x

E

Robust model-based statistics for FDR-control

The goal of any knockoff method is to help compute test statistics for a conditional independence
test. We employ a variant of holdout randomization tests (HRTs) [23] to compute test statistics wj
(tr)
(te)
for each feature xj . We split dataset DN := {(x(i) , y (i) )}N
i=1 into train and test sets DN , and DN
e (tr) and D
e (te) conditioned on each. Next, a model q̂response
respectively, then sample knockoff datasets D
N
N
(tr)
is fit with DN .
(te)
To compute knockoff statistics with q̂response , we use a measure of performance W(q̂response , DN
) on
the test set. For real-valued y, W is the mean squared-error, and for categorical y, W is expected log(te)
e (te) ) is recorded
probability of y | x. A knockoff statistic wj := W(q̂response , DN
) − W(q̂response , D
j,N
(te)
(te)
(te)
e
e
for each feature xj , where D
is D but with the jth feature swapped with D .
j,N

N

N

14

In practice, we use use flexible models like neural networks or boosted trees for q̂response . While the
model-based statistic above will satisfy the properties detailed in section 2 and control FDR, its ability
to do so is hindered by imperfect knockoffs. In such cases, we observe that knockoff statistics for null
features are centered around some ζ > 0, violating a condition required for empirical FDR control.
This happens because if the covariates and knockoffs are not equal in distribution, models trained on
the covariates will fit the covariates better than the knockoffs and inflate the value of test statistic wj .
This can lead to an increase in the false discovery rate as conditionally independent features may be
selected if their statistic is larger than the selection threshold. To combat this, we propose a mixture
statistic that trades off power for FDR-control.
The mixture statistic involves fitting a q̂response model for each feature xj using an equal mixture of
(tr)
e (tr) , then computing W as above. Such a q̂response achieves lower performance on
data in DN
and D
j,N
(te)
e (te) , yielding values of wj with modes closer to 0, enabling finite
DN
, but higher performance on D
j,N
sample FDR control. However, this FDR-control comes at the cost of power as the method’s ability to
identify conditionally dependent features is reduced.

F

Nonlinear response for gene experiments

We simulate the response y | x for the gene experiment using a nonlinear response function designed
for genomics settings [14]. The response consists of two first-order terms, a second-order term, and
an additional nonlinearity in the form of a tanh:
k ∈ [m/4]
(1)
(2)
ϕk , ϕk
(3)
(4)
(5)
(6)
ϕk , ϕk , ϕk , ϕk

∼ N (1, 1)
∼ N (2, 1)

m/4

y |x=+

X

(1)

(3)

(4)

(5)

(2)

(6)

ϕk x4k−3 + ϕk x4k−2 + ϕk x4k−3 x4k−2 + ϕk tanh(ϕk x4k−1 + ϕk x4k )

k=1

where m is the number of important features. In our experiments, we set m = 20. This means that
the first 20 features are important, while the remaining 80 are unimportant.

G

Generating knockoffs for COVID-19 data

In this section, we visualize the marginals of each feature in our covid-19 dataset, and the marginals
of knockoffs sampled from each method. Figures 5 to 8 plot the marginals of samples from DDLK,
KnockoffGAN, Deep Knockoffs, and Auto-Encoding Knockoffs respectively. These provide insight
into why DDLK is able to select more features at the same nominal FDR threshold of 0.2. We first
notice that knockoff samples from DDLK match the marginals of the data very well. D DLK is the
only method that models asymmetric distributions well.
Despite our experiment using mixture density networks to implement DDLK, discrete data is also
modeled well. For example the values of O2_support_above_NC – a binary feature indicating
whether a patient required oxygen support greater than nasal cannula – are also the modes of a
mixture density learned by DDLK. Samples from Auto-Encoding Knockoffs, KnockoffGAN, and
Deep Knockoffs tend to place mass spread across these values.

15

ddlk
0.0010

40

4

50

2

20

25

0

0

0

2
0
2
O2_support_above_NC

2
0
2
device_Nasal cannula

0.0010

0
2
device_None (Room air)

0.0

0.0

0

25
50
BMI_max_12

0.0000
0
5000
10000
0
50000
D-DIMER__QUANTITATIVE
Weight_max_12

0.010

0.2

0.005

0.0

0.000

0
10
MEAN_PLATELET_VOLUME

0.10

0.0

0
500
C-REACTIVE_PROTEIN

0.00

0

10
CREATININE

0

0
1
EOSINOPHILS__ABSOLUTE

0.0

0

0
50
Resp_min_12

0.4

0.00

0
20
EOSINOPHILS_Percent

0
50
LYMPHOCYTES_Percent

95
100 105
Temp_max_12

0.00

0.0004

0.002

0.0002

0.001

0.0000

0

100000
FERRITIN

0.00

0
50
100
NEUTROPHILS_Percent

0.0

0

50
100
SpO2_max_12

0.00

0
200
BLOOD_UREA_NITROGEN

0

50
Age

100

0.0

0

100
SpO2_min_12

0.4
0.2

0.000

0

2000
LDH

0.0

4000

80
100
Temp_min_12

0.002

0
20
40
LYMPHOCYTES_ABSOLUTE

0.01

0.000

0.00

0
500
1000
PLATELET_COUNT

0

100
HR_min_12

0.050

0.02
0.5

0.01
0.00

0.00

40

0.02

0.5

0.02

0.1

20
O2Rate_max

0.05

0.0

0.04
0.02

0

0.10

0.02

0.05

0
50
NEUTROPHILS__ABSOLUTE

5000
Weight_min_12

2

0.2
0.0

0

0.1

0.5

0.05

0
100
days_since_admission

0.0000

0
50
BMI_min_12

0.2

0.10

0.05

0.0005

10

0.5

0.0002

0.4

0.00

0.1

1.0
0.0004

0.0005
0.0000

0.1

100
200
HR_max_12

300

0.0

ddlk

0.025
0

200
TROPONIN_I

0.000

0

data

2500
5000
Resp_max_12

Figure 5: The marginal distributions of knockoff samples from DDLK look very similar to those from
the data. Despite this implementation of DDLK using mixture density networks, the modes of each marginal
line up with discrete values in the data.
knockoffgan
40

4
2

20

20

0

0

0

0
2
O2_support_above_NC

0.0010

40

1
0
1
device_Nasal cannula

0.0010

0
1
device_None (Room air)

0.0

0
50
BMI_max_12

0.0000

0
5000
Weight_max_12

0
25000 50000
D-DIMER__QUANTITATIVE

0
10
MEAN_PLATELET_VOLUME

0.10

0.000

0
10
CREATININE

0

0
1
EOSINOPHILS__ABSOLUTE

0.00

0

0.0

25
50
Resp_min_12

0.4

0.0

0.00

20
O2Rate_max

40

0.10

0
20
EOSINOPHILS_Percent

0.05

0.0

95
100 105
Temp_max_12

0.00

0.00

0
200
BLOOD_UREA_NITROGEN

0.002

0
25
50
NEUTROPHILS__ABSOLUTE

0

0.02

0.0002

0.05

0.05

0
100
days_since_admission

0.0

0.2
0
500
C-REACTIVE_PROTEIN

0
5000
Weight_min_12

0.5

0.1

0.0

0.10

0.05

0.0000

0
50
BMI_min_12

1.0

0.5

0.005

0.0005

0.2

0.010

0.00

0.0

10

0.5

0.0002

0.2
0.0

0.1

1.0
0.0004

0.0005
0.0000

0.1

0
50
LYMPHOCYTES_Percent

0

100000
FERRITIN

0.000

50
100
SpO2_min_12

0.4

0.001

0.0000

0

0.2
0

2000
LDH

0.0

4000

80
100
Temp_min_12

0.04
0.2

0.02

0.02
0.00

0
50
100
NEUTROPHILS_Percent

0.0

0.02

0.2

0.01

0.1

0.00

0.0

100
200
HR_max_12

300

0

50
100
SpO2_max_12

0.00

0.5

0

50
Age

100

0.0

0
20
40
LYMPHOCYTES_ABSOLUTE

0.005

0

200
TROPONIN_I

0.000

0.02

0.002
0.000

0
500
1000
PLATELET_COUNT

knockoffgan

0

0.00

50
100 150
HR_min_12

data

2500
5000
Resp_max_12

Figure 6: The marginals distributions of samples from KnockoffGAN match the data only when the feature xj
is univariate, and has roughly equal mass on either side of the mode.

16

deepknockoffs
40

4
2

20

20

0

0

0

0
2
O2_support_above_NC

0.0010

40

1
0
1
device_Nasal cannula

0.0010

0
1
device_None (Room air)

0.1

0.0

0.0

0
50
BMI_max_12

0.0000

0
5000
Weight_max_12

0
25000 50000
D-DIMER__QUANTITATIVE

0.005

0.0

0.000

0
10
MEAN_PLATELET_VOLUME

0.10

0

0

10
CREATININE

0
1
EOSINOPHILS__ABSOLUTE

0.00

0
50
Resp_min_12

0
500
C-REACTIVE_PROTEIN

0
20
EOSINOPHILS_Percent

100
Temp_max_12

110

0
200
BLOOD_UREA_NITROGEN

0.0002

0.0000

0
50
LYMPHOCYTES_Percent

0

100000
FERRITIN

0.00

0.5

0.02

0.1

40

0.00

0

50
100
SpO2_min_12

0.4

0.001

0.2

0.000

0

2000
LDH

4000

0.04
0.02

20
O2Rate_max

0.05
0.00

0.002

0.00

0

0.10

0.0

0.05

0
25
50
NEUTROPHILS__ABSOLUTE

0.0

0.02
0.2

0.05

0
100
days_since_admission

0.0

0.4

0.5

0.10

0.05

0.5

0.1

0.0

0.0

0
5000
Weight_min_12

0.2

0.010
0.2

0.0000

0
50
BMI_min_12

10

0.5

0.0002

0.0000

0.0005

1.0

1.0
0.0004

0.0005

0.00

0.1

0.0

80
100
Temp_min_12

0.02

0.002

0.01
0
50
100
NEUTROPHILS_Percent

0.0

0.02

0.2

0.01

0.1

0.00

0.0

100
200
HR_max_12

300

0

50
100
SpO2_max_12

0.00

0

50
Age

0.0

100

0
20
40
LYMPHOCYTES_ABSOLUTE

0.000

0.005

0

200
TROPONIN_I

0.000

0
1000
PLATELET_COUNT

deepknockoffs

0

0.00

50
100 150
HR_min_12

data

2500
5000
Resp_max_12

Figure 7: The marginals distributions of samples from Deep Knockoffs match the data only when
the feature xj is univariate and has fat tails.
aek
40

4

20

2
0

0
2
O2_support_above_NC

1
0
1
device_Nasal cannula

0.2

20

0.1

0

0.0

0.0
0.5
1.0
device_None (Room air)

0

25
50
BMI_max_12

0.0005

0.0

0
50
BMI_min_12

0.0000

5000
Weight_max_12

0
25000
50000
D-DIMER__QUANTITATIVE

0.0

0

0

10
CREATININE

0.02
1

0
10
MEAN_PLATELET_VOLUME

0.00

2

0

0
20
EOSINOPHILS_Percent

0.00

0

25
50
Resp_min_12

95
100 105
Temp_max_12

0.00

0
200
BLOOD_UREA_NITROGEN

0.0004
0.1

0.0

0
100
days_since_admission

0.10

0.10

0.05

0.05

0.00

0
25
50
NEUTROPHILS__ABSOLUTE

0.00

40

0.0

0

50
SpO2_min_12

100

2
0.002

0.0002

0
50
LYMPHOCYTES_Percent

0
20
O2Rate_max

0.2

0.02

0

0.0

0.4

0.04

1
0
250
500
C-REACTIVE_PROTEIN

0.5

0.25
0
1
EOSINOPHILS__ABSOLUTE

1

0.01

0
5000
Weight_min_12

0.50

10

0.5

0.0002
0

0.0000

1.0

0.0004

0.0005

0

0.0010
0.1

1.0

0.0010

0.0000

0

40

0.0000

0

100000
FERRITIN

0.000

1

0

2000
LDH

4000

0

80
100
Temp_min_12

2
0.1

0.0

0
50
100
NEUTROPHILS_Percent

0.05
0.00

0.1

0.5

100
200
HR_max_12

300

0.0

0

50
100
SpO2_max_12

0.0

0.50

0.02

0.25

0.01

0.00

0.00

0

200
TROPONIN_I

0

50
Age

100

1

0.01

0

0.00

0
20
40
LYMPHOCYTES_ABSOLUTE

0.1

0

500
1000
PLATELET_COUNT

aek

0

0.0

50
100 150
HR_min_12

data

2500
5000
Resp_max_12

Figure 8: Auto-Encoding Knockoffs tend to learn underdispersed distributions for the covariates.
Further, all of the marginal distributions learned are univariate and exhibit variance much smaller
than that of the data.

17

