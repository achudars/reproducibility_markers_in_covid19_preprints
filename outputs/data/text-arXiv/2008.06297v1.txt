Secure Data Hiding for Contact Tracing
Craig Gotsman1, Kai Hormann2
1
2

New Jersey Institute of Technology, Newark, NJ, USA
Università della Svizzera italiana, Lugano, Switzerland

Abstract
Contact tracing is an effective tool in controlling the spread of infectious diseases such as
COVID-19. It involves digital monitoring and recording of physical proximity between people
over time with a central and trusted authority, so that when one user reports infection, it is
possible to identify all other users who have been in close proximity to that person during a
relevant time period in the past and alert them. One way to achieve this involves recording on the
server the locations, e.g. by reading and reporting the GPS coordinates of a smartphone, of all
users over time. Despite its simplicity, privacy concerns have prevented widespread adoption of
this method. Technology that would enable the “hiding” of data could go a long way towards
alleviating privacy concerns and enable contact tracing at a very large scale. In this article we
describe a general method to hide data. By hiding, we mean that instead of disclosing a data
value 𝑥, we would disclose an “encoded” version of 𝑥, namely 𝐸 𝑥 , where 𝐸 𝑥 is easy to
compute but very difficult, from a computational point of view, to invert. We propose a general
construction of such a function 𝐸 and show that it guarantees perfect recall, namely, all
individuals who have potentially been exposed to infection are alerted, at the price of an
infinitesimal number of false alarms, namely, only a negligible number of individuals who have
not actually been exposed will be wrongly informed that they have.
1. Introduction
Contact tracing has proven to be an effective tool in controlling the spread of infectious diseases
such as COVID-19. It involves digital monitoring and recording of physical proximity between
people over time, so that when one user reports infection, it is possible to identify all other users
who have been in close proximity to that person during a relevant time period in the past and
alert them. These users would be required to monitor their health and isolate, allowing early
treatment and preventing further spread. Contact tracing has been deployed successfully in
countries such as China, South Korea, Singapore, Israel, Australia, and Germany, and seems to
be the only effective way to detect and contain the spread early in the process.
There are two main approaches to contact tracing. The first is based on the relative distance
between users. Using the Bluetooth sensor on a smartphone, it is possible to detect signals from
other users with Bluetooth emitters who are physically close by (i.e. within a certain range) and
record the proximity, either locally on the user’s device, or at a central authority/server. This
method, currently under development by Apple, Google and others [1], has the advantage that

absolute locations of users are never disclosed, ensuring some degree of privacy. The
disadvantage is the reliability of the Bluetooth sensors and their ability to work well under all
relevant conditions (e.g. occlusion) and at all relevant ranges and some security concerns about
the popular decentralized approach to storing this type of data on user devices.
The second approach to contact tracing involves recording on a central server the absolute
locations, e.g. by reading and reporting the GPS coordinates of a smartphone, of all users over
time. This obviously provides the server with more information to work with than the first
approach, enabling not only alerts to nearby users, but also to identify geographic hotspots and
other patterns of contagion. It also provides a historic record of the evolution of an epidemic
which can be mined and analyzed in many other ways.
Despite the simplicity of the second approach, privacy concerns have prevented its
widespread adoption. Many people do not want their location history to be known to any third
party, thus would avoid using any software that explicitly discloses this information. Some have
gone so far as to call contact tracing based on unprotected disclosure of location data illegal or
unconstitutional [2]. A number of commercial contact tracing apps, which report and store
explicit location data, have recently been found in violation of user privacy policies, having
shared this data with unauthorized third parties [3]. Such privacy concerns must be addressed if
automatic contact tracing is to be deployed, as it is not very effective unless adopted by a
majority of the population.
Technology that would enable the “hiding” or “obfuscation” of location data could go a long
way towards alleviating privacy concerns and enabling contact tracing at a very large scale.
Since the outbreak of COVID-19, this has been the topic of recent research, incorporating
cryptographic techniques such as private set intersection [4], private proximity testing based on
an equality testing protocol [5] and homomorphic encryption [19]. We refer the interested reader
to the comprehensive survey by Reichert et al. [20]. The objective of this article is to describe a
very simple method to hide data, which can also be used to hide spatio-temporal data. By hiding,
we mean that instead of disclosing a data value 𝑥, a user would disclose an “encoded” version of
𝑥, namely 𝐸 𝑥 . For this to be useful, it should be easy for any user to compute 𝐸 𝑥 if given 𝑥,
but be very difficult, from a computational point of view, to invert 𝐸, namely to recover 𝑥 when
provided only with 𝐸 𝑥 (even for the user who encoded 𝑥 . By “difficult” we mean it would
require a prohibitive amount of storage or of computational resources, which would effectively
deter any such attempt. Although quite distinct, as we will make clear later, these resemble in
spirit one-way functions or cryptographic hash functions used in classical cryptography. In its
simplest form, the function 𝐸 is deterministic and injective, as then it is easy to check if 𝑥 𝑦 by
simply checking if 𝐸 𝑥
𝐸 𝑦 . In the contact-tracing scenario, the data 𝑥
𝑡, 𝑙 is a data
value consisting of a concatenation of the time 𝑡 with the location 𝑙. Given the function 𝐸, a user
with ID 𝑖 would periodically transmit to a central server the pair 𝑖, 𝑒 , where 𝑒 𝐸 𝑥 is the
encoded version of 𝑥. The server would store these pairs in a database indexed by the second
component. Given a query vector 𝑒 (of a detected infection), it should be easy to search this

database to determine all pairs 𝑖′, 𝑒′ such that 𝑒′ 𝑒, namely identify which other users (having
ID 𝑖′) were also at location 𝑙 at time 𝑡 and alert them.
We depart from traditional cryptographic techniques by not requiring the use of encryption
keys of any sort, neither private nor public keys. This means that even the user who computed
𝐸 𝑥 from 𝑥 cannot recover 𝑥 from 𝐸 𝑥 unless she explicitly records the connection between
the two or stores some additional information which might facilitate the recovery. While the
basic embodiment of 𝐸 is deterministic, it is possible to add an extra layer of security by
introducing a non-deterministic (probabilistic) element to 𝐸, namely 𝐸 𝑥 could assume more
than one value for any given 𝑥. In this case we need to modify the database search to a matching
procedure: given a query 𝑒, instead of searching for other vectors 𝑒′ such that 𝑒 𝑒′, we search
for all other vectors 𝑒′ such that 𝛿 𝑒, 𝑒′
𝜏, where 𝛿 is the Hamming distance function between
two vectors, namely the number of coordinates in which they differ, and 𝜏 is some threshold.
These 𝑒′ are called matches of 𝑒. An exact match is, of course, the special case where 𝜏 0. A
judicious choice of the encoding function 𝐸 and the value 𝜏 will guarantee no false negatives (i.e.
perfect recall), namely, given a query 𝑒 corresponding to some data 𝑥, we will always find all
other matching values 𝑒′ corresponding to the same 𝑥. It will also guarantee a negligible (ideally
zero) number of false positives (also called false alarms), namely, almost never report values
𝑒′ corresponding to a different data value 𝑦 𝑥. In the contact tracing scenario, perfect recall is
necessary so that all individuals who have potentially been exposed to infection are alerted. A
tiny number of false positives are tolerable as all this means is that a small number of individuals
who have not actually been exposed will be informed that they have.
This article proposes encoding functions for spatio-temporal data. In a nutshell, it maps a 2D
location 𝑙 and time 𝑡, combined and represented as a large integer in a discrete world, to an 𝑛dimensional vector of integers 𝐸 𝑥 , where 𝑛 is quite large, e.g. 100. The range of the
components of 𝐸 𝑥 can be much larger than 𝑛, e.g. 0, … ,502 . The function 𝐸 is based on
well-known number-theoretic techniques, the preferred one making use of polynomials over
finite fields. First deployed in 1960 in Reed–Solomon error-correcting codes [6] and its variants
(the most important being the BCH code), the technique has also found use in other
cryptographic methods, such as Shamir’s secret sharing method [7] and even blockchain [8]. The
most important property of 𝐸 is that it transforms a very large integer into a long vector of much
smaller integers in an injective way, which can be thought of as an embedding in a higherdimensional space, and this transformation cannot be inverted unless a minimal number 𝑚 𝑛
of the vector coordinates (and their indices in the vector) are known. We take advantage of this
by sorting the vector coordinates so that their correspondence to the coordinate indices is lost,
making it difficult to apply the standard decoding methods. An attacker has no choice but to try
all possible permutations of subsets of size 𝑚 of the 𝑛 coordinates, making it computationally
infeasible, even for relatively small values of 𝑛 and 𝑚. Another important property is that,
although there are simple algebraic relationships between the coordinates of the vector, to the
naked eye, and even to a statistical test, they look like random integers. Thus, the distribution of
the encoded vectors in the embedding space is quite uniform, which will work in our favor.

2. The Setup
Consider an integer domain (the “world”): 𝑊
0, … , 𝑀 1 . Any integer 𝑥 ∈ 𝑊 is a valid
message and we may express it as a sequence of 𝑚 digits 𝑥
𝑥 ,…,𝑥
in base 𝑝: 𝑥
∑
𝑥 𝑝 where 𝑝 is a prime number (or more generally a prime power) and 𝑥 ∈ ℤ
0, … , 𝑝 1 . Note that this implies that 𝑚
log 𝑀 and taking a larger 𝑚 is superfluous.
Essentially, 𝑊 is synonymous with a subset of ℤ , the set of all vectors of length 𝑚, where each
coordinate is taken from ℤ .
In the contact tracing application, the spatio-temporal world consists of two-dimensional
(latitude and longitude) GPS coordinates at 1 meter resolution (or the Open Location “Plus”
Codes [9]), which translates to a grid with 10 points, and 10 different time stamps for every
30 seconds over the past month, implying a “world” of size 𝑀 10 . If we use the prime 𝑝
503, this would mean 𝑚 8.
3. The Encoding Function
We propose the following non-deterministic encoding scheme:
Let 𝑊
0, … , 𝑀 1 be an integer domain, 𝑛 a positive integer and 𝑝 a prime. Denote
by ℤ the set of vectors with 𝑛 elements from ℤ and by Δ the set of vectors with 𝑛
elements from ℤ in non-decreasing order, also known as the ordered discrete simplex.
The encoding function 𝐸: 𝑊 → ℰ ⊂ Δ has parameters 𝑀, 𝑝, 𝑛, 𝑘 , where 0 𝑘 𝑛
𝑝 and 𝑛 𝑚
log 𝑀 .
To compute 𝐸 𝑥 for a domain element 𝑥 ∈ 𝑊:
1. Express 𝑥 in base 𝑝: 𝑥 ∑
𝑥𝑝.
2. Compute the basic encoding 𝐶 𝑥
𝜋 0 , 𝜋 1 , … , 𝜋 𝑛 1 ∈ 𝒞 ⊂ ℤ , where
∑
𝜋 𝜉
𝑥 𝜉 mod 𝑝 is a polynomial of degree 𝑚 1 over the finite field ℤ .
3. Sort the coordinates of 𝐶 𝑥 in non-decreasing order to 𝐶′ 𝑥 ∈ ℰ.
4. Randomly modify 𝑘 arbitrary coordinates of 𝐶′ 𝑥 , while preserving the increasing
order of the coordinates, resulting in 𝐸 𝑥 ∈ ℰ.
Note that as a result of step 4, 𝑘 0 implies that 𝐸 𝑥 is non-deterministic, namely may assume
multiple values.
The basic code space 𝒞 ⊂ ℤ , defined as the set of all possible basic codes of world
elements 𝒞
𝐶 𝑥 : 𝑥 ∈ 𝑊 consists of vectors of length 𝑛, such that 𝐶 𝑥 ∈ ℤ . It has the
following properties:
1. 𝐶 𝑥 is injective, namely 𝑥 𝑦 iff 𝐶 𝑥
𝐶 𝑦 .
2. 𝒞 has Hamming distance 𝑑 𝑛 𝑚 1, namely any two distinct codewords 𝑐 , 𝑐 ∈
𝒞 differ from each other by at least 𝑑 coordinates: 𝛿 𝑐 , 𝑐
𝑑. This is because any

polynomial of degree 𝑚 1 over a field is uniquely determined by 𝑚 of its values. So not
only is 𝐶 an injective function (i.e. 𝑑 0 , but it maps distinct world elements quite far
apart from each other in 𝒞.
3. 𝑥 may be recovered from 𝐶 𝑥 by a variety of efficient methods, including inverting a
linear Vandermonde system.
The basic coding function 𝐶 described above was proposed by Reed and Solomon [6] as an
error-correcting code to overcome corruption of 𝑘 ⌊𝑑/2⌋ coordinates of 𝐶 𝑥 . When presented
with 𝑐′, which is a corrupted version of 𝐶 𝑥 , Property 2 guarantees that 𝐶 𝑥 is the unique
codeword in 𝒞 such that 𝛿 𝐶 𝑥 , 𝑐′
𝑘, thus error-correction performed by replacing 𝑐′ with
the vector closest to it in 𝒞 by the Hamming distance, is well-defined and yields the correct
result 𝐶 𝑥 . The corrected codeword 𝐶 𝑥 may be found by efficient algorithms (e.g. [10]) which
take into account the special algebraic structure of 𝒞.
Our non-deterministic encoding function is a variation on the theme of error-correction. In our
scenario, we are presented with two vectors 𝐸 𝑥 , 𝐸 𝑦 ∈ ℰ originating from 𝑥, 𝑦 ∈ 𝑊. We
would like to have a threshold 𝜏 such that 𝑥 𝑦 iff 𝛿 𝐸 𝑥 , 𝐸 𝑦
𝜏.
To give the flavor of our approach, we remark that it is relatively easy to determine this
threshold if the encoding procedure does not contain the sorting step 2 in the encoding
procedure, as the following lemma implies.
Lemma 1. If we eliminate the sorting step 2 in the encoding procedure with parameters

𝑀, 𝑝, 𝑛, 𝑘 , and set 𝑘

and 𝜏

2𝑘 for 𝑚

Proof. From the definition of 𝑘, we have 𝑛
𝑥 𝑦 ⟹ 𝐶 𝑥
𝐶 𝑦 ⟹ 𝛿 𝐶 𝑥 ,𝐶 𝑦
𝑥

𝑦 ⟹ 𝛿 𝐶 𝑥 ,𝐶 𝑦

𝑛

𝑚

𝑚

log 𝑀 , then 𝑥

4𝑘, so
0 ⟹ 𝛿 𝐸 𝑥 ,𝐸 𝑦

1 ⟹ 𝛿 𝐸 𝑥 ,𝐸 𝑦

𝑛

𝑚

𝑦 iff 𝛿 𝐸 𝑥 , 𝐸 𝑦
2𝑘

𝜏

1

2𝑘

4𝑘

2𝑘

𝜏.

𝜏
□

While not incorporating the sorting step 2 is amenable to easy analysis and identification of 𝑘
and 𝜏, it also compromises the security of the encoding 𝐸 𝑥 , namely, it is then quite easy to
recover 𝑥 from 𝐸 𝑥 . This is essentially error-correction from 𝑘 errors, which, as mentioned
above, is possible by a number of efficient algorithms, taking advantage of the special algebraic
structure of 𝒞 [10].
The advantage of introducing sorting step 2 is precisely because it prevents the use of the
standard error-correction algorithms, since the critical correspondence between the coordinates
of 𝐶′ 𝑥 (and thus of 𝐸 𝑥 ) and the indices in the original 𝐶 𝑥 is lost.
The disadvantage of introducing sorting step 2 is that it modifies the Hamming distance 𝑑
present in 𝒞, which is not likely to be preserved in 𝒞′ and ℰ. In theory it could increase the
distance, but it is much more likely to decrease it. It seems like it will be difficult to obtain a
lower bound on this distance (which could have then been used to determine a threshold 𝜏, akin

to Lemma 1), since all the algebraic structure that was present in 𝒞 has been destroyed in the
transition to 𝒞′ and ℰ.
Luckily, we are still able to make useful observations about the nature of the encoded vectors
in ℰ. To the naked eye, the basic code space 𝒞 will consist of integer vectors of essentially
random values in the range 0, … , 𝑝 1 . By “random” we mean actually pseudo-random,
namely that although completely determined by 𝑥, it will be statistically impossible to
distinguish between these vectors and completely random vectors. The sorting of the vectors will
make them less random, but it will still be quite difficult to distinguish between the vectors in ℰ
and random non-decreasing integer vectors.
4. The Matching Algorithm
Let us recall the application: We have a database of 𝐷 pairs of user ID’s and encoded spatiotemporal values: 𝑖, 𝐸 𝑥 : 𝑖 1, … , 𝐷 . Given the 𝑞𝑢𝑒𝑟𝑦 – a vector 𝑒 – we wish to find all
matches of 𝑒, namely, find all database entries 𝑖, 𝑒′ such that both 𝑒 and 𝑒′ are possible
encodings of the same data value 𝑥, i.e. 𝛿 𝑒, 𝑒′
𝜏 for a suitable threshold 𝜏. We say that 𝜏 is
the matching threshold and 𝑒 matches 𝑒.
Recall that the size of the world is 𝑀 |𝑊| 10 . Assuming 1 billion = 10 users, each
storing location data for every 30 seconds over the past month, namely, close to 10 timestamped locations, this implies that the database could contain 𝐷 10 entries.
We would like to show that even though the vectors are sorted, a matching threshold of 𝜏
2𝑘 for “reasonable” values of 𝑘, as in Lemma 1 above, is still a good choice. This is because the
size of the database (𝐷) is much smaller than the size of the world (𝑀), thus the probability that
database vectors match a typical query vector is infinitesimally small, unless they are encodings
of the same world data.
Remember that 𝐷 ≪ 𝑀 ≪ 𝑁, where 𝑀 𝑝 and 𝑁 𝑝 . Now, if given a query 𝑒
𝐸 𝑥 for which there exists a matching database entry 𝑒′, then obviously 𝛿 𝑒, 𝑒′
2𝑘. So to
avoid false negatives, namely, to avoid missing correct matches, we must take 𝜏 2𝑘.
Can we expect a given query vector 𝑒 𝐸 𝑥 to “accidentally” match a vector 𝑒′
𝐸 𝑦 corresponding to another 𝑦 𝑥 in the database because of the sorting and corruption of the
original basic code vectors in 𝒞 ? The following theorem implies that this false positive is highly
unlikely.
Theorem 1: Given any 𝑒 ∈ ℰ, an upper bound for the probability of a vector 𝑒 ∈ ℰ, generated

by sorting the coordinates of a random vector 𝑧 ∈ ℤ , differing from 𝑒 in at most 𝜏 non-adjacent
coordinates is
Prob 𝛿 𝑒, 𝑒′

𝜏

𝑠 𝑝, 𝑛, 𝜏

𝑛!
⋅
𝑝

2𝑝
.
𝑑!

Proof. For the case 𝜏 0, the probability of an exact match in all coordinates is at most 𝑛!/𝑝 ,
since all 𝑛! permutations of 𝑒 can be taken as 𝑧 among all 𝑝 possible unsorted vectors in ℤ ,

such that 𝛿 𝑒, 𝑒′
0. For every coordinate of 𝑒 that occurs with multiplicity 𝜇 1, the
probability reduces by a factor of 𝜇!, because the order of the repeated coordinate in 𝑧 does not
matter.
For the case 𝜏 1, let us study the number of sorted vectors 𝑒′ ∈ ℰ that differ from 𝑒 in
exactly one coordinate. Letting 𝑒
0 and 𝑒
𝑝 1, it is clear that each coordinate 𝑒 ′ of 𝑒′
for 𝑖 1, … , 𝑛 can take any value in 𝑒 , … , 𝑒 1, 𝑒 1, … , 𝑒
without compromising the
correct order. Hence, there are
𝑒

𝑒

𝑝

1

𝑒

𝑒

2𝑝

2

2𝑝

sorted vectors 𝑒′ ∈ ℰ at distance 𝛿 𝑒, 𝑒′
1 from 𝑒 and thus the number of sorted vectors 𝑒′ ∈
ℰ with 𝛿 𝑒, 𝑒′
1 is at most 2𝑝 1. Using the same permutation argument as before, this
proves the upper bound for 𝜏 1.
For the case 𝜏 1 we apply the previous argument iteratively 𝜏 times while using the
assumption that the coordinates of 𝑒′ that differ from those of 𝑒 are non-adjacent. Then a vector
at distance 𝜏 1 is just a modification of a vector at distance 𝜏 in one additional coordinate, thus
the number of modifications is at most 2𝑝 . Note that this is an overestimate as a modification
may occasionally reduce the distance by one. Since the order of modification of the modified
coordinates is not important, we have counted each distinct modification 𝜏! times.
□
The assumption that the differing coordinates of 𝑒 and 𝑒 are non-adjacent makes the proof of
Theorem 1 easier, but we have experimentally observed that this upper bound holds also for the
unrestricted case.
So the expected number of false positives for any given query 𝑒 is at most 𝐷𝑠 𝑝, 𝑛, 𝜏 , which
decreases as 𝜏 decreases. For the values 𝑝 503, 𝑛 100, we may use 𝑘 10 and matching
threshold 𝜏 20, thus 𝑠 𝑝, 𝑛, 𝜏
10 . Since 𝐷 10 , the expected number of false
positives per query is infinitesimal (10
, and even the expected number of false positives
when each database entry is used as a query is still only 𝐷 𝑠 𝑝, 𝑛, 𝜏
10 .
Conclusion. In our encoding scheme, it suffices to take a corruption parameter 𝑘 which is not

too small and not too large, and then use 𝜏 2𝑘 as the matching threshold. Such a threshold will
completely avoid false negatives and produce a negligible number of false positives.
Retrieving Matching Data. Now that we have a suitable matching threshold for our matching

algorithm, we must address the algorithmic question of how to organize the database of 𝐷
encoded values (which are sorted integer vectors), such that given a query vector 𝑒, it is possible
to efficiently find all pairs 𝑖′, 𝑒′) in the database such that 𝑒′ matches 𝑒, namely such that
𝛿 𝑒, 𝑒′
𝜏 ? This is known as the “static Hamming distance range query”. Of course,
exhaustive search of the database is possible, but that would cost 𝑂 𝐷 time, which is too costly
in our scenario where 𝐷 10 . Efficient data structures have been devised for dealing with this

problem, as in Manku et al. [11]. This requires 𝑂 𝜏𝑛𝐷 storage (which is significant but not
prohibitive in our application but has very fast (𝑂 log 𝐷 query runtime. See also Liu et al.
[12] for more recent work.
5. The Tracing Algorithm
Now that we have an encoding algorithm and are able to match two encoded vectors, we
describe the procedure to be followed by the individual users and the central server to do the
actual contact tracing and alerts.
User with ID 𝒊

 The user continuously transmits to the server data pairs 𝑖, 𝑒 where 𝑒 𝐸 𝑥 and 𝑥
𝑡, 𝑙
is her time and location, tagged as “uninfected”. The user also stores the triples 𝑡, 𝑙, 𝑒 in a
local database indexed by 𝑡 and 𝑒 (e.g. on her smartphone), so that it is easy to retrieve all
𝑒′s transmitted during a given time interval and recover 𝑡, 𝑙 from its encoding 𝑒.
 If the user discovers she is infected, she sends again all pairs 𝑖, 𝑒 generated by her over the
past, say, two weeks (by querying her local database) back to the server, tagged as
“infected”.
 Upon receipt of message 𝑒 tagged with “possible infection” from the server, the user
recovers the infection time and location 𝑡, 𝑙 from 𝑒 (by querying her local database). The
user self-isolates for two weeks and can possibly report 𝑡, 𝑙 separately to friends and
family.
Central server

 Upon receipt of a data pair 𝑖, 𝑒 tagged “uninfected”, the server stores the pair on the server
database (of size 𝐷).
 Upon receipt of a pair 𝑖, 𝑒 tagged “infected”, the server retrieves from the server database
(by the matching algorithm described in Section 4) all pairs 𝑖′, 𝑒′ for which 𝑒′ matches 𝑒.
The server then sends these 𝑒′ to user 𝑖′ tagged with “possible infection”.
6. Attacking the Code
Recall that a critical objective is to “hide” the data by its encoding, namely render it
computationally infeasible to recover the (large) integer 𝑦 ∈ 𝑊 from the integer vector 𝑒
𝐸 𝑦 ∈ ℰ, either because it would require too much computation time or too much storage space.
We describe here three possible methods of attack and argue that they are infeasible.
Brute-force attack. The simplest method is just to exhaustively scan the entire world and check

if the encoded version 𝑒′ 𝐸 𝑥 of any world point 𝑥 matches the given encoding 𝑒 (namely,
that 𝛿 𝑒, 𝑒′
𝜏 . This would require |𝑊| 𝑀 10 encodings and comparisons, which is
prohibitive in runtime.
Table attack. We could reduce the runtime of the brute-force attack by trading off space for

time, employing a very large database. Simply compute some encoding 𝐸 𝑥 for every possible

𝑥 ∈ 𝑊 in a preprocessing phase and store the pairs 𝑥, 𝐸 𝑥 in a database indexed by 𝐸 𝑥 .
Given an encoding 𝑒, the matching algorithm described in Section 4 would then be able to
quickly retrieve all matches of 𝑒. However, this requires a database of size 𝑂 𝜏𝑛𝑀 which is
10 times larger than the server database. For 𝑀 10 , 𝑝
at least 10 bytes, and would be prohibitively large.

503, 𝑛

100 and 𝜏

20, this is

Direct attack. A direct attack occurs when an adversary tries to invert the encoding through a

subset of the coordinates by applying the traditional decoding algorithms such as solving a linear
Vandermonde system. This is foiled by the sorting of the coordinates of the vectors. Since
inversion requires knowledge of the correspondence between coordinates and their indices for at
least 𝑚 uncorrupted coordinates, this is what an attempt to invert 𝑒 𝐸 𝑥 must look like:
for each subset of 𝑚 coordinates (out of 𝑛)

// there are

for each permutation of 𝑚 indices (out of 𝑛)

// there are

!
!

such subsets

such permutations

solve for 𝑥 (e.g., by multiplying 𝑒 by the inverse of the Vandermonde sub-matrix
consisting of the corresponding 𝑚 rows from the full 𝑛 𝑚 Vandermonde matrix);
if 𝑥 𝑀 then continue;
compute 𝑒′ 𝐸 𝑥 ;
if 𝛿 𝑒, 𝑒′
𝜏 then return(𝑥);
end for;
end for;
Each solve costs Ω 𝑚 time. Should any of the selected subset of 𝑚 coordinates be corrupted,
the inner loop will run completely, costing
coordinates are corrupted is
average after exp

1

!
!

exp

solves. Since the probability that none of the 𝑚
, the outer loop will terminate on the

iterations and the inner loop will compute an expected number of

!
!

solves the last time it runs. Note that failure in one iteration due to one or more corrupted
coordinates will not reveal which of the 𝑚 coordinates are corrupted, so that there is no extra
information that can help to choose a “better” set of 𝑚 coordinates in the next iteration. In total,
the expected number of solves for this attack would be
503, we have 𝑚
long.

8. With 𝑘

!
!

exp

. For 𝑛

100 and 𝑝

10, the expected number of solves is 10 , which would take too

7. An Alternative: Redundant Residue Number Systems
While we have presented an encoding method based on polynomials over finite fields, it is
possible to use another method which is also employed in error-correcting coding and secret-

sharing. This involves so-called redundant residue number systems. Originally proposed in the
1950’s for efficient arithmetic computations on large integers [13], this technique was adopted
for error-correction coding soon after [14,15] and is also used in cryptography [16,17]. The main
difference between this method and the basic coding method described above based on
polynomials is that now the basic code space is 𝒞 ℤ
ℤ
⋯ ℤ instead of ℤ for a
sequence of distinct primes 𝑝 , … , 𝑝 .
Recall that the “world” is 𝑊
0, … , 𝑀 1 . Let 𝑝 , … , 𝑝 be a sequence of increasing
primes and 𝑚 an integer such that ∏
𝑝
𝑀 ∏ 𝑝 , Denote 𝑁 ∏ 𝑝 . The
encoding function 𝐸: 𝑊 → ℰ for a domain element 𝑥 ∈ 𝑊, has parameters 𝑝 , … , 𝑝 , 𝑘, 𝑛 ,
where 𝑝 are primes and 0 𝑘 𝑛 is an integer. The basic coding function is simply 𝐶 𝑥
𝑥 mod 𝑝 , … , 𝑥 mod 𝑝
∈ 𝒞. Similar to the case of polynomials over finite fields, the
infamous Chinese Remainder Theorem [15] guarantees that 𝑥 can be recovered from any subset
of 𝑚 coordinates of 𝐶 𝑥 along with their indices, so this code also has Hamming distance 𝑛
𝑚 1, and error-correction may be done using a variety of methods taking advantage of the
algebraic structure (e.g. [18]). Our encoding proceeds as above, by sorting the coordinates of the
basic code and corrupting a small subset without changing the order. Nothing else is changed.
Despite this approach actually being simpler to implement than the polynomial-based
approach, it is less desirable due to 𝑚 being more constrained as a function of the primes used.
For example, for 𝑛 80 , taking 𝑝 to be all the consecutive primes from 877 to 1,451 (having
geometric mean 1,143) yields only 𝑚 7. An appropriate 𝑘 would be 8, thus 𝜏 16. The
probability of a false positive is then 10
and the complexity of the direct attack is 10 (see
Table 1).
Table 1. Parameters of the different settings for world size 𝑀

coding
method

encoded
alphabet
vector
size
length
𝑛

polynomial
polynomial
polynomial
residues

100
100
200
80

𝑝
503
101
211
1,143

data
vector size
(base 𝒑)
𝑚
log 𝑀
8
10
9
7

corrupted matching
coordinates threshold
𝑘

𝜏

10
1
20
8

20
2
40
16

10

and database entries 𝐷

encoded
vector
size
(bits)

expected #
of false
positives

⌈𝑛 log 𝑝⌉ 𝐷 𝑠 𝑛, 𝑝, 𝜏
898
666
1,545
858

10−43
10−10
10−5
10−58

10 .

“direct attack”
complexity

𝑛

𝑛!
𝑘𝑚
exp
𝑚 !
𝑛
1016
1020
1021
1013

8. Discussion
Increasing the security. It is relatively easy to increase the security of the system, i.e. making a

direct attack on the system more difficult. In the scenario described above, where 𝑀 10 , we
took 𝑛 100, 𝑝 503, implying 𝑚 8, thus the complexity of a direct attack is 10 . If we
were to take instead 𝑛 100 and 𝑝 101, so that 𝑚 ⌈log 10 ⌉ 10, the complexity
would increase to 10 (although we would have to take 𝑘 1 and 𝜏 2 to keep the probability

of a false positive at 10
, and if this were not enough, we can increase this further by
increasing both 𝑛 and 𝑝. See Table 1 for a comparison of the attack complexity resulting from
different values of the system parameters. Increasing 𝑛 obviously increases the (bit) size 𝑛 ⋅
log 𝑝 of the code 𝐶 𝑥 and thus the size of the server database, but the same is true for the
database of the “table” attack.
Using a deterministic mapping. Our encoding method is non-deterministic, namely involves

randomly corrupting a subset of 𝑘 0 coordinates in the sorted basic code vector. The
advantage of a large 𝑘 is that it increases the difficulty of a direct attack on the database, as
described in Section 6. However, for certain values of the other system parameters, it may be
possible to make do with a deterministic encoding method, namely 𝑘 𝜏 0. In this case,
matching a query vector within the server database reduces to exact vector match, which may be
done easily by binary search on a table (of size 𝐷 of the database entries 𝑖, 𝑒 , sorted in
lexicographic order of 𝑒.
Detecting proximity. The method outlined in this article provides an easy way to determine

whether 𝑥 𝑦 by comparing 𝐸 𝑥 and 𝐸 𝑦 . Recall that 𝑥 and 𝑦 are taken from a discrete
world, which are essentially samples of the true continuous world at some finite resolution grid.
However, sometimes in contact tracing it is necessary to also determine proximity beyond the
grid resolution, either because of an increased radius of infection or simply because the accuracy
of the measured location (typically taken from a GPS device) is much worse than the grid
resolution and the chances of an exact match in measured location even when two users are
within grid resolution, is very slim.
It would seem difficult to achieve this, since the encoded vectors have a pseudo-random
distribution and any spatio-temporal correlation between two data points would be “lost in
encoding”. The easy way to circumvent this is for the user to transmit to the central server
encodings of not just her current location, but also of the neighboring grid points, effectively
“dilating” the data point. This would incur some overhead in storage and transmission costs on
both client-side and server-side.
“Inflating” the world. The world size, in our contact tracing application, is 𝑀

10 integers,
which is very large, but constrains some of the parameters in our encoding scheme. In particular,
the parameter 𝑚, if too small, could compromise the security against the direct attack, as
described in Section 6. One way to rectify this would be to “inflate” the world by means of some
function 𝑓: 𝑊 → 𝑊′ with 𝑀 |𝑊| ≪ |𝑊′| 𝑀′. This function 𝑓 should be injective and nonpolynomial, so that it cannot be inverted easily at each individual coordinate. One possibility for
such an 𝑓 is the following:
Let 𝑞 denote the 𝑖-th prime (i.e., 𝑞
2, 𝑞
3, etc.) and observe that the product of the first
𝑚
16 primes is a little larger than the size of our world. Hence, the first step is to map 𝑥 ∈ 𝑊
to the residue code vector w.r.t. these 16 primes, namely compute 𝐶 𝑥
𝑐 ,…,𝑐
with 𝑐

𝑥 mod 𝑞 . For the next step, let 𝑠

∑

𝑞 denote the sum of the first 𝑖

1 primes (i.e., 𝑠

0, 𝑠
2, 𝑠
5, etc.) and let us map each 𝑐 to the 𝑠 𝑐 1 -th prime, giving the vector
∏ 𝑐 ′ and note that 𝑓 𝑥
𝐶′ 𝑥
𝑐 ′, … , 𝑐 ′ with 𝑐 ′ 𝑞
. Finally, we define 𝑓 𝑥
is a square-free integer with exactly 𝑚 prime factors. Moreover, as the mapping 𝐶 is injective,
it follows that 𝑓 𝑥 and 𝑓 𝑦 for 𝑥 𝑦 have at most 𝑚
1 common factors, thus guaranteeing
the injectivity of 𝑓. The size of the inflated world is 𝑀′ ∏ 𝑞
10 . We now continue
to encode 𝑥′ 𝑓 𝑥 ∈ 𝑊′ instead of 𝑥 ∈ 𝑊 with the polynomial-based approach outlined above,
but now having the advantage of a larger 𝑚′ 15 instead of the previous 𝑚 8.
Other linear codes. The basic code based on polynomials that we use is a linear code, in the

sense that the coding operation is just multiplication by a matrix: 𝐶 𝑥
𝑉 ⋅ 𝑥 over ℤ . 𝑉 is the
𝑛 𝑚 Vandermonde matrix, which has the special property that all submatrices of size 𝑚 𝑚
have full rank. This property allows to recover 𝑥 from any subset of 𝑚 coordinates of 𝐶 𝑥 by
multiplying them by the inverse of the appropriate submatrix of 𝑉. Thus any 𝑛 𝑚 matrix with
similar properties would serve the same purpose. Furthermore, were we to construct an 𝑛 𝑚
matrix 𝐴 with the property that some of the submatrices of size 𝑚 𝑚 have rank less than 𝑚,
and that full rank is obtainable only when the submatrix is enlarged to 𝑚 𝑙
𝑚, this,
coupled with the corruption of coordinates during encoding, could further complicate the direct
attack on the method described in Section 6.
References
[1] https://www.apple.com/covid19/contacttracing [accessed on 07/07/2020]
[2] https://www.techrepublic.com/article/data-researchers-at-odds-will-americans-opt-in-orout-of-covid-19-contact-tracing-apps/ [accessed on 07/07/2020]
[3] https://www.msn.com/en-us/news/technology/researchers-found-north-dakotas-contacttracing-app-covertly-sending-location-and-advertising-data-to-third-parties/ar-BB14sOCn
[accessed on 07/07/2020]
[4] A. Berke, M. Bakker, P. Vepakomma, K. Larson, A. Pentland. Assessing disease exposure
risk with location data: A proposal for cryptographic preservation of privacy.
arXiv:2003.14412 (8 April 2020).
[5] J. K. Fitzsimons, A. Mantri, R. Pisarczyk, T. Rainforth, Z. Zhao. A note on blind contact
tracing at scale with appli-cations to the COVID-19 pandemic. arXiv:2004.05116 (10 April
2020).
[6] I. S. Reed, G. Solomon. Polynomial codes over certain finite fields. J. SIAM 8(2), 300–304
(1960).
[7] A. Shamir. How to share a secret. Commun. ACM, 22(11), 612–613 (1979).
[8] L. Cheng, J. Liu, C. Su, K. Liang, G. Xu, W. Wang. Polynomial-based modifiable
blockchain structure for removing fraud transactions, Future Generation Computer
Systems 99, 154–163 (2019).

[9] https://plus.codes/ [accessed on 07/07/2020]
[10] S. Gao. “A new algorithm for decoding Reed–Solomon codes” in Communications,
Information and Network Security, V. K. Bhargava, H. V. Poor, V. Tarokh, S. Yoon, Eds.
SECS 712 (Springer, 2003), pp. 55–68.
[11] G. S. Manku, A. Jain, A. D. Sarma, “Detecting near duplicates for web crawling” in Proc.
16th WWW (2007).
[12] A. X. Liu, K. Shen, E. Torng, “Large scale Hamming distance query processing” in Proc.
IEEE Conf. Data Engineering, pp. 553–564 (2011).
[13] H. L. Garner, “The residue number system” in Proc. ACM Western Joint Computer Conf.,
pp. 146–153 (1959).
[14] R. W. Watson, C. W. Hastings, “Self-checked computation using residue arithmetic” in
Proc. IEEE 54, 1920-1931 (1966).
[15] F. Barsi, P. Maestrini, Error correcting properties of redundant residue number systems.
IEEE Trans. Comp. C-22(3), 307–315 (1973).
[16] M. Mignotte, “How to share a secret” in Cryptography. EUROCRYPT 1982, T. Beth, Eds.
LNCS 149 (Springer, 1983), pp. 371–375.
[17] C. A. Asmuth, J. Bloom, A modular approach to key safeguarding. IEEE Trans. Inf.
Theory, IT-29(2), 208-210 (1983).
[18] O. Goldreich, D. Ron, M. Sudan, Chinese remaindering with errors. IEEE Trans. Inf.
Theory 46(4), 1330–1338 (2000).
[19] J. Bell, D. Butler, C. Hicks, J. Crowcroft. TraceSecure: Towards privacy preserving
contact tracing. arXiv:2004.04059 (8 April 2020).
[20] L. Reichert, S. Brack, B. Scheuermann. A survey of automatic contact tracing approaches.
Eprint:2020.672 (19 June 2020).

