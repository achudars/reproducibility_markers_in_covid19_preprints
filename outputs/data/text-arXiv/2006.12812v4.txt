An Efficient Index for Contact Tracing Query in a Large
Spatio-Temporal Database
Mohammed Eunus Alia , Shadman Saqib Eusufa , Kazi Ashik Islamb

arXiv:2006.12812v4 [cs.DB] 9 Aug 2020

a Bangladesh

University of Engineering and Technology, Bangladesh
b University of Virginia, USA

Abstract
In this paper, we study a novel contact tracing query (CTQ) that finds users who have
been in direct contact with the query user or in contact with the already contacted
users in subsequent timestamps from a large spatio-temporal database. The CTQ is of
paramount importance in the era of new COVID-19 pandemic world for finding possible list of potential COVID-19 exposed patients. A straightforward way to answer
the CTQ is using traditional spatio-temporal indexes. However, these indexes cannot
serve the purpose as each user covers a large area within the time-span of potential
disease spreading and thus they can hardly use efficient pruning techniques. We propose a multi-level index, namely QR-tree, that consider both space coverage and the
co-visiting patterns to group users so that users who are likely to meet the query user
are grouped together. More specifically, we use a quadtree to partition user movement
traces w.r.t. space and time, and then exploit these space-time mapping of user traces
to group users using an R-tree. The QR-tree facilitates efficient pruning and enables
accessing only potential sets of user who can be the candidate answers for the CTQ.
Experiments with real datasets show the effectiveness of our approach.
Keywords: Contact tracing query, Spatio-temporal database, COVID-19

Email addresses: eunus@cse.buet.ac.bd (Mohammed Eunus Ali),
s.saqibeusuf@gmail.com (Shadman Saqib Eusuf), ikaziashik@gmail.com (Kazi Ashik
Islam)

Preprint submitted to Journal of Big Data Research

August 11, 2020

1. Introduction
The world is witnessing an unprecedented pandemic as the coronavirus (SARSCoV-2) is continuing its spread across the globe. As of today (May 13, 2019) there are
more than four million confirmed cases in 185 countries and more than 290,000 people
have lost their lives due to the virus infected respiratory infection commonly referred
to as COVID-19 [1]. This virus is extremely infectious, where it can easily pass from
person to person. Thus, to curb the spread of the coronavirus, authorities around the
world implemented lockdown measures for months. However, these lockdowns have
brought much of global economic and social activity to a halt.
To avoid the socio-economic catastrophes, the authorities have gradually started to
ease the lockdowns. However, they are still struggling to find efficient techniques to
monitor the mobility of potentially COVID-19 infected patients and who have been in
contact with a virus infected person. Since people in close contact with someone who
is infected with the virus are at higher risk of becoming infected themselves, and of potentially further infecting others, closely monitoring these contacts can prevent further
transmission of the virus. This process of monitoring is known as contact tracing. In
this paper, we study the problem of contact tracing query (CTQ) in a spatio-temporal
database.
Consider the following scenario. Let D be the historical mobility traces (or equivalently trajectories) of users for the last T days, obtained from GPS-enabled phones
or mobile signals through triangulations. Thus, each user u ∈ D is represented as a
sequence of time stamped locations {(l1 , t1 ), (l2 , t2 )....(ln , tn )} denoting her visited
places l1 , l2 , ..., ln in different times t1 , t2 , ..., tn , respectively. Let q be the mobility
traces (or the trajectory) of a newly identified COVID-19 infected user, which is the
query in our system. The objective of the CTQ is to identify a set of users U ⊂ D who
have been in direct contact with q at any point of time, and subsequently find users who
came into contact with the already contacted users.
To process variants of trajectory related queries such as range, join, nearest-neighbor,
etc., a large body of trajectory indexing techniques have been proposed in the literature [2, 3, 4, 5]. These indexes are variants of traditional spatio-temporal indexes such

2

as R-tree [6] or quad-tree [7]. These indexes are tailored for answering different types
of queries. Though it may seem that the CTQ can be solved by using existing indexes
designed for range queries, running repetitive range queries for different points of the
query trajectory in the CTQ will make it extremely in-efficient. This is due to the following two reasons: (i) the mobility traces or historical trajectories of a user are usually
a set of time-stamped dispersed point locations covering a large area, which is different
than the normal point data such as POIs (Point of Interest) or trajectory data such as
taxi trips, and thus very hard to prune using traditional indexes, (ii) if a user’s travel
history matches with the query at any instance then the user will be a candidate answer,
and we need to run the process recursively as this user may have subsequently infected
others.
To answer the CTQ efficiently, we propose a two-level index structure, namely
QR-tree, that exploits the strengths of both quad-tree and R-tree. In the first level, we
use a quad-tree to partition the points of historical trajectories, where the location of a
trajectory point is specified by the space − id of the smallest quad-tree block that contains the point. Similarly, the timestamp of each location of a trajectory is mapped to a
time − id that corresponds to a time bucket containing the timestamp of the trajectory
point. After that, we transform each trajectory as a sequence of (space − id, time − id)
tuples. We consider this mapping as a transformation to a new coordinate system for
the trajectory points. Next, we apply an R-tree on the trajectory points, represented by
the new coordinate system, for grouping and saving them in disk. Finally, we present
an efficient divide-and-conquer approach to answer CTQ, where a query is recursively
divided and run through different levels of the index to find the users who match in
both space and time.
The contributions of the paper are summarized as follows:
• We are the first to introduce a novel contact tracing query (CTQ) in a large spatiotemporal database, which is of paramount importance for identifying users who
were potentially exposed to COVID-19 infected users.
• We propose a multi-level index structure, namely QR-tree, that combines the regular space-partitioning strategy of a quadtree, and the object grouping strategy of
3

an R-tree, to organize the user spatio-temporal data in such a way that facilitates
faster processing of the CTQ.
• We present an efficient divide-and-conquer approach for answering CTQ queries
using the QR-tree. We evaluate our indexes and algorithms through an extensive
experimental study on real datasets, which demonstrate both the efficiency and
effectiveness of our solution.

2. Problem Formulation
Let D be the historical mobility traces (or equivalently trajectories) of users for
the last T days, obtained from GPS-enabled phones or mobile signals through triangulation. Each user u ∈ D is represented as a sequence of time stamped locations
{(l1 , t1 ), (l2 , t2 ), ...(ln , tn )} denoting her visited places l1 , l2 , ..., ln in different times
t1 , t2 , ..., tn , respectively. Let q be the mobility traces (or the trajectory) of a COVID-19
infected user, which is represented as the sequence {(q.l1 , q.t1 ), (q.l2 , q.t2 )....(q.ln , q.tn )},
the query in our system.
Any two users u and v meet each other if and only if both the spatial distance and
temporal distance of any two points of u and v, respectively, are under certain distance
thresholds. Formally, the meeting condition for two trajectories can be expressed as
follows.
Condition of u meets v: Let {(u.l1 , u.t1 ), (u.l2 , u.t2 )....(u.ln , u.tn )} and {(v.l1 , v.t1 ),
(v.l2 , v.t2 )....(v.lm , v.tm )} be the two sequence of time-stamped locations of u and v,
respectively. Let spatialDist and temporalDist be the spatial distance and temporal distance measuring functions between two locations and two time-stamps, respectively. Now, for any i ∈ [1, n], j ∈ [1, m], if spatialDist(u.li , v.lj ) ≤ ψ and
temporalDist(u.ti , v.tj ) ≤ τ , then we say the trajectory u meets the trajectory v.
Here, ψ and τ , are spatial (euclidean) and temporal distance thresholds, respectively.
The objective of the CTQ is to identify the set of users U ⊂ D where each user
u ∈ U has potentially been exposed to the corona virus. We define the set U as follows.
1. Let U0 be the set of users where each user u ∈ U0 met with q at any timestamp
u.t in the last T days. We say that u was exposed at time u.texposed (= u.t).
4

Here, the subscript zero (0) in U0 denotes that, the number of intermediate carriers (of the virus) between user q and u is zero (i.e u was infected by the query
user q).
2. Let U1 be the set of users where each user u ∈ U1 met with any user v ∈ U0
at timestamp u.t > v.texposed . We define u.texposed (= u.t) as the time of
exposure for user u.
3. In a similar manner, we can define the set of users Ui recursively where each
user u was exposed to some user v ∈ Ui−1 . Then, we define the set U as:
U=

L−1
[

Ui

i=0

Here, L is an integer that denotes the maximum allowed depth for the recursion
and is passed as a parameter for CTQ.
Based on the above definitions, we formally define our contact tracing query as
follows.
Definition 2.1. CTQ. Given a set D of user trajectories, a COVID-19 infected user trajectory q, a spatial proximity threshold ψ, a temporal proximity threshold τ , and
SL−1
an integer L, a CTQ query finds a set of users U ⊂ D such that U = i=0 Ui ;
where Ui is the set of users who were exposed to the query user through ‘i’
number of intermediate carrier users.
3. The Proposed Index
The trajectories in our datasets can be very long (e.g., last 14 days of mobility traces
of each user) and may cover large areas. Using an R-tree to index the two spatial and
one temporal dimension of these trajectories might not be useful as each trajectory’s
MBR (Minimum Bounding Rectangle) will most likely overlap with too many other
trajectories’ MBRs, making the pruning scheme of the R-tree ineffective. On the other
hand, if we use a quadtree to index all points of the trajectories, the points of a single
trajectory may end up in many quadrant of the quadtree blocks, and thereby making it
hard to decide which of those trajectories should be stored together in a disk block to
facilitate faster retrieval of candidate users.
5

3.1. QR-tree
The key intuition of our proposed index is, the trajectories whose points are colocated at the overlapping time-instant are likely to match with the same query. Based
on this observation, we present a two-level index, the Quad R (QR) tree, that combines
the strengths of both quadtree and R-tree.
First, the spatial data space is recursively partitioned using quadtree, where each
leaf quadtree block does not contain more than θ points. Then we use a space filling
curve, specifically a z-curve (Morton order), to number these leaf quadtree blocks. We
call such a number, the spatial − id of the block. Thus, in the spatial domain each
trajectory is represented as a list of spatial − ids. Similarly, each timestamp of a
trajectory is mapped to a time bucket and assigned a number temporal − id. Thereby,
each trajectory can now be represented as sequence of (spatial − id, temporal −
id) tuples. This new mapping of trajectories can be seen as a transformation to a
new coordinate system, where x-axis represents spatial dimension and y-axis represent
temporal dimension, and each trajectory is represented as a set of points in that space.
In the next step, we use an R-tree to group trajectories based on their sets of points
in the transformed space. Essentially, each set of points in this new space is represented
as an MBR, and the R-tree groups close-by MBRs in a leaf node. Each leaf node of
the constructed R-tree is stored in a disk-page. We maintain this disk-page id in all
the corresponding leaf-blocks of the first level quadtree that contain a point of the
trajectories stored in this disk-page. In the quadtree block, we also maintain associated
temporal ids denoting the time range of trajectory points stored in the corresponding
disk-page. Note that, we do not keep the hierarchical structure of R-tree for query
processing, rather we only use the R-tree for grouping of similar trajectories in the
transformed space.
Figure 1 and Figure 2 show the construction process of the QR-tree. Figure 1(a)
shows an example with four user trajectories, {u1 , . . . , u4 }, where θ = 2. The space
is first divided into four quadrants Q1 , . . . , Q4 . As Q2 contains more than 2 trajectory points, this block is further divided into Q2.1 , . . . , Q2.4 . We then apply zordering to number these quadtree blocks as b1 , b2 , ..., b7 . After that each time-stamp
of points in the trajectories is assigned time-bucket number between t1 and t8 . After
6

Q2.1

Q1
T1

Q2.2 (t4)

b6

(t2)

(t5)

b3

b4

(t4)

b7

Q2

(t8)

(t3)

Q2.3 b5

(t5)

Q3

Q2.4

Q4
T2

(t4)

(t3)

T3

b1

(t3)

b2

T4

(t1)

T1
T2
T3
T4

(b3 , t2 ) , (b4 , t3 ) , (b7 , t4 )
(b1 , t3 ) , (b4 , t5 ) , (b5 , t8 )
(b1 , t3 ) , (b2 , t4 ) , (b5 , t5 )
(b2 , t1 ) , (b7 , t4 )

Figure 1: (a) A quadtree based space partitioning of trajectories. (b) Mapping of trajectories.
t8
t7
t6
t5
t4
t3
t2
t1

Q1 Q2 Q3 Q4

R2
T2
T1
T3
R3

T4

R1

b1 b2 b3 b4 b5 b6 b7

Q2.1 Q2.2 Q2.3 Q2.4

b6 b7 b4 b5
t 4 : R1

t 3 : R1 t 5 : R2
t 5 : R2 t 8 : R2

Figure 2: (a) An R-tree based grouping of trajectory points in a transformed space. (b) A QR-tree index
structure.

that Figure 1(b) shows the new representation of trajectories u1 − u4 as a sequence
of (bi , tj ) tuples. These points are then mapped into a new co-ordinate system in a
two-dimensional space (Figure 2(a)), where we can see points of four trajectories in
four different colors, and each set of points of a single trajectory is represented as
an MBR. These MBRs are grouped together to form an R-tree. Each leaf level node,
R1 , R2 corresponds to a disk-page. Finally, we maintain these disk-page references in
different level quadtree blocks of the QR-tree, as shown in (Figure 2(b)). For example,
with Q2.4 (b5 ), disk-page id R2 is assigned along with time-bucket ids t5 and t8 .
3.2. Q2 R-tree
We make further improvement on the proposed QR-tree index, where we augment
the index by adding another top-level quadtree. The intuition behind adding this top
level quadtree is two fold: (i) it partitions the entire sets of trajectories into different
groups based on their extents, thus the index will have better pruning capability, (ii)
since a longer trajectory will most likely contain more points than a shorter trajectory,
7

maintaining different length trajecotory in a single R-tree is challenge as trajectories of
different length may occupy different storage spaces in the disk.
In our proposed Q2 R-tree, a trajectory is stored under any non-leaf or leaf nodes
based on their extents. In this case, we recursively partition the space, and a trajectory
is stored in a quadtree block that fully contains it. Thus, long trajectories are stored
in the upper level quadtree blocks than shorter trajectories are stored in lower level
trajectory blocks. For all the trajectories in a single quadtree block, we apply QR-tree
strategy to organize them in disk. Since we use two quadtrees and one R-tree in the
index, we refer this index as Q2 R-tree.

4. Processing CTQ
In this section, we present an algorithm for processing CTQ using our proposed
QR-tree. Intuitively, the quadtree of QR-tree supports faster range query around query
trajectory points, while R-tree grouping ensures the lower I/O overhead. We apply a
spatial pruning followed by a temporal pruning using QR-tree, where the irrelevant
quadtree nodes are pruned first, and then the time buckets are used to further prune the
R-tree blocks to be retrieved. For simplicity, we present the first level contact tracing,
where the task is to find users who were directly exposed to q.
4.1. CTQ Matching Algorithm
Algorithm 1 describes the pseudocode for a divide-and-conquer algorithm for the
CTQ. A user u can be infected by q, if a point of u is within a threshold distance ψ
and a threshold time τ from any point of q. So to facilitate this spatio-temporal range
search, we consider an extended minimum bounding rectangle (EMBR) (in terms of
space) of every points of q to include the infectious region of q.
Initially, the function matchCT(·) is called with the root node N of the QR-tree
and q. It finds the relevant child nodes of N that intersect with q (or EMBRs of q) in
the function extendedIntersection(·) (Line 1.8). Thus, quadtree nodes that are within
ψ spatial distance threshold from q are considered. If a child node does not intersect
with the EMBR, it can be safely pruned. Otherwise, each unpruned child node Nc of

8

Algorithm 1: matchCT(N ,q)
Input: A quadtree node N of QR-tree, a COVID-19 positive user trajectory q
Output: A set U of user trajectories suspected to be exposed by q
1.1

U ←∅

1.2

if q = ∅ then return U

1.3

;

1.4

if N is a leaf then
← extendedTimeWindows(q)

1.5

tb

1.6

U ← evaluateContacts(N, tb

list

list , q)

1.7

Nchildren ← children(N )

1.8

qchildren ← extendedIntersection(Nchildren , q)

1.9
1.10

for Nc ∈ Nchildren , qc ∈ qchildren do
S
U ←U
matchCT(Nc , qc )

1.11

return U

N and the corresponding components of q, are passed to matchCT function according
to Algorithm 1 (Line 1.10).
The recursive method has two base conditions: (i) when q is empty (there is no
point left in that subspace for repeated division (Line 1.3)); and (ii) when N is a leaf
node. In case of a leaf node, the possibly infectious time buckets corresponding to the
points in q are calculated with the function extendedTimeWindows(·). This function
returns all the possible time windows within temporal range τ starting from that of
each point of q. Then the exposure of the trajectories stored in the disk blocks mapped
to the node N and entries of temporal bucket are computed with evaluateContacts(·).
The function evaluateContacts is used to determine which trajectories meet with q.
To compute it, first we need to retrieve trajectories which have transformed coordinates
(N, t), for each entry t ∈ tb

list .

So we look up our in memory QR-tree index and

obtain a list of relevant R−tree nodes (i.e. disk block ids). We the fetch the trajectories
stored in those disk blocks. For each user trajectory ti ∈ Tr , we compute whether the
user meets with q. The trajectory ti is included in the exposed set U if it meets with q.
The above algorithm supports contact tracing by passing the depth level L in matchCT(·)
as a recursion depth parameter. Initially the parameter is set to 0. Then in the aforementioned second base condition, we can call matchCT(·) recursively for each of the
9

computed exposed trajectories with depth parameter incremented by 1, until it has
reached L.
5. Experimental Evaluation
In this section, we compare the QR-tree with a baseline (BL) approach, where we
use a 3D R-tree (for location and timestamp) for indexing. We use it as our baseline
because, in contrast to other methods, a trajectory is saved in an Rtree leaf as a single
object. This is ideal for retrieving the whole trajectory during the processing of CTQ.
We use the mobility traces from the CDR data collected by Grameenphone Ltd between
June 19, 2012 and July 18, 2012 [8], hereafter referred to as BD Cellphone, as our
default dataset. Besides, we use Foursquare check-in dataset [9] of New York city,
hereafter referred to as NYF, to evaluate performance of CTQ in a different spatiotemporal domain. We use JDK 1.8 for implementing our algorithms, which were run
in Intel core i5-3570K processor (3.4 GHz) and 8 GB of RAM.
Performance Evaluation and Parameterization. The parameters we varied, their
ranges and default values (in bold) are shown in Table 1. We have varied a single
parameter in each experiment while the others are assigned their default values. We
measure the impact of the parameters on runtime and I/O cost i.e. # of disk blocks
accessed in CTQ processing. We configure the quadtree nodes to hold upto 128 points,
and R-tree blocks to hold upto 4 trajectories. For each set of experiments, we run 100
CTQ and present the average result.
Parameters

Ranges

# of Points Per Query Trajectory

1-50, 51-100, 101-200, > 200

# of Trajectories Indexed

10k, 25k, 50k, 100k

Spatial Distance Threshold (ψ)

1m, 2m, 4m, 10m

Temporal Distance Threshold (τ )

1 min, 15 min, 30 min, 1 hour, 3 hour

Maximum Recursion Depth (L)

1, 2, 3

Table 1: Parameters

Note that, the choice of spatial and temporal range thresholds is mostly application
specific. We have varied them in the aforementioned range mainly to demonstrate the
10

10

BL
QR

1

0.1

BL
QR

1

Time (sec)

Time (sec)

10

0.1

0.01
1-50
51-100 101-200 > 200
# of Points Per Query Trajectory

0.01
10k

(a)

(b)

BL
QR

10

# of Blocks

# of Blocks

104

103

4

BL
QR

103

10

102
1-50
51-100
101-200
> 200
# of Points Per Query Trajectory

25k
50k
100k
# of Indexed Trajectories

2

101
10k

(c)

25k
50k
# of Indexed Trajectories

100k

(d)

Figure 3: Evaluating CTQ for varying no. of points per query trajectory (a & c) and no. of trajectories (b &
d)

performance of our work. For COVID-19, 1 meter was considered as the maximum
distance for transmission via respiratory droplets [10], which is suggested as 2 meters
in some other studies[11]. Besides, there is an evidence, but perhaps no concrete proof
of transmission by aerosolized respiratory fluids, which is in fact likely to travel farther.
So we have varied the spatial range upto 10 meters, considering situations of indoor
environment. On the other hand, there is still no authentic information on the temporal
threshold for COVID-19 transmission. To the best of our knowledge, research works
are still going on in this topic. We have varied it from as low as 1 min upto 3 hours,
since the upper range is suggested so according to a study [12] in the New England
Journal of Medicine. However, upon availability of more legitimate information about
spatial and temporal thresholds, our algorithm should work just fine with the updated
parameter values, without any modification in its design.
5.1. Experiment with BD Cellphone
(i) No. of points per query trajectory: Our algorithm using the QR-tree index outperforms the baseline by 2 orders of magnitude in terms of both runtime (Figure 3a) and
by 1 − 2 orders of magnitude in terms of I/O cost (Figure 3c). As the number of points
in query trajectory increases, more user trajectories at different blocks are expected to
11

10

10

BL
QR

1

Time (sec)

Time (sec)

1

0.1

BL
QR

0.1

0.01

0.01
1min 15min 30min
1h
3h
Temporal Distance Threshold, τ

1
2
4
10
Spatial Distance Threshold, ψ (meter)

(a)
BL
104 QR

# of Blocks

# of Blocks

104

(b)

BL
QR

103

10

2

103

102
1min 15min 30min
1h
3h
Temporal Distance Threshold, τ

1
2
4
10
Spatial Distance Threshold, ψ (meter)

(c)

(d)

Figure 4: Evaluating CTQ for varying spatial distance threshold, ψ (a & c) and temporal distance threshold,
τ (b & d)

10

2

10

1

10

0

10

-1

10

-2

BL
QR
104
# of Blocks

Time (sec)

BL
103 QR

1

2

3

Maximum Recursion Depth, L

103

102

1

2

3

Maximum Recursion Depth, L

(a)

(b)

Figure 5: Evaluating CTQ for varying maximum recursion depth, L

12

be processed. So runtime as well as I/O should increase in both the approaches, as
reflected in the graph (Figure 3a, 3c).
(ii) No. of indexed trajectories: The QR-tree outperforms the baseline by around 2
orders of magnitude in terms of runtime (Figure 3b) and by around 1 order of magnitude (Figure 3d) in terms of disk I/O cost. Both the approaches follow an increasing
trend with the increase in the number of indexed trajectories. This is because more
trajectories require more disk blocks to be stored. So a higher number of disk blocks,
i.e., larger number of trajectories, are expected to be retrieved in query processing,
requiring more time to be processed.
(iii) Spatio-temporal thresholds (ψ, τ ): When we vary spatial (ψ) or temporal distance
thresholds (τ ), QR-tree works better than the baseline by at around 1 − 2 orders of
magnitude in terms of runtime (Figure 4a, 4b) and by at least 1 order of magnitude
(Figure 4c, 4d) in terms of disk I/O cost.
(iv) Maximum recursion depth (L): The performance of the QR-tree is significantly
important when we consider multiple levels of CTQ, that is, when we consider exposure from already exposed users upto a certain level, instead of confirmed patients
only. The QR-tree outperforms baseline approach by 2 − 3 orders of magnitude in
terms of runtime (Figure 5a) and by around 1 − 2 orders of magnitude in terms of I/O
cost (Figure 5b) when we vary maximum recursion depth level, L. More importantly,
note that, the QR-tree can provide results in tens of seconds in case of upto three levels
of exposure while the baseline would require thousands of seconds to do that. The
benefits of I/O may seem misleading for higher depth levels (Figure 5b) because the
CTQ processing gets saturated in terms of disk block access, i.e. it accesses almost all
the blocks in both approaches (baseline being marginally higher) to retrieve potential
candidate trajectories. For this reason, the baseline approach has a somewhat flat tail
for already accessing all the disk blocks. But running the experiment with higher number of trajectories to demonstrate this I/O gain is not feasible because of the intractable
runtime of the baseline method. Besides, instead of default temporal distance threshold
(τ ) value of 15 minutes, we have used τ = 1 minute for running this experiment to keep
the results demonstrable.

13

1

BL
QR

0.1

0.01

BL
QR

0.1

Time (sec)

Time (sec)

1

0.01

0.001
1
2
4
10
Spatial Distance Threshold, ψ (meter)

0.001
1min 15min 30min 1h
3h
Temporal Distance Threshold, τ

(a)

(b)
1000 BL
QR

BL
QR

# of Blocks

# of Blocks

1000

100

100

10
1
2
4
10
Spatial Distance Threshold, ψ (meter)

(c)

10

1
1min 15min 30min

1h

3h

Temporal Distance Threshold, τ

(d)

Figure 6: Evaluating CTQ on NYF for varying spatial distance threshold, ψ (a & c) and temporal distance
threshold, τ (b & d)

5.2. Experiments with NYF
The NYF dataset is significantly smaller than the BD Cellphone dataset. We report
only the impacts of varying spatio-temporal distance thresholds in the experiments with
this dataset since varying the other parameters would be of little value for the dataset
size.
(i) Spatio-temporal thresholds (ψ, τ ): The QR-tree works better than the baseline by
at around 2 orders of magnitude in terms of runtime (Figure 6a, 6b) and by around
1 − 2 orders of magnitude (Figure 6c, 6d) in terms of I/O cost. So the performance of
QR-tree is comparatively even better for NYF dataset. The I/O graph of baseline looks
flat because all the disk blocks have been accessed by it whatever the parameter values
are. This is because the dataset spans over a longer temporal domain than that of BD
Cellphone.
5.3. Evaluation of Q2 R-tree
In a real system, the performance gain by our proposed index will largely be attributed to the lower I/O cost. This is not simulated in the runtime experiments. So the
merits demonstrated for the QR-tree is very likely to be manifold to what is reported in
case of a real deployment.
14

# of Blocks

2000

QR
Q2R

1500

1000

500
50k
100k
150k
200k
# of Indexed Trajectories

Figure 7: I/O comparison of enhanced tree for CTQ

The further enhancement we have proposed on the QR-tree, namely the Q2 R-tree
works slightly better in terms of I/O cost specially when we deal with larger number
of trajectories, as demonstrated in Figure 7. Note that, this experiment is run by
indexing 50k, 100k, 150k and 200k trajectories respectively. The Q2 R-tree achieves
2 − 5% reduction in the number of disk blocks accessed, specially for higher number
of trajectories. So, though the CTQ processing using the Q2 R-tree needs multiple levels
of tree traversal, marginally lower I/O overhead can eventually result in better runtime
performance as well, which is subject to further experiments in real systems.

6. Related Works
The works related to ours mostly encompass studies in trajectory indexing in spatiotemporal domain and some query processing using these indexes. Besides there are
many ongoing researches in contact tracing with the outbreak of COVID-19 pandemic,
most of which attempt to solve the challenge from different perspectives.
6.1. Spatio-temporal Trajectory Indexing
Indexing of moving objects i.e. storing trajectory data efficiently has received considerable attention throughout the last two decades. Mokbel et al. present a summary
of spatio-temporal indexing methods in their survey [13] according to some of the earlier studies in this field. They point out three techniques that have been used to index
historic trajectory data. These are augmentation of temporal index with existing spatial
index, combining both spatial and temporal access in a single structure and indexing mainly based on temporal information while treating spatial index as secondary.

15

Nguyen-Dinh et al. extend the work in [14] and summarize the indexing methods
adopted in 2003-2010 period according to the aforementioned categories. Mahmood
et al. focus on the more recent techniques in [15], in succession of the previous works.
We describe some of these indexing methodologies briefly and present comparative arguments of the relevant ones with our work. The details and more elaborate discussion
can be found in [13], [14], [15] and the research works they have addressed in these
studies.
RT-tree, 3D R-tree etc. indexing methods deal with temporal information along
with spatial data as summarized in [13]. RT-tree [16] simply augments the time interval information with the MBRs of R-tree. So it achieves a performance as good
as R-tree for spatial queries but the temporal queries often span the whole tree. Our
proposed contact tracing query need to process both spatial and temporal ranges, so
it would be inefficient for our purpose. On the other hand, 3D R-tree [17] considers
temporal attribute as an additional dimension with the spatial R-tree, processing spatial
and temporal queries alike. We have used this approach as our baseline method for its
potential applicability to our proposed query. Spatio-temporal R-tree (STR-tree) [18]
is another approach to index spatio-temporal data with R-tree at the core but with different insertion and splitting strategy. It focuses on both spatial locality and trajectory
preservation based on a configurable parameter [13]. However different segments of a
trajectory may be stored in different nodes or spatio-temporally close trajectories may
be grouped separately in this approach, both of which can deteriorate the performance
of our proposed query processing.
Some trajectory oriented access methods puts more emphasis on grouping the
points of each trajectory together. TB-tree [18], SETI [5] etc. adopt such mechanisms. Spatial queries and keeping spatially closed objects together are not among
their primary concerns as stated in [13].
Trajectory-bundle tree (TB-tree) strictly emphasizes on trajectory preservation and
gives up on spatial locality if needed. It is also built on top of R-tree, which means,
the MBRs of TB-tree overlap a lot in contrary to its minimization as would be done in
regular R-tree. This structure can deal with trajectory based queries involving topology
with spatio-temporal attributes like area, time etc. or those based on navigation quite
16

efficiently. But in the contact tracing query we need both trajectory interaction in terms
of spatio-temporal locality and trajectory preservation for its efficient processing. So
it not readily applicable to our problem as well. Besides, both TB-tree and STR-tree
retrieves trajectory segments incrementally [18]. If someone is infected in our case, her
whole trajectory needs to be retrieved, which would be costly using these indexes.
The indexing mechanism SETI, proposed in [5] addresses the scalability issues of
existing indexing schemes. It presents a two level index structure: the first level index
partitions the spatial domain into static, uniform and non-overlapping cells, the second
level index uses a traditional R-tree to index the time domain. Using the first index,
the segments of each trajectory are assigned to the cells, according to their spatial
coordinates. If a segment spans multiple cells then it is split at the cell boundary.
Then, the time span of the segments (i.e the minimum and the maximum timestamp)
in each cell are saved in an R-tree. So, effectively the spatial and temporal dimensions
are decoupled in the process. The authors mainly discussed range queries with their
proposed index where a spatial and then a temporal filtering is done using the first
and second level index respectively. After that, a refinement step retrieves the desired
trajectories. The index also supports efficient insert, delete and update.
The Start-End timestamp B-tree (SEB-tree) [19] is another trajectory oriented indexing similar to SETI. The space is partitioned into overlapping zones which are indexed using SEB-tree considering only start and end timestamps. The moving objects
are mapped to their zones using hashing. But unlike SETI, SEB-tree works on the two
dimensional points instead of the trajectories.
Some of the other indexing schemes [13] presents for indexing historic trajectory
data include MR-tree, HR-tree, MV3R-tree etc. These indexes disintegrate spatial and
temporal dimensions as they aim at storing spatial attributes of the trajectories at different timestamps in different R-trees.
[14] presents some specialized indexing methods besides some improvements on
the previous works. The MTSB-tree [20] has its similarity with SETI in terms of spatiotemporal organization with the difference that it uses Time-Split B-tree (TSB-tree) for
temporal indexing of trajectory segments instead of R-tree based temporal index of
SETI. So trajectory segments are sorted in increasing order of time. FNR-tree and
17

MON-tree use multiple R-trees to store object movement locations and time intervals.
The latter one also uses a hash structure for mapping object movement lines to the
lower level temporal R-tree. GS-tree indexes trajectories in a constrained graph by dividing them into nodes and edges. It is a balanced binary tree that discriminates time
dimension from the spatial counterpart. Here a leaf node represents MBR of edges and
points to two different data structures for spatial and temporal dimensions. The Compressive Start-End tree (CSE-tree) [21] divides space in disjoint regions like SETI and
maintains temporal indexes for each of these regions. It considers time intervals as two
dimensional points and maintains separate B+ trees for indexing end times followed
by start times to group trajectory segments. Polar tree is specialized to index direction
of the moving objects. It uses an in-memory unbalanced binary tree to index orientation of objects with respect to a given focal point. It can efficiently determine if many
objects get close to or far from a reference site. Besides, RTR-tree and TP2 R-tree provides better support for range queries in euclidean space in indoor environments. The
other indexing methods studied in the survey are out of scope of this literature as they
bear little resemblance to our work.
[15] describes some of the more recent works in trajectory indexing. TrajStore
partitions trajectories and clusters spatio-temporally close segments together on the
disk. TrajTree also relies on trajectory segmentation where leaf nodes contain subtrajectories and non-leaves hold sequences of the bounding boxes of their child nodes.
Most of the other spatio-temporal indexes are specialized and application specific. For
instance, UTH and UTGRID deals with trajectories with uncertain portions, PARINET
is specific to trajectories along road networks, TRIFL optimizes trajectory indexing in
flash storage and so on.
6.2. State of the Art Queries
The common queries in spatio-temporal domain can be classified into two broad
categories, coordinate based query and trajectory based query [18]. Coordinate based
queries include point spefic query, range query, nearest neighbor search etc. while trajectory based query can involves topology or navigational details. Coordinate based
queries have been addressed since the earlier works in the spatio-temporal trajectory
18

domain like RT-tree, 3D R-tree [13] etc., which were improved later in more efficient
indexes like SETI, SEB-tree etc. Trajectory oriented queries where trajectory preservation can play an important role was addressed and efficiently processed using STR-tree,
TB-tree in [18]. The later indexes proposes improvements in both directions, works
with new queries like k-NN (e.g. TrajTree), but these queries do not align with the proposed novel contact tracing query since both spatio-temporal range search and whole
trajectory retrieval are of utmost importance here.
A query somewhat similar to the contact tracing query (CTQ) is presented in [22],
which the authors call trajectory multi-range query (MRQ). The goal of MRQ is to
find the set of trajectories that go through a set of given spatio-temporal ranges. We
can consider CTQ as a multi-range query over trajectories too, where there is a query
spatio-temporal range for each point of the CTQ query trajectory. However, there is a
very important distinction between MRQ and CTQ. In MRQ, the resultant trajectories
pass through all the given spatio-temporal ranges, whereas, in the case of CTQ, even if
a trajectory goes through only one of the query spatio-temoral ranges, we need to return
it and do further processing on it. Also, in CTQ we consider indirect contact/exposure
to the query trajectory which is not considered in MRQ.
6.3. Recent Progress in Contact Tracing
Since the start of the COVID-19 pandemic, governments have rolled out contact
tracing apps ([23]) in order to contain the spread of the virus. The aim of these apps
is to understand if a user was exposed to a known COVID infected person, and if so,
notify her for testing and starting the quarantine process. A review of the existing technologies for contact tracing is presented in [24]. Proximity based contact tracing apps
use Bluetooth and WiFi to infer relative proximity to other users. Location based technologies, on the other hand, use GPS to locate the exact position of the users. Although
GPS positioning is not very accurate in indoor spaces, that problem can be overcome
with the additional use of crowd-sourced WiFi localisation. With modern WiFi access
points the accuracy is good enough for contact tracing [24]. However, both of these
two technologies require a smartphone and an app to be installed by the user. The
infrastructure and devices required by these methods may not be available in certain
19

places, specially in developing countries. In such situations, using mobile operator’s
infrastructure to locate the phone of a user is an option. This has the advantage of not
requiring the user to do anything and the usage of existing infrastructure. However,
there still remains the accuracy and privacy concerns.

7. Conclusions
We have proposed a novel CTQ in the context of spatio-temporal databases and
developed a multi-level index, namely QR-tree, to efficiently process the CTQ. Experimental results show that the QR-tree based approach outperform the baseline by 1-2
orders of magnitude both in terms of processing time and I/O. In future, we plan to develop a system based on the proposed index and make it available for the community.

References
[1] CoronavirusJHU, https://coronavirus.jhu.edu/ (2020).
[2] M. F. Mokbel, W. G. Aref, Indexing Historical Spatio-Temporal Data, 2009, pp.
1448–1451.
[3] M. E. Ali, S. S. Eusuf, K. Abdullah, F. M. Choudhury, J. S. Culpepper, T. Sellis, The maximum trajectory coverage query in spatial databases, PVLDB 12 (3)
(2018) 197–209.
[4] S. Shang, L. Chen, Z. Wei, C. S. Jensen, K. Zheng, P. Kalnis, Trajectory similarity
join in spatial networks, PVLDB 10 (11) (2017) 1178–1189.
[5] V. P. Chakka, A. Everspaugh, J. M. Patel, et al., Indexing large trajectory data sets
with seti., in: CIDR, Vol. 75, 2003, p. 76.
[6] N. Beckmann, H.-P. Kriegel, R. Schneider, B. Seeger, The r*-tree: An efficient
and robust access method for points and rectangles, in: SIGMOD, 1990, pp. 322–
331.
[7] H. Samet, The quadtree and related hierarchical data structures, ACM Comput.
Surv. 16 (2) (1984) 187–260.
20

[8] M. M. Hasan, M. E. Ali, Estimating travel time of dhaka city from mobile phone
call detail records, in: ICTD, 2017, pp. 14:1–14:11.
[9] D. Yang, D. Zhang, V. W. Zheng, Z. Yu, Modeling user activity preference by
leveraging user spatial temporal characteristics in lbsns, IEEE Transactions on
Systems, Man, and Cybernetics: Systems 45 (1) (2015) 129–142.
[10] Transmission of sars-cov-2:

implications for infection prevention pre-

cautions, https://www.who.int/news-room/commentaries/detail/transmission-ofsars-cov-2-implications-for-infection-prevention-precautions, accessed: 202008-04.
[11] Can coronavirus spread through the air?, https://tbsnews.net/coronaviruschronicle/can-coronavirus-spread-through-air-60679, accessed: 2020-08-04.
[12] N. Van Doremalen, T. Bushmaker, D. H. Morris, M. G. Holbrook, A. Gamble,
B. N. Williamson, A. Tamin, J. L. Harcourt, N. J. Thornburg, S. I. Gerber, et al.,
Aerosol and surface stability of sars-cov-2 as compared with sars-cov-1, New
England Journal of Medicine 382 (16) (2020) 1564–1567.
[13] M. F. Mokbel, T. M. Ghanem, W. G. Aref, Spatio-temporal access methods, IEEE
Data Eng. Bull. 26 (2) (2003) 40–49.
[14] L.-V. Nguyen-Dinh, W. G. Aref, M. Mokbel, Spatio-temporal access methods:
Part 2 (2003-2010).
[15] A. R. Mahmood, S. Punni, W. G. Aref, Spatio-temporal access methods: a survey
(2010-2017), GeoInformatica 23 (1) (2019) 1–36.
[16] X. Xu, J. Han, An improved r-tree indexing structure for temporal spatial
databases, in: Proc. of the Intl. Symp. on Spatial Data Handling, SDH, 1990,
pp. 1040–1049.
[17] Y. Theodoridis, M. Vazirgiannis, T. Sellis, Spatio-temporal indexing for large
multimedia applications, in: Proceedings of the Third IEEE International Conference on Multimedia Computing and Systems, 1996, pp. 441–448.
21

[18] D. Pfoser, C. S. Jensen, Y. Theodoridis, et al., Novel approaches to the indexing
of moving object trajectories., in: VLDB, 2000, pp. 395–406.
[19] Z. Song, N. Roussopoulos, Seb-tree: An approach to index continuously moving objects, in: International Conference on Mobile Data Management, Springer,
2003, pp. 340–344.
[20] P. Zhou, D. Zhang, B. Salzberg, G. Cooperman, G. Kollios, Close pair queries in
moving object databases, in: Proceedings of the 13th annual ACM international
workshop on Geographic information systems, 2005, pp. 2–11.
[21] L. Wang, Y. Zheng, X. Xie, W.-Y. Ma, A flexible spatio-temporal indexing
scheme for large-scale gps track retrieval, in: The Ninth International Conference
on Mobile Data Management (mdm 2008), IEEE, 2008, pp. 1–8.
[22] M.-E. Yadamjav, F. M. Choudhury, Z. Bao, H. Samet, Efficient multi-range query
processing on trajectories, in: ER, 2018.
[23] H. Stevens, M. B. Haines, TraceTogether: Pandemic Response, Democracy, and
Technology, East Asian Science, Technology and Society.
[24] F. Legendre, M. Humbert, A. Mermoud, V. Lenders, Contact tracing: An
overview of technologies and cyber risks (2020). arXiv:2007.02806.

22

