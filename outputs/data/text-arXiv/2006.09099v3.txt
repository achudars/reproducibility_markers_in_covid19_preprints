arXiv:2006.09099v3 [cs.NI] 27 Jul 2020

Identifying the BLE Advertising Channel for
Reliable Distance Estimation on Smartphones
Christian Gentner*

Daniel Günther*

Philipp H. Kindt*

German Aerospace Center (DLR)
Wessling, Germany
christian.gentner@dlr.de

Technical University of Munich (TUM)
Munich, Germany
d.guenther@tum.de

Technical University of Munich (TUM)
Munich, Germany
philipp.kindt@tum.de

Abstract—As a response to the global COVID-19 surge in
2020, many countries have implemented lockdown or stay-athome policies. If, however, the contact persons of every infected
patient could be identified, the number of virus transmissions
could be reduced, while the more incisive measures could be
softened. For this purpose, contact tracing using smartphones is
being considered as a promising technique. Here, smartphones
emit and scan for Bluetooth Low Energy (BLE) signals for
detecting devices in range. When a device is detected, its distance
is estimated by evaluating its received signal strength. The main
insight that is exploited for distance estimation is that the
attenuation of a signal increases with the distance along which
it has traveled. However, besides distance, there are multiple
additional factors that impact the attenuation and hence disturb
distance estimation. Among them, frequency-selective hardware
and signal propagation belong to the most significant ones. For
example, a BLE device transmits beacons on three different
frequencies (channels), while the transmit power and the receiver
sensitivity depend on the frequency. As a result, the received
signal strength varies for each channel, even when the distance
remains constant. However, the information on which wireless
channel a beacon has been received is not made available to a
smartphone. Hence, this error cannot be compensated, e.g., by
calibration. In this paper, we for the first time provide a solution
to detect the wireless channel on which a packet has been received
on a smartphone. We experimentally evaluate our proposed
technique on multiple different smartphone models. Our results
help to make contact tracing more robust by improving the
accuracy of distance estimation.

I. I NTRODUCTION
The global surge of the novel coronavirus SARS-CoV-2 has
resulted in many countries implementing lockdown and stayat-home policies. This has lead to a burdensome situation
for the population and causes severe economic problems.
However, whenever a person is tested positive, if all of their
contacts could be identified, the further spread of the virus
could potentially be stopped or slowed down, while other,
more incisive measures could be softened. Thereby, it is of
crucial importance that contact persons are identified and
warned at the earliest possible time.
For this purpose, smartphone-based contact tracing
approaches are being considered as an important tool. Here,
every device continually transmits Bluetooth Low Energy
* All authors contributed equally to this paper. This work has been submitted
to the IEEE for possible publication. Copyright may be transferred without
notice, after which this version may no longer be accessible.

(BLE) beacons and listens for incoming transmissions.
As soon as a beacon from another device is received, the
distance between both of them is estimated. When the contact
duration (which is estimated based on the period of time
during which beacons from a particular device are received)
is sufficient and/or the estimated distance is small enough, a
contact is considered as relevant. Hence, when a person is
tested positive for SARS-CoV-2, all relevant contacts can be
identified in retrospect by evaluating the smartphone data [1].
Besides contact tracing, distance- or proximity estimation
plays a key role in a host of applications, such as indoor
navigation or object tracking.
Distance Estimation: Distance estimation works as follows.
One device transmits a beacon with a certain transmit power
Pt . This value is piggy-backed onto the beacon. The wireless
signal then undergoes a certain path loss, which depends on the
distance along which the signal travels. The opposite device
will receive the beacon with a certain power Pr . In free space,
a wireless signal traveling along a distance d between a sender
and a receiver will be received with a power of

2
λ
Pr = Pt · Gt Gr ·
,
(1)
4πd
see [2]. In Equation (1), λ is the wavelength of the signal
and Gt and Gr are the gains of transmitter and receiver,
respectively. Gt and Gr can be obtained by calibrating each
smartphone model individually. Since Pr and Pt are known
by the receiver, the distance d can be estimated.
This estimation is aggravated by multiple effects, of which
the most important ones are the following.
•

•

The antennas of both devices might be directional and
hence, the orientation between both devices impacts Pt
and Pr .
Human tissue attenuates the signal by a considerably
higher degree than free space. For example, the attenuation between the chest and the back of the human
body has been reported as 19.2 dB [3]. As a result,
the estimated distance is strongly disturbed when human
tissue is within the direct signal path, and hence also by
how two human bodies are oriented relatively to each
other, and where the phones are worn on the body.

•

Multipath propagation, e.g., reflections on metal surfaces,
can interfere with the direct signal.
The sensitivity of Gt and Gr depend on the wireless
channel and therefore the frequency on which a beacon
is received.

On smartphones, the received power of a BLE signal
is available in the form of a received signal strength
indicator (RSSI), which is provided by the Bluetooth radio.
Distance estimation using the RSSI on smartphones has
been studied thoroughly throughout the last years, e.g., in
[4], [5]. Currently, due to the high relevance for contact
tracing, analyzing and increasing the accuracy of distance
estimation is receiving considerable attention by the scientific
community [6], [7].
Channel-Dependent RSSI: This paper addresses the problem
of the frequency dependence of the RSSI, which reduces the
accuracy of distance estimation. In the BLE protocol, which is
used for contact tracing on smartphones, advertising packets
are sent on 3 different channels, which are spread over almost
the entire frequency band used. These 3 channels use center
frequencies of 2.402 GHz, 2.426 GHz and 2.480 GHz [8].
Because of the following three effects, the RSSI depends on
the channel on which the packet was received.
1) Almost every device has frequency-dependent values of
Gr and Gt . In other words, a packet sent on a certain
channel (and hence frequency) will have a larger power
than when being sent on a different channel, and the
receiver will similarly sense different RSSI values for
the same actual signal power on different channels. This
effect can lead to a RSSI estimation error of multiple dB,
which can result in a distance estimation error of several
meters. If it is known on which channel each packet is
received, then Gr and Gt can be measured separately
for each channel, and hence the error can be cancelled
easily.
2) The path loss of a signal depends on the channel/frequency on which the signal is transmitted, see
Equation (1). This effect can also be cancelled easily
when the channel on which a packet was received is
known.
3) Packets sent on different channels propagate differently
in the environment. BLE signals are reflected, scattered
and diffracted by objects in the surrounding. Hence,
the signal reaching the receiving antenna consists of
multiple replicas of the transmitted signal, which are
called multipath components. These replica of the transmitted signal interfere with those transmitted along the
direct path, i.e., the line-of-sight path. When interfering
constructively, the RSSI increases, whereas it is reduced
in the case of destructive interference. Thus, the RSSI
accuracy might be drastically reduced due to the distorted received signal by multipath propagation.
These effects are shown in Fig. 1, which depicts multiple
RSSI measurements for the 3 different channels used in BLE.

Channel 37 (2402 MHz)
Channel 38 (2426 MHz)
Channel 39 (2480 MHz)
All channels mean
Path-loss model

RSSI

•

distance [m]

Fig. 1: Measured RSSI at a Google Pixel 3 smartphone for
different distances. As a transmitter a Google Pixel 2 was used.

Here, we used a Google Pixel 2 smartphone as a transmitter
and a Google Pixel 3 as a receiver. Transmitter and receiver
were placed in a height of 67 cm in an indoor environment, and
their distance was changed for each measurement. As can be
seen, for a given distance, the RSSI differs significantly among
the 3 channels. In particular, we could observe differences
of up to 15 dB. This occurred even for distances below 2 m,
which are the most relevant ones for contact tracing.
In addition to measured RSSI values, Fig. 1 also depicts
the path loss model as given by Equation (1), where Gt ,
Gr and Pt have been fitted to minimize the squared error
between model and measurements. As already mentioned, the
distance is usually estimated based on such a model, which
assigns a distance to each RSSI value. When now estimating
the distance based on the RSSI, an attenuation of 15 dB due
to the channel-dependent multipath propagation can lead to
distance estimation errors in the order of tens of meters.
Hence, it is of crucial importance to be aware of the channel
on which a packet was received. If the channel was known,
the estimation error due to frequency-selective hardware and
free-space path loss could be cancelled using calibration.
Furthermore, errors due to multipath propagation could be
reduced by computing the average of the same number of
RSSI values from different channels, or by advanced methods,
e.g. [9].
Unavailability of Channel Information: The BLE radio
does not relay the information on which channel a beacon
was received to the smartphone operating system. Indeed, the
BLE host control interface, which is used for data exchange
between radio and smartphone, specifies that incoming
advertising packets are reported to the host without any
channel information [8]. As a result, the frequency-dependent
error cannot be mitigated. A potential method for reducing
the error is averaging over multiple packets from different

channels. However, without knowing on which channel a
packet was received, it cannot be ensured that the same
number of packets from each channel are used for averaging.
Proposed Solution: In this paper, we for the first time propose
a technique to detect on which channel an advertising packet
was received on an Android smartphone. We thereby exploit
an undocumented behavior of many Bluetooth SoCs found in
recent smartphones. In particular, consecutive reception windows are separated from each other by a period of time that is
significantly larger than the distance between two consecutive
packets. After scanning for incoming packets is activated by
an application (app), we observe that on most smartphones
we have tested, scanning starts on the same channel. Hence,
we can exploit this behavior for obtaining the first channel on
which the smartphone scans. We can then classify the channel
of later received packets based on associating their reception
time with the time windows during which the receiver listens
for incoming packets and the corresponding channels.
Contributions: Compared to existing works, we in this paper
make the following contributions:
1) We for the first time propose a technique to identify
the channel on which a BLE advertising packet was
received.
2) We evaluate the detection probability of our proposed
method in detail. Our results suggest that the channel
of reception can be detected reliably in 100 % of all
attempts.
3) We test our proposed methodology on different smartphone models from different manufactures and show that
it is compatible with the vast majority of the phones we
have tested.
Besides contact tracing, our proposed method can also be
used to improve distance estimation in a host of different
applications.
Paper Organization: The rest of this paper is organized as
follows. In the next section, we give a brief overview on
related work. In Section III, we describe how the procedure
used for contact tracing in BLE, called advertising and scanning, works. Next, in Section IV, we describe our proposed
technique for channel detection. We experimentally evaluate
this technique in Section V and conclude our findings in
Section VI.
II. R ELATED W ORK
In this Section, we briefly summarize related work on
contact tracing and distance estimation using smartphones.
Contact Tracing: Prior to the global SARS-CoV-2 outbreak
in 2020, digital contact tracing did not receive much attention
from the scientific community. Early approaches where based
on off-the shelf sensor nodes worn by the subjects [10], or on
indoor localization using RFID readers [11]. Research interest
massively increased after the beginning of the surge of
COVID-19 infections in 2020, and electronic contact tracing

is actively being studied today. It appears to be a promising
tool for slowing down the spread of SARS-CoV-2, especially
because the time window within which contact persons need
to be identified must be short for controlling the further spread
of the virus [12]. Since a solution had to become effective
quickly after the outbreak, it was not possible to design and
deploy a custom tracing device from scratch. Smartphones
were already widely available in the population, and contact
tracing could be realized once a suitable application (app) had
been developed. However, smartphones were not designed
for the purpose of contact tracing [13]. Therefore, their
capabilities for contact tracing are limited, which reduces the
accuracy and reliability of the tracing procedure. Nevertheless,
besides the deployment of multiple national tracing apps all
over the world, also the scientific community is working on
the design of tracing apps [1], [14], [15]. Hence, despite
not being the optimal platform, significant effort is being
invested in implementing contact tracing on smartphones and
improving its performance. Besides privacy, accurate distance
estimation, which has already been studied earlier in the
context of other applications than contact tracing, remains a
central problem. We next describe approaches on distance
estimation using smartphones.
Distance Estimation using Smartphones: Estimating the
distance between a pair of smartphones has been studied using
different techniques, such as correlating the measurements
of the ambient magnetic field by different smartphones [16],
acoustic ranging [17] or the RSSI of the Bluetooth or IEEE
802.11 (WiFi) radio. Among these approaches, RSSI-based
mathods have turned out to be the most practical one. Since
BLE is only available in relatively recent smartphones, early
studies have focused on distance estimation using WiFi or the
“legacy” Bluetooth, called Bluetooth BR/EDR. For example,
Comm2Sense [18] configures smartphones as mobile WiFihotspots to estimate the proximity of two devices based on
the WiFi RSSI. Since setting up mobile WiFi-hotspots on
smartphones is inconvenient for the user and the energy
consumption of WiFi drains the battery quickly, a large number
of other approaches, e.g., [19], [20], are built on the RSSI of
Bluetooth BR/EDR. Whereas the RSSI in Bluetooth BR/EDR
is measured relatively to a “golden receive power range” [8],
the BLE protocol specifies that the RSSI is an absolute
received power with an accuracy of ±6 dB. In addition, BLE
is designed for scanning for incoming beacons continuously
in the background. As a result, more recent approaches on
distance estimation build upon the BLE protocol. For example,
[4] uses 3 different approximation models, which are selected
based on a coarse classification of the estimated distance. A
large number of approaches, e.g., [21]–[23], have studied the
analysis of the sensed RSSI data. Furthermore, the work in
[7], [24] has experimentally evaluated the accuracy of distance
estimation using smartphones in the context of contact tracing.
However, the accuaracy of the RSSI data itself has always been
considered as immutable. Hence, to the best of our knowledge,
detecting the channel on which a packet was received for

improving the accuracy of distance estimation has not been
considered previously to this work.
III. A DVERTISING AND S CANNING IN BLE
A contact tracing app will use the following procedure for
detecting devices in its surrounding. It is provided by the BLE
protocol [8] and referred to as advertising and scanning.
Every device periodically schedules an advertising event
once per Ta time-units. Ta is called the advertising interval
and is composed of a static part Ta,0 plus a random delay
ρ ∈ [0, 10 ms]. In each such event, three beacons in a row
are sent. The first of them is sent on channel 37 (which
corresponds to a center frequency of 2.402 GHz), the second
one on channel 38 (2.426 GHz) and the third one on channel
39 (2.480 GHz) [8]. This is depicted in Fig. 2. Here, every
arrow stands for an advertising event. Since the 3 individual
beacons in each event are sent within short amounts of time,
we do not show them in the figure.
For being able to receive incoming beacons, every device
also listens to the channel by using so-called scan windows.
Every scan window has a duration of ds time-units, and there is
one such window every scan interval Ts . After every instance
of the scan window, the channel for the succeeding window
is toggled between channel 37, 38 and 39 in a round-robin
fashion. This is also depicted in Fig. 2.
A device can detect the presence of another device, once
a beacon from the remote device coincides with one of its
scan windows [25]. Most values for (Ta , Ts , ds ) supported by
Android fulfill Ta < ds (cf. Fig. 2) and hence, the reception
of at least one beacon is guaranteed in each scan window.
Note that the number of coinciding beacons might vary for
every scan window. For example, in Fig. 2, the scan window
on channel 38 has 3 coinciding beacons, whereas the window
on channel 39 has 4.
The Android operating system does not allow an app to
select these parameter values directly. Instead, an app can
chose between three different settings that determine Ta and
three different ones that determine Ts and ds . These settings
are listed in Table I.
It needs to be mentioned that there is no transparent
mapping between these settings and the corresponding values.
First, the values that correspond to a certain setting (e.g.,
SCAN MODE BALANCED) are not officially specified by
Google. We have therefore obtained them from the sourcecode of the latest version of Android1 . Second, the values that
are actually used could differ from those given in Table I due
to scheduling conflicts. In particular, the radio might maintain
other Bluetooth connections, and the points in time at which
other packets are exchanged might overlap with those needed
for advertising and scanning. In addition, the Bluetooth radio
is also used for WiFi on many devices, which could lead
to additional scheduling conflicts. However, we found in our
experiments that the values from Table I are actually used
1 In older Android versions, the parameter values of the scan modes are
different.

during normal operation, i.e., when no scheduling conflicts
are present.
Android Setting
SCAN MODE LOW POWER
SCAN MODE BALANCED
SCAN MODE LOW LATENCY
ADVERTISE MODE LOW POWER
ADVERTISE MODE BALANCED
ADVERTISE MODE LOW LATENCY

Ta [s]
1.000
0.250
0.100

Ts [s]
5.120
4.096
4.096
-

ds [s]
0.512
1.024
4.096
-

TABLE I: BLE parameterizations in Android.
For the sake of completeness, we here also
mention three other configuration options. First, the
SCAN MODE OPPORTUNISTIC setting can be used
by an app to obtain scan results when scanning has been
triggered by a different app, without triggering the scanning
itself. Second, a different set of values for Ts and ds is
available when using batch scanning, where multiple received
packets are reported to the app jointly after some time instead
of immediately after discovery. However, we could not find
any documentation of this feature and hence did not study it
in detail in this paper. Third, Google and Apple are currently
drafting their Exposure Notification service [26]. Here, an
advertising interval of 200 ms to 270 ms is specified, while
no values for Ts and ds are given. None of these additional
options will supersede the need for channel detection, as we
propose in this paper.
IV. C HANNEL D ETECTION
In this section, we describe how the channel on which an
incoming beacon is received can be detected on a smartphone.
As already mentioned, the BLE radio does not relay this
information to the smartphone’s operating system, since the
Bluetooth standard does not specify an interface for this.
According to the BLE specification [8], the channel on
which the radio scans is toggled after every scan window.
Thereby, the same order of channels 37, 38, 39, 37,... is always
pursued.
Though the BLE specification does not specify on which
channel the radio has to scan first after its activation, we
could observe on different smartphone models (see Section V
and Table III) that when scanning is activated, the device will
always begin with channel 37.
Let the point in time at which scanning was activated be
given by t. Then, incoming packets will only be received on
channel c ∈ {37, 38, 39}, if their reception time falls within a
time-interval Ic (k) = [tl,c (k), tr,c (k)], k = 1, 2, 3, 4, ..., with
tl,c (k)
tr,c (k)

= t + 3 · (k − 1) · Ts + (c − 37) · Ts
= t + 3 · (k − 1) · Ts + (c − 37) · Ts + ds .

(2)

Equation (2) directly follows from Fig. 2. Therefore, we
can detect the channel on which a beacon was received by
classifying the time of each beacon reception into I37 , I38 or
I39 .

Fig. 2: Advertising and scanning in BLE. Arrows depict advertising events, which consist of a sequence of 3 packets on 3
different channels. The rectangles depict scan windows.

The values for ds and Ts can be obtained from Table I.
However, recall that especially in case of scheduling conflicts,
the phone might potentially deviate from this periodic scheme.
Though we could observe that the values from Table I appear
to be used in most cases (i.e., when no scheduling conflicts are
present), there might potentially be (slight) changes of these
parameter values, or even dropped scan windows or beacons.
In our experiments, the scan windows always occurred at the
expected points in time given by Equation 2, even when WiFi
was activated. However, some of the transmitted beacons were
not received, indicating that the scan windows were interrupted
on a short-term basis for carrying out WiFi communication.
This does not negatively impact channel detection, since the
classification of reception times according to Equation (2)
remains unaffected. The same holds true when beacon transmissions are omitted or their transmission times change due
to scheduling conflicts.
Because the clocks of the smartphone and Bluetooth radio
are not synchronized, they could drift against each other. This
might disturb the channel detection based on Equation (2),
since the classification is carried out within an app that relies
on the clock of the smartphone, whereas the scan windows are
scheduled using the clock of the radio. To mitigate the effects
of this, we slightly modify the interval borders of Ic (k) from
Equation 2 to Iˆc (k) = [t̂l,c (k), t̂r,c (k)], k = 1, 2, 3, 4, ..., with
t̂l,c (k)
t̂r,c (k)

= 3 · (k − 1) · Ts + (c − 37) · Ts +
= t + 3 · (k − 1) · Ts + (c − 36) · Ts − tg/2 .
tg/2

tg in Equation (3). All subsequent packets are handled in the
inner while loop starting in Line 13 of Algorithm 1. For each
such packet, the reception time is computed and t (i.e., the time
when scanning was started) is subtracted. The resulting time
difference is used by the ClassifyChannel()-function, which
infers the channel of reception by evaluating Equation (3).
After Max-Scan-Time (cf. Line 16 in Algorithm 1) has passed,
the scanning is re-started to limit the clock drift between
smartphone and radio, as already explained. The guard time
tg compensates for any clock drift before this re-start.
In the next section, we evaluate the accuracy of channel
detection using this algorithm on different smartphone models
and for different re-start intervals of the BLE scanning procedure.
Algorithm 1: Android BLE Channel-Detector
1
2
3
4
5
6
7
8
9

(3)

Hence, for realizing a more robust detection, we here classify
each received packet by into which instance of Ts it falls, even
when being received outside of the (estimated) scan window.
Further, tg is a guard time to compensate for the clock drift, for
which we propose a concrete value in Section V. In addition,
for limiting this drift, we propose to regularly re-start the
scanning after a certain period of time. We evaluate after which
amount of time such a re-start should occur in Section V.
Algorithm 1 shows the pseudo-code of our proposed algorithm for detecting the channel on which a packet was
received. In order to limit the power consumption of the
smartphone, the algorithm starts the BLE scanner using the
SCAN MODE LOW POWER setting (c.f. Line 4 in Algorithm 1). As soon as BLE signals are detected, the main part
of the algorithm is executed and the BLE scanner is re-started
using the SCAN MODE LOW LATENCY setting (c.f. Line
9-12 in Algorithm 1). We remember the timestamp t when
the scanning was re-started. Note that this timestamp does
not perfectly coincide with the actual re-start of the BLE
scanning, since there might be delays and/or jitter. The effect
of such misalignments are mitigated through the guard time

10
11
12
13
14

15
16
17
18
19
20
21

doInit = true;
while 1 do
if doInit then
Scan-Mode = SCAN MODE LOW POWER;
Re-Start-Scan();
doInit = false;
Channel-Detection = false;
if BLE signals detected then
Channel-Detection = true;
Scan-Mode = SCAN MODE LOW LATENCY;
Re-Start-Scan();
t = GetSystemTime();
// see Eq. (3)
while Channel-Detection do
if BLE signal received then
/* classify BLE signal into Iˆ37 ,
Iˆ38 or Iˆ39 using Eq. (3)
*/
ClassifyChannel(t, GetSystemTime());
if GetSystemTime() - t > Max-Scan-Time then
Re-Start-Scan();
t = GetSystemTime() ;
// see Eq. (3)
if No signals detected then
doInit = true;
break;

V. E VALUATION
In this section, we evaluate the proper functioning of our
proposed technique for channel identification and the accuracy

of Algorithm 1. Towards this, we first describe our experimental setup and then give experimental data.
A. Experimental Setup
In order to evaluate our approach and Algorithm 1 on
different smartphone models, we have set up the following
test environment. Four Raspberry Pis2 , denoted as R(i), i =
1 . . . 4 continuously transmitted BLE advertising packets. Each
Raspberry Pi was configured to transmit on a different set of
channels, viz., R(1) on channel 37, R(2) on channel 38, R(3)
on channel 39 and R(4) on all three channels, as also shown in
Table II. The advertising interval was set to 100 ms, which is
way below ds (cf. Table I). Hence, multiple advertising packets
will fall into every scan window. Note that Ta = 100 ms
is used by the ADVERTISE MODE LOW LATENCY setting on Android smartphones. Therefore, though having been
obtained using Raspberry Pis as senders, our results remain
valid when packets are sent using smartphones. It is worth
mentioning that we have tested our proposed methodology also
with all other advertising intervals supported by Android (viz.,
100 ms and 1000 ms), and found it to be working successfully
irrespective of the value of Ta used.
In BLE, the services a device offers are advertised with the
payload of its packets. Such services are identified by unique
identifiers, so-called Universally Unique Identifiers (UUIDs).
We have assigned a different UUID to the packets of each
Raspberry Pi.
The packets of R(4), which are sent on all three channels,
are received in every scan window. This allowed us to detect
the individual scan windows of the smartphone. In addition,
we could directly see on which channel a beacon was received,
since we have encoded the channel information via the UUIDs
of each device. In other words, since e.g., R(1) only advertises
on channel 37 and we can detect that a packet was sent by
R(1) using its UUID, we could easily infer on which channel
the scanner was scanning.
Raspberry Pi
R(1)
R(2)
R(3)
R(4)

Channel
37
38
39
37,38,39

Center Frequency in [GHz]
2.402
2.426
2.480
2.402, 2.426, 2.480

TABLE II: Experimental setup with 4 Raspberry Pis advertising on different channels.
B. Results
1) Behavior of the BLE Radio: Fig. 3a shows the
reception times of all packets in an experiment using the SCAN MODE LOW LATENCY setting. Fig. 3b
depicts the results from an experiment in which the
SCAN MODE BALANCED setting was used. Both experiments were carried out using the Google Pixel 3 smartphone.
2 In our experiments with Samsung Galaxy S5 and Xiaomi MI-A2 smartphones, these Raspberry Pis were replaced by Bluegiga BLE112 radios, which
carried out the same tasks as the Raspberry Pis.

The individual measurements lie in such a close proximity
that they appear as lines rather than as individual points. We
have sorted the packets by their UUIDs, which identify their
channel. The different background colors in the figure depict
the estimated instances of the scan interval and their channel,
as given by Equation 3. Assuming that scanning started on
channel 37, red indicates that in this interval, the scan window
was listening on channel 37. Similarly, green corresponds to
channel 38 and blue to channel 39. Note that the colors of
the depicted received packets do not follow this scheme, since
they would be indistinguishable if they had the same color as
the background.
In both experiments, scanning was activated at time t =
0 s. In the SCAN MODE LOW LATENCY setting, as can
be seen in Fig. 3a, the received packets follow the pattern
predicted by Equation (3), which is exploited by Algorithm 1.
In particular, starting from time t = 0 s, packets are received
on channel 37 for Ts time units. Next, a sequence of packets
is received on channel 38, 39, 37, 38, 39, . . . .
In contrast, when using the SCAN MODE BALANCED
setting, we found that the regular scanning pattern begins
after a certain offset to from the starting time, which is
indicated by the white background color in Fig. 3b. Before
to has passed, the smartphone scans using an unpredictable
pattern. In the situation exemplified in Fig. 3b, the device
first scanned on channel 37 and then on channel 38, each
for an amount of time that exceeds ds . After to has passed,
the device re-sets to channel 37 and the scheme as given
by Equation (2) begins. Hence, if the offset to would be
known, the channel could be classified correctly according
to Equation (3). However, our measurements with different
smartphone models showed that this offset to varies every
time the scanning is started, and in addition depends on
the smartphone model. This justifies that our algorithm is
built upon the SCAN MODE LOW LATENCY setting for
detecting the channel of an incoming BLE signal, despite this
setting being the most power-hungry one on Android devices.
Since we only switch to this mode for short amounts of
time after an initial reception (i.e., until the channel has been
identified and a sufficient number of packets for computing the
distance have been received), the energy overhead of this will
be acceptable. Recent results [13] show that - depending on the
smartphone model - the battery of the smartphone is drained by
between 5 % and 20 % earlier compared to when Bluetooth is
switched off, if the SCAN MODE LOW LATENCY setting
is used during all times. Since we only use this mode for small
fractions of the time, the reduction of the battery runtime will
be way below this.
2) Classification Accuracy: While Fig. 3 shows that
the behavior of the BLE radio on multiple smartphone
models appears to be suitable for channel detection, in
which fraction of all attempts can the channel be classified
correctly when using Algorithm 1? In order to evaluate the
success rate of the channel detection algorithm, which we
call the detection accuracy, Fig. 4 shows the fraction of
packets for which the channel was detected correctly as a

Device Name
Google Pixel 2
Google Pixel 3
OnePlus 5
Samsung Galaxy S5
Xiaomi MI-A2
Xiaomi Mi 9T Pro
Huawei P20 lite
Samsung Galaxy M20
iPhone 6s

Model
Pixel 2
Pixel 3
ONEPLUS A5000
SM-G900F
M1804D2SG
M1903F11G
ANE-LX1
SM-M205FN
MN1E2LL/A

Compatible
X
X
X
X
X
X
7
7
7

Classification
Accuracy
100 %
100 %
100 %
99.5%
100 %
100 %
-

Android Version
10
10
9
8.1.0
9
10
9
10
13.5.1 (iOS)

Comments
Older API: Ts = 5 s, Lineage OS.
Different scan intervals, no channel reset
Different scan pattern, no channel reset
No channel reset

(a) SCAN MODE LOW LATENCY

probability of correct classification

TABLE III: Tested Android devices, a full list of devices can be found in [27]

Pixel 2 - t g = 0s
Pixel 3 - t g = 0s
Pixel 2 - t g = 0.2s
Pixel 3 - t g = 0.2s

scanning time [min]

(b) SCAN MODE BALANCED

Fig. 3: Sequence of received packets classified by their channel
of reception of the Google Pixel 3 smartphone. The different
background colors indicate the estimated channel based on
Equation (3).

function of the time since the last re-start of the scanning
procedure for the Google Pixel 2 and Google Pixel 3
smartphones. Both smartphones continuously recorded the
received BLE signals of the Raspberry Pis for 24 h. Scanning
was re-started every 30 min. This re-starting was necessary
because the Android operating system automatically
switches
from
the
SCAN MODE LOW LATENCY
to
the
SCAN MODE OPPORTUNISTIC
setting
after
30 min
of
continuous
scanning.
In
the
SCAN MODE OPPORTUNISTIC setting, the device
only schedules scan windows when a different app explicitly
triggers the scanning (i.e., by using a different mode than
SCAN MODE OPPORTUNISTIC), which would have
interrupted our measurements.
We used a guard time of tg = 0 s and tg = 0.2 s,
respectively. As can be seen in the figure, by using a guard
time of tg = 0.2 s, we obtain a detection accuracy of 100 %
for more than 10 min of contiguous scanning without restarting for the Pixel 3 smartphone, and 15 min for the Pixel 2

Fig. 4: Probability of classifying the channel correctly (detection accuracy) as a function of the scanning time without
re-starting for the Pixel 2 and Pixel 3 smartphones. Two guard
times tg = 0 s and 0.2 s were applied. The BLE scanner was
re-started at t = 0 s.
smartphone. For a guard time of tg = 0 s, the initial detection
accuracy is slightly reduced to around 97 %. When scanning is
carried out for more than 10 min without reset, the detection
accuracy gradually becomes smaller for both values of tg . This
is caused by clock drift between the smartphone and radio, as
already described. We therefore propose to set tg to 0.2 s and
Max-Scan-Time in Algorithm 1 to 10 min. In general, for a
larger value of tg , Algorithm 1 can be run for a longer time
without the need of a reset of the scanning procedure. On
the other hand, an increasing number of packets need to be
discarded, if tg is increased.
3) Different Smartphone Models: We have shown that our
proposed algorithm works in principle, but will it work for all
smartphone models from different manufacturers? For answering this question, we have tested different smartphone models
for their compatibility with our proposed methodology. In
particular, we have tested whether they always start scanning
on channel 37 and then switch to the next channel after every
instance of Ts . We also evaluated the detection accuracy for
each of them. Table III summarizes the results of this experiment. Out of 9 smartphones from different manufacturers we

UUID*

time [s]

UUID*

(a) Samsung Galaxy S5

time [s]

(b) Huawei P20 Lite

Fig. 5: Sequences of received packets classified
by their channel of reception over time in the
SCAN MODE LOW LATENCY setting for the Samsung
Galaxy S5 and the Huawei P20 Lite smartphones. The
different background colors in the upper part of the figure
indicate the estimated channel of the scan intervals given by
Equation (3).

have tested, Algorithm 1 is compatible with 6.
Table III shows the classification accuracy for a recording
time of 7 min and a guard time of tg = 0.2 s, similar to Fig. 4.
Here, we re-started the scanning after every minute, since we
feel that a 1 min time-frame is practical for estimating the
distance. We obtained a classification accuracy of 100% for
5 of the 6 compatible devices, while the accuracy for the
remaining smartphone (viz., the Galaxy S5) is only reduced by
0.5 %. These results can be further improved when tweaking
the parameters tg = 0.2 s and the interval after which the
scanning is re-started individually for each smartphone model.
Also, for most smartphones, a classification accuracy of 100 %
can be maintained for a longer duration than 1 minute (cf.
Fig. 4).
Below, we discuss multiple smartphone models that
exhibited an abnormal behavior in detail.
Samsung Galaxy S5: The Samsung Galaxy S5 we have
tested was using an older version of Android, in which
the scan intervals that were actually used differ from the
ones in the most recent Android version. Nevertheless, our
proposed algorithm works successfully when adjusting Ts .
The results of this experiment are shown in Fig. 5a. Similarly
to Fig. 3, the received packets over time are classified by
their channel of reception in Fig. 5a. In our experiment, the
SCAN MODE LOW LATENCY setting was used. As can
be seen, when adjusting the scan interval, the channel can be

Fig. 6: Two different sequences of received packets classified
by their reception channel over time for the Samsung Galaxy
M20 smartphone. Here, the SCAN MODE LOW LATENCY
setting was used.
tracked reliably over time.
Huawei P20 Lite: The Huawei P20 lite and the Samsung
Galaxy M20 smartphones were the only two Android
smartphones we have tested, on which our proposed
methodology did not work. In our experiments, we found
that the Huawei P20 Lite smartphone used a scan window
between 100 ms and 200 ms. Fig. 5b depicts the results of
this experiment with a Huawei P20 smartphone, in which
the SCAN MODE LOW LATENCY setting was used. As
can be seen, the channel is switched much more frequently
than expected. However, we could not identify a predictable
toggling behaviour of the the Huawei P20 smartphone in our
experiments. Hence, the algorithm was not able to classify
the BLE signals into Iˆ37 , Iˆ38 or Iˆ39 using Equation (3).
Samsung Galaxy M20:
Fig. 6 depicts the received
packets classified by their reception channels in two different
experiments using the Samsung Galaxy M20 smartphone. The
Samsung Galaxy M20 smartphone also uses scan windows of
length ds = 4.096 s in the SCAN MODE LOW LATENCY
setting. However, as can be seen, the channels are toggled in
a different order than specified by the BLE specification. For
example, in the upper part of the figure, the device started
scanning on channel 38, then switched to channel 39, then to
channel 37 and then to 39 again. The lower part of the figure
depicts another such abnormal scanning sequence. In addition
to this abnormality, the starting channel is not reset when
the scanning procedure is re-started. Clearly, this scanning
pattern does not comply to the BLE standard.
Apple iPhone 6s: We also wrote a dedicated Apple iOS
app for testing our approach on such devices. Using this

app, we could reveal the following behavior on an iPhone
6s. After resetting the scanning, the device always continues
to scan on the channel on which it had scanned at the time
it was stopped. Clearly, this prevents using our proposed
methodology. In addition, the scan windows were scheduled
in an unpredictable manner in our experiments. In particular,
the scan interval appeared to increase over time. Furthermore,
unlike on Android, iOS does not allow an app to choose
among different settings that determine Ts and ds . Finally,
transmitting in the background, i.e., when the screen is
locked, is not possible on iOS.
Other Phone Models: In addition to the evaluation data
contained in this paper, we plan to test additional smartphone
models for their scanning behavior in the future. For this
reason, we have launched a website [27] on which we will
list the outcomes of additional experiments. The website is
available under https://www.dlr.de/kn/covid.
VI. C ONCLUDING R EMARKS
As required by the BLE specification, the information on
which wireless channel a beacon has been received is not made
available to a smartphone. Fortunately, as we have shown in
this paper, the behavior of BLE radios used on many recent
smartphone models allows for reliably detecting the channel
indirectly, since the radio always starts scanning channel 37
after a re-start. Hence, we in this paper for the first time
proposed a solution to reliably detect the wireless channel
on which a packet has been received on a smartphone. We
also showed that the channel on which the smartphone scans
can be tracked over time by an Android application after restarting the BLE scanning procedure. The proposed technique
was experimentally evaluated on multiple different smartphone
models. In particular, we showed that a probability of detecting
the correct channel of 100 % can be obtained for the Google
Pixel 2 and Pixel 3 smartphones, and similar probabilities for
other smartphone models.
The information on which channel a packet has been
received is highly relevant for distance estimation. e.g., in
the context of contact tracing. In particular, the error induced
by the frequency-dependent gains Gr and Gt , as well as the
frequency dependent signal propagation in free space, can be
cancelled easily. Also the issue of multi-path propagation,
which can occur especially in indoor environments, can be
mitigated when the channel on which a packet was received
is known.
Since smartphones have not been designed for contact
tracing, tracing apps need to be regarded as a best-effort
approach without any guarantees on the performance. For this
reason, also a technique that improves the accuracy of distance
estimation for most (but not all) smartphone models will
contribute to a higher rate of successfully classified contacts.
Therefore, we believe that our proposed technique will be
helpful for distance estimation in contact tracing apps against
COVID-19. Besides this, a host of other distance estimationbased applications can benefit from our proposed technique.

VII. ACKNOWLEDGEMENT
The authors would like to thank Prof. Dr. Christoph
Günther, Dr. Armin Dammann and Prof. Dr. Samarjit
Chakraborty for many interesting discussions on this paper.
R EFERENCES
[1] C. Günther, M. Günther, and D. Günther, “Tracing contacts to
control the covid-19 pandemic,” arXiv preprint arXiv:2004.00517,
2020. [Online]. Available: https://arxiv.org/abs/2004.00517
[2] H. Friis, “A note on a simple transmission formula,” Proceedings of the
IRE, vol. 34, no. 5, pp. 254–256, may 1946.
[3] A. Alomainy, Y. Hao, A. Owadally, C. G. Parini, Y. Nechayev, C. C.
Constantinou, and P. S. Hall, “Statistical analysis and performance evaluation for on-body radio propagation with microstrip patch antennas,”
IEEE Transactions on Antennas and Propagation, vol. 55, no. 1, pp.
245–248, 2007.
[4] T. Chowdhury, M. Rahman, A.-A. Parvez, A. Alam, A. Basher, A. Alam,
and S. Rizwan, “A multi-step approach for RSSI-based distance estimation using smartphones,” in IEEE International Conference on
Networking Systems and Security (NSysS), 2015, pp. 1–5.
[5] S. Liu and A. Striegel, “Accurate extraction of face-to-face proximity
using smartphones and Bluetooth,” in IEEE International Conference on
Computer Communications and Networks (ICCCN), 2011, pp. 1–5.
[6] F. Sattler, J. Ma, P. Wagner, D. Neumann, M. Wenzel, R. Schäfer,
W. Samek, K.-R. Müller, and T. Wiegand, “Risk estimation of SARSCoV-2 transmission from Bluetooth Low Energy Measurements,”
arXiv preprint arXiv:2004.11841, 2020. [Online]. Available: https:
//arxiv.org/abs/2004.11841
[7] D. J. Leith and S. Farrell, “Coronavirus contact tracing: Evaluating
the potential of using Bluetooth received signal strength for proximity
detection,” 2020.
[8] Bluetooth SIG, “Specification of the Bluetooth system 5.2,” December
2019, volume 0, available via bluetooth.org.
[9] C. Gentner, T. Jost, W. Wang, S. Zhang, A. Dammann, and U.-C.
Fiebig, “Multipath assisted positioning with simultaneous localization
and mapping,” IEEE Trans. Wireless Commun., vol. 15, no. 9, pp. 6104–
6117, Sep. 2016.
[10] M. S. Hashemian, K. G. Stanley, and N. Osgood, “Flunet: Automated
tracking of contacts during flu season,” in International Symposium on
Modeling and Optimization in Mobile, Ad Hoc, and Wireless Networks
(WiOpt), 2010, pp. 348–353.
[11] T. Hellmich, C. Clements, N. ElSherif, K. S. Pasupathy, D. Nestler, A. J.
Boggust, V. Ernste, G. Marisamy, K. Koenig, and M. Hallbeck, “Contact
tracing with a real-time location system: A case study of increasing
relative effectiveness in an emergency department,” American Journal
of Infection Control, vol. 45, no. 12, pp. 1308 – 1311, 2017.
[12] L. Ferretti, C. Wymant, M. Kendall, L. Zhao, A. Nurtay, L. AbelerDörner, M. Parker, D. Bonsall, and C. Fraser, “Quantifying SARS-CoV2 transmission suggests epidemic control with digital contact tracing,”
Science, 2020.
[13] P. Kindt, T. Chakraborty, and S. Chakraborty, “How reliable is
smartphone-based electronic contact tracing for covid-19?” arXiv
preprint arXiv:2005.05625, 2020. [Online]. Available: https://arxiv.org/
abs/2005.05625
[14] A. Wolisz, “A fully distributed, privacy respecting approach for
back-tracking of potentially infectious contacts,” arXiv preprint
arXiv:2003.14243, 2020. [Online]. Available: https://arxiv.org/abs/2003.
14243
[15] K. Holzapfel, M. Karl, L. Lotz, G. Carle, C. Djeffal, C. Fruck,
C. Haack, D. Heckmann, P. Kindt, M. Köppl, P. Krause, L. Shtembari,
L. Marx, S. Meighen-Berger, B. Neumair, M. Neumair, J. Pollmann,
T. Pollmann, E. Resconi, S. Schönert, A. Turcati, C. Wiesinger,
G. Zattera, C. Allan, E. Barco, K. Bitterschulte, J. Buchwald,
C. Fischer, J. Gampe, M. Häcker, J. Islami, A. Pomplun, S. Preisner,
N. Quast, C. Romberg, C. Steinlehner, and T. Ziehm, “Digital contact
tracing service: An improved decentralized design for privacy and
effectiveness,” CoRR, vol. abs/2006.16960, 2020. [Online]. Available:
https://arxiv.org/abs/2006.16960
[16] S. Jeong, S. Kuk, and H. Kim, “A smartphone magnetometer-based diagnostic test for automatic contact tracing in infectious disease epidemics,”
IEEE Access, vol. 7, pp. 20 734–20 747, 2019.

[17] B. Thiel, K. Kloch, and P. Lukowicz, “Sound-based proximity detection
with mobile phones,” in International Workshop on Sensing Applications
on Mobile Phones (PhoneSense), 2012.
[18] I. Carreras, A. Matic, P. Saar, and V. Osmani, “Comm2Sense: Detecting
proximity through smartphones,” in IEEE International Conference on
Pervasive Computing and Communications (PerCom) Workshops, 2012,
pp. 253–258.
[19] S. Liu, Y. Jiang, and A. Striegel, “Face-to-face proximity estimation
using bluetooth on smartphones,” IEEE Transactions on Mobile Computing (TMC), vol. 13, no. 4, pp. 811–823, 2014.
[20] N. Palaghias, S. A. Hoseinitabatabaei, M. Nati, A. Gluhak, and
K. Moessner, “Accurate detection of real-world social interactions with
smartphones,” in IEEE International Conference on Communications
(ICC), 2015, pp. 579–585.
[21] D. Kim, S. Kim, D. Choi, and S.-H. Jin, “Accurate indoor proximity
zone detection based on time window and frequency with Bluetooth Low
Energy.” in International Conference on Mobile Systems and Pervasive
Computing (MobiSPC), 2015, pp. 88–95.
[22] P. Ng, J. She, and R. Ran, “A compressive sensing approach to detect
the proximity between smartphones and BLE beacons,” IEEE Internet
of Things Journal, vol. 6, no. 4, pp. 7162–7174, 2019.
[23] I. Bisio, A. Sciarrone, and S. Zappatore, “A new asset tracking architecture integrating RFID, Bluetooth Low Energy tags and ad hoc
smartphone applications,” Pervasive and Mobile Computing, vol. 31,
pp. 79–93, 2016.
[24] D. Leith and S. Farrell, “Measurement-based evaluation of Google/Apple
exposure notification API for proximity detection in a commuter
bus,” CoRR, vol. abs/2006.08543, 2020. [Online]. Available: https:
//arxiv.org/abs/2006.08543
[25] P. Kindt, M. Saur, M. Balszun, and S. Chakraborty, “Neighbor discovery
latency in BLE-like protocols,” IEEE Transactions on Mobile Computing
(TMC), vol. 17, no. 3, pp. 617–631, 2018.
[26] Apple, Google, “Exposure notification bluetooth specification,”
April 2020, available via https://blog.google/documents/70/Exposure
Notification - Bluetooth Specification v1.2.2.pdf.
[27] “Android Received Channel Detection Website,” https://www.dlr.de/kn/
covid.

