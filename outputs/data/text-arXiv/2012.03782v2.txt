PCT-TEE: Trajectory-based Private Contact Tracing System
with Trusted Execution Environment

arXiv:2012.03782v2 [cs.CR] 15 Feb 2021

FUMIYUK KATO, YANG CAO, and YOSHIKAWA MASATOSHI, Kyoto University, Japan
Existing Bluetooth-based Private Contact Tracing (PCT) systems can privately detect whether people have
come into direct contact with COVID-19 patients. However, we find that the existing systems lack functionality
and flexibility, which may hurt the success of the contact tracing. Specifically, they cannot detect indirect
contact (e.g., people may be exposed to coronavirus because of used the same elevator even without direct
contact); they also cannot flexibly change the rules of “risky contact”, such as how many hours of exposure
or how close to a COVID-19 patient that is considered as risk exposure, which may be changed with the
environmental situation.
In this paper, we propose an efficient and secure contact tracing system that enables to trace both direct
contact and indirect contact. To address the above problems, we need to utilize users’ trajectory data for
private contact tracing, which we call trajectory-based PCT. We formalize this problem as Spatiotemporal
Private Set Intersection. By analyzing different approaches such as homomorphic encryption that could be
extended to solve this problem, we identify that Trusted Execution Environment (TEE) is a proposing method
to achieve our requirements. The major challenge is how to design algorithms for spatiotemporal private set
intersection under limited secure memory of TEE. To this end, we design a TEE-based system with flexible
trajectory data encoding algorithms. Our experiments on real-world data show that the proposed system can
process thousands of queries on tens of million records of trajectory data in a few seconds.
CCS Concepts: • Security and privacy → Domain-specific security and privacy architectures; Privacy
protections.
Additional Key Words and Phrases: Private Contact Tracing, Trusted Execution Environment, Intel SGX
ACM Reference Format:
Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi. 2020. PCT-TEE: Trajectory-based Private Contact Tracing
System with Trusted Execution Environment. J. ACM 37, 4, Article 111 (August 2020), 28 pages.

1

INTRODUCTION

Since the beginning of 2020, the emergence of COVID-19 has caused a worldwide pandemic.
Many governments and companies are developing various measures and technologies to prevent
the spread of the virus [10, 44, 49, 62]. At present, contact tracing is expected to be a powerful
countermeasure for controlling the spread of infection. The effectiveness of contact tracing has
already been shown by several previous studies [6, 18, 45, 55]. However, conducting effective
contact tracing often requires collecting citizens’ personal information, such as locations [64] or
telephone numbers [57], which raises ethical issues and serious privacy violations [29]. Therefore,
acceptable private contact tracing (PCT) is urgently needed.
Recently, Bluetooth-based private contact tracing has been intensively studied [5, 26, 47, 60, 61].
Decentralized privacy-preserving proximity tracing (DP3T) [61], which is an open protocol for PCT
Authors’ address: Fumiyuk Kato, fumiyuki@db.soc.i.kyoto-u.ac.jp; Yang Cao, yang@i.kyoto-u.ac.jp; Yoshikawa Masatoshi,
yoshikawa@i.kyoto-u.ac.jp, Kyoto University, Yoshida-Honcho, Sakyo, Kyoto, Japan, 606-8501.
Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee
provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and
the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored.
Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires
prior specific permission and/or a fee. Request permissions from permissions@acm.org.
© 2020 Association for Computing Machinery.
0004-5411/2020/8-ART111 $15.00
https://doi.org/

J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111

111:2

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

using Bluetooth low energy beacons, is already being used in applications developed in the world.
To strongly protect users’ privacy, it uses only contact (proximity) history detected by the Bluetooth
low energy beacons. In DP3T, the base mechanism is that the applications use the Bluetooth signal
of a smartphone to broadcast a random ID that does not include sensitive information such as the
user’s identity or location, and the nearby smartphone devices receive and store the data for a
limited time. Users who are then discovered to be infected with the coronavirus send a report to
the server that includes the random IDs they have generated. Meanwhile, the user routinely checks
to see if the random IDs received from devices they have contacted in the past have been uploaded
to the server. Additionally, there are similar methods for adopting decentralized architecture, such
as Epione [60], PACT protocol [47], CEN [5, 56] and Google and Apple specifications [26].
However, Bluetooth-based private contact tracing has several limitations in terms of functionality
and flexibility. First, Bluetooth-based PCT only detects direct contact (i.e., human-human contact)
but cannot detect indirect contact (i.e., human-object, e.g., used the same elevator shortly after a
COVID-19 patient used it). The Centers for Disease Control and Prevention (CDC) in the US has
shown that it is possible that a person can obtain COVID-19 by touching a surface or object that
has the virus on it and then touching their own mouth, nose, or eyes [19] — even though they do
not have direct contact with COVID-19 patients. Second, the Bluetooth-based PCT lacks flexibility
in terms of determining the rule of “risky contact". Essentially, the rule of risky contact in the
Bluetooth-based PCT is hard-wired into the Bluetooth device since the risky contact is implicitly
defined as two devices in close proximity to each other’s signal range. In practice, whether or
not it is a risky contact varies with the environmental situation and the nature of the virus. The
rules of risky contact in COVID-19 have been updated along with the understanding of the virus
[17]. For example, in the beginning of the pandemic, professionals believed that transmission only
took place through direct human-human contact; however, recently, it was argued that airborne
transmission should be taken into account [59]. Moreover, recent reviews have pointed out the
current PCT application limitations [39, 65], which are the inability to detect infections that do not
involve direct contact and radio signal limitations for contact detection [1, 18].
In this work, we propose secure and efficient trajectory-based private contact tracing to enable
both direct and indirect contact tracing. By comparing the trajectory data between a user and the
infected patients, we can check whether or not the user visits the “infected locations” within the
certain time period. The rule of risky contact can be flexibly defined according to the condition of a
location and the nature of the virus. The following four requirements for trajectory-based private
contact tracing are listed as follows.
(1) Efficiency: The query throughput that can be handled by the central server is crucial.
(2) Security: A client’s trajectory data must be protected from the server and any other clients.
However, nothing about the server side data is disclosed to the client except the query result.
(3) Flexibility: The rule of risky contact should be flexibly changeable.
(4) Accuracy: The server must return the true result because the result is so sensitive and can
significantly affect the users.
As shown in Figure 1, we assume that the health agency (e.g., the government or official healthcare
institute) registers trajectory data of the confirmed COVID-19 patients (these data are encrypted or
released under the consent of the patients) to a server that is untrusted by clients (i.e., queriers).
The server receives queries and encrypted personal trajectories from clients and returns a Boolean
value of whether there is risky contact or not by computing an intersection between server and
client trajectories in private manner.
Although the problem of trajectory-based PCT is similar to the well-studied problem of private
set intersection (PSI), the existing approaches for PSI cannot satisfy all of the above-mentioned four
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

PCT-TEE: Trajectory-based Private Contact Tracing System with Trusted Execution Environment

111:3

Fig. 1. Trajectory-based PCT overview.

[61]
[9, 46]
[54]
[45]
Our work

Functionality

Efficiency

Security

Flexibility

Accuracy

⃝
⃝

⃝
⃝
⃝

⃝
⃝
⃝
⃝
⃝

⃝

⃝
⃝
⃝
⃝

Table 1. Comparison with existing approaches.

requirements. PSI ensures that two (or more) parties collaboratively calculate the intersection of
their private sets, while nothing about the private data will be disclosed to the other party except the
existing information of the intersection or the result. However, existing techniques for PSI, mostly
based on cryptographic primitives, cannot achieve all of the abovementioned requirements. The
state-of-the-art cryptography-based PSI approach, such as oblivious transfer [46] or homomorphic
encryption [9] has limitations in terms of efficiency, and there are still performance problems [40, 45]
in medium or large workloads. This is mainly due to the heavy use of time-consuming cryptographic
primitives. Recently, secure hardware (such as Intel SGX or ARM TrustZone) -based approaches
have received increasing attention. It enables to make Trusted Execution Environment (TEE)
[11, 48], which is used for speeding up secure computations on untrusted party. Tamrakar et al. [54]
proposed the first efficient TEE-based PSI. It is efficient, however, it does not satisfy our requirement
of accuracy since it introduces a nonzero false positive rate because of using probabilistic data
structures, and flexibility has not been considered. Thus, we summary the comparison with our
work in Table 1, adding [45] which is MPC-based private contact tracing system using trajectories.
Functionality means the capability to detect indirect contact.
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111:4

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

Our contributions in this paper are three-folded. First, we formulate the problem of trajectorybased PCT. We show that our problem is a generalization of well-studied private proximity testing
[40] and private set intersection (PSI). Our formulation is parametrized for both time and space
and can be used in general settings. We name this formulation Spatiotemporal Private Set Intersection. Second, we propose PCT-TEE, a TEE-based system architecture and efficient algorithms
for trajectory-based PCT. In addition to satisfying the abovementioned requirements, a challenge
in designing the TEE-based algorithm is the constraint of the secure memory (i.e., enclave) on
secure hardware. We solve these problems by designing a novel trajectory data encoding method,
TrajectoryHash, and combining it with finite state automaton. We show this is generalization of our
previous encoding [30]. TrajectoryHash and finite state automaton enable algorithmic flexibility,
more efficient compression, and deterministic and fast search performance for high-speed PSI on
TEE. Third, we implement the proposed system on Intel SGX and open source the prototype code
in GitHub1 . Our experiments on real-world datasets show that the proposed system is efficient and
effective in practical scenarios. Specifically, the proposed encoding and data structure compresses
the actual trajectory data to one-sixth the size of the hash table with the same performance, and as a
result, the total runtime is substantially reduced. Moreover, we show that our system implemented
on a single machine equipped with SGX can handle thousands of queries on tens million records of
trajectory data in a few seconds.
Outline. In Section 2, we show some features of Intel SGX that are related to our architecture. In
Section 3, we show a comparison compare TEE-based PSI and conventional cryptography-based PSI
performance. In Section 4, we describe the problem statement and formulate the PCT problem. In
Section 5, we explain overview of our architecture, and in Section 6, algorithm and trajectory-based
data compression. In Section 7, we show how our system achieve the requirements. In Section 8,
we show the experimental results and evaluation. In Section 9, we show related works including
related recent PCT applications and our position. Finally, we provide the conclusions in Section 10.
2

TRUSTED EXECUTION ENVIRONMENT

Before explaining our system, we introduce the secure hardware used in this paper for ease of
understanding our system. Below we focus on Intel SGX, which is representative implementation
of TEE. The proposed architecture and algorithms in this paper can be applied to any other types
of secure hardware. Intel SGX[11] is the extended instruction set of Intel x86 processors, which
enables the creation of an isolated trusted execution environment, called the enclave. In addition
to powerful server machines, SGX is installed on some PCs. SGX is also available on some public
cloud platforms, such as Azure Confidential Computing, Alibaba Cloud, and IBM Cloud. We show
a brief overview of SGX in the following paragraphs.
Enclave resides in the protected memory region, called the Enclave Page Cache (EPC), in which
all programs and data can be unencrypted and fast processed while they transparently encrypted
outside the CPU package by a memory encryption engine using a secret key that only processor
hardware can access. In other words, SGX adopts a model that considers the CPU package as a trust
boundary and everything outside as untrusted. In this trusted space, accesses from any untrusted
software, including OS/Hypervisor, are prohibited by the CPU, protecting the confidentiality and
integrity of the program and data inside the enclave. Therefore, programs using SGX must use two
types of instructions called OCALL/ECALL to invoke functions across trust boundaries under strict
control. These instructions often require too much clock cycles [58], and so does uploading data to
enclave. This observation is important to improve our system performance.

1 https://github.com/ylab-public/PCT

J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

PCT-TEE: Trajectory-based Private Contact Tracing System with Trusted Execution Environment

111:5

Memory size limitation. A challenge in designing algorithms for Intel SGX is the size constraint
of EPC. The maximum size of EPC is limited to 128 MB, including 32 MB meta-data for secure
management (or 256 MB including 64 MB meta-data in the recent Intel hi-end processor[32]). This
limitation may actually be gradually improved, but it will continue to be a problem for hardware
and memory securing performance. Assume that memory is allocated beyond this memory size
constraint. In this case, SGX with Linux allows paging with special encryption. However, many
studies have shown that the performance is greatly degraded by severe overhead [21, 24, 53], which
is derived from a requirement to preserve confidentiality and integrity even outside the enclave.
Therefore, it is necessary to design an efficient algorithm that works within SGX. It is still important
problem, and Kockan et al. [31] shows a method to overcome the severe memory limitation of the
TEEs for genomic data analysis.
Attestation. SGX supports two types of attestations, local and remote, which can verify the correct
initial state and genuineness of the trusted environment of the enclave from outside. In our paper,
we focus on remote attestation (RA)[11]. We can request RA to the enclave and receive a report
with measurements (e.g., MRENCLAVE and MRSIGNER) based on the hash of the initial enclave
state and other environment as a hash-chain, which can identify the programs, complete memory
layout, and even builder’s key information, and this measurement cannot be tampered with. Intel
Enhanced Privacy ID signs this measurement, and Intel Attestation Service can verify the correctness
of the signature as a role of a trusted third party. In addition to verifying the SGX environment,
secure key exchange between the enclave and remote client is performed within this RA protocol.
Therefore, after that protocol, we can communicate over a secure channel with a remote enclave
by fast encryption scheme such as AES-GCM, and finally, we can safely perform a confidential
calculation in the remote enclave. Our system utilizes this primitive for private computation.
3

PRIVATE SET INTERSECTION

Private Set Intersection (PSI) is well-studied and important problem. PSI refers to a setting where
multiple parties each hold a set of private sets, and wish to learn the intersection of their sets
without revealing any information except for the intersection itself. Existing main approach is to
use cryptographic primitives, the summary is following. We can summary conventional approaches
in two aspects, methodology and security model.
In the first aspect, firstly there is a method that is based on the commutative properties of the
Diffie–Hellman (DH) key exchange [14]. It requires to compute polynomial interpolation which
needs computation cost so much. Huang et al. [27] describes garbled circuit-based approach. Their
proposed SCS circuit family improved the efficiency at that time. This approach is similar to
secure hardware-based approach described later in terms of leveraging general-purpose secure
computation. Oblivious transfer (OT) [42, 43, 46] is one of the most promising approach. While they
are generally for semi-honest adversaries, [46] extends the method to malicious adversary using
dual execution technique [37]. Homomorphic encryption (HE) [8, 9] is suitable for an unbalanced
setting where the server-side data size is large and the client-side data size is small, because it
can replace oblivious pseudorandom function in OT-based approach with leveled fully HE and
substantially reduce the amount of data to be transmitted. Lastly, there is a method extended
from private information retrieval [15]. Many improvements are proposed in this way, however,
there is still no method to achieve practical efficiency on large scale data in execution time and
communication bandwidth.
In the second aspect, there are semi-honest [22] or malicious adversary. Roughly speaking, a
semi-honest adversary is an attacker who tries to infer secret information from the information he
obtains, although he follows correct protocols and does not craft send and received data, while a
malicious adversary is an attacker who crafts the send and received data and execute the protocol
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111:6

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

TEE
OT [46]
HE [9]

bandwidth

computation

requirements

O (𝑛)

O (𝑛)

O (𝑁 )
O (𝑛 log 𝑁 )

O (𝑁 log 𝑁 )
O (𝑁 )

RA
hardware
-

server
security
malicious
malicious
semi-honest

Table 2. PSI comparison: cryptography-based(OT, HE) v.s. TEE-based

as much times as possible to extract secret information. Generally, malicious client setting requires
more secure standard and larger costs. Which model we should secure depends on the applications
and situations, but in our scenario, we consider malicious adversary.
We consider secure hardware-based approach can be better option. From point of view of
methodology, we do not have to use above-mentioned cryptographic primitives. Using Intel SGX,
platform verification and transparent memory encryption by hardware work so fast and totally it
can achieve highly efficient PSI. Additionally, TEE provides refined security model for malicious
adversary. [52] shows any operation and inputs expose no information about the inside state or
data of the trusted execution environment. All we have to care about is privacy leakage outside TEE
and software implementation bugs. So, secure hardware-based method provides sufficient security
model. [54] shows the design for private membership test using TEE. Although not directly related
to the speed of PSI, their proposed carousel approach is useful to improve query throughput.
We describe a closer comparison between existing cryptography-based PSI and secure hardwarebased PSI in efficiency. We recognize the state-of-the-art approaches are [46] in balanced data size
setting in server and client, and [9] in unbalanced. The second one supposes for semi-honest server,
and it is faster than others in the malicious server model. Table 2 shows a comparison of properties
between them and secure hardware (Intel SGX). It includes relatively rough asymptotic bandwidth
and computation costs at every PSI execution. We denote 𝑛, 𝑁 as clients data size and server data
size ,respectively, and 𝑛 ≤ 𝑁 . Asymptotic comparisons is acceptable for one purpose because of the
large impact of different coefficients. But we can see, with secure hardware, both communication
and computing costs are dramatically more efficient as it is proportional only to a client data size
(Table 2). On the other hand, secure TEE-based approach requires remote attestation in advance
and a hardware with special functionality in server side. Cryptography-based methods do not need
any special devices; they solely consist of algorithms. As shown in Table 2, by using a variant of
Cuckoo hashing, OT-based one [46] reduces communication cost to (𝑁 ) from naive (𝑁 2 ) cost. In
[9], communication cost is efficiently reduced to O (𝑛 log 𝑁 ) and the server computation cost is
O (𝑛) homomorphic evaluations on large circuits of size O (𝑁 /𝑛) (∗). These facts show that secure
hardware-based method demands extra cost such as special hardware, but a better choice for large
scale deployment because of their significant efficiency.
4

PROBLEM FORMULATION

We first introduce the scenario of trajectory-based private contact tracing, and then we formulate
our problem based on well-studied private proximity testing.
4.1

Scenario

In our scenario, we assume that trajectory-based PCT is used to prevent the spread of COVID-19.
We consider a centralized architecture that stores the trajectory data of infected patients on a
central server and accepts PCT requests from users with their trajectory data. In practice, infected
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

PCT-TEE: Trajectory-based Private Contact Tracing System with Trusted Execution Environment

111:7

patients’ trajectories can be received in bulk from public institutions such as a government or
health agency.
In the operation of the system, based on the incubation period of the virus, the server always
keeps the trajectory data of the infected patients for the past 14 days (up to 21 days). All the data
periodically updates in batches (e.g., once per day), adding and deleting data. The server transforms
the trajectory data to an appropriate structure in advance and is always ready to accept PCT
requests from clients. The client sends encrypted trajectory data for the past 14 days as a PCT
request and the server performs contact detection and then returns the results to the client. The
results can be time-stamped and signed in SGX as needed, so that they can be verified by a third
party, allowing clients to use them in various agencies and events to show that the risk of infection
is low.
Finally, the threat model is a malicious server with privileges for software/hardware and honest
clients. The client must only trust the CPU package equipped with SGX used on the server. If
the client is malicious and send crafted trajectories, the client finds out that some of the crafted
records is match with the infected people trajectories. This can not be a problem when assuming
that the infected people trajectories are allowed to be public, but if not, we need to take measures
against malicious clients. A reasonable measure is to restrict the number of PCT request attempts
for each clients by authentication. However, it may still leak the privacy of the infected person
to a malicious client with strong prior knowledge. To protect even in such a case, we may have
to return probabilistic outputs to guarantee differential privacy. Nevertheless, in this paper, we
assumes that the data of infected people can be public.
4.2

Problem Statement

Trajectory-based PCT. The trajectory-based PCT protocol is an asymmetric protocol between a
client and a server. When a client wants to know the contact with trajectories stored on a server,
this protocol returns 1 or 0 to the client, depending on the result, and does not disclose the private
information of the client to the server. In the use case for infections, each client has a set of trajectory
data for one person, and the server has trajectory data for many infected patients.
In conventional private proximity testing [40], when two people, user 𝑢 and 𝑣, have geographic
data 𝑋𝑖 that consists of location 𝑙𝑡(𝑖) (= (latitude, longitude)) of time 𝑡 (𝑖 = 𝑢, 𝑣), user 𝑢 executes the
protocol and obtains the result as follows;

(

1 ( ||𝑙𝑡(𝑢) − 𝑙𝑡(𝑣) || ≤ 𝜃 )
0 ( 𝑜𝑡ℎ𝑒𝑟𝑠 )

where 𝜃 is a proximity threshold. After that, 𝑣 does not learn any information about 𝑋𝑢 and 𝑢 does
not learn information except ||𝑙𝑡(𝑢) − 𝑙𝑡(𝑣) || ≤ 𝜃 .
In the simplest form, trajectory-based PCT can be represented as an extension of such a formulation. For contact tracings, a contact can be determined according to human time-series tracking
data. We can perform private proximity testing by extending single geographic data to time-series
trajectory data. The threshold can also be extended to two-dimensional thresholds to check spatialtemporal proximity. PCT allows to capture indirect contacts by examine that the patients are in
the same place within a specific period. Therefore, we obtain the following formula denoting the
trajectory data of user 𝑖 as 𝑋𝑖 = (𝑥 1(𝑖) = (𝑡 1(𝑖) , 𝑙 1(𝑖) ), ..., 𝑥𝑛(𝑖) = (𝑡𝑛(𝑖) , 𝑙𝑛(𝑖) )), and 𝑢 can obtain the result
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111:8

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

Fig. 2. Spatiotemporal Private Set Intersection.

of contact with 𝑣,


1 (∃ 𝑥𝑖(𝑢) ∈ 𝑋𝑢 , 𝑥 𝑗(𝑣) ∈ 𝑋 𝑣 𝑠.𝑡 .



||𝑙𝑖(𝑢) − 𝑙 𝑗(𝑣) || ≤ 𝜃𝑔𝑒𝑜 and ||𝑡𝑖(𝑢) − 𝑡 𝑗(𝑣) || ≤ 𝜃 𝑡𝑖𝑚𝑒 )


 0 ( 𝑜𝑡ℎ𝑒𝑟𝑠 )


(1)

where 𝜃𝑔𝑒𝑜 and 𝜃 𝑡𝑖𝑚𝑒 are the spatial and temporal proximity thresholds, respectively. Furthermore,
𝑣 does not learn any information about 𝑋𝑢 , and 𝑢 can obtain only 1 or 0 about 𝑋 𝑣 in this protocol.
And we define it as Trajectory-basd PCT.
We simplify this problem by mapping any continuous data to a discrete space for computational
efficiency. We denote A as the set of all symbols in a discrete space, and 𝐴𝑖 ∈ A as the 𝑖-th
element. By mapping 𝑓𝜃 : 𝑥 → 𝐴, any point 𝑥 in the trajectory data is mapped to a single symbol
𝐴. We call this mapping “encoding" and we introduce the corresponding method in Section 4.2.
Encoding 𝑓𝜃 must be adjusted according to parameter 𝜃 = (𝜃𝑔𝑒𝑜 , 𝜃 𝑡𝑖𝑚𝑒 ), which corresponds to the
size of pre-defined subspace in the 3D spatiotemporal space and each subspace corresponds to one
unique symbol, as shown in Figure 2. For example, suppose 𝑓𝜃 (𝑥 1 ) = 𝐴1 , 𝑓𝜃 (𝑥 2 ) = 𝐴2 , 𝑓𝜃 (𝑥 3 ) = 𝐴2 ,
𝑓𝜃 (𝑥 4 ) = 𝐴2 , 𝑓𝜃 (𝑥 5 ) = 𝐴2 , trajectory point 𝑥 1 is mapped to 𝐴1 , and 𝑥 2 ,𝑥 3 ,𝑥 4 ,𝑥 5 are mapped to 𝐴2 in
Figure 2. We determine contact by considering the intersection of these symbol sets between 𝑢 and
𝑣. This can be formulated as follows,

 1 ∃ A (𝑢) ∩ A (𝑣) ≠ ∅ 𝑠.𝑡 .




(2)
A (𝑢) = { 𝑓𝜃 (𝑥𝑖(𝑢) ) | 𝑥𝑖(𝑢) ∈ 𝑋𝑢 } and A (𝑣) = { 𝑓𝜃 (𝑥 𝑗(𝑣) ) | 𝑥 𝑗(𝑣) ∈ 𝑋 𝑣 }


 0 ( 𝑜𝑡ℎ𝑒𝑟𝑠 )

𝑣 does not learn any information about 𝑋𝑢 , and 𝑢 can obtain only 1 or 0 about 𝑋 𝑣 in this problem.
And we name this problem as Spatiotemporal Private Set Intersection.
In this work, we consider Spatiotemporal Private Set Intersection as contact between 𝑢 and 𝑣. It
is an approximation of Trajectory-based PCT.
Efficiency. Trajectory-based PCT requires efficiency in several aspects.
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

PCT-TEE: Trajectory-based Private Contact Tracing System with Trusted Execution Environment

111:9

• The first is the response throughput since the server will always be exposed to requests from
a large number of users. It can be a substantial workload in such a centralized protocol.
• The second aspect is the bandwidth. Since the protocol is applied to many users, it is necessary
to reduce the bandwidth for communication efficiency.
• The third aspect is scalability. For instance, for COVID-19, the size of the infected patients’
data and the user’s size may increase in the event of the infection spreading.
The efficiency requirements depend entirely on the context in which PCT is deployed and are
determined by the number of users, frequency of use, number of data, etc.
Security. Considering the threat model in trajectory-based PCT, the most prominent threat that
we should defend against is the malicious server. Informally, the malicious server tries to obtain
information illegally without the constraint of following the protocol. In a typical model, the
server runs in the untrusted software and hardware environment, and it has a full control over
the operating system and/or hypervisor, memory hardware units, and packet flow in the network.
Under this model, it is essentially necessary to have cryptographic indistinguishability in the
PCT processing on the server and delivering on the network to protect user privacy because the
adversary can monitor raw data. Other party, such as other clients, can be an another threat,
however, in our scenario they cannot interfere other client protocols. The most harmful thing they
can do is to monitor the network, except for hacking the server system, and it is enough to consider
the security of untrusted servers, including the communication part.
More formal security definition for malicious attacker on the remote attestation protocol using
SGX follows [4, 52].
Flexibility and Accuracy. Flexibility, expressed slightly more formally, is the requirement that
(𝜃𝑔𝑒𝑜 , 𝜃 𝑡𝑖𝑚𝑒 ) are parameters in the system. For example, these parameters need to be changed to
minimal values if it is found after the system is released that only direct contact needs to be captured
because of the virus’s capacity for transmission. Accuracy does not allow the PCT to return any
probabilistic answer, which is highly dependent on the domain where PCT system is deployed. Since
our system does not return statistics, we believe it is better to avoid probabilistic data structures
whenever possible, satisfying both determinism and efficiency is the most demanded.
5

SYSTEM OVERVIEW

We introduce an overview of the system. Table 3 shows the symbols and parameters that are used
in the rest of the paper.
Figure 3 shows the overview of our architecture using a trusted enclave. Our method consists
of several steps, including the transformation of data maintained on the server side and the
transformation of data sent from the clients as follows.
First, we describe the data of infected patients on the server.
1 : (Update master data) The government updates the infected patient data 𝐷 in batch processing.
𝐷 is in the raw form of trajectory data 𝐷 = [(𝑡 1, 𝑙 1 ), ..., (𝑡𝑛𝑅 , 𝑙𝑛𝑅 )], which does not have to include
the user IDs since there is no need to distinguish trajectory data by infected users.
2 : (Mapping) step 2 is executed in the same batch processing as step 1. We map from the raw data
format 𝐷 to efficient dictionary representation 𝑅 with function mapToChunkedDictionary(𝐷, 𝜃 ).
This mapping function includes encoding, chunking, and transforming to dictionary representation.
Encoding is to encode each trajectory data into 1D string representation. It corresponds to 𝑓𝜃 in
Def. ??. Chunking is to split the data set into 𝑁𝑅 chunks. Transforming is to transform each chunks
into dictionary representations 𝑅 that consists of 𝑁𝑅 chunks 𝑟𝑖 (𝑖 = 1, ..., 𝑁𝑅 ), where each chunk
fits in the enclave memory limitation. How to represent the chunked data specialized in PSI under
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111:10

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

Table 3. Symbols and parameters.

Symbols
𝑁𝐷
𝐷
𝑁𝐶
𝑐𝑖 ∈ C
𝑁𝑅
𝑅
𝑟𝑖
𝑞𝑖
𝑄
𝑁𝑄
𝜃
(𝑡𝑖 , 𝑙𝑖 )

Explanation
number of raw trajectory data of infected people
raw trajectory data of infected people
number of clients
a client 𝑖 (∈ {1, ..., 𝑁𝐶 }) and all clients set
number of chunks of central data
mapped 𝐷, array of efficient chunks (= (𝑟 1, ..., 𝑟 𝑁𝑅 ))
𝑖-th chunked data of 𝑅, efficient representation (e.g., FSA)
client 𝑖’s query data (raw trajectory data)
merged and mapped 𝑁𝐶 query data (e.g., unique array)
unique size of 𝑄
parameter of PCT, 𝜃 = (𝜃 𝑡𝑖𝑚𝑒 , 𝜃𝑔𝑒𝑜 )
𝑖-th row of trajectory data, time 𝑡𝑖 and location 𝑙𝑖 = (𝑙𝑖𝑙𝑎𝑡 , 𝑙𝑖𝑙𝑜𝑛 )

Fig. 3. Architecture overview: circle numbers correspond to the steps shown in System Overview.

SGX memory constraint is our challenge. These encoding and compression scheme are described
in Section 6.
The next part is the processing of queries from clients.
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

PCT-TEE: Trajectory-based Private Contact Tracing System with Trusted Execution Environment

111:11

3 : (Remote attestation) The client verifies the remote enclave through the remote attestation
protocol before sending the request to the server. The client can confirm that the enclave has not
been tampered with and then securely exchange keys with the enclave. Thereafter, the key is used
to encrypt the data, which enables secret communication to the remote enclave through a secure
channel.
4 : (Request) Many clients send PCT requests to the server. In the figure, 𝑐𝑖 sends 𝑞𝑖 as a parameter
of the query that which contains her trajectory data. Trajectory data is encoded by 𝑓𝜃 before
encryption, so server and client share the parameter 𝜃 . 𝑞𝑖 is encrypted in all the untrusted areas
after leaving client environment, and is only visible in the verified enclave.
5 : (Queuing) Until a certain number (𝑁𝑐 ) of requests are accumulated, 𝑞𝑖 is queued outside the
enclave and they are passed to the enclave together by loadToEnclave function. This function is
actually implemented by the so-called ECALL in to invoke a SGX function. This technique is used
in [54] as well, and we aim to optimize the query processing for multiple (e.g. 1000) users by batch
processing. This optimization can also mitigate the ECALL overheads.
6 : (Mapping) After uploaded to the trusted enclave, the data is finally decrypted. Inside the
enclave, the number of 𝑞𝑖 are grouped together and mapped to query representation 𝑄 using
mapToUniqeArray. The function also takes query data and a granularity parameter 𝜃 as step
2. We intend to convert the data structure suitable for PSI; basically, 𝑄 is represented as a unique
array. If trajectory representation is large, this part can be bottleneck. Moreover, these query data is
private and cannot be handled outside enclave. Therefore, encoding trajectory data to small bytes
(step 4) is critical.
7 : (Contact detection): The chunked data 𝑟𝑖 are imported into the enclave one by one, and
we compute the set intersection of 𝑟𝑖 and 𝑄 in the enclave. This can be done by checking the
string-based match with the transformation in step 2. The results are stored together.
8 : (Response construction) After the iterations for all the chunks are completed, responses for all
clients are constructed from the results and complete query data 𝑞𝑖 (𝑖 = 1, ..., 𝑁𝐶 ) inside the trusted
enclave by constructResponses. This can be done by simply checking whether each query has
data of the results. Finally, it returns the encrypted result through the secure channel to each client.
6

TRAJECTORY DATA REPRESENTATION

In this section we focus on trajectory data representation which is optimized for PSI processing in
the memory constraint of Intel SGX. The most important issue is how to represent each trajectory
data. It is encoding and corresponds to 𝑓𝜃 in Eq. ??. We need to encode different trajectory data into
an unique 1d data to perform PSI. We also have to make encoded data small as described in Section
4.1. The compact representation contributes to whole system performance, and the compressibility
contributes performance of the PSI part which is the core component of our system. In particular, we
carefully develop the dictionary representation 𝑅 (= (𝑟 1, ...𝑟 𝑁𝑅 )) obtained by the mapping in step 2.
𝑅 should satisfy the following constraints. First, a memory-efficient data structure storing trajectory
data to overcome severe memory constraints should be used. Second, fast search performance
should be implemented for fast PSI. Third, a deterministic search method for accurate PSI should
be provided.
Standard dictionary representations do not fulfill our requirements. A well-known data structure
for dictionary representation is the hash table, and we consider the hash table as a baseline. The
hash table ideally supports the O (1) key-based search. While it provides the desirable search
performance and allows deterministic search, it fails to satisfy efficiency because its size increases
linearly with the size of the data. A smaller data structure is preferable in our setting because the
overheads caused by SGX is considerably heavy. While probabilistic data structures such as the
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111:12

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

Bloom filter provide the same speed of search performance as the hash table and superior memory
efficiency, they do not satisfy deterministic search.
Our proposed method to achieve the desired dictionary representation is a combination of
encoding and finite state automaton (FSA). Roughly speaking, the encoding process transforms
trajectory data into highly similar string representations and then utilizes the similarity to create a
compressed dictionary representation using FSA. FSA is a deterministic finite state acceptor and
can be cyclic and permits the sharing of both prefixes and suffixes among the same nodes (described
in Section 6.2).
6.1

TrajectoryHash

We introduce encoding which corresponds 𝑓𝜃 in Spatiotemporal Private Set Intersection. The
encoding should satisfy following 3 properties. The first property that our encoding must satisfy
is that there is an injective function between discretized and different trajectory data and unique
strings. Obviously, if this property is not satisfied, PSI cannot be performed correctly. Second
property is small size. The space after mapping should be as small as possible because if it is small,
all data, including both the server data and the queries from the client, will be small. That’s the
ideal situation for TEE-based secure computation. Our previous work [30] lacks this aspect. The
other desired property is that the string has many similarities because of the FSA. We introduce
TrajectoryHash encoding and show it satisfies both properties.
The trajectory data 𝑋 consist of an array of tuples of temporal data and geographical data, such
as UNIX epoch and tuples of latitude and longitude, as follows.
X = [𝑥 1 = (𝑡 1, 𝑙 1 ), ..., 𝑥𝑛 = (𝑡𝑛 , 𝑙𝑛 )]
𝑡𝑘 ∈ time (UNIX epoch)
𝑙𝑘 = (𝑙𝑘𝑙𝑎𝑡 , 𝑙𝑘𝑙𝑜𝑛 ) ∈ coordinate ((latitude, longtitude))
𝑡 1 and 𝑡𝑛 are determined as 𝑡𝑠𝑡𝑎𝑟𝑡 and 𝑡𝑒𝑛𝑑 considering conditions such as a lifespan of the virus.
Algorithm 1 shows the pseudo code of TrajectoryHash. This encoding is based on two encoding
QuadKeyEncode, PeriodicEncode and binary level mixing function, Mixing. ST-Hash [23] is
similar to our encoding. The part to be mixed at the binary level is the same, but each 2 encoding
methods and the motivation are different. We use QuadKeyEncode and PeriodicEncode to
preserve trajectory data similarity and hierarchical structure to compress the trajectories.
parameter 𝜃𝑔𝑒𝑜
20
19
18
17
16

distance
parameter 𝜃 𝑡𝑖𝑚𝑒
0.15 m
0.3 m
0.6 m
1.2 m
2.4 m

32
26
24
22

time
1s
1 min
4 min
17 min

Table 5. Approximately scale of parameter 𝜃 𝑡𝑖𝑚𝑒 .
Table 4. Approximately scale of parameter 𝜃𝑔𝑒𝑜 .

QuadKeyEncode is based on quadkey introduced by Bing Map [50], which is a method of
encoding into bits in the tile coordinate space, recursively dividing into two parts according to a given
level, as shown in Figure 4. Note that, in our method QuadKeyEncode outputs separated binaries.
As we can see in the figure, while we get "212"(=100110) using quadkey encoding, QuadKeyEncode
outputs 101 and 010. Detailed algorithm is described in Algorithm 1. The parameter 𝜃𝑔𝑒𝑜 and the
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

PCT-TEE: Trajectory-based Private Contact Tracing System with Trusted Execution Environment

111:13

Fig. 4. quadkey and QuadKeyEncode.

approximate distance included in the square in tile coordinates are shown in the table 4. For instance,
given 𝜃𝑔𝑒𝑜 = 16, (𝑙𝑙𝑜𝑛 , 𝑙𝑙𝑎𝑡 ) = (135.3214557, 30.4564223), we get the output 1110000000111010 and
0110100100111110 as binaries. Using this encoding, we get unique binaries for each distinguishable
area by 𝜃𝑔𝑒𝑜 . Moreover, we can keep hierarchical structure and similarity of trajectory locations
into binary representation.
PeriodicEncode is optimized to discretize the time data over a specific given period and at
specific given time intervals. This encoding outputs bits with minimum length that can express
a distinct time interval according to given 𝜃 𝑡𝑖𝑚𝑒 in the period 𝑡𝑠𝑡𝑎𝑟𝑡 to 𝑡𝑒𝑛𝑑 . Given 2 weeks as the
period, the relation between parameter 𝜃 𝑡𝑖𝑚𝑒 and the approximate time interval are shown in the
table 5. Final output length is determined by both 𝜃 𝑡𝑖𝑚𝑒 and (𝑡𝑠𝑡𝑎𝑟𝑡 , 𝑡𝑒𝑛𝑑 ). For example, given
(𝑡, 𝑡𝑠𝑡𝑎𝑟𝑡 , 𝑡𝑒𝑛𝑑 , 𝜃 𝑡𝑖𝑚𝑒 ) = (“2020/10/10 10 : 00”, “2020/10/05 00 : 00”, “2020/10/19 00 : 00”, 24)
then, detailed processing is as follows.
𝑡𝑒𝑛𝑑 − 𝑡𝑠𝑡𝑎𝑟𝑡 = 1603065600 − 1601856000 = 1209600
𝑚𝑎𝑥𝐿𝑒𝑛𝑔𝑡ℎ = 21 (1209600 < 221 = 2097152) (line 27)
𝑡𝑑𝑖 𝑓 𝑓 = 1602324000 − 1601856000 = 468000 (line 29)
𝑠ℎ𝑖 𝑓 𝑡 = 32 − 24 = 8 (line 30)
𝑡𝑑𝑖 𝑓 𝑓 = 468000/2 ∗ ∗8 = 1828 (line 31)
𝑏𝑖𝑛𝑎𝑟𝑦 = AsBinary(1828) = 11100100100 (line 32)
𝑏𝑖𝑛𝑎𝑟𝑦 = ZeroPadding(11100100100, 21 − 8) = 0011100100100 (line 33)

Finally, we can get 0011100100100 as a binary. In this way, we get minimum representation to
express trajectory time information and preserve time representation similarity of the trajectories
in the period while adjusting intervals to given granularity parameter 𝜃 𝑡𝑖𝑚𝑒
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111:14

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

Fig. 5. Geohash and previous periodical encoding.

Now, we have three binaries, like this longitude: 1110000000111010, latitude: 0110100100111110,
Periodic: 0011100100100. Note that if lengths of three binaries are different, we have to call ZeroPadding to make the same length because Base8Encode is encode to string by three bits.
However, zero padding does not become an issue. No matter how many such zero values, they are
likely one shared node in the FSA. So, periodic encoding is changed into 0000011100100100 (from
0011100100100) by ZeroPadding.
Next, we mix them into one binaries by Mixing (line 9). We consider there can be some variants,
mixing or simply merge without mixing. Plausible option is mixing one by one from each binaries
(mixTH) as shown in Figure 6. In this mixing, the 3D trajectory data is encoded like Figure 8, where
the 3D similarity of trajectory data is naturally preserved into the binaries in a balanced manner
for time and location. In addition, there may be cases where a different mixture is more desirable. It
depends on datasets. In some cases, it may be more compressible to merge periodic binaries behind
without mixing (seqTH), as showing Figure 7. For example, when people do not move so much
such as sleeping, a higher similarity than mixTH is expected to be obtained. Furthermore, because
there is no need for mixing, it eliminates the padding and minimize the number of bytes of the
periodic binaries.
In particular, we can regard our previous work [30] as a specific mixing where first we mix
latitude and longitude binaries and then we merge it and periodic strings without mixing as shown
Figure 12. We use geohash encoding [41] and more naive periodical encoding than this version
Figure 12 (b). However, the biggest difference is that we are assuming a binary-level merge in
TrajectoryHash, so we can minimize the size of the output. This is a big advantage in our system.
Lastly, we encode the binaries to string by Base8Encode for ease of transport. Base8Encode
simply generates a string by assigning one of 0-7 characters to every 3 bits (Figure 6). Although
using Base64 encoding looks more space efficient, when actually used in PCT, the data reverts to
binaries, and either way basically works. Here, we use Base8 for more flexibility with respect to the
length of the bytes.
6.2

Data structure

We explain that FSA satisfies our three requirements mentioned before. We can use FSA as a
deterministic acyclic finite state acceptor and it can store and compress string data, sharing string
prefixes and suffixes from the tree structure’s roots It also provides a fast string search as a dictionary
in proportion to the maximum depth. Moreover, the search cost can be O (1) if the maximum length
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

PCT-TEE: Trajectory-based Private Contact Tracing System with Trusted Execution Environment

111:15

Fig. 7. Sequential merge TrajectoryHash (seqTH).
Fig. 6. Mixing TrajectoryHash (mixTH).

Fig. 8. TrajectoryHash interpretation in the time-series map.

is small, which is asymptotically equivalent to the hash table and may be advantageous because it
does not need computing hash functions. Thus, it basically meets our requirements. [13] shows
its effectiveness by extensive experiments. Therefore, we increase the compression efficiency by
introducing FSA, and this data structure satisfies our requirements. Trie [20] also has similar
functions and it is conventionally used in trajectory data storage [33], however, FSA is better in
this case because of many shared node.
Figure 9 shows an example how well our encoding works with FSA. Assume that the TrajectoryHash encode trajectories like ’5660211300766360’, ’5660211300762760’, and ’5660211301043560’...,
which are generally similar sequence because of continuous trajectories. Actually, considering
trajectory data we collect from real world, time is continuously changing in small increments, and
location information is likely to be close or almost immobile. Therefore, encoded data is expected
to have much similarity like example data. Thus, FSA has much less data size than if we normally
hold the data using the hash table, etc.
6.3

Chunking

We have to consider the way to make chunked FSA. At step 2 of Figure 3, we transform raw data
into chunked FSA. Generally, chunking FSA is not a straightforward task, because compression
results depends on how to make small FSA or how to divide large FSA, which is different from the
hash table. Using the hash table, a performance does not depends on such a way because the data
size is determined by the number of stored data. However, we can solve this problem by simple
operation. Before constructing FSA, we sort raw data in numerical order and we iteratively take
𝑁𝐷 /𝑁𝑅 trajectory data from top to bottom and transform them into single FSA. By this operation,
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111:16

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

Algorithm 1 TrajectoryHash
Input: 𝑡,, (𝑙𝑙𝑎𝑡 , 𝑙𝑙𝑜𝑛 ), 𝜃 𝑡𝑖𝑚𝑒 , 𝜃𝑔𝑒𝑜 , 𝑡𝑠𝑡𝑎𝑟𝑡 , 𝑡𝑒𝑛𝑑
Output: ℎ𝑎𝑠ℎ
1: 𝑏 1, 𝑏 2 ← QuadKeyEncode(𝑙𝑙𝑎𝑡 , 𝑙𝑙𝑜𝑛 , 𝜃𝑔𝑒𝑜 )
⊲ 𝑏 1 , 𝑏 2 are binary sequence with 𝜃𝑔𝑒𝑜 length
2: 𝑏 3 ← PeriodicEncode(𝑡, 𝜃 𝑡𝑖𝑚𝑒 )
⊲ 𝑏 3 are binary sequence
3: if Length(𝑏 1 ) ≤ Length(𝑏 3 ) then
⊲ padding 0 to match the longer length
4:
𝑏 1 ← ZeroPadding(𝑏 1, Length(𝑏 3 ))
5:
𝑏 2 ← ZeroPadding(𝑏 2, Length(𝑏 3 ))
6: else
7:
𝑏 3 ← ZeroPadding(𝑏 3, Length(𝑏 1 ))
8: end if
9: 𝑏𝑖𝑛𝑎𝑟𝑦 ← Mixing(𝑏 1, 𝑏 2, 𝑏 3 )
10: ℎ𝑎𝑠ℎ ← Base8Encode(𝑏𝑖𝑛𝑎𝑟𝑦)
11: return ℎ𝑎𝑠ℎ
12: procedure QuadKeyEncode(𝑙𝑙𝑎𝑡 , 𝑙𝑙𝑜𝑛 , 𝜃𝑔𝑒𝑜 )
13:
𝑚𝑎𝑥𝐿𝑎𝑡𝑖𝑡𝑢𝑑𝑒 ← 360 arctan(exp(𝜋))/𝜋 − 90
⊲ ≃ 85.05112877980659
14:
𝑙𝑙𝑎𝑡 ← min(𝑚𝑎𝑥𝐿𝑎𝑡𝑖𝑡𝑢𝑑𝑒, max(−𝑚𝑎𝑥𝐿𝑎𝑡𝑖𝑡𝑢𝑑𝑒, 𝑙𝑙𝑎𝑡 ))
⊲ for clipping
𝑙𝑙𝑜𝑛 + 180
⊲ transform to the Tile Coordinates
15:
𝑝𝑥 ←
360
1 1

1 + sin (𝑙𝑙𝑎𝑡 × 𝜋/180)
16:
𝑝𝑦 ←
− log
2 𝜋
1 − sin (𝑙𝑙𝑎𝑡 × 𝜋/180)
17:
𝑚𝑎𝑝𝑆𝑖𝑧𝑒 ← 2𝜃𝑔𝑒𝑜
⊲ map consists of 2𝜃𝑔𝑒𝑜 × 2𝜃𝑔𝑒𝑜 areas
18:
𝑥 ← Floor(𝑝𝑥 × 𝑚𝑎𝑝𝑆𝑖𝑧𝑒)
⊲ round down function
19:
𝑦 ← Floor(𝑝𝑦 × 𝑚𝑎𝑝𝑆𝑖𝑧𝑒)
20:
𝑋𝑏𝑖𝑛𝑎𝑟𝑦 ← AsBinary(𝑥)
⊲ get as bit array representation
21:
𝑋𝑏𝑖𝑛𝑎𝑟𝑦 ← ZeroPadding(𝑋𝑏𝑖𝑛𝑎𝑟𝑦, 𝜃𝑔𝑒𝑜 )
⊲ padding 0 to 𝜃𝑔𝑒𝑜 length
22:
𝑌𝑏𝑖𝑛𝑎𝑟𝑦 ← AsBinary(𝑦)
23:
𝑌𝑏𝑖𝑛𝑎𝑟𝑦 ← ZeroPadding(𝑋𝑏𝑖𝑛𝑎𝑟𝑦, 𝜃𝑔𝑒𝑜 )
24:
return 𝑋𝑏𝑖𝑛𝑎𝑟𝑦, 𝑌𝑏𝑖𝑛𝑎𝑟𝑦
25: end procedure
26: procedure PeriodicEncode(𝑡, 𝑡𝑠𝑡𝑎𝑟𝑡 , 𝑡𝑒𝑛𝑑 , 𝜃 𝑡𝑖𝑚𝑒 )
27:
𝑚𝑎𝑥𝐿𝑒𝑛𝑔𝑡ℎ ← Length(AsBinary(𝑡𝑒𝑛𝑑 − 𝑡𝑠𝑡𝑎𝑟𝑡 ))
28:
⊲ maximum bit length to represent the period 𝑡𝑠𝑡𝑎𝑟𝑡 to 𝑡𝑒𝑛𝑑
29:
𝑡𝑑𝑖 𝑓 𝑓 ← 𝑡 − 𝑡𝑠𝑡𝑎𝑟𝑡
30:
𝑠ℎ𝑖 𝑓 𝑡 ← 32 − 𝜃 𝑡𝑖𝑚𝑒
⊲ 32 = max bit length of UNIX epoch
31:
𝑡𝑑𝑖 𝑓 𝑓 ← Floor(𝑡𝑑𝑖 𝑓 𝑓 /2𝑠ℎ𝑖 𝑓 𝑡 )
⊲ right shift 𝑡𝑑𝑖 𝑓 𝑓 >> 𝑠ℎ𝑖 𝑓 𝑡
32:
𝑏𝑖𝑛𝑎𝑟𝑦 ← AsBinary(𝑡𝑑𝑖 𝑓 𝑓 )
33:
𝑏𝑖𝑛𝑎𝑟𝑦 ← ZeroPadding(𝑏𝑖𝑛𝑎𝑟𝑦, 𝑚𝑎𝑥𝐿𝑒𝑛𝑔𝑡ℎ − 𝑠ℎ𝑖 𝑓 𝑡)
34:
return 𝑏𝑖𝑛𝑎𝑟𝑦
35: end procedure

we can stably construct compressive FSA representations because a chunk of data have much
similarity.
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

PCT-TEE: Trajectory-based Private Contact Tracing System with Trusted Execution Environment

111:17

Fig. 9. FSA with our encoding.

6.4

Discussion

In our system we introduce, 𝑅 is raw format, not encrypted, which is based on the consent of the
infected people. We think this setting has been acceptable in the society. However, we can consider
another model where we do not need the consent of the infected people,even though they are from
different parties that do not trust each other. Basically, this can be achieved without changing the
structure too much.
The people or health agency who register infected people’s data perform remote attestation for
untrusted server and send encrypted data to enclave. Using SGX Sealing capability [11, 28], we
securely encrypt and store enclave secrets for persistent storage to disk, using a private Seal Key
that is unique to the particular platform and enclave. While extra overhead is needed, we can keep
the data confidentiality and integrity. Even though we use this capability, the main bottleneck is
that we need to prepare the chunks in enclave because we have to capture what data each trajectory
data is to construct FSA. If the size of infected trajectories becomes large, this preparation can cause
too excessive workloads in enclave. Practically, it is difficult unless we propose a way to avoid the
bottleneck here. However, once chunks are prepared, sealed, and stored in untrused storage, we
can achieve the same performance through the same processing as raw data.
7
7.1

SYSTEM ANALYSIS
Algorithm Analysis

Here, we discuss asymptotic computational costs of PSI and precautions. We show our algorithm
of trajectory-based PCT related to the PSI part in Algorithm 2. Some of functions are described in
5. Dictionary 𝑟𝑖 must implement the contains method that returns a Boolean value whether it
includes the target or not. In the case of the hash table, it is the computation of the hash function,
and in the case of FSA, the acceptance routine with finite state automaton, both of them are
asymptotically constant. The computational costs of trajectory-based PCT are as follows. Assume
that the cost of a single key search for a dictionary is 𝑐 and the unique size of 𝑄 is 𝑁𝑄 , the calculation
cost is
𝑐 × 𝑁𝑅 × 𝑁𝑄 = O (𝑁𝑅 𝑁𝑄 )
Seemingly, 𝑁𝑄 and the number of chunks 𝑁𝑅 is constant and PSI is completely scalable for an
infected trajectory size. However, note that the size of 𝑁𝑅 depends on the memory constraints of
SGX. When processing thousands of queries together, exact 𝑞𝑖 (𝑖 = 1, ..., 𝑁𝐶 ) information needs to
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111:18

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

Algorithm 2 iterative PSI
Input: 𝑞𝑖 (𝑖 = 1, ..., 𝑛𝑐 ), 𝜃 = (𝜃𝑔𝑒𝑜 , 𝜃 𝑡𝑖𝑚𝑒 ), 𝑅 ← mapToChunkedDictionary(𝐷, 𝜃 )
⊲ 1, 2
Output: 𝑅𝑒𝑠𝑝𝑜𝑛𝑠𝑒𝑠
1: loadToEnclave(𝑞 1, ..., 𝑞 𝑁𝐶 )
⊲ 5 6
2: 𝑞 1, ..., 𝑞𝑛𝑐 ← decrypt(𝑞 1, ..., 𝑞𝑛𝑐 )
⊲ by AES-GCM etc. using shared key through RA
3: 𝑄 ← mapToUniqeArray(𝑞 1, ..., 𝑞 𝑁𝐶 , 𝜃 )
⊲ 6
4: 𝑅𝑒𝑠𝑢𝑙𝑡𝑠 ← {}
5: for 𝑟 𝑖 ← 𝑅 do
⊲ 7 𝑅 has 𝑁𝐷 chunks
6:
loadToEnclave(𝑟𝑖 )
⊲ iteratively load chunked data 𝑟𝑖
7:
for 𝑣𝑎𝑙𝑢𝑒 in 𝑄 do
⊲ 7 𝑄 is array with 𝑁𝑄 length
8:
if 𝑟𝑖 .contains(𝑣𝑎𝑙𝑢𝑒) then
9:
𝑅𝑒𝑠𝑢𝑙𝑡𝑠 ← 𝑅𝑒𝑠𝑢𝑙𝑡𝑠 ∪ 𝑣𝑎𝑙𝑢𝑒
10:
end if
11:
end for
12: end for
13: 𝑅𝑒𝑠𝑝𝑜𝑛𝑠𝑒𝑠 ← constructResponses(𝑞 1, ..., 𝑞 𝑁𝐶 , 𝑅𝑒𝑠𝑢𝑙𝑡𝑠)
⊲ 8
14: 𝑅𝑒𝑠𝑝𝑜𝑛𝑠𝑒𝑠 ← encrypt(𝑅𝑒𝑠𝑝𝑜𝑛𝑠𝑒𝑠)
15: 𝑅𝑒𝑠𝑝𝑜𝑛𝑠𝑒𝑠 ← loadFromEnclave(𝑅𝑒𝑠𝑝𝑜𝑛𝑠𝑒𝑠)
⊲ return encrypted data to untrusted area

be kept within the enclave to correctly reconstruct the response, which can be several tens of MB
in size; eventually, the size available for chunk 𝑟𝑖 is not large. This means that there is actually a
practical lower bound on 𝑁𝑅 . Lastly, our routine includes decrypt and encrypt. These encryptions
are implemented by fast and simple methods, such as 128bit AES-GCM, so that the execution time
is not dominant.
7.2

Requirements

Finally, we show how our system meets the requirements we mentioned first.
Efficiency. There are four points, Intel SGX, chunking, data representation, and query multiplexing. First, as described in Section 3, SGX bring us efficient PSI. SGX allows software to perform
secret computations transparently and eliminates the need for complicated and time-consuming
cryptographic techniques to perform PSI. This fact is the basis of the efficiency of our system. The
computational overhead is small and the overall speed is dramatically improved. Second, chunking,
𝑅 into 𝑟𝑖 (𝑖 = 1, ..., 𝑁𝐷 ), avoids serious paging overhead caused by severe memory constraints of
SGX even when the infected patients’ data become too large to fit into the enclave. Third, the
memory-efficient dictionary representation (Section 6) reduces the number of chunks, resulting
in reducing PSI execution and overheads for upload to enclave. This is core point of our system.
Fourth, steps 5 and 6 (Section 5) show query multiplexing and improve the throughput of the query
processing. Reading the chunked data 𝑟𝑖 , as in Step 7, is costly due to the 𝑁𝐷 iteration, and doing
this for every query have large overheads.
Security. Our protocol follows remote attestation and secure computation provided by Intel SGX.
Previous researches [4, 52] shows the protocol security. Informally, any state cannot be observed
from outside TEE, and even if any inputs, any tampering with the state that can be performed
by the malicious server will not divulge any information about the client trajectories. Hence, it is
guaranteed that all information attacker can observe is only outside TEE. However, in our system, all
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

PCT-TEE: Trajectory-based Private Contact Tracing System with Trusted Execution Environment

111:19

information observed outside TEE must be encrypted. Therefore, cryptographically strong security
for the client’s privacy from any external attacker is ensured when using proper encryption and
without software vulnerability. More formal definitions require elaborate modeling of the attacker
and private information, but our setting is common and we defer to the earlier work [4, 52]. Note
that some of side channel attacks are out of scope in their work and in our work. To protect such
attacks, we have to consider data-Obliviousness [2, 36] to change into uniform side channels.
Flexibility. We achieve flexibility by parametrizing the encoding of the data using a granularity
parameter 𝜃 . The parameter is shared between the server and clients. Once data is encoded by the
parameter, all we have to do is normal PSI. In other words, we parametrize not PSI routine but
target data by parametrized encoding. In this way, we have to update all the data when we want
to change the rules of risky contact. However, because we have to update all the data once a day
anyway, it is not a big deal. Thus, we can achieve this requirements keeping the processing so light
and efficient.
Accuracy. This is trivially achieved because our query-answer does not allow any probabilistic
answers.
8

EXPERIMENT

We conducted experiments using real trajectory data to demonstrate that the proposed architecture
for PCT can achieve high query throughput and expected properties.
Experimental setup. We use an HP Z2 SFF G4 Workstation, with 4-core 3.80 GHz Intel Xeon
E-2174G CPU (8 threads, with 8 MB cache), 64 GB RAM, and a 1 TB disk, which supports the SGX
instruction set and has 128 MB PRM (Processor Reserved Memory) in which 96 MB EPC is available
for user use. The host OS is Ubuntu 16.04 LTS, with Linux kernel 4.4.0-178. We use version 1.1.2 of
the Rust SGX SDK1 [63] which supports Intel SGX SDK v2.9.1, and Rust nightly-2020-04-07. Our
experimental implementation is available in Github2 .
8.1 Preliminary Experiments
Before experiment, as described in Section 3, we consider secure hardware-based PSI is much better
than cryptography-based PSI in efficiency. To show that, we compare both PSI executions in the
similar setting to our scenario. For fairness, we compare single end-to-end PSI query without multiplexing optimization described in Section 5. Our secure hardware-based approach implementation
is based on Intel SGX and simply uses hash table and perform PSI inside enclave, and OT-based
approach implementation 3 follows [46]. Table 6 describe the execution time comparison between
OT-based [46] and secure hardware (Intel SGX) -based PSI in balanced setting where we assume
only RA protocol is performed in advance and online phase includes client-side encryption and
decryption time. We change the set size 103 to 106 , and each data has 128bit. As shown in Table
6, Intel SGX can easily overcome the state-of-the-art method in balanced setting. In particular, at
105 106 the difference of execution time becomes significant because of the overhead of oblivious
transfer while SGX has scalability in this range of the sizes. Additionally, secure hardware substantially improves bandwidth. The communication cost of SGX is almost the same as original size
because the data we have to send is just encrypted data by symmetric-key like AES-128. Assuming
many clients, this is essential. Although the efficiency is better in the two aspects, what we should
also pay attention here is the last line in the Table. Despite using Intel SGX, the execution time is
so slow. This is because of the memory constraint of SGX. When 𝑁 = 5.0 × 106 (80 MB), trusted
1 https://github.com/apache/incubator-teaclave-sgx-sdk
2 https://github.com/ylab-public/PCT
3 https://github.com/osu-crypto/libPSI

J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111:20

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

size 𝑁 (bytes)
103 (16 KB)
104 (0.16 MB)
105 (1.6 MB)
106 (16 MB)
5.0 × 106 (80 MB)

Intel SGX
execution (ms) /
communication (MB)
38 / 0.016
52 / 0.16
153 / 1.6
1552 / 16
121526 / 80

OT [46]
execution (ms) /
communication (MB)
35 / 2
207 / 22
2389 / 235
27110 / 2482
154826 / 12502

Table 6. PSI comparison: cryptographiy-based vs secure-hardware-based; execution time (balanced)

size 𝑁 (bytes)

size 𝑛

216 (1 MB)
216 (1 MB)
220 (17 MB)
220 (17 MB)
224 (268 MB)
224 (268 MB)

5535
11041
5535
11041
5535
11041

Intel SGX
execution (ms) /
communication (MB)
77 / 0.089
73 / 0.17
72 / 0.089
85 / 0.17
249 / 0.089
424 / 0.17

(HE [9])
(600 / 2.6)
(1300 / 4.1)
(2200 / 5.6)
(4000 / 12.0)
(10600 / 11.0)
(16200 / 21.1)

Table 7. PSI comparison: cryptographiy-based vs secure-hardware-based; execution time (unbalanced)

enclave has to handle approximately 160 MB data which overflows beyond the memory limitation
(=96 MB). As a result, it causes a serious overhead.
Table 7 shows the results when using Intel SGX in unbalanced setting. We also show the results
of [9] as a reference value from their paper’s result, which is total execution time (sender online and
receiver enc. and dec.) of the best parameters and maximum multi-threading (≤ 64). These number
is the best of their implementation, but the table shows Intel SGX-based PSI is significantly fast and
efficient in unbalanced setting. Even though security model is more strict than [9] (semi-honest).
Secure hardware-based PSI is basically not affected by server-side data size 𝑁 as shown in Table 2.
However, when it is beyond the SGX memory constraint, the execution time becomes slow due to
paging overheads as shown at 𝑁 = 224 (268MB). In this case, the client size is so small, and less
paging is required and the impact looks smaller than the previous result.
In this way, we can achieve fast PSI by utilizing secure hardware. We expect cryptographybased methods will be gradually improved, however, it is unlikely it will catch up with the secure
hardware-based method in the near future. To deploy into a practical situation for private contact
tracing system, it is better to adopt secure hardware.
8.2

Experiments

Datasets. We conduct the experiments with a real dataset, including data on people’s trajectories
in specific regions of Japan available in JoRAS3 of The University of Tokyo. We use the people flow
dataset for Kinki and Tokyo in Japan to create our experimental dataset. We extract only the time
and coordinate information and create our dataset by applying the encoding described in Section 6.
3 http://www.csis.u-tokyo.ac.jp

J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

PCT-TEE: Trajectory-based Private Contact Tracing System with Trusted Execution Environment

name

parameter

original
th54
𝜃 = (18, 27)
th60
𝜃 = (20, 27)
gp10
𝜃 = (1440, 10)
sep54
𝜃 = (18, 27)

size

time

111:21

geo

24 bytes
7 bytes
32 s
0.6 × 0.6 m
8 bytes
32 s 0.15 × 0.15 m
14 bytes 1 min 0.6 × 1.0 m
6 bytes
32 s
0.6 × 0.6 m

Table 8. Encoding methods and properties.

We show the appropriateness of the scale of the experiment. Regarding the number of data
points, in a practical case, where Japan is considered as an example, the maximum number of new
infections in Japan as of July 25 was 981 per day, which means that the maximum number of new
infections is approximately 14 x 1000 = 14,000 in 2 weeks. If the trajectory data were collected
every 10 minutes, the total number of trajectory data would be 2.8 × 107 . Therefore, 107 -108 rows of
data are plausibly as large as the infected patient data in our experiment. And each clients has 1440
trajectories for 2 weeks. This number corresponds to the case in which trajectories were collected
every 14 minutes over 2 weeks.
Minimum trajectory data information that ID is eliminated consists of time, longitude and latitude.
Figure 10 shows such 3D trajectory data distribution of Kinki, the scatter is 100000 trajectory points
randomly sampled from one day datasets. We can see the trajectory has some patterns and biased
distribution, and hence expect to be compressed. Trajectories of Tokyo is shown in Figure 11, which
is clearly more dense.

Fig. 10. Trajectory distribution of Kinki.
Fig. 11. Tokyo.

Firstly, we show the compression results. In our method, trajectory data point is represented
as 1 string. Generally, the minimum size of trajectory data point has 24 bytes because datetime
information is 8 bytes and longitude and latitude are 8 bytes respectively. Table 8 shows name of
the encoding methods we use in experiments and relationship of parameter 𝜃 = (𝜃𝑔𝑒𝑜 , 𝜃 𝑡𝑖𝑚𝑒 ) and
granularity and byte size of single data in 2 weeks setting. th54 and th60 use TrajectoryHash with
shown parameters and gp10 (geohash and periodic) is our previous encoding [30] and sep54 use
sepTH described in Section 6.1 which merges without mixing binaries. As shown in the table, th54
and th60 and sep54 have higher accuracy in both time and geo scale than gp10. Figure 12 shows
compression results for 107 trajectory data of Kinki and Tokyo and Random data. The size is the
number of unique data in the encoded form to be a fair comparison of compression capacity. The
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111:22

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

Fig. 12. Data compression results.

Fig. 13. Chunked data size.

figure shows the size of hash table and FSA holding the same data encoded by abovementioned
encodings. Compared to Random data (right side), all encoding makes FSA smaller with real
trajectories. We can see that compared to gp10, the compression rate of TrahectoryHash looks
smaller. When using FSA, naive encoding is not such a problem because shared nodes are ignored.
On the other hand, as described in Section 6, because it is better for each data to have a smaller size,
we should use th54 or septh54 (Table 8). In both datasets of Kinki (left side) and Tokyo (middle),
TrajectoryHash-based method is the smallest data representation. Seemingly, septh54 has trade-offs
depending on datasets. th54 is better with 3D similarity and septh54 with 2D similarity. Relatively,
the distribution of Tokyo is denser than that of Kinki, which affects the compression rate. Overall,
TrajectoryHash has more impact on mapping single trajectory data compact than compressing
multiple FSA trajectories.
We actually handle more large data for server data. As mentioned in Section 6.3, before chunking,
we sort trajectories. Thus, when the data is more extensive, chunked data can be more compressible
because similar data are likely gathered. Figure 13 shows the chunked data size given each central
data size, and the band means deviations. Chunk size is fixed at 1000 × 104 , and the figure shows
that as the original data becomes larger, the compression rate of chunked data increases up to
approximately a certain value.
To work our system correctly, we have to determine the proper chunk size. Figure 14 shows PSI
execution time in different chunk size using gp10 and 107 data. Too small or large chunk size causes
severe overheads because of EPC limitation. From this observation, we can find the existence of
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

PCT-TEE: Trajectory-based Private Contact Tracing System with Trusted Execution Environment

111:23

an optimal chunk size. Eventually, in this setting, when the client size is 1000 3000, the optimal
chunk size is approximately 1.0 × 107 (= 27 MB) when using FSA. And approximately 2.0 × 106 (=
28 MB) when using hash table. Considering discussion in Section 7.1, this result is reasonable. This
is because the space used for query data in EPC is approximately 60 MB and the EPC limitation is
96 MB. For example, 2000 clients × 1440 data × 14 bytes = 40 MB, and some more space is needed.
Therefore, we can determine a chunk size by considering the client query size.

Fig. 14. Psi execution time for each chunk size with gp10 encoding. Hash table (left) and FSA (right)

Next, we show PSI throughput comparison in Figure 15. We compare th54 as our proposed
method with FSA (th54), our previous method (gp10), and the non-private fastest set intersection
(Plain), which is implemented by hash table. The difference between th54 and gp10 is mainly due
to the overhead of loading the data into enclave, therefore, more space-efficient data representation
is better. We fix client size and chunk size at 4000 and 1.0 × 107 respectively, and measure PSI
exefcution time for each central data size. In other words, the time it takes to process 4000 PSI
queries (each has 1440 trajectories). Looking the figure, firstly, a th54 is totally better than our
previous encoding gp10. Moreover, surprisingly, our proposed method performances are close to
non-private set intersection and within a single-digit difference. Therefore, the iteration overheads
are acceptable, and th54 improve the overheads by more compressive characteristic. But it’s not
that significant; the true advantage of th54 is next. Other computations that should be performed in
a trusted enclave include decryption, assemble multiple queries (step6 in Section 5), and encrypted
response construction. Figure 16 describes their total execution time. The above figures show the
results when server data size is fixed at 107 , and the below figures show the results when client
query size is fixed at 3000. The left side is about th54, and the right side is gp10. Overall, th54 (left)
is more efficient than gp10 (right). That is mainly due to the small size of each data by th54, rather
than to PSI’s speeding up. Large data cause overheads in decryption and assembly and any other
processing, especially inside enclave. So, because th54 has smaller bytes, as shown in Table 8, there
are such differences. In this way, th54 is more scalable for many clients. And lastly, we stress that
the overall execution time is totally kept low. The time needed to process 4,000 queries, including
each trajectory data, is only 2 seconds Generally, secure computations such as PSI take an order of
magnitude longer. However, our results show such a secure computation is feasible in practical
scale. In particular, we proposed a system specialized in private contact tracing for epidemics.
9
9.1

RELATED WORKS
Private Contact Tracing

There are DP3T [61] and similar schemes [5, 26, 47, 60], as shown in section ??, which are decentralized architectures using the device’s wireless signals. They are the most popular implementation
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111:24

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

Fig. 15. Psi execution time.

Fig. 16. th54 is left side and gp10 is right side.

methods so far. Our proposed system directly handle trajectory data in private manner to detect
indirect contacts. Reichert et al. [45] propose a setting similar to our study. They also show a
system for centralized contact tracing on a server using GPS data. Their method bases on standard
multiparty computation with ORAM, which they say underperforms in practical scenarios. [12, 34]
propose the use of more comprehensive data including more richer data such as users’ detailed
trajectory data. In this way, we can create datasets that are effective not only for contact tracing,
but also for a variety of other tasks, such as analyzing infection clusters.
We need to refer to the open source project SafeTrace (https://github.com/enigmampc/SafeTrace)
[16]. SafeTrace also uses TEE for secure computation for contact tracing. Their system is expected
to run on an instance of IBM Cloud, which is a very feasible approach. It does not focus on only
notification to users, but intend to provide data analysis platform on TEE. Our efficient private
contact tracing scheme on TEE is greatly inspired by their project.
J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

PCT-TEE: Trajectory-based Private Contact Tracing System with Trusted Execution Environment

111:25

Block-chain [3, 35] can also be used for contact tracing. It stores trajectory data in private and
verifiable manner. [35] discusses the feasibility to deploy blockchain-based data tracking solution.
In this thesis, we focus on how to provide the PCT functionality using given data, and how to
collect and store the data in private manner is addressed in the future work.
9.2

Trajectory data

Trajectory data consists of the record sets of location and time information. Our research is related
to trajectory data representation and compression. Quadkey [33, 50] we use in TrajectoryHash is
one of the encoding for geodata. Another popular encoding is geohash [41]. While both methods
use recursive bisection on longitude and latitude, the main difference is the encoding. Geohash
uses Base32 encoding, thus, it corresponds to decomposition into a matrix with 4 columns and
8 rows. However, quadkey is 2×2 matrix. Additionally, quadkey uses mercator projection and
hence tile coordinates. Quadkey is better in points that the obtained mesh is close to real world
squares, encoding granularity is more adjustable. A shortcoming is code size is larger than geohash.
However, if we use them as binaries, there is actually no big difference. Both methods are used and
applied in the literature [25, 38, 67] that focus on the location data and utilize their tree-structures
or proximity to have more utilities. However, we use mixing the time data in the encoding. ST-Hash
[23] is used to make spatiotemporal indexing for key-value stores. Although it also uses mixing
spatiotemporal data into single encoding as we do, inside encoding for both time and location
are different. In particular, our encoding is has more advantage when there is a specific period.
Moreover, the motivation is totally different, and we consider storing data as FSA for compression.
Another compression direction is variants of Douglas-Peucker that are route-wise compression.
The basic idea is reproduction by estimating the route from minimum points [51]. The compression
is performed by approximating the route information rather than the position information. [7]
shows the method that compress vehicle trajectories using the route information of road and maps.
REST [66] extracts important trajectory routes and compress trajectories using the route. Our
compression is based on the similarity of trajectory points. Therefore, it is orthogonal to these
compression methods. However, such a route-wise compression may not work well in contact
tracing, because it is not possible to tell whether or not they are really in contact just by intersecting.
To detect the contact, it is necessary to include some time information in the route information.
10

CONCLUSION

In this paper, we proposed a trajectory-based private contact tracing system using trusted hardware to control the spread of infectious diseases. We identified the problems of existing private
contact tracing systems, clarified the requirements for trajectory-based private contact tracing,
and presented a TEE-based architecture to achieve secure, efficient, flexible, and accurate contact
tracing. Our experimental results with real data suggested that our proposed system can work on
a realistic scale. We hope this study could stimulate different communities and help to develop
solutions to combat COVID-19 as soon as possible.
ACKNOWLEDGMENTS
This work is partially supported by JSPS KAKENHI Grant No. 17H06099, 18H04093, 19K20269,
JST/NSF Joint Research SICORP 20-201031504, and CCF-Tencent Open Fund WeBank Special Fund.
Additionally, this is joint research with CSIS, the University of Tokyo (No. 974) and used the
following data ID: 3000200800, 3038201000.

J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111:26

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

REFERENCES
[1] Roba Abbas and Katina Michael. 2020. COVID-19 contact trace app deployments: Learnings from Australia and
Singapore. IEEE Consumer Electronics Magazine 9, 5 (2020), 65–70.
[2] Adil Ahmad, Kyungtae Kim, Muhammad Ihsanulhaq Sarfaraz, and Byoungyoung Lee. 2018. OBLIVIATE: A Data
Oblivious Filesystem for Intel SGX.. In NDSS.
[3] Md Murshedul Arifeen, Abdullah Al Mamun, M Shamim Kaiser, and Mufti Mahmud. 2020. Blockchain-enable contact
tracing for preserving user privacy during COVID-19 outbreak. (2020).
[4] Raad Bahmani, Manuel Barbosa, Ferdinand Brasser, Bernardo Portela, Ahmad-Reza Sadeghi, Guillaume Scerri, and Bogdan Warinschi. 2017. Secure multiparty computation from SGX. In International Conference on Financial Cryptography
and Data Security. Springer, 477–497.
[5] Johannes K Becker, David Li, and David Starobinski. 2019. Tracking anonymized bluetooth devices. Proceedings on
Privacy Enhancing Technologies 2019, 3 (2019), 50–65.
[6] Samuel Brack, Leonie Reichert, and Björn Scheuermann. 2020. Decentralized Contact Tracing Using a DHT and Blind
Signatures. IACR Cryptol. ePrint Arch. 2020 (2020), 398.
[7] Chao Chen, Yan Ding, Xuefeng Xie, Shu Zhang, Zhu Wang, and Liang Feng. 2019. TrajCompressor: An online mapmatching-based trajectory compression framework leveraging vehicle heading direction and change. IEEE Transactions
on Intelligent Transportation Systems 21, 5 (2019), 2012–2028.
[8] Hao Chen, Zhicong Huang, Kim Laine, and Peter Rindal. 2018. Labeled PSI from fully homomorphic encryption with
malicious security. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security.
1223–1237.
[9] Hao Chen, Kim Laine, and Peter Rindal. 2017. Fast private set intersection from homomorphic encryption. In Proceedings
of the 2017 ACM SIGSAC Conference on Computer and Communications Security. 1243–1255.
[10] Hyunghoon Cho, Daphne Ippolito, and Yun William Yu. 2020. Contact tracing mobile apps for COVID-19: Privacy
considerations and related trade-offs. arXiv preprint arXiv:2003.11511 (2020).
[11] Victor Costan and Srinivas Devadas. 2016. Intel SGX Explained. IACR Cryptol. ePrint Arch. 2016, 86 (2016), 1–118.
[12] David Culler, Prabal Dutta, Gabe Fierro, Joseph E Gonzalez, Nathan Pemberton, Johann Schleier-Smith, Kalyanaraman
Shankari, Alvin Wan, and Thomas Zachariah. 2020. CoVista: A Unified View on Privacy Sensitive Mobile Contact
Tracing Effort. arXiv preprint arXiv:2005.13164 (2020).
[13] Jan Daciuk and Dawid Weiss. 2011. Smaller Representation of Finite State Automata. In Proceedings of the 16th
International Conference on Implementation and Application of Automata (Blois, France) (CIAA’11). Springer-Verlag,
Berlin, Heidelberg, 118–129.
[14] Emiliano De Cristofaro, Jihye Kim, and Gene Tsudik. 2010. Linear-complexity private set intersection protocols secure
in malicious model. In International Conference on the Theory and Application of Cryptology and Information Security.
Springer, 213–231.
[15] Daniel Demmler, Peter Rindal, Mike Rosulek, and Ni Trieu. 2018. PIR-PSI: scaling private contact discovery. Proceedings
on Privacy Enhancing Technologies 2018, 4 (2018), 159–178.
[16] enigma. 2020. https://www.enigma.co/products/.
[17] Brittany Falkers. 2020.
How COVID-19 cases are evolving, along with our understanding of the
virus. https://www.kgw.com/article/news/health/coronavirus/multnomah-co-top-health-official-talks-about-ourevolving-understanding-of-the-novel-coronavirus/283-f2deae47-ff37-4699-9b4b-12e0c522f03c.
[18] Luca Ferretti, Chris Wymant, Michelle Kendall, Lele Zhao, Anel Nurtay, Lucie Abeler-Dörner, Michael Parker, David
Bonsall, and Christophe Fraser. 2020. Quantifying SARS-CoV-2 transmission suggests epidemic control with digital
contact tracing. Science 368, 6491 (2020).
[19] Centers for Disease Control and Prevention. 2020. CDC updates COVID-19 transmission webpage to clarify information
about types of spread. https://www.cdc.gov/media/releases/2020/s0522-cdc-updates-covid-transmission.html.
[20] Edward Fredkin. 1960. Trie memory. Commun. ACM 3, 9 (1960), 490–499.
[21] Anders T Gjerdrum, Robert Pettersen, Håvard D Johansen, and Dag Johansen. 2017. Performance of Trusted Computing
in Cloud Infrastructures with Intel SGX.. In CLOSER. 668–675.
[22] Oded Goldreich. 2009. Foundations of cryptography: volume 2, basic applications. Cambridge university press.
[23] Xuefeng Guan, Cheng Bo, Zhenqiang Li, and Yaojin Yu. 2017. ST-hash: An efficient spatiotemporal index for massive
trajectory data in a NoSQL database. In 2017 25th International Conference on Geoinformatics. IEEE, 1–7.
[24] Shay Gueron. 2016. Memory encryption for general-purpose processors. IEEE Security & Privacy 14, 6 (2016), 54–62.
[25] Ning Guo, Wei Xiong, Ye Wu, Luo Chen, and Ning Jing. 2019. A geographic meshing and coding method based on
adaptive Hilbert-Geohash. IEEE Access 7 (2019), 39815–39825.
[26] Yaron Gvili. 2020. Security analysis of the covid-19 contact tracing specifications by apple inc. and google inc. IACR
Cryptol. ePrint Arch. 2020 (2020), 428.

J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

PCT-TEE: Trajectory-based Private Contact Tracing System with Trusted Execution Environment

111:27

[27] Yan Huang, David Evans, and Jonathan Katz. 2012. Private set intersection: Are garbled circuits better than custom
protocols?. In NDSS.
[28] Intel. 2016. Introduction to Intel® SGX Sealing. https://software.intel.com/content/www/us/en/develop/blogs/
introduction-to-intel-sgx-sealing.html.
[29] Christian S Jensen, Hua Lu, and Man Lung Yiu. 2009. Location privacy techniques in client-server architectures. In
Privacy in location-based applications. Springer, 31–58.
[30] Fumiyuki Kato, Yang Cao, and Masatoshi Yoshikawa. 2020. Secure and Efficient Trajectory-Based Contact Tracing
using Trusted Hardware. In Proceedings of the 7th international workshop on privacy and security of big data.
[31] Can Kockan, Kaiyuan Zhu, Natnatee Dokmai, Nikolai Karpov, M Oguzhan Kulekci, David P Woodruff, and S Cenk
Sahinalp. 2020. Sketching algorithms for genomic data analysis and querying in a secure enclave. Nature Methods 17,
3 (2020), 295–301.
[32] Kevin Lahey. 2020. Monitoring Intel SGX Enclaves. https://fortanix.com/blog/2020/02/monitoring-intel-sgx-enclaves/.
[33] DongWoo Lee and Steve HL Liang. 2011. Crowd-sourced carpool recommendation based on simple and efficient
trajectory grouping. In Proceedings of the 4th ACM SIGSPATIAL International Workshop on Computational Transportation
Science. 12–17.
[34] Y Luo, N Tang, G Li, W Li, T Zhao, and X Yu. 2020. DEEPEYE: a data science system for monitoring and exploring
COVID-19 data. IEEE Data Eng. Bull 12 (2020).
[35] Dounia Marbouh, Tayaba Abbasi, Fatema Maasmi, Ilhaam A Omar, Mazin S Debe, Khaled Salah, Raja Jayaraman, and
Samer Ellahham. 2020. Blockchain for COVID-19: Review, Opportunities, and a Trusted Tracking System. Arabian
Journal for Science and Engineering (2020), 1–17.
[36] Pratyush Mishra, Rishabh Poddar, Jerry Chen, Alessandro Chiesa, and Raluca Ada Popa. 2018. Oblix: An efficient
oblivious search index. In 2018 IEEE Symposium on Security and Privacy (SP). IEEE, 279–296.
[37] Payman Mohassel and Matthew Franklin. 2006. Efficiency tradeoffs for malicious two-party computation. In International Workshop on Public Key Cryptography. Springer, 458–473.
[38] Roger Moussalli, Mudhakar Srivatsa, and Sameh Asaad. 2015. Fast and flexible conversion of geohash codes to and
from latitude/longitude coordinates. In 2015 IEEE 23rd Annual International Symposium on Field-Programmable Custom
Computing Machines. IEEE, 179–186.
[39] Mirco Nanni, Gennady Andrienko, Chiara Boldrini, Francesco Bonchi, Ciro Cattuto, Francesca Chiaromonte, Giovanni
Comandé, Marco Conti, Mark Coté, Frank Dignum, et al. 2020. Give more data, awareness and control to individual
citizens, and they will help COVID-19 containment. arXiv preprint arXiv:2004.05222 (2020).
[40] Arvind Narayanan, Narendran Thiagarajan, Mugdha Lakhani, Michael Hamburg, Dan Boneh, et al. 2011. Location
privacy via private proximity testing.. In NDSS, Vol. 11.
[41] Gustavo Niemeyer. 2008. http://geohash.org/site/tips.html.
[42] Benny Pinkas, Thomas Schneider, and Michael Zohner. 2014. Faster Private Set Intersection Based on OT Extension.
In 23rd USENIX Security Symposium (USENIX Security 14). USENIX Association, San Diego, CA, 797–812. https:
//www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/pinkas
[43] Benny Pinkas, Thomas Schneider, and Michael Zohner. 2018. Scalable private set intersection based on OT extension.
ACM Transactions on Privacy and Security (TOPS) 21, 2 (2018), 1–35.
[44] Chuan Qin, Luoqi Zhou, Ziwei Hu, Shuoqi Zhang, Sheng Yang, Yu Tao, Cuihong Xie, Ke Ma, Ke Shang, Wei
Wang, and Dai-Shi Tian. 2020. Dysregulation of Immune Response in Patients With Coronavirus 2019 (COVID19) in Wuhan, China. Clinical Infectious Diseases 71, 15 (03 2020), 762–768. https://doi.org/10.1093/cid/ciaa248
arXiv:https://academic.oup.com/cid/article-pdf/71/15/762/33538038/ciaa248.pdf
[45] L. Reichert, Samuel Brack, and B. Scheuermann. 2020. Privacy-Preserving Contact Tracing of COVID-19 Patients.
IACR Cryptol. ePrint Arch. 2020 (2020), 375.
[46] Peter Rindal and Mike Rosulek. 2017. Malicious-secure private set intersection via dual execution. In Proceedings of the
2017 ACM SIGSAC Conference on Computer and Communications Security. 1229–1242.
[47] Ronald L Rivest, Jon Callas, Ran Canetti, Kevin Esvelt, Daniel Kahn Gillmor, Yael Tauman Kalai, Anna Lysyanskaya,
Adam Norige, Ramesh Raskar, Adi Shamir, et al. 2020. The PACT protocol specification. Private Automated Contact
Tracing Team, MIT, Cambridge, MA, USA, Tech. Rep. 0.1 (2020).
[48] Mohamed Sabt, Mohammed Achemlal, and Abdelmadjid Bouabdallah. 2015. Trusted execution environment: what it
is, and what it is not. In 2015 IEEE Trustcom/BigDataSE/ISPA, Vol. 1. IEEE, 57–64.
[49] Marcel Salathé, Christian L Althaus, Richard Neher, Silvia Stringhini, Emma Hodcroft, Jacques Fellay, Marcel Zwahlen,
Gabriela Senti, Manuel Battegay, Annelies Wilder-Smith, et al. 2020. COVID-19 epidemic in Switzerland: on the
importance of testing, contact tracing and isolation. Swiss medical weekly 150, 11-12 (2020), w20225.
[50] Joe Schwartz(Microsoft). 2018. Bing Maps Tile System. https://docs.microsoft.com/en-us/bingmaps/articles/bingmaps-tile-system.

J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

111:28

Fumiyuk Kato, Yang Cao, and Yoshikawa Masatoshi

[51] Renchu Song, Weiwei Sun, Baihua Zheng, and Yu Zheng. 2014. PRESS: A novel framework of trajectory compression
in road networks. arXiv preprint arXiv:1402.1546 (2014).
[52] Pramod Subramanyan, Rohit Sinha, Ilia Lebedev, Srinivas Devadas, and Sanjit A Seshia. 2017. A formal foundation for secure remote execution of enclaves. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and
Communications Security. 2435–2450.
[53] Meysam Taassori, Ali Shafiee, and Rajeev Balasubramonian. 2018. VAULT: Reducing paging overheads in SGX with
efficient integrity verification structures. In Proceedings of the Twenty-Third International Conference on Architectural
Support for Programming Languages and Operating Systems. 665–678.
[54] Sandeep Tamrakar, Jian Liu, Andrew Paverd, Jan-Erik Ekberg, Benny Pinkas, and N Asokan. 2017. The circle game:
Scalable private membership test using trusted hardware. In Proceedings of the 2017 ACM on Asia Conference on
Computer and Communications Security. 31–44.
[55] Qiang Tang. 2020. Privacy-preserving contact tracing: current solutions and open questions. arXiv preprint
arXiv:2004.06818 (2020).
[56] TCNCoalition. 2020. TCN. https://github.com/TCNCoalition/TCN.
[57] Rachael Thorneloe, Tracy Epton, Wendy Fynn, Michael Daly, Natalia Stanulewicz, Angelos Kassianos, Gillian W
Shorter, Sarah-Jane Moll, Miglena Campbell, Samantha Sodergren, et al. 2020. SCOPING REVIEW OF MOBILE PHONE
APP UPTAKE AND ENGAGEMENT TO INFORM DIGITAL CONTACT TRACING TOOLS FOR COVID-19. (2020).
[58] Hongliang Tian, Qiong Zhang, Shoumeng Yan, Alex Rudnitsky, Liron Shacham, Ron Yariv, and Noam Milshten. 2018.
Switchless calls made practical in intel SGX. In Proceedings of the 3rd Workshop on System Software for Trusted Execution.
22–27.
[59] The Japan Times. 2020. New WHO guidance calls for more evidence on airborne coronavirus transmission. https:
//www.japantimes.co.jp/news/2020/07/10/world/science-health-world/who-covid19-airborne-transmission/.
[60] Ni Trieu, Kareem Shehata, Prateek Saxena, Reza Shokri, and Dawn Song. 2020. Epione: Lightweight contact tracing
with strong privacy. arXiv preprint arXiv:2004.13293 (2020).
[61] Carmela Troncoso, Mathias Payer, Jean-Pierre Hubaux, Marcel Salathé, James Larus, Edouard Bugnion, Wouter Lueks,
Theresa Stadler, Apostolos Pyrgelis, Daniele Antonioli, et al. 2020. Decentralized privacy-preserving proximity tracing.
arXiv preprint arXiv:2005.12273 (2020).
[62] C Jason Wang, Chun Y Ng, and Robert H Brook. 2020. Response to COVID-19 in Taiwan: big data analytics, new
technology, and proactive testing. Jama 323, 14 (2020), 1341–1342.
[63] Huibo Wang, Pei Wang, Yu Ding, Mingshen Sun, Yiming Jing, Ran Duan, Long Li, Yulong Zhang, Tao Wei, and
Zhiqiang Lin. 2019. Towards memory safe enclave programming with rust-sgx. In Proceedings of the 2019 ACM SIGSAC
Conference on Computer and Communications Security. 2333–2350.
[64] HUMAN RIGHTS WATCH. 2020. Mobile Location Data and Covid-19: Q&A. https://www.hrw.org/news/2020/05/13/
mobile-location-data-and-covid-19-qa.
[65] Li Xiong, Cyrus Shahabi, Yanan Da, Ritesh Ahuja, Vicki Hertzberg, Lance Waller, Xiaoqian Jiang, and Amy Franklin.
2020. REACT: Real-Time Contact Tracing and Risk Monitoring Using Privacy-Enhanced Mobile Tracking. SIGSPATIAL
Special 12, 2 (Oct. 2020), 3–14. https://doi.org/10.1145/3431843.3431845
[66] Yan Zhao, Shuo Shang, Yu Wang, Bolong Zheng, Quoc Viet Hung Nguyen, and Kai Zheng. 2018. REST: A referencebased framework for spatio-temporal trajectory compression. In Proceedings of the 24th ACM SIGKDD International
Conference on Knowledge Discovery & Data Mining. 2797–2806.
[67] Yuchao Zhou, Suparna De, Wei Wang, Klaus Moessner, and Marimuthu S Palaniswami. 2017. Spatial indexing for data
searching in mobile sensing environments. Sensors 17, 6 (2017), 1427.

J. ACM, Vol. 37, No. 4, Article 111. Publication date: August 2020.

