arXiv:2009.14165v2 [cs.MM] 4 Nov 2020

Performance of AV1 Real-Time Mode
1st Ludovic Roux

2nd Alexandre Gouaillard

CoSMo Software
Singapore
ludovic.roux@cosmosoftware.io

CoSMo Software
Singapore
alex.gouaillard@cosmosoftware.io

Abstract—With COVID-19, the interest for digital interactions
has raised, putting in turn real-time (or low-latency) codecs into
a new light. Most of the codec research has been traditionally
focusing on coding efficiency, while very little literature exist on
real-time codecs. It is shown how the speed at which content
is made available impacts both latency and throughput. The
authors introduce a new test set up, integrating a paced reader,
which allows to run codec in the same condition as real-time
media capture. Quality measurements using VMAF, as well as
multiple speed measurements are made on encoding of HD and
full HD video sequences, both at 25 fps and 50 fps to compare
the respective performances of several implementations of the
H.264, H.265, VP8, VP9 and AV1 codecs.
Index Terms—Real-time video codecs, video encoding performance

I. I NTRODUCTION
A. Codec Use Cases
The term codec usually refers to algorithms that encode,
respectively decode, binary representation of media.
Currently there are arguably three major use cases for largescale codec usage:
•
•
•

encoding of original raw content, client side,
trans-coding of content, server-side,
decoding of content on the receiving side.

Codecs are usually evaluated based on coding efficiency [1]
[2], a.k.a compression/quality ratio achieved against run time.
Comparisons are made using the Bjøntegaard rate difference
(BD-rate) [3] [4] and multiple papers exist to guide researchers
choosing the most representative dataset, the most meaningful
metric, and the best representation of results [5].
For example, the Xiph.org Foundation has developed the
very extensive AreWeCompressedYet [6] automatic service
to enable comparisons between different implementations of
video codecs using various metrics.
With COVID-19 and the new normal, people have a new
appetite for more interactive uses of streaming, to get the
same experience and value they were enjoying in real-life.
Correspondingly, it has increased the demand for faster-thanlive streaming, “live” being 5 seconds behind real-time, to
reach the less-than 500 ms. level of latency where human interactions thrive. In parallel, the rise of cloud gaming, augmented
reality (AR) and virtual reality (VR) have been pushing video
codecs in the same direction, albeit with generated content
978-0-7381-2384-4/20/$31.00 ©2020 IEEE

instead of natural content and even higher expectation for
latency (150 ms. max) [7].
In this paper we focus on the specific use case of realtime consumption of media for interactive applications. This
use case puts a specific emphasis on latency, making coding
efficiency a secondary target.
B. Pre-Recorded Content Encoding
The encoding throughput is the total number of frames of
the input divided by the total duration of the encoding process.
The encoding latency is the time it takes for a single frame to
go through the encoding process.
When the content is readily available, the encoding process
can be distributed, reducing the encoding time. The total run
time used in coding efficiency computation includes both
latency and processing time, diluting out latency. Latency
should be reported separately to be comparable.
In Video-on-Demand (VOD), latency is usually negligible
for both encoder and decoder compared to the encoding
time. Latency is more than often not taken into account,
and the main parameter of the encoder will be the speed
(1 to 8), which represent a coding efficiency vs complexity
compromise. Implicitly, the quality follows the speed, although
not linearly.
As such, the delay or latency induced by the encoding
and decoding processes are almost never taken in account.
Actually, assuming latency is negligeable, and the entire media
is available, many encoders use a 2-pass approach to gain
more efficiency per file/movie. Netflix is known to pioneer
distributed “per-chunks,” “per-shots” techniques investing time
and resources in the encoding process in exchange for maximum efficiency [8].
The most recent codecs performance study [9] compared
libaom AV1 encoder against x265 and libvpx-vp9 using their
best quality mode and a two-pass compression.
C. Live Content Capture Speed
A big difference between recorded content and real-time
content is the speed at which frames become available and
corresponding impact on latency. For example, real-time or
live media needs to be encoded in one-pass and not in two
or more passes like algorithms focused on coding efficiency
would.

VMAF
100
80
60
40
20

MOS
5
4
3
2
1

ACR label
excellent
good
fair
poor
bad

Error visibility
Imperceptible
Perceptible error, not annoying
Visible error, slightly annoying
Visible error, annoying
Visible error, very annoying

TABLE I: Mapping of VMAF scores to MOS values

1) Real-time encoder cannot encode faster than real-time:
Even if the encoder was able to encode one frame at a time,
at a faster-than-real-time speed, you still need to wait on the
capturer to provide the next frame before the encoder can
process it.
2) Real-time encoder latency is correlated with buffer
depth: Let’s take the use case where you have a 60 frames
deep frame buffer. With live content, you need to wait until
those frames are generated before you can start any kind
of processing. At a capture rate of 30 fps, one must wait
2 seconds before the above buffer is ready to be used, even if
the encoder can then encode faster than 30 fps.
To be able to compare traditional codec (default settings),
and real-time modes of certain codecs implementation under
the same condition, we need to make sure that the frames are
being delivered to the encoder at real-time speed even if it is
pre-recorded content.

(a) Blue sky (BS25)

(b) Pedestrian area (PA25)

(c) Riverbed (RB25)

(d) Rush hour (RH25)

(e) Station2 (ST25)

(f) Sunflower (SF25)

(g) Tractor (TR25)

(h) Crowd run (CR50)

(i) Ducks take off (DT50)

(j) In to tree (IT50)

(k) Old town cross (OT50)

(l) Park joy (PJ50)

D. Codecs Performance in Real-Time Use Cases
The run time is latency plus encoding time, and the latency
is a function of both the depth of any frame buffer and the
constant capture rate. Increasing the frame rate reduces latency
but increases the work load. The easiest way to reduce the
latency is to reduce the size of the frame buffer, or to remove
the need for a frame buffer altogether.
This is not to be confused with encoders speed setting. Most
recent codecs design involves sub algorithms, referred to as
“tools.” Some tools are more demanding in term of complexity,
or latency than others, and not all have the same impact on
efficiency. As described in [10] figure 1, the motion estimation
is the dominant contributor to run time budget in encoding.
The speed settings maps to the choice of some specific
subset defining a certain trade off between coding efficiency
and encoding speed (possibly disregarding completely the
latency). Some other codecs also have an explicit real-time
mode, settings that relate to coding/efficiency – latency trade
off.
This comes at a cost in terms of coding efficiency, and
makes the real-time mode of codecs not directly comparable
with rate-compression graphs. There is no study to date about
how much coding efficiency you trade off for decreased
latency.
In this paper, we will concentrate on the real-time mode
of some of the encoder implementations for H.264 (AVC),
VP8, VP9, and AV1 which are all used in the webrtc.org code
today. An implementation of H.265 (HEVC) will be also used
for comparison.

Fig. 1: Snapshots of each video sequences

II. M ETHODOLOGY
A. Quality Metric
Compression can be objectively evaluated. Quality of video
frames can also be evaluated objectively, however it has been
shown that scores provided by objective metrics like PNSR
(Peak Signal to Noise Ratio) [11] poorly correlate with human
evaluation of image or video quality [12]. To address this
drawback, subjective metrics like VMAF (Video Multimethod
Assessment Fusion) [13], [14] were introduced. A recent

Filename
Blue sky
Pedestrian area
Riverbed
Rush hour
Station2
Sunflower
Tractor
Crowd run
Ducks take off
In to tree
Old town cross
Park joy

Short name
BS25
PA25
RB25
RH25
ST25
SF25
TR25
CR50
DT50
IT50
OT50
PJ50

fps
25
25
25
25
25
25
25
50
50
50
50
50

Duration
8.68 s.
15 s.
10 s.
20 s.
12.52 s.
20 s.
27.6 s.
10 s.
10 s.
10 s.
10 s.
10 s.

# frames
217
375
250
500
313
500
690
500
500
500
500
500

Content type
trees and sky
people walking
light reflection on waves, riverbed visible
cars in traffic
railway tracks and train
closeup on bee foraging sunflower
tractor plowing a field
people running
ducks taking off, waves on a lake
park, closeup on tree
city old centre
people running along a canal

Camera motion
slow motion
static
static
static
zoom out
slow motion
slow motion tracking, zoom in and zoom out
slow motion
static
zoom in to a tree
slow motion
motion tracking

TABLE II: List of 12 video sequences used in this study

study on the evaluation of objective video quality metrics
has demonstrated a good correlation between subjective scores
given by humans and VMAF scores [15]. We have followed
the latest trend in codec research and used VMAF in this study.
To give an interpretation of a VMAF score, one can relate
it to the typical Mean Opinion Score (MOS) value ranging
from 1 to 5. A very common rating scale for MOS is the
Absolute Category Rating (ACR) methodology [16]: “bad,”
“poor,” “fair,” “good” and “excellent.” VMAF gives a score in
the range [0, 100]. VMAF score 20 can be mapped to “bad,”
score 40 to “poor,” score 60 to “fair,” score 80 to “good,”
and score 100 to “excellent” [17]. Table I gives a synthetic
relationship between VMAF scores and MOS values.
B. Datasets
For easier comparison of results, we have used video
sequences having the same resolution, the same color space
and the same bit depth. Only the duration or the frame rate of
video sequences is different from one video to another.
We have focused on 1080p HD video. This is the resolution
recommended to compute VMAF scores using the default
model v0.6.1 [17]. Table II gives the list of the 12 videos
used in our study.
All the video sequences use YUV format, 8 bits depth and
are not compressed. They have been selected from the publicly available Xiph.org Video Test Media [derf’s collection]
dataset.1
There are two groups of videos: a group of 7 videos having
a frame rate of 25 fps, and a group of 5 videos with a frame
rate of 50 fps. Fig. 1 shows a snapshot of each video.
C. Video Codecs
We will compare the performance of eight encoders, namely
aomenc (default and real-time settings) and SvtAv1EncApp for
AV1, vpxenc for VP8 and VP9, x265 for HEVC, x264 and
h264enc for H.264, compiled in their real-time mode when
available, and using speed 8 when applicable, using various
bitrate targets.
Table III gives for each codec all the information needed to
reproduce the results: the version we have used, where to get
1 Xiph.org Video Test Media [derf’s collection] https://media.xiph.org/
video/derf/

their source code and which options we selected to compile
them.
To give an insight of encoding performance difference between real-time mode and non real-time mode,
only for AV1, we have compiled a second version
of AOM encoder aomenc compiled using the option
-DCONFIG_REALTIME_ONLY=0. We have selected speed
option --cpu-used=3.
For the real-time version of aomenc, we have selected
the highest speed option --cpu-used=8. We will refer to
aomenc in real-time mode as aomenc-rt (encoder called with
option --rt, and to aomenc not in real-time mode as aomencgood (encoder called with good quality option --good).
We also selected the highest speed option --preset 8
for SVT-AV1.
We selected the setting --preset superfast for x265,
and the setting --preset medium for x264. In both case,
it was enough to reach the max 50 fps target.
The options used at run time to launch each codec are given
in Table IV.
Compilation of encoders and encoding of videos have been
performed on a Dell™ OptiPlex 5050 with processor Intel®
Core™ i7-7700T 8 cores at 2.90 GHz and 16 GB memory
running Ubuntu Desktop 20.04.1 64 bits operating system.
D. Real-Time Encoding Evaluation Process
The evaluation of a video encoder is usually performed by
letting the encoder to read a video file to be encoded. This
is not a realistic mode of operation for real-time where the
frames to be encoded are only available after some delay. For
example, when encoding frames received from a camera at a
rate of 25 fps, each new frame is available only after a delay
of 1/25 second, that is 40 ms. Even if the encoder is able to
encode a frame in 5 ms, it has to wait until the next frame
becomes available. We are starving the encoder.
To evaluate the encoders in a more realistic process, we
introduce a pacer program between the video file and the
encoder (see Fig. 2). The objective of the pacer is to deliver
frames to the encoder only at a selected frame rate.
A raw video file to be encoded is read by the pacer program.
The pacer is in charge of simulating the real-time delivery of
images at a selected rate. When the pacer reads frames from
a 25 fps video file, it outputs a frame every 1/25th second.

Codec
AV1

Encoder and version
libaom 2.0.0

Source code
https://aomedia.googlesource.com/aom/

AV1
VP8, VP9

SVT-AV1 0.8.4
libvpx 1.9.0

https://github.com/OpenVisualCloud/SVT-AV1
https://chromium.googlesource.com/webm/libvpx

H.265
H.264
H.264

x265 release 3.5
x264 stable cde9a933
openh264 2.1.1

https://github.com/videolan/x265
https://code.videolan.org/videolan/x264
https://github.com/cisco/openh264

Configuration options
cmake -DCMAKE_BUILD_TYPE=Release
-DCONFIG_MULTITHREAD=1 -DCONFIG_PIC=1
-DCONFIG_REALTIME_ONLY=1
-DCONFIG_RUNTIME_CPU_DETECT=1
-DCONFIG_WEBM_IO=0
build.sh release
configure --enable-pic
--enable-realtime-only
--enable-multi-res-encoding
--disable-debug --cpu=x86-64
cmake -DCMAKE_BUILD_TYPE=Release
make
make OS=linux ARCH=x86_64

TABLE III: Video encoders used in this study
Codec
aomenc rt

aomenc good

SVT-AV1

VP8

VP9

x265
x264
openh264

Encoder command options
aomenc --codec=av1 --profile=0 --kf-max-dist=90000 --end-usage=cbr --min-q=1 --max-q=63
--undershoot-pct=50 --overshoot-pct=50 --buf-sz=1000 --buf-initial-sz=500 --buf-optimal-sz=600
--max-intra-rate=300 --passes=1 --rt --lag-in-frames=0 --error-resilient=0 --tile-columns=0
--aq-mode=3 --enable-obmc=0 --enable-global-motion=0 --enable-warped-motion=0 --deltaq-mode=0
--enable-tpl-model=0 --mode-cost-upd-freq=2 --coeff-cost-upd-freq=2 --enable-ref-frame-mvs=0
--mv-cost-upd-freq=3 --enable-order-hint=0 --cpu-used=8 --threads=8 --end-usage=cbr
--target-bitrate=xxx --fps=25/1
aomenc --codec=av1 --good --passes=1 --cpu-used=3 --threads=8 --lag-in-frames=25 --min-q=0
--max-q=63 --auto-alt-ref=1 --kf-max-dist=150 --kf-min-dist=0 --drop-frame=0 --static-thresh=0
--arnr-maxframes=7 --arnr-strength=5 --sharpness=0 --undershoot-pct=100 --overshoot-pct=100
--frame-parallel=0 --tile-columns=0 --profile=0 --target-bitrate=xxx --fps=25/1
SvtAv1EncApp --tbr xxx --fps 25 --preset 8 --pred-struct 0 --profile 0 --rc 2 --min-qp 1
--max-qp 63 --vbv-bufsize 1 --tile-columns 0 --enable-global-motion 1 --enable-local-warp 0
--adaptive-quantization 0
vpxenc --codec=vp8 --lag-in-frames=0 --error-resilient=0 --kf-max-dist=90000 --static-thresh=0
--end-usage=cbr --undershoot-pct=50 --overshoot-pct=50 --buf-sz=1000 --buf-initial-sz=500
--buf-optimal-sz=600 --max-intra-rate=300 --resize-allowed=0 --drop-frame=0 --passes=1 --rt
--noise-sensitivity=0 --cpu-used=-6 --threads=8 --min-q=1 --max-q=63 --screen-content-mode=0
--target-bitrate=xxx --fps=25/1
vpxenc --codec=vp9 --lag-in-frames=0 --error-resilient=0 --kf-max-dist=90000 --static-thresh=0
--end-usage=cbr --undershoot-pct=50 --overshoot-pct=50 --buf-sz=1000 --buf-initial-sz=500
--buf-optimal-sz=600 --max-intra-rate=300 --resize-allowed=0 --drop-frame=0 --passes=1
--rt --noise-sensitivity=0 --cpu-used=7 --threads=8 --profile=0 --min-q=1 --max-q=63
--tile-columns=0 --aq-mode=3 --target-bitrate=xxx --fps=25/1
x265 --frame-threads 0 --preset superfast --bitrate xxx --fps 25
x264 --preset medium --bitrate xxx --fps 25 --demuxer raw
h264enc -rc 0 -complexity 2 -denois 0 -scene 0 -bgd 0 -fs 0 -numl 1 -tarb 0 xxx -frout 0 25

TABLE IV: Options used for encoders at run time (encoding has been performed at ten target bitrates: 800, 900, 1000, 1250,
1500, 1750, 2000, 2500, 5000 and 10000 kbps)

For a 50 fps video file, the pacer will output a frame every
1/50th second. Frames delivered by the pacer at the selected
rate are written to a Unix pipe. The video encoder being tested
reads frames from the Unix pipe. The output of the encoder is
a bitstream corresponding to the encoded video file. At last,
we evaluate the quality of the encoded video by using VMAF
video quality assessment tool.
III. R ESULTS AND A NALYSIS
We measured the VMAF scores for each encoder at ten
different target bitrates: 800, 900, 1000, 1250, 1500, 1750,
2000, 2500, 5000 and 10000 kbps (see VMAF graphs in
Figures 4a to 4l), and computed the BD-rates from the VMAF
curves according to bitrate (see Tables V and VI).
A. Pacer: Latency Impact of Real-Time Streams
We measured the encoding throughput first without using
the pacer (the encoder reads the frames directly from the video

Video
BS25
PA25
RB25
RH25
ST25
SF25
TR25
Avg 25
CR50
DT50
IT50
OT50
PJ50
Avg 50

openh264
−61.43
−56.12
−52.39
−50.78
−47.44
−65.01
−68.18
−57.34
−61.73
−66.20
−68.62
−62.80
−62.98
−64.47

x264
−12.70
−22.39
−42.83
−26.08
−6.58
−2.26
−15.59
−18.35
−24.24
−21.68
−20.14
−18.55
−6.03
−18.13

VP8
−39.29
−40.35
−32.72
−31.52
−33.41
−26.04
−25.96
−32.76
−41.74
−34.05
−40.96
−56.18
−34.54
−41.49

VP9
−9.49
−10.91
−4.03
−6.93
−16.50
−15.69
−1.16
−9.24
−13.63
−15.33
−8.31
−14.95
−13.78
−13.20

x265
7.63
16.10
−0.97
16.22
40.99
34.49
20.84
19.33
−1.65
22.54
7.52
12.56
14.10
11.01

SVT
3.61
28.94
17.38
18.74
33.33
34.65
31.39
24.01
8.90
39.03
19.98
22.24
39.18
25.87

TABLE V: BD-rate for aomenc-rt8 (Note: SVT = SVT-AV1)

file), which, supposing the encoding speed is limited by the
encoder but not by the I/O speed, provides the maximum speed
at which the encoder can operate given the input content,

(a) Average encoding speed of the (b) Average encoding speed of the
seven 25 fps videos without pacer five 50 fps videos without pacer

Fig. 2: Evaluation of video encoder in real-time mode
Video
BS25
PA25
RB25
RH25
ST25
SF25
TR25
Avg 25
CR50
DT50
IT50
OT50
PJ50
Avg 50

openh264
12.61
14.70
24.88
10.59
8.63
12.11
23.35
15.27
24.60
25.06
21.77
14.64
21.70
21.55

x264
1.36
4.41
14.91
4.51
0.61
0.34
3.75
4.27
8.06
5.81
5.02
3.03
1.75
4.73

VP8
3.90
6.62
13.17
4.30
3.98
2.88
4.14
5.57
12.78
9.99
4.85
7.11
8.33
8.61

VP9
0.96
1.76
1.21
0.82
1.14
1.10
0.14
1.02
3.94
3.72
1.44
1.47
3.51
2.82

x265
−0.55
−2.09
0.35
−1.64
−1.79
−1.54
−3.20
−1.49
0.44
−4.27
−1.21
−1.03
−2.81
−1.78

SVT
−0.31
−3.39
−4.36
−1.84
−1.76
−1.52
−4.62
−2.54
−2.06
−6.82
−2.90
−1.67
−7.17
−4.12

TABLE VI: BD-VMAF for aomenc-rt8 (Note: SVT = SVTAV1)

the bitrate target, and the hardware. We then measured the
throughput using the pacer.
Fig. 3a and 3b show the encoding throughput achieved by
the encoders when they are not limited by the pacer. At the
threshold bitrate of 2500 kbps or less, all the encoders are
able to deliver 25 fps or more on our test computer. except
SVT-AV1 which at best reach only 5.3 fps.
It is interesting to note that, when requested to encode for
a rate of 50 fps instead of 25 fps, all the encoders perform their
compression faster, although three of the five videos in the
50 fps group are rather difficult to be encoded. This increase
in compression speed allows x264 and x265 to reach 50 fps at
the threshold bitrate of 2500 kbps, while VP9 and aomenc-rt
are not able to deliver more than 30 fps.
Generally, the encoders work at a more homogeneous speed
at higher bitrates as shown by the shorter standard deviation
bars, while the measured frame rate varies much more for
lower bitrates. In fact, at low bitrates, the encoders process
videos easy to encode (Blue-sky, Pedestrian-area, Rush-hour,
Station2, Sunflower, Tractor, In-to-tree, Old-town0cross) much
faster than videos harder to encode (Riverbed, Crowd-run,
Ducks-take-off, Park-run).

(c) Average encoding speed of the (d) Average encoding speed of the
seven 25 fps videos with pacer
five 50 fps videos with pacer

Fig. 3: Average encoding speed of 1080p videos on a Dell™
OptiPlex 5050 with processor Intel® Core™ i7-7700T 8 cores
at 2.90 GHz and 16 GB memory running Ubuntu Desktop
20.04.1 64 bits operating system.

Apart from the settings, this is the conditions under which
most codec studies are being done, and performances reported.
One can see that in the case of x264 and x265, the latency
is the bottleneck of the throughput and not the encoding speed
as it can encode 50 fps media content faster than 25 fps.
Supposing a constant I/O speed, reading a frame (latency) is
constant whether the media content is originally captured at
25 or 50 fps, however, the complexity (linear to the number
of pixels to encode) per second is twice as much.
This is the opposite for libvpx, for which we can clearly see
that encoding 50 fps content is slower than encoding 25 fps
whether with VP8 or VP9.
Introducing the pacer, we measured the frame rates as shown
in Fig. 3c and 3d.
All the encoders which could deliver more than 25 fps in
the previous experiment have no problem delivering with a
paced input. SVT-AV1 remains way too slow for real-time.
All the encoders which could deliver more than 50fps in
the previous experiment, like VP8 and x264 here again have
no problem. Interestingly x265 is performing extremely well.
It is also interesting to note that aomenc-rt is slightly faster
than VP9, while one would expect the opposite. Right now
we can conclude that there is no CPU penalty when moving
from using VP9 to using AV1 real-time.
B. Interpretation of BD-rate and BD-VMAF
A BD-rate is a measure of the average percentage bitrate
savings that can be obtained for the same visual quality level.
This measure is computed over the range of quality levels that
are common to two curves.

For example, let consider VMAF scores on Fig. 4i for
Ducks-take-off (DT50) video. We want to compute the bitrate
savings at same VMAF level of aomenc-rt8 (blue curve,
VMAF range from 27 to 61) as compared to x264 (orange
curve, VMAF range from 6 to 55). The common VMAF range
for these two curves is 27 to 55. Using that common quality
range, we compute the average bitrate savings by calculating
the area between the curves (to the left of the x264 orange
curve and to the right of the aomenc-rt8 blue curve), and we
divide it by the area to the left of the aomenc-rt8 blue curve
up to the right of the y-axis. We get a BD-rate of −21.68
as shown in Table V. It is a negative value, which means
that there is a reduction in bitrate for aomenc-rt8 as compared
to x264. The interpretation of this value is that for the same
VMAF score, we may expect that aomenc-rt8 gives in average
a 21.68% bitrate savings as compared to x264.
Similarly, we can compute the average visual quality improvement for the same bitrate between aomenc-rt8 and x264
by switching the variables. Using the same example, we look
for the common bitrate range between aomenc-rt8 (blue curve,
bitrate range from 2160 to 9925 kbps) and x264 (orange
curve, bitrate range from 810 to 10000 kbps). The common
bitrate range for these two curves is 2160 to 9925 kbps. Using
that common bitrate range, we compute the average VMAF
improvement by calculating the area between the curves (to
the bottom of aomenc-rt8 blue curve and to the top of x264
orange curve), and we divide it by the area to the bottom of
the x264 orange curve down to the top of the x-axis. We get
a BD-VMAF of 5.81 as shown in Table VI. It is a positive
value, which means that there is an increase in VMAF score
for aomenc-rt8 as compared to x264. The interpretation of this
value is that for the same bitrate, we may expect that aomencrt8 gives in average a VMAF score 5.81 points higher than
x264.

to encode this video at the threshold bitrate of 2500 kbps.
The lowest bitrate delivered by openh264 for Riverbed is
3760 kbps, while it is 3460 kbps for VP8. VMAF rating at
the threshold bitrate is only between 30 and 50, which is poor
quality.
2) 50 fps datasets: The group of 50 fps videos was more
difficult to encode with good quality than the group of 25 fps
videos. Ducks-take-off was the most challenging video to
be encoded. Interestingly, like Riverbed, it is a static video
showing water with waves.
At the threshold bitrate of 2500 kbps, VMAf score is lower
than 80 for the videos in the group of 50 fps, except for video
Old-town-cross which has a very slow motion.
We notice again that openh264 provides noticeable lower
VMAF scores than the other encoders. There are three videos,
Crowd-run, Ducks-take-off and Park-joy, which encoders
openh264 and VP8 are unable to encode at the threshold bitrate
of 2500 kbps. They would require a target bitrate of 6000 kbps
or more.
The other encoders, aomenc-rt8, SVT-AV1, x265, x264 and
VP9, are able to encode all the twelve videos with a rather
similar quality. The quality of videos encoded by SVT-AV1 is
always the best, x265 comes second and aomenc-rt8 is third.
From Table VI giving BD-VMAF for aomenc-rt8, we can
get the ranking of the encoders relatively to aomenc-rt8. We
can see that for the same bitrate, VMAF score of SVT-AV1
> x265 > aomenc-rt8 > VP9 > x264 > VP8 > openh264.
Among the two encoders studied for AV1, SVT-AV1 provides a much better coding efficiency than aomenc-rt real-time.
However, SVT-AV1 is lacking an efficient real-time mode. It
took SVT-AV1 about 7 times as long as aomenc-rt to encode
the same video clips, although both were run using the same
speed of 8.
IV. CONCLUSION

C. Discussion
VMAF scores are reported in Fig. 4a to 4l. We have
highlighted a threshold of 2500 kbps for bitrate as this
value is known to be a hard-coded maximum for WebRTC
within Chromium browser, although native applications using
WebRTC are not concerned by such a limitation.
1) 25 fps datasets: VMAF scores show that all the videos
of the 25 fps group except Riverbed are relatively easy to
encode. The curves are close or very close to the perfect score
of 100 for most bitrates. It is only at low bitrate of roughly
1000 kbps or lower that VMAF score gets lower than 80.
The quality of videos encoded by openh264 is worsening at
higher bitrates and faster than for the other encoders. VP8 is
also showing a slightly lower quality of videos than the other
encoders. At the threshold of 2500 kbps bitrate, the quality
of encoded videos is excellent or good, above VMAF score
of 80.
Riverbed is the only video of the 25 fps group being difficult
to be encoded with good quality. Although this video is static,
waves on surface of water and reflection of light on the waves
are challenging for encoders. Openh264 and VP8 are not able

A. Latency
Pre-recorded content provide encoders with the capacity
to fill up buffers to increase the coding efficiency without
increasing the latency too much. The same buffers which are
filled at I/O speed for pre-recorded content need to wait for
frame to be acquired in live, real-time and interactive use case,
making any operation that requires frame buffers prohibitive.
Very often, benchmarks are only provided for pre-recorded
content, and cannot be directly translated into the real-time
configuration. One of the contribution of this paper is a process
to compute fair performance comparison of encoders in a
real-time situation, while still using standard files as input.
We think it’s going to help extend existing test beds to be
able to better assess performances of all codecs in what has
become a much more important use case.
B. Coding Efficiency
It is outside the scope of this paper, but it is interesting to
note that SVT-AV1 at speed 8 has a coding efficiency similar
or better than aomenc-good at speed 3.

(a) Blue sky (25 fps) BS25

(b) Pedestrian area (25 fps) PA25

(c) Riverbed (25 fps) RB25

(d) Rush hour (25 fps) RH25

(e) Station2 (25 fps) ST25

(f) Sunflower (25 fps) SF25

(g) Tractor (25 fps) TR25

(h) Crowd run (50 fps) CR50

(i) Ducks take off (50 fps) DT50

(j) In to tree (50 fps) IT50

(k) Old town cross (50 fps) OT50

(l) Park joy (50 fps) PJ50

Fig. 4: VMAF scores according to bitrate

The non-realtime version of aomenc has a better coding
efficiency than the real-time version. The real-time version of
AOM seems to be about 33% less efficient. While theoretically
interesting, this has but little practical interest, since the default
aomenc encoder, even at its maximum setting of speed 6 will
have too much latency to be used in interactive case. The
interesting question is: what do I gain or lose when switching
from one real-time codec to another, and which ones can
achieve the lowest latency.
We find that the real-time modes of the codecs are generally
performing relatively to each other as they would with their
non real-time version, i.e AV1 better than VP9 better than
VP8, and HEVC better than AVC. The exception is HEVC
which has a better coding efficiency than aomenc-rt real-time,
while in the non-real time mode, it is aomenc that is reported
to have a better coding efficency than HEVC [9].
x265 exhibited excellent coding efficiency. It is able to
encode 1080p videos in real-time at 50 fps. It looks like its
speed settings has also very good (low) latency. The authors
regret that the licensing situation of HEVC is still complicated.
We have shown that one can expect an average of 11% less
bandwidth usage for the same video quality with aomenc-rt
than with VP9-rt, 37% less than with VP8.
The x264 implementation of H.264 is more or less often in
par with VP8 for quality, while the openh264 implementation
of H.264 exhibits generally lower coding efficiency on the
12 video clips of this study. This illustrates that encoder
implementations of the same codec can vary a lot in quality,
and one should compare implementations and not codecs
directly.
Codec implementations improve with time, so it is likely
that the sitll young implementation of AV1 codecs will improve with time.
V. F UTURE W ORK
This is the first attempt at comparing several real-time versions of encoders, so there is a lot of room for improvement.
One obvious way to improve the results is to test on more
datasets, which could e.g. include different types of content
(high-motion videos, animation, live video games), different
resolutions (480p a.k.a. DVD size, 4k, 8k). We think there is
still a lot of work to be done to directly measure latency of
encoders.
There are many more implementation of codecs out there,
and testing different implementations, including hardware implementation would add significant value for readers.
ACKNOWLEDGEMENT
The authors would like to thank Andrew Johnson, CTO of
Nira Inc., Ioannis Katsavounidis from Netflix, and Google
collaborators (Marco Paniconi, Fyodor Kyslov, Michael
Horowitz, Yaowu Xu, Jerome Jiang, Danil Chapovalov, ...)
for their valuable help, suggestions and comments.

R EFERENCES

[1] J. De Cock, A. Mavlankar, A. Moorthy, and A. Aaron, “A large-scale
video codec comparison of x264, x265 and libvpx for practical VOD
applications,” in Applications of Digital Image Processing XXXIX, vol.
SPIE 9971, September 2016.
[2] P. Akyazi and T. Ebrahimi, “Comparison of compression efficiency
between HEVC/H.265, VP9 and AV1 based on subjective quality
assessments,” in International Conference on Quality of Multimedia
Experience (QoMEX), May 2018.
[3] G. Bjøntegaard, “Calculation of average PSNR differences between
RD-curves,” VCEG-M33, ITU-T SG16/Q6, Tech. Rep., June 2001.
[Online]. Available: http://wftp3.itu.int/av-arch/video-site/0104 Aus/
[4] ——, “Improvements of the BD-PSNR model,” VCEG-AI11, ITUT SG16/Q6, Tech. Rep., July 2008. [Online]. Available: http:
//wftp3.itu.int/av-arch/video-site/0807 Ber/
[5] T. Daede, A. Norkin, and I. Brailovskiy, “Video codec testing and
quality measurement,” IETF, Tech. Rep., January 2020. [Online].
Available: https://tools.ietf.org/id/draft-ietf-netvc-testing-09.txt
[6] xiph.org. AreWeCompressedYet. [Online]. Available: https://wiki.xiph.
org/AreWeCompressedYet
[7] J.
Uberti.
Low
latency
video
streaming.
Google.
[Online].
Available:
https://www.ietf.org/proceedings/105/slides/
slides-105-mops-low-latency-video-streaming-00
[8] Netflix.
(2018,
Mars)
Dynamic
optimizer
—
a
perceptual
video
encoding
optimization
framework.
[Online].
Available:
https://netflixtechblog.com/
dynamic-optimizer-a-perceptual-video-encoding-optimization-framework-e19f1e3a277
[9] Y. Chen, D. Mukherjee, J. Han, A. Grange, Y. Xu, S. Parker, C. Chen,
H. Su, U. Joshi, C.-H. Chiang, Y. Wang, P. Wilkins, J. Bankoski,
L. Trudeau, N. Egge, J.-M. Valin, T. Davies, S. Midtskogen, A. Norkin,
P. de Rivaz, and Z. Liu, “An overview of coding tools in AV1: the first
video codec from the Alliance for Open Media,” APSIPA Transactions
on Signal and Information Processing, vol. 9, February 2020.
[10] K. Yu, J. Lu, J. Li, and S. Li, “Practical real-time video codec for mobile
devices,” in International Conference on Multimedia and Expo (ICME).
IEEE, July 2003, pp. 509–512.
[11] American National Standards Institute, Objective video quality measurement using a peak-signal-to-noise-ratio (PSNR) full reference technique,
American National Standards Institute, Ad Hoc Group on Video Quality
Metrics, 2001.
[12] H. R. Sheikh, M. F. Sabir, and A. C. Bovik, “A statistical evaluation
of recent full reference image quality assessment algorithms,” IEEE
Transactions on Image Processing, vol. 15, pp. 3440–3451, November
2006.
[13] Z. Li, A. Aaron, I. Katsavounidis, A. Moorthy, and M. Manohara,
“Toward a practical perceptual video quality metric,” Tech.
Rep., June 2016. [Online]. Available: https://netflixtechblog.com/
toward-a-practical-perceptual-video-quality-metric-653f208b9652
[14] Netflix. VMAF – Video Multi-Method Assessment Fusion. [Online].
Available: https://github.com/Netflix/vmaf
[15] C. Lee, S. Woo, S. Baek, J. Han, J. Chae, and J. Rim, “Comparison of
objective quality models for adaptive bit-streaming services,” in International Conference on Information, Intelligence, Systems & Applications
(IISA), June 2017.
[16] ITU, “Subjective video quality assessment methods for multimedia
applications,” ITU-T, Tech. Rep. P.910, Apr. 2008.
[17] Z. Li, C. Bampis, J. Novak, A. Aaron, K. Swanson,
A. Moorthy, and J. D. Cock, “VMAF: The journey
continues,” Tech. Rep., October 2018. [Online]. Available:
https://netflixtechblog.com/vmaf-the-journey-continues-44b51ee9ed12

