medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

Two-Stage Adaptive Pooling with RT-qPCR for
COVID-19 Screening
Anoosheh Heidarzadeh and Krishna Narayanan
Department of Electrical and Computer Engineering
Texas A&M University
College Station, TX 77843
{anoosheh@tamu.edu,krn@tamu.edu}

Abstract
We propose two-stage adaptive pooling schemes, 2-STAP and 2-STAMP, for detecting COVID-19
using real-time reverse transcription quantitative polymerase chain reaction (RT-qPCR) test kits. Similar to
the Tapestry scheme of Ghosh et al., the proposed schemes leverage soft information from the RT-qPCR
process about the total viral load in the pool. This is in contrast to conventional group testing schemes
where the measurements are Boolean. The proposed schemes provide higher testing throughput than the
popularly used Dorfman’s scheme. They also provide higher testing throughput, sensitivity and specificity
than the state-of-the-art non-adaptive Tapestry scheme. The number of pipetting operations is lower than
state-of-the-art non-adaptive pooling schemes, and is higher than that for the Dorfman’s scheme. The
proposed schemes can work with substantially smaller group sizes than non-adaptive schemes and are
simple to describe. Monte-Carlo simulations using the statistical model in the work of Ghosh et al.
(Tapestry) show that 10 infected people in a population of size 961 can be identified with 70.86 tests on
the average with a sensitivity of 99.50% and specificity of 99.62%. This is 13.5x, 4.24x, and 1.3x the
testing throughput of individual testing, Dorfman’s testing, and the Tapestry scheme, respectively.

I. I NTRODUCTION
There is broad consensus among epidemiologists, economists and policy makers that wide-scale testing
of asymptomatic patients is the key for reopening the economy. While the benefits of testing are obvious,
shortage of testing kits, reagents and the ensuing low-throughput of individual testing protocols has
This material is based upon work supported by the National Science Foundation (NSF) under Grant CCF-2027997.

NOTE: This preprint reports new research that has not been certified
1 by peer review and should not be used to guide clinical practice.

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

prevented deployment of wide-scale testing. Group testing or, pooling is an alternative way to substantially
increase the testing throughput.
The idea of group testing was introduced by Dorfman [1] during World War II for testing soldiers for
syphilis without having to test each soldier individually. Dorfman’s scheme consists of two stages (or
rounds). In the first stage, the set of people to be tested is split into disjoint pools and a test is performed
on each pool. If a pool tested negative, everyone in that pool will be identified as non-infected. Otherwise,
if a pool tested positive, we proceed to the second stage where all people in a positive pool will be tested
individually, and then identified as infected or non-infected accordingly. When the prevalence is small,
Dorfman’s scheme requires substantially fewer tests than individual testing.
Dorfman-style testing has been implemented in the past in screening for many diseases including
HIV [2], Chlamydia and Gonorrhea [3]. It has also been considered for screening for influenza [4]. For
COVID-19, several experimental results have confirmed the feasibility of using Dorfman-style pooling
and it has been implemented in Nebraska in USA, Germany, India and China [5], [6], [7], [8].
While Dorfman-style pooling is easy to implement, it is not optimal. Over the past 75 years, more
sophisticated group testing schemes that provide higher testing throughput have been designed. The
literature on group testing is too vast to review in detail and an overview of the techniques can be
found in [9] and [10]. Group testing is also related to compressed sensing and insights from compressed
sensing have been used to design group testing schemes. An important difference between group testing
and compressed sensing is that in group testing, the measurements are Boolean (test result is either
positive or negative) and they naturally correspond to non-linear functions of the unknown vector.
Most of the works using group testing with real-time reverse transcription quantitative polymerase chain
reaction (RT-qPCR) have only considered Boolean measurements even though the RT-qPCR process can
produce more fine-grained information (soft information) about the total viral load in the pool. It is
well-known in information theory that such soft information can potentially be used to increase testing
throughput substantially. However, group testing schemes that leverage soft information from the RTqPCR process remain largely unexplored.
Very recently, Ghosh et al. in [11] developed a statistical model relating the soft information from
the RT-qPCR to the total viral load in the pool. They designed a scheme called Tapestry, which uses
non-adaptive group testing using Kirkman triples and they considered several decoding algorithms that
use the soft information. They showed substantial gains in testing throughput over Dorfman’s scheme and
to the best of our knowledge, this scheme is the state of the art non-adaptive group testing scheme that
works with RT-qPCR, especially since it is the only work we are aware of that uses the soft information
from the RT-qPCR measurement process.

2

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

Here, we propose two simple and effective two-stage adaptive pooling schemes that use the soft
information from the RT-qPCR process and provide several advantages over Dorfman’s scheme and
the Tapestry scheme. We refer to these algorithms as the Two-stage Adaptive Pooling (2-STAP) and
the Two-stage Adaptive Mixed Pooling (2-STAMP) schemes/algorithms. The proposed schemes provide
substantially higher throughput than Dorfman-style testing. Compared to the Tapestry scheme in [11],
2-STAP and 2-STAMP have higher testing throughput and under the statistical model developed in [11],
for all tested cases, our algorithms have higher sensitivity and higher specificity. The proposed algorithms
require fewer pipetting operations than Tapestry, but require more pipetting operations than Dorfman’s
scheme. Finally, 2-STAP and 2-STAMP work with much smaller pool sizes and population sizes than
the Tapestry algorithm and hence, is easy to describe and implement in the lab. Monte-Carlo simulations
using the statistical model in the work of Ghosh et al. (Tapestry), show that 10 infected people in a
population of size 961 can be identified with 70.86 tests on the average with a sensitivity of 99.50% and
specificity of 99.62% with a pool size of 31. This is 13.5x, 4.24x, and 1.3x the testing throughput of
individual testing, Dorfman’s testing, and the Tapestry scheme, respectively.
Unlike Tapestry, which is a non-adaptive scheme, 2-STAP and 2-STAMP require storage of the swab
samples and their accessibility for the second round of testing—similar to that of Dorfman’s scheme.
II. M EASUREMENT M ODEL
We consider pooling-based testing for COVID-19 using the real-time reverse transcription quantitative
polymerase chain reaction (RT-qPCR) technique—considered also in [11].
Consider a population of n people, labeled 1, . . . , n, that are to be tested for COVID-19. Let x1 , . . . , xn
represent the viral loads of these people. If the jth person is infected (i.e., COVID-19 positive), then x j
is a nonzero value; otherwise, if the jth person is not infected (i.e., COVID-19 negative), then x j is zero.
We wish to find the label set of all infected people in the population (e.g., if the people labeled 10 and
20 are the only infected people in the population, the label set of infected people is {10, 20}), by making
measurements using the RT-qPCR technology. A measurement y is defined as the sum of the viral loads
of a subset (or a pool) of people in the population to be tested for COVID-19. That is, y = ∑nj=1 a j x j ,
where a j ∈ {0, 1}. Suppose we collect the measurements y1 , y2 , . . . (for different pools), and observe
noisy versions of y1 , y2 , . . . , denoted by z1 , z2 , . . . . Using the same model as in [11], we assume that
the ith noisy measurement is given by
zi = yiεi ,

(1)

where εi ’s represent the random noise in the measurement process. Note that zi = 0 if and only if yi = 0
(i.e., all people participating in the ith measurement are non-infected), and zi 6= 0 if and only if yi 6= 0

3

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

(i.e., there exists at least one infected person among the people participating in the ith measurement). A
detailed explanation about the multiplicative noise model in (1) can be found in Appendix I.
We refer to the process of generating the measurements as pooling, and refer to the process of estimating
the set of infected people from the noisy measurements as recovery. Given a pooling algorithm and a
recovery algorithm, the average fraction of infected people that have been identified as non-infected is
[k]

referred to as the false negative rate (denoted by r− ), and the average fraction of non-infected people
[k]

that have been identified as infected is referred to as the false positive rate (denoted by r+ ), where both
[k]

averages are taken over all populations of size n that contain k infected people. The quantities 1 − r− and
[k]

1 − r+ are referred to as the conditional sensitivity and the conditional specificity, respectively. (Here,
the term “conditional” reflects that the false negative rate and the false positive rate are computed by
averaging over all populations with a fixed number of infected people.)
Our goal is to design a pooling algorithm and a recovery algorithm such that the total number
of measurements is minimized while the false negative rate and the false positive rate remain below
some target thresholds (e.g., below 1%), or equivalently, the conditional sensitivity and the conditional
specificity remain above some target thresholds (e.g., above 99%).
III. 2-STAP: A T WO -S TAGE A DAPTIVE P OOLING
In this section, we propose a two-stage adaptive pooling scheme which we refer to as the 2-STAP
scheme. The 2-STAP scheme is inspired by the well-known two-stage Dorfman’s scheme which was
originally proposed in the context of group testing but requires substantially fewer measurements.
Translating Dorfman’s scheme into the language of our work, in the first stage, the people are pooled
into a number of disjoint groups (or pools) of equal size, and one measurement is made for each pool
where the measurement is the sum of viral loads of all people in that pool. In the second stage of
Dorfman’s scheme, one measurement is made for every person in a positive pool (i.e., a pool whose
measurement in the first stage is nonzero), and no additional measurements are made for any negative
pool (i.e., a pool whose measurement in the first stage is zero). A schematic of Dorfman’s scheme is
shown in Fig. 1.
The first stage of the 2-STAP scheme is the same as that of Dorfman’s scheme. The second stage of the
2-STAP scheme, however, differs from that of Dorfman’s scheme. In particular, in the second stage of the
2-STAP scheme, for each positive pool a number of measurements are made, where each measurement
is the sum of viral loads of some (not necessarily singleton) subset of people in that pool. Similar to the
Dorfman’s scheme, the second stage of the 2-STAP scheme makes no additional measurements for any
negative pools.

4

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

Fig. 1. Schematic of Dorfman’s Scheme for pool size = 10.

Fig. 2. Schematic of 2-STAP-I for pool size = 10.

5

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

We present two variants of the 2-STAP scheme: 2-STAP-I and 2-STAP-II. In 2-STAP-I, for all positive
pools, the number of measurements and the pooling scheme in the second stage will be the same,
regardless of the observed measurements for these pools in the first stage. On the other hand, in 2-STAPII, for each positive pool, the number of measurements and the pooling scheme in the second stage will
be chosen based on the observed measurement for that pool in the first stage. Although the 2-STAP-II
scheme requires a smaller average number of measurements (for a given target level of accuracy), but
the 2-STAP-I scheme makes it easier to understand the main advantages of the proposed schemes over
non-adaptive schemes and Dorfman’s scheme. A schematic of the 2-STAP-I scheme is shown in Fig. 2.
Once the second-stage measurements for a positive pool are collected, the recovery algorithm takes
all these measurements (together with the first-stage measurement for that pool) as input, and returns an
estimate of the label set of infected people in that pool. Details about the pooling matrices we have used
in our Monte-Carlo simulations can be found in Appendix II, and the detailed mathematical description
of the recovery algorithm can be found in [12].
IV. 2-STAMP: A T WO -S TAGE A DAPTIVE M IXED P OOLING
In this section, we propose another two-stage adaptive pooling scheme, which we refer to as the 2STAMP scheme, by generalizing the 2-STAP scheme. The first stage of the 2-STAMP scheme is the same
as that in the 2-STAP scheme, but in the second stage we make measurements on mixtures (groups) of
positive pools together, instead of making measurements on separate pools only. For the ease of exposition,
we explain a special case of the 2-STAMP scheme when up to two pools can be mixed together. The
same idea can be easily extended for mixing larger number of pools.
The main idea behind mixing pools in the second stage is as follows. Consider two positive pools
that we expect to contain a relatively small number of infected people. (For each positive pool, the
number of infected people can be estimated based on the observed measurement for that pool in the
first stage, for details, see [12]). By mixing these pools together and making measurements on the
mixed pool altogether (instead of making measurements on the pools individually), we can save a few
measurements while maintaining the implementation/computational complexity of both the pooling and
recovery algorithms affordable. However, the rest of the pools that are expected to contain a relatively
large number of nonzero coordinates will be measured individually, so as to avoid the pooling and/or
recovery algorithms to become too complex implementation-wise or computationally. Details about the
mixing process and pooling matrices we have used in our Monte-Carlo simulations can be found in
Appendix II, and the detailed description of the recovery algorithm can be found in [12].

6

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

V. C OMPARISONS B ETWEEN THE P ROPOSED S CHEMES AND THE TAPESTRY S CHEME
The key differences between the proposed schemes and the Tapestry scheme are listed below:
•

Tapestry is a single-stage scheme, and hence all measurements can be made in parallel. The proposed
schemes are, however, two-stage schemes; and notwithstanding that all measurements in each stage
can be made in parallel, the measurements in the second stage can only be made after those in the
first stage.

•

When compared to Tapestry, in the tested cases, the proposed schemes achieve a better trade-off
between the average number of measurements and the (conditional) average false negative/positive
rate. This comes from two facts: (i) the pooling algorithm of the proposed schemes is more flexible
than that of the Tapestry scheme. This is because the total number of measurements in the latter
can vary for different realizations of viral loads, whereas the former uses the same number of
measurements always; and (ii) the measurements in the proposed schemes are localized to small
pools. This makes it possible to implement recovery algorithms that are carefully designed for
the multiplicative noise model with reasonable computational complexity. In contrast, the recovery
algorithms discussed in the Tapestry scheme were borrowed from the compressed sensing literature
where the noise model is assumed to be additive. Unlike the recovery algorithms used for Tapestry,
the recovery algorithm proposed in this work also takes into account the signal and noise distributions
and the sparsity parameter (prevalence) or its estimate.

•

The pooling algorithm of the proposed schemes can potentially have a substantially lower computational and implementation complexity than that of the Tapestry scheme. This follows from two
facts: (i) the total number of nonzero entries in the overall pooling matrix of the proposed schemes
can be much smaller than that in the Tapestry scheme; and (ii) the nonzero entries in each row of
the pooling matrix in the Tapestry scheme are spread out everywhere, whereas the nonzero entries in
the pooling matrix of the proposed schemes are localized in each row. In particular, in the first stage
each measurement is localized to a pool of people with consecutive labels, and the measurements
in the second stage for each pool are over the people in that pool only.
VI. M ONTE -C ARLO S IMULATION R ESULTS

In this section, we present our simulation results. As a case study, in these simulations, we have
considered a population of n = 961 people to be tested for COVID-19 and assumed that the prevalence
is p = 0.01. (In the simulations, we considered both cases where p is known or unknown a priori,
and we did not observe any significant difference in the performance of either of the proposed schemes,
2-STAP and 2-STAMP.) For both the proposed schemes, we have considered pooling the population into

7

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

q = 31 pools, each of size s =

n
q

= 31, in the first stage. Three different values of number of infected

people in the population (k), namely k ∈ {5, 10, 15}, have been considered. For every k, we performed
100 Monte-Carlo simulations, where the statistical models used for viral load and measurement noise
were obtained from [11].
Table I summarizes our results for the proposed 2-STAP (both variants) and 2-STAMP schemes and the
results for the Tapestry scheme for the same problem model (i.e., the same population size and the same
viral load and noise distributions) where each measurement is made on a pool of 31 people (see [11]).
In this table, mmin , mmax , mstd , and mave represent the minimum, maximum, standard deviation, and
the average of the number of measurements used in 100 simulations, respectively. The sensitivity and
specificity results are rounded to two decimal places, for fair comparison with the results reported in [11].
More detailed results for the 2-STAP-I, 2-STAP-II, and 2-STAMP schemes are presented in Tables II, III,
and IV, respectively. In these tables, α is a parameter used in the recovery algorithm that controls the
trade-off between sensitivity and specificity (for more details, see [12]).
Comparing the results of Tapestry and the two variants of 2-STAP in Table I, it can be seen that
for k ∈ {5, 10}, 2-STAP-I requires smaller number of measurements on the average for the same (or
even higher) sensitivity and specificity (see also Table II). For k = 15, 2-STAP-I uses about 10 more
measurements than Tapestry on the average, but it achieves a substantially higher specificity by about
2% for almost the same sensitivity (see also Table II). It can also be seen that for all k ∈ {5, 10, 15},
2-STAP-II can provide higher sensitivity and higher specificity than Tapestry with even smaller (average)
number of measurements. For instance, for the case of k = 10 infected people, with an average number
of measurements about 75, 2-STAP-II can achieve a sensitivity of 99.30% and a specificity of 99.54%,
see Table III. However, using Tapestry, for k = 10, one can achieve a sensitivity and a specificity between
98.50% and 99.49% with 93 measurements (about 20% more measurements than that in 2-STAP-II).
These improvements in the performance are mainly due to the fact that 2-STAP is an adaptive scheme
(although with a very small degree of adaptivity, i.e., using only one round of feedback), whereas Tapestry
is a non-adaptive scheme. In particular, identifying all negative pools (which contain a relatively large
fraction of population for sufficiently low prevalence) at the end of the first stage and using a relatively
small number of additional measurements only for each positive pool in the second stage enable us to
achieve a better trade-off between average number of measurements, sensitivity, and specificity.
As can be seen in Table I, 2-STAMP can achieve a sensitivity and a specificity higher than those
attainable with 2-STAP-I and 2-STAP-II, with even smaller average number of measurements. For
instance, for k = 10, with only about 71 (< 75 in 2-STAP-II) measurements on average, 2-STAMP can
achieve a sensitivity of 99.30% (the same as that in 2-STAP-II) and a specificity of 99.81% (> 99.54%

8

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

TABLE I
P ERFORMANCE RESULTS FOR THE TAPESTRY SCHEME [11] AND THE PROPOSED 2-STAP AND 2-STAMP SCHEMES
( SENSITIVITY AND SPECIFICITY RESULTS ARE ROUNDED TO TWO DECIMAL PLACES )

k

mmin

mmax

mstd

mave

93

93

0

93

5

Conditional

Conditional

Sensitivity

Specificity

Tapestry + COMP + NN-LASSO [11]

1.00

1.00

Tapestry + COMP + NN-OMP [11]

1.00

1.00

Tapestry + COMP + SBL [11]

1.00

1.00

Pooling Scheme

49

61

2.94

59.08

2-STAP-I

1.00

1.00

47

57

2.26

54.55

2-STAP-II

1.00

1.00

46

55

2.25

52.56

2-STAMP

1.00

1.00

Tapestry + COMP + NN-LASSO [11]

0.98

0.99

Tapestry + COMP + NN-OMP [11]

0.96

1.00

Tapestry + COMP + SBL [11]

0.99

0.99

93

93

0

93

10
73

91

5.54

82.96

2-STAP-I

1.00

1.00

66

81

4.18

74.98

2-STAP-II

0.99

1.00

63

76

3.74

70.86

2-STAMP

1.00

1.00

Tapestry + COMP + NN-LASSO [11]

0.94

0.97

Tapestry + COMP + NN-OMP [11]

0.86

0.99

Tapestry + COMP + SBL [11]

0.98

0.97

93

93

0

93

15
85

121

7.31

103.30

2-STAP-I

0.98

0.99

78

106

5.65

92.66

2-STAP-II

0.98

0.99

74

99

5.02

86.85

2-STAMP

0.99

0.99

in 2-STAP-II), see Table III. The advantage of 2-STAMP over both variants of 2-STAP comes from the
saving in the number of measurements in the second stage. In particular, in 2-STAMP, mixing small
groups (namely, groups of size two) of pools with small number of infected people gives rise to an
opportunity for making a smaller number of measurements on the mixed super-pool (as compared to the
total number of measurements used in 2-STAP for all pools in the mix) without compensating the overall
accuracy.
R EFERENCES
[1] R. Dorfman, “The detection of defective members of large populations,” The Annals of Mathematical Statistics, vol. 14,
no. 4, pp. 436–440, 1943.
[2] J. Emmanuel, M. Bassett, H. Smith, and J. Jacobs, “Pooling of sera for human immunodeficiency virus (HIV) testing: an
economical method for use in developing countries.” Journal of clinical pathology, vol. 41, no. 5, pp. 582–585, 1988.

9

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

TABLE II
D ETAILED PERFORMANCE RESULTS FOR THE 2-STAP-I SCHEME

k

5

10

15

mmin

49

73

85

mmax

61

91

121

mstd

2.94

5.54

7.30

α

Conditional
Sensitivity

Conditional
Specificity

0.943

0.9920

0.9995

0.926

0.9960

0.9994

0.893

0.9980

0.9993

0.943

0.9810

0.9988

0.909

0.9930

0.9982

0.885

0.9950

0.9978

0.847

0.9820

0.9939

0.758

0.9893

0.9885

0.649

0.9940

0.9817

mave

59.08

82.96

103.30

TABLE III
D ETAILED PERFORMANCE RESULTS FOR THE 2-STAP-II SCHEME

k

mmin

mmax

mstd

mave

5

47

57

2.26

54.55

10

15

66

78

81

106

4.18

5.65

74.98

92.66

α

Conditional
Sensitivity

Conditional
Specificity

0.813

0.9920

0.9986

0.794

0.9940

0.9983

0.787

0.9980

0.9982

0.943

0.9810

0.9987

0.794

0.9930

0.9954

0.730

0.9950

0.9927

0.787

0.9820

0.9903

0.654

0.9893

0.9802

0.515

0.9940

0.9724

[3] J. L. Lewis, V. M. Lockary, and S. Kobic, “Cost savings and increased efficiency using a stratified specimen pooling
strategy for chlamydia trachomatis and neisseria gonorrhoeae,” Sexually Transmitted Diseases, vol. 39, no. 1, pp. 46–48,
2012.
[4] T. T. Van, J. Miller, D. M. Warshauer, E. Reisdorf, D. Jernigan, R. Humes, and P. A. Shult, “Pooling nasopharyngeal/throat
swab specimens to increase testing capacity for influenza viruses by PCR,” Journal of clinical microbiology, vol. 50, no. 3,
pp. 891–896, 2012.
[5] C. R. Bilder, P. C. Iwen, B. Abdalhamid, J. M. Tebbs, and C. S. McMahan, “Tests in short supply? try group testing,”
Significance (Oxford, England), vol. 17, no. 3, p. 15, 2020.
[6] N. Shental, S. Levy, S. Skorniakov, V. Wuvshet, Y. Shemer-Avni, A. Porgador, and T. Hertz, “Efficient high throughput

10

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

TABLE IV
D ETAILED PERFORMANCE RESULTS FOR THE 2-STAMP SCHEME

k

5

10

15

mmin

46

63

74

mmax

55

76

99

mstd

2.25

3.74

5.02

mave

52.56

70.86

86.85

α

Conditional
Sensitivity

Conditional
Specificity

0.893

0.9920

0.9989

0.877

0.9940

0.9986

0.847

0.9980

0.9978

0.980

0.9800

0.9990

0.935

0.9930

0.9981

0.885

0.9950

0.9962

0.909

0.9813

0.9945

0.877

0.9900

0.9916

0.840

0.9947

0.9847

SARS-CoV-2 testing to detect asymptomatic carriers,” medRxiv, 2020.
[7] I. Yelin, N. Aharony, E. Shaer-Tamar, A. Argoetti, E. Messer, D. Berenbaum, E. Shafran, A. Kuzli,
N. Gandali, T. Hashimshony, Y. Mandel-Gutfreund, M. Halberthal, Y. Geffen, M. Szwarcwort-Cohen, and
R. Kishony, “Evaluation of covid-19 RT-qPCR test in multi-sample pools,” medRxiv, 2020. [Online]. Available:
https://www.medrxiv.org/content/early/2020/03/27/2020.03.26.20039438
[8] C. A. Hogan, M. K. Sahoo, and B. A. Pinsky, “Sample pooling as a strategy to detect community transmission of SARSCoV-2,” Jama, vol. 323, no. 19, pp. 1967–1969, 2020.
[9] D. Du and F. K. Hwang, Combinatorial group testing and its applications. World Scientific, 2000, vol. 12.
[10] M. Aldridge, O. Johnson, and J. Scarlett, Group Testing: An Information Theory Perspective. now, 2019.
[11] S. Ghosh, A. Rajwade, S. Krishna, N. Gopalkrishnan, T. E. Schaus, A. Chakravarthy, S. Varahan, V. Appu, R. Ramakrishnan,
S. Ch et al., “Tapestry: A single-round smart pooling technique for COVID-19 testing,” medRxiv, 2020.
[12] A. Heidarzadeh and K. R. Narayanan, “Two-stage adaptive pooling with RT-qPCR for COVID-19 screening,” 2020.
[Online]. Available: http://pooling.wikidot.com/local–files/research-papers/2-StageSchemes-arxivversion.pdf

A PPENDIX I
D ETAILED E XPLANATION ABOUT M ULTIPLICATIVE N OISE M ODEL
The multiplicative noise model is inspired by the current RT-qPCR technology for COVID-19 testing.
Suppose that an individual person is to be tested for COVID-19 by using this technology. The sample
collected from the person to be tested is dispersed into a liquid medium, and the reverse transcription
(RT) process is applied to convert the RNA molecules of the SARS-CoV-2 virus (the coronavirus that
causes COVID-19) in the liquid (if the person is infected) into cDNA. Followed by adding primers that
are complementary to the cDNA of the viral genome, these primers attach themselves to the cDNA
of the viral genome, and together they undergo an exponential amplification process by the RT-qPCR

11

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

machine [11]. This process consists of a maximum of Cmax cycles. The output of the RT-qPCR process
is the cycle count C after which the concentration of DNA exceeds a pre-specified threshold Dmin or
Cmax . The thresholds Dmin and Cmax are often chosen so that: (i) if a person is not infected, the DNA
concentration does not exceed Dmin over the course of Cmax cycles, and (ii) if a person is infected,
the DNA concentration exceeds Dmin at some point, say cycle C, over the course of Cmax cycles. Note
that for a fixed Dmin , the larger is the viral load of an infected person, the smaller C will be. Ideally,
the concentration of DNA molecules is doubled in every cycle, i.e., after C cycles the concentration of
DNA molecules is x2C , where x is the viral load of the person to be tested. In reality, however, the
amplification process may not be ideal. To reflect the randomness in the process, we use the same model
as the one suggested in [11] and assume that the concentration of DNA molecules after C cycles is
given by xbC+∆ for some positive constant b (close to 2), where x is the viral load of the person to be
tested, and ∆ is a Gaussian random variable with mean zero and variance σ∆2 . The multiplicative term
ε = b∆ can be viewed as the noise in the amplification process. Note that the closer are b to 2 and σ∆
to 0, the weaker will be the noise and the closer will be the process to ideal. For any x > 0, let Cx
be the number of cycles it takes for the concentration of DNA molecules to be approximately equal to
Dmin . That is, xbCx +∆ ≈ Dmin . The cycle count measurement Cx can be converted to an equivalent
measurement z given by z = Dmin b−Cx . It can then be seen that z = xε gives the measurement model
with multiplicative noise, as in (1).
A PPENDIX II
N UMBER OF M EASUREMENTS AND P OOLING M ATRICES U SED IN S IMULATIONS
For the 2-STAP-I scheme, for each positive pool, 6 measurements were used in the second stage, and
the pooling matrix used in the simulations can be found in Fig. 3.

16
17
17
17
18
19

1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31

1
0
0
1
1
0

0
1
0
1
0
1

0
1
1
0
0
1

0
0
1
1
0
1

1
1
1
0
0
0

1
1
0
0
1
0

0
1
1
0
1
0

1
0
1
0
0
1

1
1
0
0
0
1

1
0
1
1
0
0

1
0
0
0
1
1

0
1
0
0
1
1

0
1
0
1
1
0

0
0
1
0
1
1

1
0
0
1
0
1

0
0
1
1
1
0

0
1
1
1
0
0

0
0
0
1
1
1

1
0
1
0
1
0

1
1
0
1
0
0

1
0
1
1
0
1

1
0
1
0
1
1

1
1
1
0
0
1

1
0
0
1
1
1

1
1
0
1
1
0

0
1
0
1
1
1

0
0
1
1
1
1

0
1
1
1
0
1

1
1
0
0
1
1

0
1
1
0
1
1

0
1
1
1
1
0

3

3

3

3

3

3

3

3

3

3

3

3

3

3

3

3

3

3

3

3

4

4

4

4

4

4

4

4

4

4

4

Fig. 3. The pooling matrix with 6 rows and 31 columns used in the simulations for the 2-STAP-I scheme. (The number of 1’s
in each row is shown in front of the row, and the number of 1’s in each column is shown below the column.)

For the 2-STAP-II scheme, the number of measurements used in the second stage for each positive
pool was chosen as follows: 5, 6, 7, 8 measurements if our estimate of the number of infected people in

12

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

the pool (based on the observed measurement in the first stage for that pool) is 1, 2, 3, ≥ 4, respectively.
The pooling matrices used in the simulations for these number of measurements can be found in Fig. 4.
For the 2-STAMP scheme, we first estimated the number of infected people in each positive pool based
on the observed measurement for that pool in the first stage. Then, we sorted the pools in the decreasing
order with respect to their estimated number of infected people. For any pool for which the (estimated)
number of infected people is 3 or ≥ 4, we used 7 or 8 measurements, respectively. The pooling matrices
used in the simulations for these number of measurements can be found in Fig. 4.
For any two consecutive pools (in the sorted order) that collectively contain 2, 3, 4 infected people
(based on our estimates), we used 9, 10, 11 measurements, respectively, on the mixed pool formed by
combining the two pools together. The pooling matrices used in the simulations for these number of
measurements can be found in Fig. 5.

13

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

15
15
15
15
15
15
15
15
15
15
15
15
15
15
15

1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31

0
1
0
00
010
000
000
00
00
01

1
2
0
10
020
010
001
00
10
02

0
3
1
00
130
000
011
00
10
03

1
4
1
10
140
010
012
00
20
04

0
5
0
01
050
100
001
01
10
05

1
6
0
11
060
110
002
01
20
06

0
7
1
01
170
100
012
01
20
07

1
8
1
11
180
110
013
01
30
08

0
9
0
00
091
000
101
00
11
09

1
10
121
010
110
003
01
30
20

1
10
130
011
010
103
00
31
30

0
11
040
110
001
013
10
30
41

0
01
051
101
100
113
01
31
50

0
01
060
101
001
113
10
31
61

1
01
170
100
011
013
10
30
71

0
10
081
010
101
003
11
30
81

0 1 1 1 0 0 0 1 1
11 00 11 00 10 00 01 10 00
090 10
11 11
10 12
10 13
01 14
01 15
01 16
10 17
11
1
0
1
0
1
0
0
11 01 10 01 01 01 10 010 001
000 110 010 011 100 101 101 011 111
113 103 013 103 103 103 013 003 104
00 01 00 10 01 11 11 10 11
1 0
31 31 30 31 31 3
3 0
3 1
4
9 0 100 110 121 130 141 151 161 171

1
01
18
11
101
110
114
01
14
180

0
10
021
010
100
001
013
10
30
1

0
01
031
100
101
010
113
00
31
0

0
11
041
110
100
010
013
00
30
0

1
11
150
110
010
010
003
00
30
0

0
10
060
011
000
101
003
11
30
1

1
00
170
000
011
001
103
10
31
1

1
00
180
001
010
101
003
11
30
1

1
00
191
001
110
100
013
01
30
0

0
01
10
01
101
100
110
013
01
30
0

0
00
11
01
001
101
100
113
01
31
0

0
11
12
00
110
000
011
003
10
30
1

1
10
13
10
011
010
100
003
01
30
0

0
00
14
00
001
001
101
103
11
31
1

1
01
15
10
100
011
010
103
00
1
3
0

0
10
16
01
010
101
000
113
00
1
3
0

0
00
17
01
001
101
101
114
11
14
1

3

3

3

3

3

3

3

3

3

3

3

3

3

3

3

4

18 00
18 11
18 0
18 1
18 11
18
18 01
18
18 1
18 10
18
18 10
18
18
013
18
18 01
18 0
3
18 10
15 13
15 10
15
15 10
1
15
15 0
15 10
15
16 0
15 00
15
16 0
15 01
16
16 0
15 1
16 10
16 3
16 10
16 1
3
16 1
3

1
0
10
10
01
010
102
00
21
010

1 0 1 0 1 0 1 0
1 0 0 1 1 0 0 1
10 01 11 01 11 00 10 00
12
11 13
01 14
01 15
11 16
11 17
00 18
00 19
10
1
0
1
0
1
0
00 10 10 10 10 01 011 001
113 102 103 113 114 001 002 012
00 01 01 01 01 10 10 10
1 311
1
02 02
31 (a)21 5 ×
3
3 pooling
4 0
1 matrix
012 013 014 015 016 117 118 119

1
1
10
20
10
011
013
10
03
120

0
0
01
21
00
101
002
11
02
121

1
0
11
22
00
1
1
01
0
3
1
1
03
122

0
1
01
23
10
0
11
1
03
1
1
03
123

1
1
11
24
10
1
11
1
04
1
1
04
124

0
0
00
25
0
001
011
2
01
12
125

1
0
10
26
0
101
011
3
01
13
126

0
1
00
27
1
001
111
3
01
13
127

1
1
10
28
1
101
111
4
01
14
128

0
0
01
29
0
011
011
3
11
13
129

1
0
11
30
0
111
011
4
11
14
130

0
1
01
31
1
011
111
4
11
14
131

1
01
19
10
101
011
114
10
14
1
19

1
01
20
11
100
111
014
11
04
1
20

1
10
21
11
011
110
104
01
14
0
21

1
11
22
11
1
1
10
1
10
0
14
0
04
0
22

0
11
23
01
1
11
0
10
1
14
1
0
14
0
23

1
10
24
11
1
00
1
11
0
04
1
1
04
1
24

0
01
25
0
011
011
111
114
14
1
25

0
11
26
0
111
010
101
114
04
1
26

1
10
27
1
100
101
011
014
14
1
27

0
11
28
0
110
001
111
014
14
1
28

1
11
29
1
110
101
110
004
14
0
29

0
10
30
0
101
011
011
114
14
1
30

1
11
31
1
110
100
101
014
04
1
31

0
01
18
01
101
101
110
114
01
14
0

1
10
19
11
010
110
001
014
10
04
1

1
00
20
10
001
011
101
104
11
14
1

0
11
21
01
110
100
011
014
10
04
1

1
00
22
11
0
0
10
1
01
0
11
1
04
1
14
1

0
11
23
00
1
1
01
0
11
1
00
1
14
0
14
0

1
01
24
10
0
11
1
00
1
11
0
04
1
1
04
1

1
10
25
1
101
111
010
100
104
04
0

1
01
26
1
011
111
110
100
104
04
0

0
01
27
0
010
001
111
011
114
14
1

0
11
28
0
110
000
101
011
014
14
1

1
11
29
1
110
101
110
000
104
04
0

1
01
30
1
011
110
101
110
004
14
0

1
10
31
1
100
100
001
011
014
14
1

4

4

4

4

4

4

4

4

4

4

4

4

4

4

10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31

1
0
11
11
00
112
00
21
011

11 11 21 10 20 20 31 11 20 21 30 21 30 30 41 10 20 20 30 21 31 31 41 20 31 31 41 31 41 41
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31

(b) 6 × 31 pooling matrix
13 03 13 13 13 03 03 0 3 0 3 0 3 13 13 03 03 13 04 04 14 04 14 04 14 04 14 04 04 41 41 40 41
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31

(c) 7 × 31 pooling matrix

13
13
13
13
14
14
14
14

1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31

0
1
0
1
0
0
1
0

0
0
0
1
0
1
1
0

1
0
0
1
0
1
0
0

0
1
1
0
1
0
0
0

1
1
0
0
0
1
0
0

0
0
0
1
1
0
1
0

0
1
0
0
1
0
0
1

0
0
1
0
0
1
1
0

0
0
0
0
0
1
1
1

0
1
0
0
0
1
1
0

0
0
1
1
0
0
0
1

1
0
0
0
0
1
0
1

0
0
1
1
1
0
0
0

0
0
1
0
0
1
0
1

0
1
0
0
1
0
1
0

0
0
0
0
1
1
0
1

1
1
1
0
0
0
1
0

1
0
1
0
1
0
1
0

1
0
0
1
1
0
0
1

1
1
0
0
0
1
0
1

0
0
1
0
1
1
0
1

0
0
1
1
0
1
1
0

1
1
1
0
1
0
0
0

1
0
1
0
0
1
0
1

1
0
0
1
0
0
1
1

0
1
0
0
1
0
1
1

1
0
1
0
0
0
1
1

1
1
0
1
0
0
0
1

0
1
0
1
1
1
0
0

0
1
0
1
1
0
1
0

1
0
1
1
1
0
0
0

3

3

3

3

3

3

3

3

3

3

3

3

3

3

3

3

4

4

4

4

4

4

4

4

4

4

4

4

4

4

4

(d) 8 × 31 pooling matrix
1

2

3

23 0

1

0

4

5

6

7

8

0

0

0

0

0

9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45
0

1

1

0

0

0 1 1 1 1 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 1 0 1 0 0 1 0 0 1 0 0 1
0 number
1 0 0of 1’s
1 in
1 each
0 0row0 is 0shown
1 0in 1front
0 of1 the1 row,
0 and
1 0the0number
1 0 of0 1’s1 in0each
1 column
0 1 0is shown
0 0 below
1 0 the
0 column.)
0 1 0 0

1

24 0

1

1

0

1

0

24 1

0

0

0

0

1

0

1

0

1

0

0

1

1

0

0

0

0

0

1

1

0

1

0

0

0

0

1

0

1

1

0

0

0

0

1

1

0

1

1

1

0

0

0

0

24 0

0

1

0

1

1

1

1

0

0

1

0

1

0

1

0

1

0

0

0

0

1

0

1

1

1

1

0

0

0

0

1

0

0

0

1

1

1

0

1

0

1

0

1

1

24 0

1

1

0

0

1

0

0

1

0

0

0

0

0

1

1

0

1

1

1

1

1

0

1

0

0

1

0

1

0

1

0

0

1

0

0

0

0

1

0

0

0

1

0

0

24 1

1

1

0

0

0

0

0

0

1

0

1

0

0

0

0

1

0

1

0

0141

1

1

1

1

0

0

1

0

0

1

1

0

0

0

0

0

1

0

0

1

0

0

1

24 0

1

1

1

1

0

1

0

1

0

1

0

0

1

0

0

0

0

1

0

1

0

0

0

1

1

1

0

0

1

0

1

0

1

1

1

0

0

0

0

0

0

0

0

0

25 1

0

0

0

1

1

0

0

1

0

0

1

0

1

0

1

0

1

0

0

1

0

0

0

0

0

0

0

0

0

0

0

1

0

1

0

0

0

0

1

1

1

1

0

0

Fig. 4. The pooling matrices with 5, 6, 7, 8 rows and 31 columns used in the simulations for the 2-STAP-II scheme. (The

medRxiv preprint doi: https://doi.org/10.1101/2020.07.05.20146936; this version posted July 7, 2020. The copyright holder for this preprint
(which was not certified by peer review) is the author/funder, who has granted medRxiv a license to display the preprint in perpetuity.
It is made available under a CC-BY-NC-ND 4.0 International license .

1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31

0
1
0
1
0
14 0
14 1
14 0

0
0
0
1
0
1
1
0

1
0
0
1
0
1
0
0

0
1
1
0
1
0
0
0

1
1
0
0
0
1
0
0

0
0
0
1
1
0
1
0

0
1
0
0
1
0
0
1

0
0
1
0
0
1
1
0

0
0
0
0
0
1
1
1

0
1
0
0
0
1
1
0

0
0
1
1
0
0
0
1

1
0
0
0
0
1
0
1

0
0
1
1
1
0
0
0

0
0
1
0
0
1
0
1

0
1
0
0
1
0
1
0

0
0
0
0
1
1
0
1

1
1
1
0
0
0
1
0

1
0
1
0
1
0
1
0

1
0
0
1
1
0
0
1

1
1
0
0
0
1
0
1

0
0
1
0
1
1
0
1

0
0
1
1
0
1
1
0

1
1
1
0
1
0
0
0

1
0
1
0
0
1
0
1

1
0
0
1
0
0
1
1

0
1
0
0
1
0
1
1

1
0
1
0
0
0
1
1

1
1
0
1
0
0
0
1

0
1
0
1
1
1
0
0

0
1
0
1
1
0
1
0

1
0
1
1
1
0
0
0

3

3

3

3

3

3

3

3

3

3

3

3

3

3

3

3

4

4

4

4

4

4

4

4

4

4

4

4

4

4

4

13
13
13
13
14

1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62

23 0

1

0

0

0

0

0

0

0

1

1

1

1

0

0

0

0

0

0

0

0

0

1

0

1

0

0

1

1

0

1

0

0

1

0

0

1

0

0

1

1

0

1

1

0

1

1

0

0

0

0

0

1

1

0

0

1

1

0

0

1

0

24 0

0

0

1

0

0

1

1

0

0

0

0

1

0

1

0

1

1

0

1

0

0

1

0

0

1

0

1

0

1

0

0

0

1

0

0

0

1

0

0

1

1

0

1

0

0

0

1

1

0

0

1

0

0

1

0

0

0

1

1

0

1

24 1

0

0

0

0

1

0

1

0

1

0

0

1

1

0

0

0

0

0

1

1

0

1

0

0

0

0

1

0

1

1

0

0

0

0

1

1

0

1

1

1

0

0

0

0

0

0

1

1

0

1

1

1

0

0

0

0

0

1

0

1

0

24 0

0

1

0

1

1

1

1

0

0

1

0

1

0

1

0

1

0

0

0

0

1

0

1

1

1

1

0

0

0

0

1

0

0

0

1

1

1

0

1

0

1

0

1

1

0

0

0

0

0

0

0

0

0

1

1

0

0

0

0

0

0

24 0

1

1

0

0

1

0

0

1

0

0

0

0

0

1

1

0

1

1

1

1

1

0

1

0

0

1

0

1

0

1

0

0

1

0

0

0

0

1

0

0

0

1

0

0

0

0

0

0

1

0

0

0

1

1

1

0

1

1

0

0

0

24 1

1

1

0

0

0

0

0

0

1

0

1

0

0

0

0

1

0

1

0

0

1

1

1

1

1

0

0

1

0

0

1

1

0

0

0

0

0

1

0

0

1

0

0

1

0

0

1

1

0

1

0

1

0

1

0

0

0

0

0

0

1

24 0

1

1

1

1

0

1

0

1

0

1

0

0

1

0

0

0

0

1

0

1

0

0

0

1

1

1

0

0

1

0

1

0

1

1

1

0

0

0

0

0

0

0

0

0

1

0

0

0

1

0

0

0

0

0

1

1

1

0

1

0

0

25 1

0

0

0

1

1

0

0

1

0

0

1

0

1

0

1

0

1

0

0

1

0

0

0

0

0

0

0

0

0

0

0

1

0

1

0

0

0

0

1

1

1

1

0

0

1

1

1

0

0

1

1

1

1

0

1

0

0

0

1

0

1

25 0

0

0

1

1

0

0

0

0

0

0

1

0

0

0

1

1

0

0

1

0

0

0

1

0

0

0

0

0

0

1

0

1

0

1

1

0

1

0

0

0

0

1

1

1

1

1

0

1

1

1

1

0

0

0

0

1

0

0

1

1

1

3

4

4

3

4

4

3

3

3

3

3

4

4

3

3

3

4

3

3

4

4

3

4

4

4

4

3

3

3

3

4

3

3

4

3

4

3

3

3

4

4

4

4

4

3

4

3

4

4

3

4

4

4

3

4

4

3

3

3

4

3

4

(a) 9 × 62 pooling matrix

1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62

21 0

0

0

0

0

0

1

0

0

1

0

0

1

0

1

0

1

0

0

0

0

1

1

0

0

1

1

1

0

0

0

0

0

1

1

0

0

0

0

0

1

0

1

1

1

1

1

0

1

0

1

0

1

0

0

0

0

0

0

0

0

0

21 1 21 30 41 50 60 71 80 90 10
0 11
1 12
0 13
0 14
0 15
0 16
1 17
0 18
1 19
0 20
0 21
1 22
1 23
0 24
0 25
1 26
0 27
0 28
0 29
0 30
1 31
0 32
1 33
0 34
0 35
0 36
1 37
0 38
0 39
0 40
1 41
0 42
0 43
1 44
1 45
1 46
0 47
0 48
0 49
1 50
1 51
0 52
1 53
0 54
0 55
0 56
0 57
0 58
0 59
1 60
0 61
0 62
0

21 01 0 0 0 0 0 10 0 0 10 0 01 10 0 10 01

10 0 0 0 01

10 10 0 0 10

10 10 0 0 01

01 0 10 10 01

0 01 01 01

10 0 10 10 1

10 10 0

1

0

1

0

10

01

01

0

01

01

01

01

01

01

21 1 10 01 10 0 01 10 0 01 01 10 0 0 01 0 10

0 10 0 01 10

10 0 01 1 01

01 0 0 10 01

10 01 01 0 10

01 0 0 10

01 01 10 10 10

0 01 01

10

10

0

10

0

0

0

0

01

0

10

01

0

0

21
22 10 01 0 0 01 0 0 01 0 01 0 10 0 0 01 1

01 0 0 01 10

01 0 0 0 0

0 01 01 01 10

1 0 0 0 10

0 1 10 10

01 0 0 01 10

0 0 0

10

01

10

0

0

1

10

0

10

1

10

1

1

1

21
22 10 0 10 0 0 10 0 01 10 1 01 0 01 1 01 01

0 0 01 10 0

0 01 10 10 1

10 0 0 01 10

0 10 10 01 01

10 0 01 01

10 1 0 0 0

0 1 1

01

0

01

0

0

0

01

0

10

0

0

10

0

01

22 0 10 0 01 1 01 01 10 0 10 0 0 0 01 10 10

10 01 01 10 01

10 0 01 0 0

0 10 1 10 0

10 01 0 0 0

01 1 01 0

10 0 01 10 0

01 01 0

0

10

0

01

0

10

0

01

01

10

01

10

1

10

22 0 01 0 01 0 0 01 1 01 10 1 01 10 1 10 10

01 0 10 0 0

0 10 0 0 10

01 0 0 1 0

0 01 01 10 10

01 0 10 1

0 10 0 0 0

01 10 1

10

01

10

0

0

01

10

0

0

01

01

0

0

1

22 0 0 01 10 1 10 10 0 0 0 0 01 0 10 01 0

0 1 10 0 10

0 01 1 0 0

0 01 1 0 01

01 1 01 01 01

10 10 10 0

0 01 10 0 0

10 10 0

0

01

0

1

01

0

0

1

10

0

10

01

1

0

22
23 0 10 01 1 0 01 10 1 1 0 10 1 01 10 0 0

10 0 01 01 0

0 01 0 01 0

1 0 01 10 01

0 10 10 0 0

1 0 0 10

0 0 01 01 0

10 0 10

0

10

01

01

01

1

01

01

0

10

10

0

0

10

22 03 03 13 04 13 03 04 04 03 04 03 14 03 04 14 04

03 13 03 03 03

03 14 13 03 03

04 13 14 04 14

14 14 14 13 14

04 03 03 04

03 13 04 04 03

03 04 03

04

14

04

14

13

04

03

13

03

03

04

14

14

04

23 0

0

1

1

0

1

0

1

1

0

0

1

1

0

0

0

0

0

1

1

0

0

1

0

1

0

1

3

3

3

4

3

3

4

4

3

4

3

4

3

4

4

4

3

3

3

3

3

3

4

3

1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62

19 1

0

0

1

0

0

1

0

1

19 10 21 30
19 10 01 0
19 0 1 0
19 0 10 01
20 01 10
19
20 0 0
19
20 10 0
20 0 0

40 51 60
10 0 01
0 10 0
0 0 10

0 01 0
10 01 0
0 10 01
01 10 0

71 80 90
10 01 10
10 0 0
01 1 0

0 0 01
01 10 10
0 0 10
1 01 01

1

0

0

0

0

0 11
0 12
0 13
0 14
0
10
10 01 0 0 01
01 01 0 01 01
0 1 0 01 10

0 10 10
01 0 10
0 0 01
10 0 0

0 1 10
01 10 01
01 10 0
1 0 1

0

0

1

0

1

0

0

1

0

1

0

0

0

0

0

1

1

0

0

0

0

0

0

1

1

1

1

1

1

0

0

0

0

0

0

3 3 4 3 4 4 4 4 4 4 3 4 4 3
(b)
10 × 62 pooling matrix

3

4

3

3

4

4

3

3

4

3

4

4

4

4

3

4

3

3

3

3

4

4

4

4

0

0

0

0

0

0

0

1

0

0

0

1

0

1

0

0

0

0

0

1

0

1

0

0

1

0

0

0

0

0

1 16
0 17
1 18
0 19
0
15
0 01 10 01 10
1 0 10 01 0
0 10 0 10 0

0 21
0 22
0 23
0 24
1
20
01 0 1 01 0
0 0 0 0 1
1 01 10 10 0

1 26
0 27
0 28
1 29
1
25
0 0 0 0 0
10 0 01 10 10
0 0 0 01 0

0 31
0 32
0 33
0 34
1
30
01 01 10 0 0
01 0 0 0 1
10 1 01 01 0

0 36
0 37
1 38
0 39
0
35
10 10 01 0 10
0 0 10 01 01
0 0 10 0 0

0 41
0 42
0 43
0 44
0
40
01 0 01 01 0
0 01 01 0 0
10 0 10 10 0

10 01
0 0
0 10

0 0
1 10
0 01

0 01
0 01
0 10

10 0
0 10
0 01

01 0
0 0
1 01

0
0

0
21 0 0 01 0 1 0 0 0 01 01 10 10 01 0 0
20
21 01 0 1 0 0 1 10 10 0 0 0 10 0 10 01
20
21 03 03 14 03 13 04 04 04 13 13 04 03 14 04 03

01
0

21 1

0

1

0

0

1

0

0

0

0

0

0

0

0

1

3

3

4

3

3

4

4

4

3

3

4

3

4

4

3

0 10 01
0 0 01
0 01 10
01 0 1

0
1

10
03

10
0 1 0 0
1 0 10 01
04 14 04 04

0

1

0

0

1

3

4

4

4

4

0 0 10
0 01 0
0 0 0
0 10 01

10
01

0
13

01
0 01 0 01
01 0 1 10
03 13 04 13

0

1

0

1

0

3

3

3

4

3

10 0 0
01 10 01
01 01 01
10 0 10

0
1

0
13

01
10 10 10 0
0 0 01 1
03 03 04 04

0

0

0

1

1

3

3

3

4

4

01 01 10
1 10 01
10 1 0
10 0 10

01
10

0
14

0
0 1 01 10
0 0 0 0
04 14 14 03

0

0

0

0

0

4

4

4

4

3

01 1 10
0 0 0
1 10 01
0 01 0

01
0

10 1 01
0 0 0
0 10 1
0 01 0

0

1

0

0

0

0 46
1 47
1 48
1 49
0
45
01 10 0 0 01
0 10 10 10 0
10 01 0 0 1

01 01
0 0
10 10

1

1

0

0

0

1

0

1

0

1

0 51
1 52
0 53
1 54
1
50
10 10 0 0 0
0 10 0 10 1
01 01 0 01 0

0 56
1 57
0 58
0 59
1
55
10 0 10 0 1
0 10 0 01 10
0 0 0 01 10

0 01 01
10 0 01
0 10 10
0 01 10

0
10

0
1

0
10

01
01

0
10

1
0

0
0

0
01

0
0

10
1

0
0

0
0

0
10

0
0

10
10

01
0

10
0

01
0

01
10

0
01

0
1

0
0

01
0

0
0

0
01

0
01

10
01

0
0

10
01

10
0

01
10

0
10

01
0

1

0

0

0 61
0 62
0
60
10 0 0
0 01 01

01
0

01
10

0
10

1
0

10
01

01
0

10
01

0
10

1
0

01
01 0 10 0
01 10 0 1
13 04 03 03

0
01

1
04

10 0 1 10
0 1 0 01
04 04 14 03

0
13

01 0 0
0 1 01
14 04 04

13

03

04

03

04

03

03

03

13

04

14

0
14

0
03

10
03

1

0

1

0

1

1

0

0

1

0

0

1

1

0

0

1

1

1

0

1

0

0

0

0

0

0

0

4

4

4

4

3

3

4

3

3

3

4

4

4

3

3

4

3

4

3

3

3

3

4

4

4

3

3

(c) 11 × 62 pooling matrix

Fig. 5. The pooling matrices with 9, 10, 11 rows and 62 columns used in the simulations for the 2-STAMP scheme. (The
number of 1’s in each row is shown in front of the row, and the number of 1’s in each column is shown below the column.)

15

